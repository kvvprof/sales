
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model accounts
 * 
 */
export type accounts = $Result.DefaultSelection<Prisma.$accountsPayload>
/**
 * Model app_groups
 * 
 */
export type app_groups = $Result.DefaultSelection<Prisma.$app_groupsPayload>
/**
 * Model applications
 * 
 */
export type applications = $Result.DefaultSelection<Prisma.$applicationsPayload>
/**
 * Model banks
 * 
 */
export type banks = $Result.DefaultSelection<Prisma.$banksPayload>
/**
 * Model banks_items
 * 
 */
export type banks_items = $Result.DefaultSelection<Prisma.$banks_itemsPayload>
/**
 * Model banks_pakets
 * 
 */
export type banks_pakets = $Result.DefaultSelection<Prisma.$banks_paketsPayload>
/**
 * Model blocks
 * 
 */
export type blocks = $Result.DefaultSelection<Prisma.$blocksPayload>
/**
 * Model contractors
 * 
 */
export type contractors = $Result.DefaultSelection<Prisma.$contractorsPayload>
/**
 * Model floors
 * 
 */
export type floors = $Result.DefaultSelection<Prisma.$floorsPayload>
/**
 * Model items
 * 
 */
export type items = $Result.DefaultSelection<Prisma.$itemsPayload>
/**
 * Model objects
 * 
 */
export type objects = $Result.DefaultSelection<Prisma.$objectsPayload>
/**
 * Model pakets
 * 
 */
export type pakets = $Result.DefaultSelection<Prisma.$paketsPayload>
/**
 * Model r_roles_apps
 * 
 */
export type r_roles_apps = $Result.DefaultSelection<Prisma.$r_roles_appsPayload>
/**
 * Model r_users_client_contractors
 * 
 */
export type r_users_client_contractors = $Result.DefaultSelection<Prisma.$r_users_client_contractorsPayload>
/**
 * Model r_users_roles
 * 
 */
export type r_users_roles = $Result.DefaultSelection<Prisma.$r_users_rolesPayload>
/**
 * Model roles
 * 
 */
export type roles = $Result.DefaultSelection<Prisma.$rolesPayload>
/**
 * Model roles_client
 * 
 */
export type roles_client = $Result.DefaultSelection<Prisma.$roles_clientPayload>
/**
 * Model sections
 * 
 */
export type sections = $Result.DefaultSelection<Prisma.$sectionsPayload>
/**
 * Model sub_pakets
 * 
 */
export type sub_pakets = $Result.DefaultSelection<Prisma.$sub_paketsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model users_client
 * 
 */
export type users_client = $Result.DefaultSelection<Prisma.$users_clientPayload>
/**
 * Model banks_items_versions
 * 
 */
export type banks_items_versions = $Result.DefaultSelection<Prisma.$banks_items_versionsPayload>
/**
 * Model entities
 * 
 */
export type entities = $Result.DefaultSelection<Prisma.$entitiesPayload>
/**
 * Model r_items_banks_items
 * 
 */
export type r_items_banks_items = $Result.DefaultSelection<Prisma.$r_items_banks_itemsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const applications_type: {
  retool: 'retool',
  next: 'next',
  next_client: 'next_client'
};

export type applications_type = (typeof applications_type)[keyof typeof applications_type]

}

export type applications_type = $Enums.applications_type

export const applications_type: typeof $Enums.applications_type

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.accounts.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.accounts.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.accounts`: Exposes CRUD operations for the **accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.accounts.findMany()
    * ```
    */
  get accounts(): Prisma.accountsDelegate<ExtArgs>;

  /**
   * `prisma.app_groups`: Exposes CRUD operations for the **app_groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_groups
    * const app_groups = await prisma.app_groups.findMany()
    * ```
    */
  get app_groups(): Prisma.app_groupsDelegate<ExtArgs>;

  /**
   * `prisma.applications`: Exposes CRUD operations for the **applications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applications
    * const applications = await prisma.applications.findMany()
    * ```
    */
  get applications(): Prisma.applicationsDelegate<ExtArgs>;

  /**
   * `prisma.banks`: Exposes CRUD operations for the **banks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banks
    * const banks = await prisma.banks.findMany()
    * ```
    */
  get banks(): Prisma.banksDelegate<ExtArgs>;

  /**
   * `prisma.banks_items`: Exposes CRUD operations for the **banks_items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banks_items
    * const banks_items = await prisma.banks_items.findMany()
    * ```
    */
  get banks_items(): Prisma.banks_itemsDelegate<ExtArgs>;

  /**
   * `prisma.banks_pakets`: Exposes CRUD operations for the **banks_pakets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banks_pakets
    * const banks_pakets = await prisma.banks_pakets.findMany()
    * ```
    */
  get banks_pakets(): Prisma.banks_paketsDelegate<ExtArgs>;

  /**
   * `prisma.blocks`: Exposes CRUD operations for the **blocks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.blocks.findMany()
    * ```
    */
  get blocks(): Prisma.blocksDelegate<ExtArgs>;

  /**
   * `prisma.contractors`: Exposes CRUD operations for the **contractors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contractors
    * const contractors = await prisma.contractors.findMany()
    * ```
    */
  get contractors(): Prisma.contractorsDelegate<ExtArgs>;

  /**
   * `prisma.floors`: Exposes CRUD operations for the **floors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Floors
    * const floors = await prisma.floors.findMany()
    * ```
    */
  get floors(): Prisma.floorsDelegate<ExtArgs>;

  /**
   * `prisma.items`: Exposes CRUD operations for the **items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.items.findMany()
    * ```
    */
  get items(): Prisma.itemsDelegate<ExtArgs>;

  /**
   * `prisma.objects`: Exposes CRUD operations for the **objects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Objects
    * const objects = await prisma.objects.findMany()
    * ```
    */
  get objects(): Prisma.objectsDelegate<ExtArgs>;

  /**
   * `prisma.pakets`: Exposes CRUD operations for the **pakets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pakets
    * const pakets = await prisma.pakets.findMany()
    * ```
    */
  get pakets(): Prisma.paketsDelegate<ExtArgs>;

  /**
   * `prisma.r_roles_apps`: Exposes CRUD operations for the **r_roles_apps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more R_roles_apps
    * const r_roles_apps = await prisma.r_roles_apps.findMany()
    * ```
    */
  get r_roles_apps(): Prisma.r_roles_appsDelegate<ExtArgs>;

  /**
   * `prisma.r_users_client_contractors`: Exposes CRUD operations for the **r_users_client_contractors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more R_users_client_contractors
    * const r_users_client_contractors = await prisma.r_users_client_contractors.findMany()
    * ```
    */
  get r_users_client_contractors(): Prisma.r_users_client_contractorsDelegate<ExtArgs>;

  /**
   * `prisma.r_users_roles`: Exposes CRUD operations for the **r_users_roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more R_users_roles
    * const r_users_roles = await prisma.r_users_roles.findMany()
    * ```
    */
  get r_users_roles(): Prisma.r_users_rolesDelegate<ExtArgs>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<ExtArgs>;

  /**
   * `prisma.roles_client`: Exposes CRUD operations for the **roles_client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles_clients
    * const roles_clients = await prisma.roles_client.findMany()
    * ```
    */
  get roles_client(): Prisma.roles_clientDelegate<ExtArgs>;

  /**
   * `prisma.sections`: Exposes CRUD operations for the **sections** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sections
    * const sections = await prisma.sections.findMany()
    * ```
    */
  get sections(): Prisma.sectionsDelegate<ExtArgs>;

  /**
   * `prisma.sub_pakets`: Exposes CRUD operations for the **sub_pakets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sub_pakets
    * const sub_pakets = await prisma.sub_pakets.findMany()
    * ```
    */
  get sub_pakets(): Prisma.sub_paketsDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.users_client`: Exposes CRUD operations for the **users_client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users_clients
    * const users_clients = await prisma.users_client.findMany()
    * ```
    */
  get users_client(): Prisma.users_clientDelegate<ExtArgs>;

  /**
   * `prisma.banks_items_versions`: Exposes CRUD operations for the **banks_items_versions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banks_items_versions
    * const banks_items_versions = await prisma.banks_items_versions.findMany()
    * ```
    */
  get banks_items_versions(): Prisma.banks_items_versionsDelegate<ExtArgs>;

  /**
   * `prisma.entities`: Exposes CRUD operations for the **entities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entities
    * const entities = await prisma.entities.findMany()
    * ```
    */
  get entities(): Prisma.entitiesDelegate<ExtArgs>;

  /**
   * `prisma.r_items_banks_items`: Exposes CRUD operations for the **r_items_banks_items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more R_items_banks_items
    * const r_items_banks_items = await prisma.r_items_banks_items.findMany()
    * ```
    */
  get r_items_banks_items(): Prisma.r_items_banks_itemsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.15.0
   * Query Engine version: 12e25d8d06f6ea5a0252864dd9a03b1bb51f3022
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    accounts: 'accounts',
    app_groups: 'app_groups',
    applications: 'applications',
    banks: 'banks',
    banks_items: 'banks_items',
    banks_pakets: 'banks_pakets',
    blocks: 'blocks',
    contractors: 'contractors',
    floors: 'floors',
    items: 'items',
    objects: 'objects',
    pakets: 'pakets',
    r_roles_apps: 'r_roles_apps',
    r_users_client_contractors: 'r_users_client_contractors',
    r_users_roles: 'r_users_roles',
    roles: 'roles',
    roles_client: 'roles_client',
    sections: 'sections',
    sub_pakets: 'sub_pakets',
    users: 'users',
    users_client: 'users_client',
    banks_items_versions: 'banks_items_versions',
    entities: 'entities',
    r_items_banks_items: 'r_items_banks_items'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'accounts' | 'app_groups' | 'applications' | 'banks' | 'banks_items' | 'banks_pakets' | 'blocks' | 'contractors' | 'floors' | 'items' | 'objects' | 'pakets' | 'r_roles_apps' | 'r_users_client_contractors' | 'r_users_roles' | 'roles' | 'roles_client' | 'sections' | 'sub_pakets' | 'users' | 'users_client' | 'banks_items_versions' | 'entities' | 'r_items_banks_items'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      accounts: {
        payload: Prisma.$accountsPayload<ExtArgs>
        fields: Prisma.accountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accountsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$accountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accountsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          findFirst: {
            args: Prisma.accountsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$accountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accountsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          findMany: {
            args: Prisma.accountsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>[]
          }
          create: {
            args: Prisma.accountsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          createMany: {
            args: Prisma.accountsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.accountsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          update: {
            args: Prisma.accountsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          deleteMany: {
            args: Prisma.accountsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.accountsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.accountsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          aggregate: {
            args: Prisma.AccountsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccounts>
          }
          groupBy: {
            args: Prisma.accountsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.accountsCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountsCountAggregateOutputType> | number
          }
        }
      }
      app_groups: {
        payload: Prisma.$app_groupsPayload<ExtArgs>
        fields: Prisma.app_groupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_groupsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$app_groupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_groupsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$app_groupsPayload>
          }
          findFirst: {
            args: Prisma.app_groupsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$app_groupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_groupsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$app_groupsPayload>
          }
          findMany: {
            args: Prisma.app_groupsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$app_groupsPayload>[]
          }
          create: {
            args: Prisma.app_groupsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$app_groupsPayload>
          }
          createMany: {
            args: Prisma.app_groupsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.app_groupsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$app_groupsPayload>
          }
          update: {
            args: Prisma.app_groupsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$app_groupsPayload>
          }
          deleteMany: {
            args: Prisma.app_groupsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.app_groupsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.app_groupsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$app_groupsPayload>
          }
          aggregate: {
            args: Prisma.App_groupsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateApp_groups>
          }
          groupBy: {
            args: Prisma.app_groupsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<App_groupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.app_groupsCountArgs<ExtArgs>,
            result: $Utils.Optional<App_groupsCountAggregateOutputType> | number
          }
        }
      }
      applications: {
        payload: Prisma.$applicationsPayload<ExtArgs>
        fields: Prisma.applicationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.applicationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.applicationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>
          }
          findFirst: {
            args: Prisma.applicationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.applicationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>
          }
          findMany: {
            args: Prisma.applicationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>[]
          }
          create: {
            args: Prisma.applicationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>
          }
          createMany: {
            args: Prisma.applicationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.applicationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>
          }
          update: {
            args: Prisma.applicationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>
          }
          deleteMany: {
            args: Prisma.applicationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.applicationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.applicationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>
          }
          aggregate: {
            args: Prisma.ApplicationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateApplications>
          }
          groupBy: {
            args: Prisma.applicationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ApplicationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.applicationsCountArgs<ExtArgs>,
            result: $Utils.Optional<ApplicationsCountAggregateOutputType> | number
          }
        }
      }
      banks: {
        payload: Prisma.$banksPayload<ExtArgs>
        fields: Prisma.banksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.banksFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.banksFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banksPayload>
          }
          findFirst: {
            args: Prisma.banksFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.banksFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banksPayload>
          }
          findMany: {
            args: Prisma.banksFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banksPayload>[]
          }
          create: {
            args: Prisma.banksCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banksPayload>
          }
          createMany: {
            args: Prisma.banksCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.banksDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banksPayload>
          }
          update: {
            args: Prisma.banksUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banksPayload>
          }
          deleteMany: {
            args: Prisma.banksDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.banksUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.banksUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banksPayload>
          }
          aggregate: {
            args: Prisma.BanksAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBanks>
          }
          groupBy: {
            args: Prisma.banksGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BanksGroupByOutputType>[]
          }
          count: {
            args: Prisma.banksCountArgs<ExtArgs>,
            result: $Utils.Optional<BanksCountAggregateOutputType> | number
          }
        }
      }
      banks_items: {
        payload: Prisma.$banks_itemsPayload<ExtArgs>
        fields: Prisma.banks_itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.banks_itemsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.banks_itemsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_itemsPayload>
          }
          findFirst: {
            args: Prisma.banks_itemsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.banks_itemsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_itemsPayload>
          }
          findMany: {
            args: Prisma.banks_itemsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_itemsPayload>[]
          }
          create: {
            args: Prisma.banks_itemsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_itemsPayload>
          }
          createMany: {
            args: Prisma.banks_itemsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.banks_itemsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_itemsPayload>
          }
          update: {
            args: Prisma.banks_itemsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_itemsPayload>
          }
          deleteMany: {
            args: Prisma.banks_itemsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.banks_itemsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.banks_itemsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_itemsPayload>
          }
          aggregate: {
            args: Prisma.Banks_itemsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBanks_items>
          }
          groupBy: {
            args: Prisma.banks_itemsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Banks_itemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.banks_itemsCountArgs<ExtArgs>,
            result: $Utils.Optional<Banks_itemsCountAggregateOutputType> | number
          }
        }
      }
      banks_pakets: {
        payload: Prisma.$banks_paketsPayload<ExtArgs>
        fields: Prisma.banks_paketsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.banks_paketsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_paketsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.banks_paketsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_paketsPayload>
          }
          findFirst: {
            args: Prisma.banks_paketsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_paketsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.banks_paketsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_paketsPayload>
          }
          findMany: {
            args: Prisma.banks_paketsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_paketsPayload>[]
          }
          create: {
            args: Prisma.banks_paketsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_paketsPayload>
          }
          createMany: {
            args: Prisma.banks_paketsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.banks_paketsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_paketsPayload>
          }
          update: {
            args: Prisma.banks_paketsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_paketsPayload>
          }
          deleteMany: {
            args: Prisma.banks_paketsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.banks_paketsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.banks_paketsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_paketsPayload>
          }
          aggregate: {
            args: Prisma.Banks_paketsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBanks_pakets>
          }
          groupBy: {
            args: Prisma.banks_paketsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Banks_paketsGroupByOutputType>[]
          }
          count: {
            args: Prisma.banks_paketsCountArgs<ExtArgs>,
            result: $Utils.Optional<Banks_paketsCountAggregateOutputType> | number
          }
        }
      }
      blocks: {
        payload: Prisma.$blocksPayload<ExtArgs>
        fields: Prisma.blocksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blocksFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blocksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blocksFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          findFirst: {
            args: Prisma.blocksFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blocksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blocksFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          findMany: {
            args: Prisma.blocksFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>[]
          }
          create: {
            args: Prisma.blocksCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          createMany: {
            args: Prisma.blocksCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.blocksDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          update: {
            args: Prisma.blocksUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          deleteMany: {
            args: Prisma.blocksDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.blocksUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.blocksUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          aggregate: {
            args: Prisma.BlocksAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBlocks>
          }
          groupBy: {
            args: Prisma.blocksGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BlocksGroupByOutputType>[]
          }
          count: {
            args: Prisma.blocksCountArgs<ExtArgs>,
            result: $Utils.Optional<BlocksCountAggregateOutputType> | number
          }
        }
      }
      contractors: {
        payload: Prisma.$contractorsPayload<ExtArgs>
        fields: Prisma.contractorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contractorsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contractorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contractorsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contractorsPayload>
          }
          findFirst: {
            args: Prisma.contractorsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contractorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contractorsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contractorsPayload>
          }
          findMany: {
            args: Prisma.contractorsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contractorsPayload>[]
          }
          create: {
            args: Prisma.contractorsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contractorsPayload>
          }
          createMany: {
            args: Prisma.contractorsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.contractorsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contractorsPayload>
          }
          update: {
            args: Prisma.contractorsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contractorsPayload>
          }
          deleteMany: {
            args: Prisma.contractorsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.contractorsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.contractorsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contractorsPayload>
          }
          aggregate: {
            args: Prisma.ContractorsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContractors>
          }
          groupBy: {
            args: Prisma.contractorsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContractorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.contractorsCountArgs<ExtArgs>,
            result: $Utils.Optional<ContractorsCountAggregateOutputType> | number
          }
        }
      }
      floors: {
        payload: Prisma.$floorsPayload<ExtArgs>
        fields: Prisma.floorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.floorsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$floorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.floorsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$floorsPayload>
          }
          findFirst: {
            args: Prisma.floorsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$floorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.floorsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$floorsPayload>
          }
          findMany: {
            args: Prisma.floorsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$floorsPayload>[]
          }
          create: {
            args: Prisma.floorsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$floorsPayload>
          }
          createMany: {
            args: Prisma.floorsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.floorsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$floorsPayload>
          }
          update: {
            args: Prisma.floorsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$floorsPayload>
          }
          deleteMany: {
            args: Prisma.floorsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.floorsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.floorsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$floorsPayload>
          }
          aggregate: {
            args: Prisma.FloorsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFloors>
          }
          groupBy: {
            args: Prisma.floorsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FloorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.floorsCountArgs<ExtArgs>,
            result: $Utils.Optional<FloorsCountAggregateOutputType> | number
          }
        }
      }
      items: {
        payload: Prisma.$itemsPayload<ExtArgs>
        fields: Prisma.itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.itemsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.itemsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          findFirst: {
            args: Prisma.itemsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.itemsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          findMany: {
            args: Prisma.itemsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>[]
          }
          create: {
            args: Prisma.itemsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          createMany: {
            args: Prisma.itemsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.itemsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          update: {
            args: Prisma.itemsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          deleteMany: {
            args: Prisma.itemsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.itemsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.itemsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          aggregate: {
            args: Prisma.ItemsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItems>
          }
          groupBy: {
            args: Prisma.itemsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.itemsCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemsCountAggregateOutputType> | number
          }
        }
      }
      objects: {
        payload: Prisma.$objectsPayload<ExtArgs>
        fields: Prisma.objectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.objectsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$objectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.objectsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$objectsPayload>
          }
          findFirst: {
            args: Prisma.objectsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$objectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.objectsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$objectsPayload>
          }
          findMany: {
            args: Prisma.objectsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$objectsPayload>[]
          }
          create: {
            args: Prisma.objectsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$objectsPayload>
          }
          createMany: {
            args: Prisma.objectsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.objectsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$objectsPayload>
          }
          update: {
            args: Prisma.objectsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$objectsPayload>
          }
          deleteMany: {
            args: Prisma.objectsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.objectsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.objectsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$objectsPayload>
          }
          aggregate: {
            args: Prisma.ObjectsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateObjects>
          }
          groupBy: {
            args: Prisma.objectsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ObjectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.objectsCountArgs<ExtArgs>,
            result: $Utils.Optional<ObjectsCountAggregateOutputType> | number
          }
        }
      }
      pakets: {
        payload: Prisma.$paketsPayload<ExtArgs>
        fields: Prisma.paketsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paketsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$paketsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paketsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$paketsPayload>
          }
          findFirst: {
            args: Prisma.paketsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$paketsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paketsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$paketsPayload>
          }
          findMany: {
            args: Prisma.paketsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$paketsPayload>[]
          }
          create: {
            args: Prisma.paketsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$paketsPayload>
          }
          createMany: {
            args: Prisma.paketsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.paketsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$paketsPayload>
          }
          update: {
            args: Prisma.paketsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$paketsPayload>
          }
          deleteMany: {
            args: Prisma.paketsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.paketsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.paketsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$paketsPayload>
          }
          aggregate: {
            args: Prisma.PaketsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePakets>
          }
          groupBy: {
            args: Prisma.paketsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PaketsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paketsCountArgs<ExtArgs>,
            result: $Utils.Optional<PaketsCountAggregateOutputType> | number
          }
        }
      }
      r_roles_apps: {
        payload: Prisma.$r_roles_appsPayload<ExtArgs>
        fields: Prisma.r_roles_appsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.r_roles_appsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_roles_appsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.r_roles_appsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_roles_appsPayload>
          }
          findFirst: {
            args: Prisma.r_roles_appsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_roles_appsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.r_roles_appsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_roles_appsPayload>
          }
          findMany: {
            args: Prisma.r_roles_appsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_roles_appsPayload>[]
          }
          create: {
            args: Prisma.r_roles_appsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_roles_appsPayload>
          }
          createMany: {
            args: Prisma.r_roles_appsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.r_roles_appsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_roles_appsPayload>
          }
          update: {
            args: Prisma.r_roles_appsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_roles_appsPayload>
          }
          deleteMany: {
            args: Prisma.r_roles_appsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.r_roles_appsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.r_roles_appsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_roles_appsPayload>
          }
          aggregate: {
            args: Prisma.R_roles_appsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateR_roles_apps>
          }
          groupBy: {
            args: Prisma.r_roles_appsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<R_roles_appsGroupByOutputType>[]
          }
          count: {
            args: Prisma.r_roles_appsCountArgs<ExtArgs>,
            result: $Utils.Optional<R_roles_appsCountAggregateOutputType> | number
          }
        }
      }
      r_users_client_contractors: {
        payload: Prisma.$r_users_client_contractorsPayload<ExtArgs>
        fields: Prisma.r_users_client_contractorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.r_users_client_contractorsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_users_client_contractorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.r_users_client_contractorsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_users_client_contractorsPayload>
          }
          findFirst: {
            args: Prisma.r_users_client_contractorsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_users_client_contractorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.r_users_client_contractorsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_users_client_contractorsPayload>
          }
          findMany: {
            args: Prisma.r_users_client_contractorsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_users_client_contractorsPayload>[]
          }
          create: {
            args: Prisma.r_users_client_contractorsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_users_client_contractorsPayload>
          }
          createMany: {
            args: Prisma.r_users_client_contractorsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.r_users_client_contractorsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_users_client_contractorsPayload>
          }
          update: {
            args: Prisma.r_users_client_contractorsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_users_client_contractorsPayload>
          }
          deleteMany: {
            args: Prisma.r_users_client_contractorsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.r_users_client_contractorsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.r_users_client_contractorsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_users_client_contractorsPayload>
          }
          aggregate: {
            args: Prisma.R_users_client_contractorsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateR_users_client_contractors>
          }
          groupBy: {
            args: Prisma.r_users_client_contractorsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<R_users_client_contractorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.r_users_client_contractorsCountArgs<ExtArgs>,
            result: $Utils.Optional<R_users_client_contractorsCountAggregateOutputType> | number
          }
        }
      }
      r_users_roles: {
        payload: Prisma.$r_users_rolesPayload<ExtArgs>
        fields: Prisma.r_users_rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.r_users_rolesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_users_rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.r_users_rolesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_users_rolesPayload>
          }
          findFirst: {
            args: Prisma.r_users_rolesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_users_rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.r_users_rolesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_users_rolesPayload>
          }
          findMany: {
            args: Prisma.r_users_rolesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_users_rolesPayload>[]
          }
          create: {
            args: Prisma.r_users_rolesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_users_rolesPayload>
          }
          createMany: {
            args: Prisma.r_users_rolesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.r_users_rolesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_users_rolesPayload>
          }
          update: {
            args: Prisma.r_users_rolesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_users_rolesPayload>
          }
          deleteMany: {
            args: Prisma.r_users_rolesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.r_users_rolesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.r_users_rolesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_users_rolesPayload>
          }
          aggregate: {
            args: Prisma.R_users_rolesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateR_users_roles>
          }
          groupBy: {
            args: Prisma.r_users_rolesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<R_users_rolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.r_users_rolesCountArgs<ExtArgs>,
            result: $Utils.Optional<R_users_rolesCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: Prisma.$rolesPayload<ExtArgs>
        fields: Prisma.rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.rolesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>,
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      roles_client: {
        payload: Prisma.$roles_clientPayload<ExtArgs>
        fields: Prisma.roles_clientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roles_clientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$roles_clientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roles_clientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$roles_clientPayload>
          }
          findFirst: {
            args: Prisma.roles_clientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$roles_clientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roles_clientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$roles_clientPayload>
          }
          findMany: {
            args: Prisma.roles_clientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$roles_clientPayload>[]
          }
          create: {
            args: Prisma.roles_clientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$roles_clientPayload>
          }
          createMany: {
            args: Prisma.roles_clientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.roles_clientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$roles_clientPayload>
          }
          update: {
            args: Prisma.roles_clientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$roles_clientPayload>
          }
          deleteMany: {
            args: Prisma.roles_clientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.roles_clientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.roles_clientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$roles_clientPayload>
          }
          aggregate: {
            args: Prisma.Roles_clientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoles_client>
          }
          groupBy: {
            args: Prisma.roles_clientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Roles_clientGroupByOutputType>[]
          }
          count: {
            args: Prisma.roles_clientCountArgs<ExtArgs>,
            result: $Utils.Optional<Roles_clientCountAggregateOutputType> | number
          }
        }
      }
      sections: {
        payload: Prisma.$sectionsPayload<ExtArgs>
        fields: Prisma.sectionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sectionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sectionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload>
          }
          findFirst: {
            args: Prisma.sectionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sectionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload>
          }
          findMany: {
            args: Prisma.sectionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload>[]
          }
          create: {
            args: Prisma.sectionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload>
          }
          createMany: {
            args: Prisma.sectionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.sectionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload>
          }
          update: {
            args: Prisma.sectionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload>
          }
          deleteMany: {
            args: Prisma.sectionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.sectionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.sectionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload>
          }
          aggregate: {
            args: Prisma.SectionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSections>
          }
          groupBy: {
            args: Prisma.sectionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SectionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sectionsCountArgs<ExtArgs>,
            result: $Utils.Optional<SectionsCountAggregateOutputType> | number
          }
        }
      }
      sub_pakets: {
        payload: Prisma.$sub_paketsPayload<ExtArgs>
        fields: Prisma.sub_paketsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sub_paketsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sub_paketsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sub_paketsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sub_paketsPayload>
          }
          findFirst: {
            args: Prisma.sub_paketsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sub_paketsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sub_paketsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sub_paketsPayload>
          }
          findMany: {
            args: Prisma.sub_paketsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sub_paketsPayload>[]
          }
          create: {
            args: Prisma.sub_paketsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sub_paketsPayload>
          }
          createMany: {
            args: Prisma.sub_paketsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.sub_paketsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sub_paketsPayload>
          }
          update: {
            args: Prisma.sub_paketsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sub_paketsPayload>
          }
          deleteMany: {
            args: Prisma.sub_paketsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.sub_paketsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.sub_paketsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sub_paketsPayload>
          }
          aggregate: {
            args: Prisma.Sub_paketsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSub_pakets>
          }
          groupBy: {
            args: Prisma.sub_paketsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Sub_paketsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sub_paketsCountArgs<ExtArgs>,
            result: $Utils.Optional<Sub_paketsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>,
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      users_client: {
        payload: Prisma.$users_clientPayload<ExtArgs>
        fields: Prisma.users_clientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.users_clientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$users_clientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.users_clientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$users_clientPayload>
          }
          findFirst: {
            args: Prisma.users_clientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$users_clientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.users_clientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$users_clientPayload>
          }
          findMany: {
            args: Prisma.users_clientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$users_clientPayload>[]
          }
          create: {
            args: Prisma.users_clientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$users_clientPayload>
          }
          createMany: {
            args: Prisma.users_clientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.users_clientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$users_clientPayload>
          }
          update: {
            args: Prisma.users_clientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$users_clientPayload>
          }
          deleteMany: {
            args: Prisma.users_clientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.users_clientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.users_clientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$users_clientPayload>
          }
          aggregate: {
            args: Prisma.Users_clientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsers_client>
          }
          groupBy: {
            args: Prisma.users_clientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Users_clientGroupByOutputType>[]
          }
          count: {
            args: Prisma.users_clientCountArgs<ExtArgs>,
            result: $Utils.Optional<Users_clientCountAggregateOutputType> | number
          }
        }
      }
      banks_items_versions: {
        payload: Prisma.$banks_items_versionsPayload<ExtArgs>
        fields: Prisma.banks_items_versionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.banks_items_versionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_items_versionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.banks_items_versionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_items_versionsPayload>
          }
          findFirst: {
            args: Prisma.banks_items_versionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_items_versionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.banks_items_versionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_items_versionsPayload>
          }
          findMany: {
            args: Prisma.banks_items_versionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_items_versionsPayload>[]
          }
          create: {
            args: Prisma.banks_items_versionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_items_versionsPayload>
          }
          createMany: {
            args: Prisma.banks_items_versionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.banks_items_versionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_items_versionsPayload>
          }
          update: {
            args: Prisma.banks_items_versionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_items_versionsPayload>
          }
          deleteMany: {
            args: Prisma.banks_items_versionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.banks_items_versionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.banks_items_versionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$banks_items_versionsPayload>
          }
          aggregate: {
            args: Prisma.Banks_items_versionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBanks_items_versions>
          }
          groupBy: {
            args: Prisma.banks_items_versionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Banks_items_versionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.banks_items_versionsCountArgs<ExtArgs>,
            result: $Utils.Optional<Banks_items_versionsCountAggregateOutputType> | number
          }
        }
      }
      entities: {
        payload: Prisma.$entitiesPayload<ExtArgs>
        fields: Prisma.entitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.entitiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.entitiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>
          }
          findFirst: {
            args: Prisma.entitiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.entitiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>
          }
          findMany: {
            args: Prisma.entitiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>[]
          }
          create: {
            args: Prisma.entitiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>
          }
          createMany: {
            args: Prisma.entitiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.entitiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>
          }
          update: {
            args: Prisma.entitiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>
          }
          deleteMany: {
            args: Prisma.entitiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.entitiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.entitiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>
          }
          aggregate: {
            args: Prisma.EntitiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEntities>
          }
          groupBy: {
            args: Prisma.entitiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EntitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.entitiesCountArgs<ExtArgs>,
            result: $Utils.Optional<EntitiesCountAggregateOutputType> | number
          }
        }
      }
      r_items_banks_items: {
        payload: Prisma.$r_items_banks_itemsPayload<ExtArgs>
        fields: Prisma.r_items_banks_itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.r_items_banks_itemsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_items_banks_itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.r_items_banks_itemsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_items_banks_itemsPayload>
          }
          findFirst: {
            args: Prisma.r_items_banks_itemsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_items_banks_itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.r_items_banks_itemsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_items_banks_itemsPayload>
          }
          findMany: {
            args: Prisma.r_items_banks_itemsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_items_banks_itemsPayload>[]
          }
          create: {
            args: Prisma.r_items_banks_itemsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_items_banks_itemsPayload>
          }
          createMany: {
            args: Prisma.r_items_banks_itemsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.r_items_banks_itemsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_items_banks_itemsPayload>
          }
          update: {
            args: Prisma.r_items_banks_itemsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_items_banks_itemsPayload>
          }
          deleteMany: {
            args: Prisma.r_items_banks_itemsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.r_items_banks_itemsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.r_items_banks_itemsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$r_items_banks_itemsPayload>
          }
          aggregate: {
            args: Prisma.R_items_banks_itemsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateR_items_banks_items>
          }
          groupBy: {
            args: Prisma.r_items_banks_itemsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<R_items_banks_itemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.r_items_banks_itemsCountArgs<ExtArgs>,
            result: $Utils.Optional<R_items_banks_itemsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type App_groupsCountOutputType
   */

  export type App_groupsCountOutputType = {
    applications: number
  }

  export type App_groupsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | App_groupsCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes
  /**
   * App_groupsCountOutputType without action
   */
  export type App_groupsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App_groupsCountOutputType
     */
    select?: App_groupsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * App_groupsCountOutputType without action
   */
  export type App_groupsCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationsWhereInput
  }


  /**
   * Count Type ApplicationsCountOutputType
   */

  export type ApplicationsCountOutputType = {
    r_roles_apps: number
  }

  export type ApplicationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    r_roles_apps?: boolean | ApplicationsCountOutputTypeCountR_roles_appsArgs
  }

  // Custom InputTypes
  /**
   * ApplicationsCountOutputType without action
   */
  export type ApplicationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationsCountOutputType
     */
    select?: ApplicationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApplicationsCountOutputType without action
   */
  export type ApplicationsCountOutputTypeCountR_roles_appsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: r_roles_appsWhereInput
  }


  /**
   * Count Type BanksCountOutputType
   */

  export type BanksCountOutputType = {
    accounts: number
    banks_items_versions: number
  }

  export type BanksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | BanksCountOutputTypeCountAccountsArgs
    banks_items_versions?: boolean | BanksCountOutputTypeCountBanks_items_versionsArgs
  }

  // Custom InputTypes
  /**
   * BanksCountOutputType without action
   */
  export type BanksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanksCountOutputType
     */
    select?: BanksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BanksCountOutputType without action
   */
  export type BanksCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountsWhereInput
  }

  /**
   * BanksCountOutputType without action
   */
  export type BanksCountOutputTypeCountBanks_items_versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: banks_items_versionsWhereInput
  }


  /**
   * Count Type Banks_itemsCountOutputType
   */

  export type Banks_itemsCountOutputType = {
    items: number
  }

  export type Banks_itemsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Banks_itemsCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * Banks_itemsCountOutputType without action
   */
  export type Banks_itemsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banks_itemsCountOutputType
     */
    select?: Banks_itemsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Banks_itemsCountOutputType without action
   */
  export type Banks_itemsCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemsWhereInput
  }


  /**
   * Count Type Banks_paketsCountOutputType
   */

  export type Banks_paketsCountOutputType = {
    banks_items: number
  }

  export type Banks_paketsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banks_items?: boolean | Banks_paketsCountOutputTypeCountBanks_itemsArgs
  }

  // Custom InputTypes
  /**
   * Banks_paketsCountOutputType without action
   */
  export type Banks_paketsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banks_paketsCountOutputType
     */
    select?: Banks_paketsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Banks_paketsCountOutputType without action
   */
  export type Banks_paketsCountOutputTypeCountBanks_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: banks_itemsWhereInput
  }


  /**
   * Count Type BlocksCountOutputType
   */

  export type BlocksCountOutputType = {
    pakets: number
  }

  export type BlocksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pakets?: boolean | BlocksCountOutputTypeCountPaketsArgs
  }

  // Custom InputTypes
  /**
   * BlocksCountOutputType without action
   */
  export type BlocksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocksCountOutputType
     */
    select?: BlocksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlocksCountOutputType without action
   */
  export type BlocksCountOutputTypeCountPaketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paketsWhereInput
  }


  /**
   * Count Type ContractorsCountOutputType
   */

  export type ContractorsCountOutputType = {
    accounts: number
    r_users_client_contractors: number
  }

  export type ContractorsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | ContractorsCountOutputTypeCountAccountsArgs
    r_users_client_contractors?: boolean | ContractorsCountOutputTypeCountR_users_client_contractorsArgs
  }

  // Custom InputTypes
  /**
   * ContractorsCountOutputType without action
   */
  export type ContractorsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorsCountOutputType
     */
    select?: ContractorsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContractorsCountOutputType without action
   */
  export type ContractorsCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountsWhereInput
  }

  /**
   * ContractorsCountOutputType without action
   */
  export type ContractorsCountOutputTypeCountR_users_client_contractorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: r_users_client_contractorsWhereInput
  }


  /**
   * Count Type ObjectsCountOutputType
   */

  export type ObjectsCountOutputType = {
    sections: number
  }

  export type ObjectsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | ObjectsCountOutputTypeCountSectionsArgs
  }

  // Custom InputTypes
  /**
   * ObjectsCountOutputType without action
   */
  export type ObjectsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectsCountOutputType
     */
    select?: ObjectsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ObjectsCountOutputType without action
   */
  export type ObjectsCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sectionsWhereInput
  }


  /**
   * Count Type PaketsCountOutputType
   */

  export type PaketsCountOutputType = {
    sub_pakets: number
  }

  export type PaketsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sub_pakets?: boolean | PaketsCountOutputTypeCountSub_paketsArgs
  }

  // Custom InputTypes
  /**
   * PaketsCountOutputType without action
   */
  export type PaketsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaketsCountOutputType
     */
    select?: PaketsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaketsCountOutputType without action
   */
  export type PaketsCountOutputTypeCountSub_paketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sub_paketsWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    r_roles_apps: number
    r_users_roles: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    r_roles_apps?: boolean | RolesCountOutputTypeCountR_roles_appsArgs
    r_users_roles?: boolean | RolesCountOutputTypeCountR_users_rolesArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountR_roles_appsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: r_roles_appsWhereInput
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountR_users_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: r_users_rolesWhereInput
  }


  /**
   * Count Type Roles_clientCountOutputType
   */

  export type Roles_clientCountOutputType = {
    users_client: number
  }

  export type Roles_clientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_client?: boolean | Roles_clientCountOutputTypeCountUsers_clientArgs
  }

  // Custom InputTypes
  /**
   * Roles_clientCountOutputType without action
   */
  export type Roles_clientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_clientCountOutputType
     */
    select?: Roles_clientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Roles_clientCountOutputType without action
   */
  export type Roles_clientCountOutputTypeCountUsers_clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: users_clientWhereInput
  }


  /**
   * Count Type Sub_paketsCountOutputType
   */

  export type Sub_paketsCountOutputType = {
    items: number
  }

  export type Sub_paketsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Sub_paketsCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * Sub_paketsCountOutputType without action
   */
  export type Sub_paketsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sub_paketsCountOutputType
     */
    select?: Sub_paketsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Sub_paketsCountOutputType without action
   */
  export type Sub_paketsCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    r_users_roles: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    r_users_roles?: boolean | UsersCountOutputTypeCountR_users_rolesArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountR_users_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: r_users_rolesWhereInput
  }


  /**
   * Count Type Users_clientCountOutputType
   */

  export type Users_clientCountOutputType = {
    r_users_client_contractors: number
  }

  export type Users_clientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    r_users_client_contractors?: boolean | Users_clientCountOutputTypeCountR_users_client_contractorsArgs
  }

  // Custom InputTypes
  /**
   * Users_clientCountOutputType without action
   */
  export type Users_clientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_clientCountOutputType
     */
    select?: Users_clientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Users_clientCountOutputType without action
   */
  export type Users_clientCountOutputTypeCountR_users_client_contractorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: r_users_client_contractorsWhereInput
  }


  /**
   * Count Type Banks_items_versionsCountOutputType
   */

  export type Banks_items_versionsCountOutputType = {
    banks_items: number
  }

  export type Banks_items_versionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banks_items?: boolean | Banks_items_versionsCountOutputTypeCountBanks_itemsArgs
  }

  // Custom InputTypes
  /**
   * Banks_items_versionsCountOutputType without action
   */
  export type Banks_items_versionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banks_items_versionsCountOutputType
     */
    select?: Banks_items_versionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Banks_items_versionsCountOutputType without action
   */
  export type Banks_items_versionsCountOutputTypeCountBanks_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: banks_itemsWhereInput
  }


  /**
   * Count Type EntitiesCountOutputType
   */

  export type EntitiesCountOutputType = {
    objects: number
  }

  export type EntitiesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    objects?: boolean | EntitiesCountOutputTypeCountObjectsArgs
  }

  // Custom InputTypes
  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntitiesCountOutputType
     */
    select?: EntitiesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountObjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: objectsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model accounts
   */

  export type AggregateAccounts = {
    _count: AccountsCountAggregateOutputType | null
    _avg: AccountsAvgAggregateOutputType | null
    _sum: AccountsSumAggregateOutputType | null
    _min: AccountsMinAggregateOutputType | null
    _max: AccountsMaxAggregateOutputType | null
  }

  export type AccountsAvgAggregateOutputType = {
    id: number | null
    bank_id: number | null
    contractors_id: number | null
  }

  export type AccountsSumAggregateOutputType = {
    id: number | null
    bank_id: number | null
    contractors_id: number | null
  }

  export type AccountsMinAggregateOutputType = {
    id: number | null
    number: string | null
    bank_id: number | null
    contractors_id: number | null
  }

  export type AccountsMaxAggregateOutputType = {
    id: number | null
    number: string | null
    bank_id: number | null
    contractors_id: number | null
  }

  export type AccountsCountAggregateOutputType = {
    id: number
    number: number
    bank_id: number
    contractors_id: number
    _all: number
  }


  export type AccountsAvgAggregateInputType = {
    id?: true
    bank_id?: true
    contractors_id?: true
  }

  export type AccountsSumAggregateInputType = {
    id?: true
    bank_id?: true
    contractors_id?: true
  }

  export type AccountsMinAggregateInputType = {
    id?: true
    number?: true
    bank_id?: true
    contractors_id?: true
  }

  export type AccountsMaxAggregateInputType = {
    id?: true
    number?: true
    bank_id?: true
    contractors_id?: true
  }

  export type AccountsCountAggregateInputType = {
    id?: true
    number?: true
    bank_id?: true
    contractors_id?: true
    _all?: true
  }

  export type AccountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to aggregate.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accounts
    **/
    _count?: true | AccountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountsMaxAggregateInputType
  }

  export type GetAccountsAggregateType<T extends AccountsAggregateArgs> = {
        [P in keyof T & keyof AggregateAccounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccounts[P]>
      : GetScalarType<T[P], AggregateAccounts[P]>
  }




  export type accountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountsWhereInput
    orderBy?: accountsOrderByWithAggregationInput | accountsOrderByWithAggregationInput[]
    by: AccountsScalarFieldEnum[] | AccountsScalarFieldEnum
    having?: accountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountsCountAggregateInputType | true
    _avg?: AccountsAvgAggregateInputType
    _sum?: AccountsSumAggregateInputType
    _min?: AccountsMinAggregateInputType
    _max?: AccountsMaxAggregateInputType
  }

  export type AccountsGroupByOutputType = {
    id: number
    number: string
    bank_id: number
    contractors_id: number
    _count: AccountsCountAggregateOutputType | null
    _avg: AccountsAvgAggregateOutputType | null
    _sum: AccountsSumAggregateOutputType | null
    _min: AccountsMinAggregateOutputType | null
    _max: AccountsMaxAggregateOutputType | null
  }

  type GetAccountsGroupByPayload<T extends accountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountsGroupByOutputType[P]>
            : GetScalarType<T[P], AccountsGroupByOutputType[P]>
        }
      >
    >


  export type accountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    bank_id?: boolean
    contractors_id?: boolean
    banks?: boolean | banksDefaultArgs<ExtArgs>
    contractors?: boolean | contractorsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accounts"]>


  export type accountsSelectScalar = {
    id?: boolean
    number?: boolean
    bank_id?: boolean
    contractors_id?: boolean
  }

  export type accountsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banks?: boolean | banksDefaultArgs<ExtArgs>
    contractors?: boolean | contractorsDefaultArgs<ExtArgs>
  }

  export type $accountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "accounts"
    objects: {
      banks: Prisma.$banksPayload<ExtArgs>
      contractors: Prisma.$contractorsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      number: string
      bank_id: number
      contractors_id: number
    }, ExtArgs["result"]["accounts"]>
    composites: {}
  }

  type accountsGetPayload<S extends boolean | null | undefined | accountsDefaultArgs> = $Result.GetResult<Prisma.$accountsPayload, S>

  type accountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<accountsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountsCountAggregateInputType | true
    }

  export interface accountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['accounts'], meta: { name: 'accounts' } }
    /**
     * Find zero or one Accounts that matches the filter.
     * @param {accountsFindUniqueArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends accountsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, accountsFindUniqueArgs<ExtArgs>>
    ): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Accounts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {accountsFindUniqueOrThrowArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends accountsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, accountsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindFirstArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends accountsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, accountsFindFirstArgs<ExtArgs>>
    ): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Accounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindFirstOrThrowArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends accountsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, accountsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.accounts.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountsWithIdOnly = await prisma.accounts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends accountsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, accountsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Accounts.
     * @param {accountsCreateArgs} args - Arguments to create a Accounts.
     * @example
     * // Create one Accounts
     * const Accounts = await prisma.accounts.create({
     *   data: {
     *     // ... data to create a Accounts
     *   }
     * })
     * 
    **/
    create<T extends accountsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, accountsCreateArgs<ExtArgs>>
    ): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {accountsCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const accounts = await prisma.accounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends accountsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, accountsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Accounts.
     * @param {accountsDeleteArgs} args - Arguments to delete one Accounts.
     * @example
     * // Delete one Accounts
     * const Accounts = await prisma.accounts.delete({
     *   where: {
     *     // ... filter to delete one Accounts
     *   }
     * })
     * 
    **/
    delete<T extends accountsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, accountsDeleteArgs<ExtArgs>>
    ): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Accounts.
     * @param {accountsUpdateArgs} args - Arguments to update one Accounts.
     * @example
     * // Update one Accounts
     * const accounts = await prisma.accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends accountsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, accountsUpdateArgs<ExtArgs>>
    ): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {accountsDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends accountsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, accountsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const accounts = await prisma.accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends accountsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, accountsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Accounts.
     * @param {accountsUpsertArgs} args - Arguments to update or create a Accounts.
     * @example
     * // Update or create a Accounts
     * const accounts = await prisma.accounts.upsert({
     *   create: {
     *     // ... data to create a Accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accounts we want to update
     *   }
     * })
    **/
    upsert<T extends accountsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, accountsUpsertArgs<ExtArgs>>
    ): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.accounts.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends accountsCountArgs>(
      args?: Subset<T, accountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountsAggregateArgs>(args: Subset<T, AccountsAggregateArgs>): Prisma.PrismaPromise<GetAccountsAggregateType<T>>

    /**
     * Group by Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accountsGroupByArgs['orderBy'] }
        : { orderBy?: accountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the accounts model
   */
  readonly fields: accountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    banks<T extends banksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, banksDefaultArgs<ExtArgs>>): Prisma__banksClient<$Result.GetResult<Prisma.$banksPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    contractors<T extends contractorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, contractorsDefaultArgs<ExtArgs>>): Prisma__contractorsClient<$Result.GetResult<Prisma.$contractorsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the accounts model
   */ 
  interface accountsFieldRefs {
    readonly id: FieldRef<"accounts", 'Int'>
    readonly number: FieldRef<"accounts", 'String'>
    readonly bank_id: FieldRef<"accounts", 'Int'>
    readonly contractors_id: FieldRef<"accounts", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * accounts findUnique
   */
  export type accountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts findUniqueOrThrow
   */
  export type accountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts findFirst
   */
  export type accountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts findFirstOrThrow
   */
  export type accountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts findMany
   */
  export type accountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts create
   */
  export type accountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * The data needed to create a accounts.
     */
    data: XOR<accountsCreateInput, accountsUncheckedCreateInput>
  }

  /**
   * accounts createMany
   */
  export type accountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accounts.
     */
    data: accountsCreateManyInput | accountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * accounts update
   */
  export type accountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * The data needed to update a accounts.
     */
    data: XOR<accountsUpdateInput, accountsUncheckedUpdateInput>
    /**
     * Choose, which accounts to update.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts updateMany
   */
  export type accountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accounts.
     */
    data: XOR<accountsUpdateManyMutationInput, accountsUncheckedUpdateManyInput>
    /**
     * Filter which accounts to update
     */
    where?: accountsWhereInput
  }

  /**
   * accounts upsert
   */
  export type accountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * The filter to search for the accounts to update in case it exists.
     */
    where: accountsWhereUniqueInput
    /**
     * In case the accounts found by the `where` argument doesn't exist, create a new accounts with this data.
     */
    create: XOR<accountsCreateInput, accountsUncheckedCreateInput>
    /**
     * In case the accounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accountsUpdateInput, accountsUncheckedUpdateInput>
  }

  /**
   * accounts delete
   */
  export type accountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter which accounts to delete.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts deleteMany
   */
  export type accountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to delete
     */
    where?: accountsWhereInput
  }

  /**
   * accounts without action
   */
  export type accountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
  }


  /**
   * Model app_groups
   */

  export type AggregateApp_groups = {
    _count: App_groupsCountAggregateOutputType | null
    _avg: App_groupsAvgAggregateOutputType | null
    _sum: App_groupsSumAggregateOutputType | null
    _min: App_groupsMinAggregateOutputType | null
    _max: App_groupsMaxAggregateOutputType | null
  }

  export type App_groupsAvgAggregateOutputType = {
    id: number | null
  }

  export type App_groupsSumAggregateOutputType = {
    id: number | null
  }

  export type App_groupsMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type App_groupsMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type App_groupsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type App_groupsAvgAggregateInputType = {
    id?: true
  }

  export type App_groupsSumAggregateInputType = {
    id?: true
  }

  export type App_groupsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type App_groupsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type App_groupsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type App_groupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_groups to aggregate.
     */
    where?: app_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_groups to fetch.
     */
    orderBy?: app_groupsOrderByWithRelationInput | app_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_groups
    **/
    _count?: true | App_groupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: App_groupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: App_groupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_groupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_groupsMaxAggregateInputType
  }

  export type GetApp_groupsAggregateType<T extends App_groupsAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_groups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_groups[P]>
      : GetScalarType<T[P], AggregateApp_groups[P]>
  }




  export type app_groupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_groupsWhereInput
    orderBy?: app_groupsOrderByWithAggregationInput | app_groupsOrderByWithAggregationInput[]
    by: App_groupsScalarFieldEnum[] | App_groupsScalarFieldEnum
    having?: app_groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_groupsCountAggregateInputType | true
    _avg?: App_groupsAvgAggregateInputType
    _sum?: App_groupsSumAggregateInputType
    _min?: App_groupsMinAggregateInputType
    _max?: App_groupsMaxAggregateInputType
  }

  export type App_groupsGroupByOutputType = {
    id: number
    name: string
    _count: App_groupsCountAggregateOutputType | null
    _avg: App_groupsAvgAggregateOutputType | null
    _sum: App_groupsSumAggregateOutputType | null
    _min: App_groupsMinAggregateOutputType | null
    _max: App_groupsMaxAggregateOutputType | null
  }

  type GetApp_groupsGroupByPayload<T extends app_groupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_groupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_groupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_groupsGroupByOutputType[P]>
            : GetScalarType<T[P], App_groupsGroupByOutputType[P]>
        }
      >
    >


  export type app_groupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    applications?: boolean | app_groups$applicationsArgs<ExtArgs>
    _count?: boolean | App_groupsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["app_groups"]>


  export type app_groupsSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type app_groupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | app_groups$applicationsArgs<ExtArgs>
    _count?: boolean | App_groupsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $app_groupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_groups"
    objects: {
      applications: Prisma.$applicationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["app_groups"]>
    composites: {}
  }

  type app_groupsGetPayload<S extends boolean | null | undefined | app_groupsDefaultArgs> = $Result.GetResult<Prisma.$app_groupsPayload, S>

  type app_groupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<app_groupsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: App_groupsCountAggregateInputType | true
    }

  export interface app_groupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_groups'], meta: { name: 'app_groups' } }
    /**
     * Find zero or one App_groups that matches the filter.
     * @param {app_groupsFindUniqueArgs} args - Arguments to find a App_groups
     * @example
     * // Get one App_groups
     * const app_groups = await prisma.app_groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends app_groupsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, app_groupsFindUniqueArgs<ExtArgs>>
    ): Prisma__app_groupsClient<$Result.GetResult<Prisma.$app_groupsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one App_groups that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {app_groupsFindUniqueOrThrowArgs} args - Arguments to find a App_groups
     * @example
     * // Get one App_groups
     * const app_groups = await prisma.app_groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends app_groupsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, app_groupsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__app_groupsClient<$Result.GetResult<Prisma.$app_groupsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first App_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_groupsFindFirstArgs} args - Arguments to find a App_groups
     * @example
     * // Get one App_groups
     * const app_groups = await prisma.app_groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends app_groupsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, app_groupsFindFirstArgs<ExtArgs>>
    ): Prisma__app_groupsClient<$Result.GetResult<Prisma.$app_groupsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first App_groups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_groupsFindFirstOrThrowArgs} args - Arguments to find a App_groups
     * @example
     * // Get one App_groups
     * const app_groups = await prisma.app_groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends app_groupsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, app_groupsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__app_groupsClient<$Result.GetResult<Prisma.$app_groupsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more App_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_groupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_groups
     * const app_groups = await prisma.app_groups.findMany()
     * 
     * // Get first 10 App_groups
     * const app_groups = await prisma.app_groups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const app_groupsWithIdOnly = await prisma.app_groups.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends app_groupsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, app_groupsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_groupsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a App_groups.
     * @param {app_groupsCreateArgs} args - Arguments to create a App_groups.
     * @example
     * // Create one App_groups
     * const App_groups = await prisma.app_groups.create({
     *   data: {
     *     // ... data to create a App_groups
     *   }
     * })
     * 
    **/
    create<T extends app_groupsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, app_groupsCreateArgs<ExtArgs>>
    ): Prisma__app_groupsClient<$Result.GetResult<Prisma.$app_groupsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many App_groups.
     * @param {app_groupsCreateManyArgs} args - Arguments to create many App_groups.
     * @example
     * // Create many App_groups
     * const app_groups = await prisma.app_groups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends app_groupsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, app_groupsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a App_groups.
     * @param {app_groupsDeleteArgs} args - Arguments to delete one App_groups.
     * @example
     * // Delete one App_groups
     * const App_groups = await prisma.app_groups.delete({
     *   where: {
     *     // ... filter to delete one App_groups
     *   }
     * })
     * 
    **/
    delete<T extends app_groupsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, app_groupsDeleteArgs<ExtArgs>>
    ): Prisma__app_groupsClient<$Result.GetResult<Prisma.$app_groupsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one App_groups.
     * @param {app_groupsUpdateArgs} args - Arguments to update one App_groups.
     * @example
     * // Update one App_groups
     * const app_groups = await prisma.app_groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends app_groupsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, app_groupsUpdateArgs<ExtArgs>>
    ): Prisma__app_groupsClient<$Result.GetResult<Prisma.$app_groupsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more App_groups.
     * @param {app_groupsDeleteManyArgs} args - Arguments to filter App_groups to delete.
     * @example
     * // Delete a few App_groups
     * const { count } = await prisma.app_groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends app_groupsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, app_groupsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_groups
     * const app_groups = await prisma.app_groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends app_groupsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, app_groupsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App_groups.
     * @param {app_groupsUpsertArgs} args - Arguments to update or create a App_groups.
     * @example
     * // Update or create a App_groups
     * const app_groups = await prisma.app_groups.upsert({
     *   create: {
     *     // ... data to create a App_groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_groups we want to update
     *   }
     * })
    **/
    upsert<T extends app_groupsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, app_groupsUpsertArgs<ExtArgs>>
    ): Prisma__app_groupsClient<$Result.GetResult<Prisma.$app_groupsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of App_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_groupsCountArgs} args - Arguments to filter App_groups to count.
     * @example
     * // Count the number of App_groups
     * const count = await prisma.app_groups.count({
     *   where: {
     *     // ... the filter for the App_groups we want to count
     *   }
     * })
    **/
    count<T extends app_groupsCountArgs>(
      args?: Subset<T, app_groupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_groupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_groupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_groupsAggregateArgs>(args: Subset<T, App_groupsAggregateArgs>): Prisma.PrismaPromise<GetApp_groupsAggregateType<T>>

    /**
     * Group by App_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_groupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_groupsGroupByArgs['orderBy'] }
        : { orderBy?: app_groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_groupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_groupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_groups model
   */
  readonly fields: app_groupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_groupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    applications<T extends app_groups$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, app_groups$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the app_groups model
   */ 
  interface app_groupsFieldRefs {
    readonly id: FieldRef<"app_groups", 'Int'>
    readonly name: FieldRef<"app_groups", 'String'>
  }
    

  // Custom InputTypes
  /**
   * app_groups findUnique
   */
  export type app_groupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_groups
     */
    select?: app_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_groupsInclude<ExtArgs> | null
    /**
     * Filter, which app_groups to fetch.
     */
    where: app_groupsWhereUniqueInput
  }

  /**
   * app_groups findUniqueOrThrow
   */
  export type app_groupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_groups
     */
    select?: app_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_groupsInclude<ExtArgs> | null
    /**
     * Filter, which app_groups to fetch.
     */
    where: app_groupsWhereUniqueInput
  }

  /**
   * app_groups findFirst
   */
  export type app_groupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_groups
     */
    select?: app_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_groupsInclude<ExtArgs> | null
    /**
     * Filter, which app_groups to fetch.
     */
    where?: app_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_groups to fetch.
     */
    orderBy?: app_groupsOrderByWithRelationInput | app_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_groups.
     */
    cursor?: app_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_groups.
     */
    distinct?: App_groupsScalarFieldEnum | App_groupsScalarFieldEnum[]
  }

  /**
   * app_groups findFirstOrThrow
   */
  export type app_groupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_groups
     */
    select?: app_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_groupsInclude<ExtArgs> | null
    /**
     * Filter, which app_groups to fetch.
     */
    where?: app_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_groups to fetch.
     */
    orderBy?: app_groupsOrderByWithRelationInput | app_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_groups.
     */
    cursor?: app_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_groups.
     */
    distinct?: App_groupsScalarFieldEnum | App_groupsScalarFieldEnum[]
  }

  /**
   * app_groups findMany
   */
  export type app_groupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_groups
     */
    select?: app_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_groupsInclude<ExtArgs> | null
    /**
     * Filter, which app_groups to fetch.
     */
    where?: app_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_groups to fetch.
     */
    orderBy?: app_groupsOrderByWithRelationInput | app_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_groups.
     */
    cursor?: app_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_groups.
     */
    skip?: number
    distinct?: App_groupsScalarFieldEnum | App_groupsScalarFieldEnum[]
  }

  /**
   * app_groups create
   */
  export type app_groupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_groups
     */
    select?: app_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_groupsInclude<ExtArgs> | null
    /**
     * The data needed to create a app_groups.
     */
    data: XOR<app_groupsCreateInput, app_groupsUncheckedCreateInput>
  }

  /**
   * app_groups createMany
   */
  export type app_groupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_groups.
     */
    data: app_groupsCreateManyInput | app_groupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_groups update
   */
  export type app_groupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_groups
     */
    select?: app_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_groupsInclude<ExtArgs> | null
    /**
     * The data needed to update a app_groups.
     */
    data: XOR<app_groupsUpdateInput, app_groupsUncheckedUpdateInput>
    /**
     * Choose, which app_groups to update.
     */
    where: app_groupsWhereUniqueInput
  }

  /**
   * app_groups updateMany
   */
  export type app_groupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_groups.
     */
    data: XOR<app_groupsUpdateManyMutationInput, app_groupsUncheckedUpdateManyInput>
    /**
     * Filter which app_groups to update
     */
    where?: app_groupsWhereInput
  }

  /**
   * app_groups upsert
   */
  export type app_groupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_groups
     */
    select?: app_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_groupsInclude<ExtArgs> | null
    /**
     * The filter to search for the app_groups to update in case it exists.
     */
    where: app_groupsWhereUniqueInput
    /**
     * In case the app_groups found by the `where` argument doesn't exist, create a new app_groups with this data.
     */
    create: XOR<app_groupsCreateInput, app_groupsUncheckedCreateInput>
    /**
     * In case the app_groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_groupsUpdateInput, app_groupsUncheckedUpdateInput>
  }

  /**
   * app_groups delete
   */
  export type app_groupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_groups
     */
    select?: app_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_groupsInclude<ExtArgs> | null
    /**
     * Filter which app_groups to delete.
     */
    where: app_groupsWhereUniqueInput
  }

  /**
   * app_groups deleteMany
   */
  export type app_groupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_groups to delete
     */
    where?: app_groupsWhereInput
  }

  /**
   * app_groups.applications
   */
  export type app_groups$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    where?: applicationsWhereInput
    orderBy?: applicationsOrderByWithRelationInput | applicationsOrderByWithRelationInput[]
    cursor?: applicationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationsScalarFieldEnum | ApplicationsScalarFieldEnum[]
  }

  /**
   * app_groups without action
   */
  export type app_groupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_groups
     */
    select?: app_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_groupsInclude<ExtArgs> | null
  }


  /**
   * Model applications
   */

  export type AggregateApplications = {
    _count: ApplicationsCountAggregateOutputType | null
    _avg: ApplicationsAvgAggregateOutputType | null
    _sum: ApplicationsSumAggregateOutputType | null
    _min: ApplicationsMinAggregateOutputType | null
    _max: ApplicationsMaxAggregateOutputType | null
  }

  export type ApplicationsAvgAggregateOutputType = {
    app_group_id: number | null
  }

  export type ApplicationsSumAggregateOutputType = {
    app_group_id: number | null
  }

  export type ApplicationsMinAggregateOutputType = {
    id: string | null
    name: string | null
    active: boolean | null
    type: $Enums.applications_type | null
    path: string | null
    description: string | null
    app_group_id: number | null
  }

  export type ApplicationsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    active: boolean | null
    type: $Enums.applications_type | null
    path: string | null
    description: string | null
    app_group_id: number | null
  }

  export type ApplicationsCountAggregateOutputType = {
    id: number
    name: number
    active: number
    type: number
    path: number
    description: number
    app_group_id: number
    _all: number
  }


  export type ApplicationsAvgAggregateInputType = {
    app_group_id?: true
  }

  export type ApplicationsSumAggregateInputType = {
    app_group_id?: true
  }

  export type ApplicationsMinAggregateInputType = {
    id?: true
    name?: true
    active?: true
    type?: true
    path?: true
    description?: true
    app_group_id?: true
  }

  export type ApplicationsMaxAggregateInputType = {
    id?: true
    name?: true
    active?: true
    type?: true
    path?: true
    description?: true
    app_group_id?: true
  }

  export type ApplicationsCountAggregateInputType = {
    id?: true
    name?: true
    active?: true
    type?: true
    path?: true
    description?: true
    app_group_id?: true
    _all?: true
  }

  export type ApplicationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applications to aggregate.
     */
    where?: applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applications to fetch.
     */
    orderBy?: applicationsOrderByWithRelationInput | applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned applications
    **/
    _count?: true | ApplicationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationsMaxAggregateInputType
  }

  export type GetApplicationsAggregateType<T extends ApplicationsAggregateArgs> = {
        [P in keyof T & keyof AggregateApplications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplications[P]>
      : GetScalarType<T[P], AggregateApplications[P]>
  }




  export type applicationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationsWhereInput
    orderBy?: applicationsOrderByWithAggregationInput | applicationsOrderByWithAggregationInput[]
    by: ApplicationsScalarFieldEnum[] | ApplicationsScalarFieldEnum
    having?: applicationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationsCountAggregateInputType | true
    _avg?: ApplicationsAvgAggregateInputType
    _sum?: ApplicationsSumAggregateInputType
    _min?: ApplicationsMinAggregateInputType
    _max?: ApplicationsMaxAggregateInputType
  }

  export type ApplicationsGroupByOutputType = {
    id: string
    name: string
    active: boolean | null
    type: $Enums.applications_type
    path: string | null
    description: string | null
    app_group_id: number
    _count: ApplicationsCountAggregateOutputType | null
    _avg: ApplicationsAvgAggregateOutputType | null
    _sum: ApplicationsSumAggregateOutputType | null
    _min: ApplicationsMinAggregateOutputType | null
    _max: ApplicationsMaxAggregateOutputType | null
  }

  type GetApplicationsGroupByPayload<T extends applicationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationsGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationsGroupByOutputType[P]>
        }
      >
    >


  export type applicationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    active?: boolean
    type?: boolean
    path?: boolean
    description?: boolean
    app_group_id?: boolean
    app_groups?: boolean | app_groupsDefaultArgs<ExtArgs>
    r_roles_apps?: boolean | applications$r_roles_appsArgs<ExtArgs>
    _count?: boolean | ApplicationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applications"]>


  export type applicationsSelectScalar = {
    id?: boolean
    name?: boolean
    active?: boolean
    type?: boolean
    path?: boolean
    description?: boolean
    app_group_id?: boolean
  }

  export type applicationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_groups?: boolean | app_groupsDefaultArgs<ExtArgs>
    r_roles_apps?: boolean | applications$r_roles_appsArgs<ExtArgs>
    _count?: boolean | ApplicationsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $applicationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "applications"
    objects: {
      app_groups: Prisma.$app_groupsPayload<ExtArgs>
      r_roles_apps: Prisma.$r_roles_appsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      active: boolean | null
      type: $Enums.applications_type
      path: string | null
      description: string | null
      app_group_id: number
    }, ExtArgs["result"]["applications"]>
    composites: {}
  }

  type applicationsGetPayload<S extends boolean | null | undefined | applicationsDefaultArgs> = $Result.GetResult<Prisma.$applicationsPayload, S>

  type applicationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<applicationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApplicationsCountAggregateInputType | true
    }

  export interface applicationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['applications'], meta: { name: 'applications' } }
    /**
     * Find zero or one Applications that matches the filter.
     * @param {applicationsFindUniqueArgs} args - Arguments to find a Applications
     * @example
     * // Get one Applications
     * const applications = await prisma.applications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends applicationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, applicationsFindUniqueArgs<ExtArgs>>
    ): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Applications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {applicationsFindUniqueOrThrowArgs} args - Arguments to find a Applications
     * @example
     * // Get one Applications
     * const applications = await prisma.applications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends applicationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, applicationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationsFindFirstArgs} args - Arguments to find a Applications
     * @example
     * // Get one Applications
     * const applications = await prisma.applications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends applicationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, applicationsFindFirstArgs<ExtArgs>>
    ): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Applications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationsFindFirstOrThrowArgs} args - Arguments to find a Applications
     * @example
     * // Get one Applications
     * const applications = await prisma.applications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends applicationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, applicationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applications
     * const applications = await prisma.applications.findMany()
     * 
     * // Get first 10 Applications
     * const applications = await prisma.applications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicationsWithIdOnly = await prisma.applications.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends applicationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, applicationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Applications.
     * @param {applicationsCreateArgs} args - Arguments to create a Applications.
     * @example
     * // Create one Applications
     * const Applications = await prisma.applications.create({
     *   data: {
     *     // ... data to create a Applications
     *   }
     * })
     * 
    **/
    create<T extends applicationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, applicationsCreateArgs<ExtArgs>>
    ): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Applications.
     * @param {applicationsCreateManyArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const applications = await prisma.applications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends applicationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, applicationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Applications.
     * @param {applicationsDeleteArgs} args - Arguments to delete one Applications.
     * @example
     * // Delete one Applications
     * const Applications = await prisma.applications.delete({
     *   where: {
     *     // ... filter to delete one Applications
     *   }
     * })
     * 
    **/
    delete<T extends applicationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, applicationsDeleteArgs<ExtArgs>>
    ): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Applications.
     * @param {applicationsUpdateArgs} args - Arguments to update one Applications.
     * @example
     * // Update one Applications
     * const applications = await prisma.applications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends applicationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, applicationsUpdateArgs<ExtArgs>>
    ): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Applications.
     * @param {applicationsDeleteManyArgs} args - Arguments to filter Applications to delete.
     * @example
     * // Delete a few Applications
     * const { count } = await prisma.applications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends applicationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, applicationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applications
     * const applications = await prisma.applications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends applicationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, applicationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Applications.
     * @param {applicationsUpsertArgs} args - Arguments to update or create a Applications.
     * @example
     * // Update or create a Applications
     * const applications = await prisma.applications.upsert({
     *   create: {
     *     // ... data to create a Applications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Applications we want to update
     *   }
     * })
    **/
    upsert<T extends applicationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, applicationsUpsertArgs<ExtArgs>>
    ): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationsCountArgs} args - Arguments to filter Applications to count.
     * @example
     * // Count the number of Applications
     * const count = await prisma.applications.count({
     *   where: {
     *     // ... the filter for the Applications we want to count
     *   }
     * })
    **/
    count<T extends applicationsCountArgs>(
      args?: Subset<T, applicationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationsAggregateArgs>(args: Subset<T, ApplicationsAggregateArgs>): Prisma.PrismaPromise<GetApplicationsAggregateType<T>>

    /**
     * Group by Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends applicationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: applicationsGroupByArgs['orderBy'] }
        : { orderBy?: applicationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, applicationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the applications model
   */
  readonly fields: applicationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for applications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__applicationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    app_groups<T extends app_groupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, app_groupsDefaultArgs<ExtArgs>>): Prisma__app_groupsClient<$Result.GetResult<Prisma.$app_groupsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    r_roles_apps<T extends applications$r_roles_appsArgs<ExtArgs> = {}>(args?: Subset<T, applications$r_roles_appsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$r_roles_appsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the applications model
   */ 
  interface applicationsFieldRefs {
    readonly id: FieldRef<"applications", 'String'>
    readonly name: FieldRef<"applications", 'String'>
    readonly active: FieldRef<"applications", 'Boolean'>
    readonly type: FieldRef<"applications", 'applications_type'>
    readonly path: FieldRef<"applications", 'String'>
    readonly description: FieldRef<"applications", 'String'>
    readonly app_group_id: FieldRef<"applications", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * applications findUnique
   */
  export type applicationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * Filter, which applications to fetch.
     */
    where: applicationsWhereUniqueInput
  }

  /**
   * applications findUniqueOrThrow
   */
  export type applicationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * Filter, which applications to fetch.
     */
    where: applicationsWhereUniqueInput
  }

  /**
   * applications findFirst
   */
  export type applicationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * Filter, which applications to fetch.
     */
    where?: applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applications to fetch.
     */
    orderBy?: applicationsOrderByWithRelationInput | applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applications.
     */
    cursor?: applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applications.
     */
    distinct?: ApplicationsScalarFieldEnum | ApplicationsScalarFieldEnum[]
  }

  /**
   * applications findFirstOrThrow
   */
  export type applicationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * Filter, which applications to fetch.
     */
    where?: applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applications to fetch.
     */
    orderBy?: applicationsOrderByWithRelationInput | applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applications.
     */
    cursor?: applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applications.
     */
    distinct?: ApplicationsScalarFieldEnum | ApplicationsScalarFieldEnum[]
  }

  /**
   * applications findMany
   */
  export type applicationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * Filter, which applications to fetch.
     */
    where?: applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applications to fetch.
     */
    orderBy?: applicationsOrderByWithRelationInput | applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing applications.
     */
    cursor?: applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applications.
     */
    skip?: number
    distinct?: ApplicationsScalarFieldEnum | ApplicationsScalarFieldEnum[]
  }

  /**
   * applications create
   */
  export type applicationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * The data needed to create a applications.
     */
    data: XOR<applicationsCreateInput, applicationsUncheckedCreateInput>
  }

  /**
   * applications createMany
   */
  export type applicationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many applications.
     */
    data: applicationsCreateManyInput | applicationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * applications update
   */
  export type applicationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * The data needed to update a applications.
     */
    data: XOR<applicationsUpdateInput, applicationsUncheckedUpdateInput>
    /**
     * Choose, which applications to update.
     */
    where: applicationsWhereUniqueInput
  }

  /**
   * applications updateMany
   */
  export type applicationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update applications.
     */
    data: XOR<applicationsUpdateManyMutationInput, applicationsUncheckedUpdateManyInput>
    /**
     * Filter which applications to update
     */
    where?: applicationsWhereInput
  }

  /**
   * applications upsert
   */
  export type applicationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * The filter to search for the applications to update in case it exists.
     */
    where: applicationsWhereUniqueInput
    /**
     * In case the applications found by the `where` argument doesn't exist, create a new applications with this data.
     */
    create: XOR<applicationsCreateInput, applicationsUncheckedCreateInput>
    /**
     * In case the applications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<applicationsUpdateInput, applicationsUncheckedUpdateInput>
  }

  /**
   * applications delete
   */
  export type applicationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * Filter which applications to delete.
     */
    where: applicationsWhereUniqueInput
  }

  /**
   * applications deleteMany
   */
  export type applicationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applications to delete
     */
    where?: applicationsWhereInput
  }

  /**
   * applications.r_roles_apps
   */
  export type applications$r_roles_appsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_roles_apps
     */
    select?: r_roles_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_roles_appsInclude<ExtArgs> | null
    where?: r_roles_appsWhereInput
    orderBy?: r_roles_appsOrderByWithRelationInput | r_roles_appsOrderByWithRelationInput[]
    cursor?: r_roles_appsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: R_roles_appsScalarFieldEnum | R_roles_appsScalarFieldEnum[]
  }

  /**
   * applications without action
   */
  export type applicationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
  }


  /**
   * Model banks
   */

  export type AggregateBanks = {
    _count: BanksCountAggregateOutputType | null
    _avg: BanksAvgAggregateOutputType | null
    _sum: BanksSumAggregateOutputType | null
    _min: BanksMinAggregateOutputType | null
    _max: BanksMaxAggregateOutputType | null
  }

  export type BanksAvgAggregateOutputType = {
    id: number | null
  }

  export type BanksSumAggregateOutputType = {
    id: number | null
  }

  export type BanksMinAggregateOutputType = {
    id: number | null
    name: string | null
    city: string | null
    bik: string | null
    correspondent_number: string | null
  }

  export type BanksMaxAggregateOutputType = {
    id: number | null
    name: string | null
    city: string | null
    bik: string | null
    correspondent_number: string | null
  }

  export type BanksCountAggregateOutputType = {
    id: number
    name: number
    city: number
    bik: number
    correspondent_number: number
    _all: number
  }


  export type BanksAvgAggregateInputType = {
    id?: true
  }

  export type BanksSumAggregateInputType = {
    id?: true
  }

  export type BanksMinAggregateInputType = {
    id?: true
    name?: true
    city?: true
    bik?: true
    correspondent_number?: true
  }

  export type BanksMaxAggregateInputType = {
    id?: true
    name?: true
    city?: true
    bik?: true
    correspondent_number?: true
  }

  export type BanksCountAggregateInputType = {
    id?: true
    name?: true
    city?: true
    bik?: true
    correspondent_number?: true
    _all?: true
  }

  export type BanksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which banks to aggregate.
     */
    where?: banksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks to fetch.
     */
    orderBy?: banksOrderByWithRelationInput | banksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: banksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned banks
    **/
    _count?: true | BanksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BanksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BanksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BanksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BanksMaxAggregateInputType
  }

  export type GetBanksAggregateType<T extends BanksAggregateArgs> = {
        [P in keyof T & keyof AggregateBanks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanks[P]>
      : GetScalarType<T[P], AggregateBanks[P]>
  }




  export type banksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: banksWhereInput
    orderBy?: banksOrderByWithAggregationInput | banksOrderByWithAggregationInput[]
    by: BanksScalarFieldEnum[] | BanksScalarFieldEnum
    having?: banksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BanksCountAggregateInputType | true
    _avg?: BanksAvgAggregateInputType
    _sum?: BanksSumAggregateInputType
    _min?: BanksMinAggregateInputType
    _max?: BanksMaxAggregateInputType
  }

  export type BanksGroupByOutputType = {
    id: number
    name: string
    city: string | null
    bik: string
    correspondent_number: string | null
    _count: BanksCountAggregateOutputType | null
    _avg: BanksAvgAggregateOutputType | null
    _sum: BanksSumAggregateOutputType | null
    _min: BanksMinAggregateOutputType | null
    _max: BanksMaxAggregateOutputType | null
  }

  type GetBanksGroupByPayload<T extends banksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BanksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BanksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BanksGroupByOutputType[P]>
            : GetScalarType<T[P], BanksGroupByOutputType[P]>
        }
      >
    >


  export type banksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    city?: boolean
    bik?: boolean
    correspondent_number?: boolean
    accounts?: boolean | banks$accountsArgs<ExtArgs>
    banks_items_versions?: boolean | banks$banks_items_versionsArgs<ExtArgs>
    _count?: boolean | BanksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banks"]>


  export type banksSelectScalar = {
    id?: boolean
    name?: boolean
    city?: boolean
    bik?: boolean
    correspondent_number?: boolean
  }

  export type banksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | banks$accountsArgs<ExtArgs>
    banks_items_versions?: boolean | banks$banks_items_versionsArgs<ExtArgs>
    _count?: boolean | BanksCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $banksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "banks"
    objects: {
      accounts: Prisma.$accountsPayload<ExtArgs>[]
      banks_items_versions: Prisma.$banks_items_versionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      city: string | null
      bik: string
      correspondent_number: string | null
    }, ExtArgs["result"]["banks"]>
    composites: {}
  }

  type banksGetPayload<S extends boolean | null | undefined | banksDefaultArgs> = $Result.GetResult<Prisma.$banksPayload, S>

  type banksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<banksFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BanksCountAggregateInputType | true
    }

  export interface banksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['banks'], meta: { name: 'banks' } }
    /**
     * Find zero or one Banks that matches the filter.
     * @param {banksFindUniqueArgs} args - Arguments to find a Banks
     * @example
     * // Get one Banks
     * const banks = await prisma.banks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends banksFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, banksFindUniqueArgs<ExtArgs>>
    ): Prisma__banksClient<$Result.GetResult<Prisma.$banksPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Banks that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {banksFindUniqueOrThrowArgs} args - Arguments to find a Banks
     * @example
     * // Get one Banks
     * const banks = await prisma.banks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends banksFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, banksFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__banksClient<$Result.GetResult<Prisma.$banksPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Banks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banksFindFirstArgs} args - Arguments to find a Banks
     * @example
     * // Get one Banks
     * const banks = await prisma.banks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends banksFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, banksFindFirstArgs<ExtArgs>>
    ): Prisma__banksClient<$Result.GetResult<Prisma.$banksPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Banks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banksFindFirstOrThrowArgs} args - Arguments to find a Banks
     * @example
     * // Get one Banks
     * const banks = await prisma.banks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends banksFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, banksFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__banksClient<$Result.GetResult<Prisma.$banksPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Banks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banks
     * const banks = await prisma.banks.findMany()
     * 
     * // Get first 10 Banks
     * const banks = await prisma.banks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const banksWithIdOnly = await prisma.banks.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends banksFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, banksFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$banksPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Banks.
     * @param {banksCreateArgs} args - Arguments to create a Banks.
     * @example
     * // Create one Banks
     * const Banks = await prisma.banks.create({
     *   data: {
     *     // ... data to create a Banks
     *   }
     * })
     * 
    **/
    create<T extends banksCreateArgs<ExtArgs>>(
      args: SelectSubset<T, banksCreateArgs<ExtArgs>>
    ): Prisma__banksClient<$Result.GetResult<Prisma.$banksPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Banks.
     * @param {banksCreateManyArgs} args - Arguments to create many Banks.
     * @example
     * // Create many Banks
     * const banks = await prisma.banks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends banksCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, banksCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Banks.
     * @param {banksDeleteArgs} args - Arguments to delete one Banks.
     * @example
     * // Delete one Banks
     * const Banks = await prisma.banks.delete({
     *   where: {
     *     // ... filter to delete one Banks
     *   }
     * })
     * 
    **/
    delete<T extends banksDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, banksDeleteArgs<ExtArgs>>
    ): Prisma__banksClient<$Result.GetResult<Prisma.$banksPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Banks.
     * @param {banksUpdateArgs} args - Arguments to update one Banks.
     * @example
     * // Update one Banks
     * const banks = await prisma.banks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends banksUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, banksUpdateArgs<ExtArgs>>
    ): Prisma__banksClient<$Result.GetResult<Prisma.$banksPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Banks.
     * @param {banksDeleteManyArgs} args - Arguments to filter Banks to delete.
     * @example
     * // Delete a few Banks
     * const { count } = await prisma.banks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends banksDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, banksDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banks
     * const banks = await prisma.banks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends banksUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, banksUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Banks.
     * @param {banksUpsertArgs} args - Arguments to update or create a Banks.
     * @example
     * // Update or create a Banks
     * const banks = await prisma.banks.upsert({
     *   create: {
     *     // ... data to create a Banks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banks we want to update
     *   }
     * })
    **/
    upsert<T extends banksUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, banksUpsertArgs<ExtArgs>>
    ): Prisma__banksClient<$Result.GetResult<Prisma.$banksPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banksCountArgs} args - Arguments to filter Banks to count.
     * @example
     * // Count the number of Banks
     * const count = await prisma.banks.count({
     *   where: {
     *     // ... the filter for the Banks we want to count
     *   }
     * })
    **/
    count<T extends banksCountArgs>(
      args?: Subset<T, banksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BanksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BanksAggregateArgs>(args: Subset<T, BanksAggregateArgs>): Prisma.PrismaPromise<GetBanksAggregateType<T>>

    /**
     * Group by Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends banksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: banksGroupByArgs['orderBy'] }
        : { orderBy?: banksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, banksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBanksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the banks model
   */
  readonly fields: banksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for banks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__banksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    accounts<T extends banks$accountsArgs<ExtArgs> = {}>(args?: Subset<T, banks$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, 'findMany'> | Null>;

    banks_items_versions<T extends banks$banks_items_versionsArgs<ExtArgs> = {}>(args?: Subset<T, banks$banks_items_versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$banks_items_versionsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the banks model
   */ 
  interface banksFieldRefs {
    readonly id: FieldRef<"banks", 'Int'>
    readonly name: FieldRef<"banks", 'String'>
    readonly city: FieldRef<"banks", 'String'>
    readonly bik: FieldRef<"banks", 'String'>
    readonly correspondent_number: FieldRef<"banks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * banks findUnique
   */
  export type banksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks
     */
    select?: banksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banksInclude<ExtArgs> | null
    /**
     * Filter, which banks to fetch.
     */
    where: banksWhereUniqueInput
  }

  /**
   * banks findUniqueOrThrow
   */
  export type banksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks
     */
    select?: banksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banksInclude<ExtArgs> | null
    /**
     * Filter, which banks to fetch.
     */
    where: banksWhereUniqueInput
  }

  /**
   * banks findFirst
   */
  export type banksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks
     */
    select?: banksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banksInclude<ExtArgs> | null
    /**
     * Filter, which banks to fetch.
     */
    where?: banksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks to fetch.
     */
    orderBy?: banksOrderByWithRelationInput | banksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banks.
     */
    cursor?: banksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banks.
     */
    distinct?: BanksScalarFieldEnum | BanksScalarFieldEnum[]
  }

  /**
   * banks findFirstOrThrow
   */
  export type banksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks
     */
    select?: banksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banksInclude<ExtArgs> | null
    /**
     * Filter, which banks to fetch.
     */
    where?: banksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks to fetch.
     */
    orderBy?: banksOrderByWithRelationInput | banksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banks.
     */
    cursor?: banksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banks.
     */
    distinct?: BanksScalarFieldEnum | BanksScalarFieldEnum[]
  }

  /**
   * banks findMany
   */
  export type banksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks
     */
    select?: banksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banksInclude<ExtArgs> | null
    /**
     * Filter, which banks to fetch.
     */
    where?: banksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks to fetch.
     */
    orderBy?: banksOrderByWithRelationInput | banksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing banks.
     */
    cursor?: banksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks.
     */
    skip?: number
    distinct?: BanksScalarFieldEnum | BanksScalarFieldEnum[]
  }

  /**
   * banks create
   */
  export type banksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks
     */
    select?: banksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banksInclude<ExtArgs> | null
    /**
     * The data needed to create a banks.
     */
    data: XOR<banksCreateInput, banksUncheckedCreateInput>
  }

  /**
   * banks createMany
   */
  export type banksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many banks.
     */
    data: banksCreateManyInput | banksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * banks update
   */
  export type banksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks
     */
    select?: banksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banksInclude<ExtArgs> | null
    /**
     * The data needed to update a banks.
     */
    data: XOR<banksUpdateInput, banksUncheckedUpdateInput>
    /**
     * Choose, which banks to update.
     */
    where: banksWhereUniqueInput
  }

  /**
   * banks updateMany
   */
  export type banksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update banks.
     */
    data: XOR<banksUpdateManyMutationInput, banksUncheckedUpdateManyInput>
    /**
     * Filter which banks to update
     */
    where?: banksWhereInput
  }

  /**
   * banks upsert
   */
  export type banksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks
     */
    select?: banksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banksInclude<ExtArgs> | null
    /**
     * The filter to search for the banks to update in case it exists.
     */
    where: banksWhereUniqueInput
    /**
     * In case the banks found by the `where` argument doesn't exist, create a new banks with this data.
     */
    create: XOR<banksCreateInput, banksUncheckedCreateInput>
    /**
     * In case the banks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<banksUpdateInput, banksUncheckedUpdateInput>
  }

  /**
   * banks delete
   */
  export type banksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks
     */
    select?: banksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banksInclude<ExtArgs> | null
    /**
     * Filter which banks to delete.
     */
    where: banksWhereUniqueInput
  }

  /**
   * banks deleteMany
   */
  export type banksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which banks to delete
     */
    where?: banksWhereInput
  }

  /**
   * banks.accounts
   */
  export type banks$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    where?: accountsWhereInput
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    cursor?: accountsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * banks.banks_items_versions
   */
  export type banks$banks_items_versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items_versions
     */
    select?: banks_items_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_items_versionsInclude<ExtArgs> | null
    where?: banks_items_versionsWhereInput
    orderBy?: banks_items_versionsOrderByWithRelationInput | banks_items_versionsOrderByWithRelationInput[]
    cursor?: banks_items_versionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Banks_items_versionsScalarFieldEnum | Banks_items_versionsScalarFieldEnum[]
  }

  /**
   * banks without action
   */
  export type banksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks
     */
    select?: banksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banksInclude<ExtArgs> | null
  }


  /**
   * Model banks_items
   */

  export type AggregateBanks_items = {
    _count: Banks_itemsCountAggregateOutputType | null
    _avg: Banks_itemsAvgAggregateOutputType | null
    _sum: Banks_itemsSumAggregateOutputType | null
    _min: Banks_itemsMinAggregateOutputType | null
    _max: Banks_itemsMaxAggregateOutputType | null
  }

  export type Banks_itemsAvgAggregateOutputType = {
    id: number | null
    order_num: number | null
    banks_pakets_id: number | null
    version_id: number | null
  }

  export type Banks_itemsSumAggregateOutputType = {
    id: number | null
    order_num: number | null
    banks_pakets_id: number | null
    version_id: bigint | null
  }

  export type Banks_itemsMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    order_num: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    banks_pakets_id: number | null
    propogated_at: Date | null
    version_id: bigint | null
  }

  export type Banks_itemsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    order_num: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    banks_pakets_id: number | null
    propogated_at: Date | null
    version_id: bigint | null
  }

  export type Banks_itemsCountAggregateOutputType = {
    id: number
    name: number
    code: number
    order_num: number
    is_active: number
    created_at: number
    updated_at: number
    banks_pakets_id: number
    propogated_at: number
    version_id: number
    _all: number
  }


  export type Banks_itemsAvgAggregateInputType = {
    id?: true
    order_num?: true
    banks_pakets_id?: true
    version_id?: true
  }

  export type Banks_itemsSumAggregateInputType = {
    id?: true
    order_num?: true
    banks_pakets_id?: true
    version_id?: true
  }

  export type Banks_itemsMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    order_num?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    banks_pakets_id?: true
    propogated_at?: true
    version_id?: true
  }

  export type Banks_itemsMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    order_num?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    banks_pakets_id?: true
    propogated_at?: true
    version_id?: true
  }

  export type Banks_itemsCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    order_num?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    banks_pakets_id?: true
    propogated_at?: true
    version_id?: true
    _all?: true
  }

  export type Banks_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which banks_items to aggregate.
     */
    where?: banks_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks_items to fetch.
     */
    orderBy?: banks_itemsOrderByWithRelationInput | banks_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: banks_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned banks_items
    **/
    _count?: true | Banks_itemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Banks_itemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Banks_itemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Banks_itemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Banks_itemsMaxAggregateInputType
  }

  export type GetBanks_itemsAggregateType<T extends Banks_itemsAggregateArgs> = {
        [P in keyof T & keyof AggregateBanks_items]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanks_items[P]>
      : GetScalarType<T[P], AggregateBanks_items[P]>
  }




  export type banks_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: banks_itemsWhereInput
    orderBy?: banks_itemsOrderByWithAggregationInput | banks_itemsOrderByWithAggregationInput[]
    by: Banks_itemsScalarFieldEnum[] | Banks_itemsScalarFieldEnum
    having?: banks_itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Banks_itemsCountAggregateInputType | true
    _avg?: Banks_itemsAvgAggregateInputType
    _sum?: Banks_itemsSumAggregateInputType
    _min?: Banks_itemsMinAggregateInputType
    _max?: Banks_itemsMaxAggregateInputType
  }

  export type Banks_itemsGroupByOutputType = {
    id: number
    name: string
    code: string
    order_num: number | null
    is_active: boolean
    created_at: Date | null
    updated_at: Date | null
    banks_pakets_id: number | null
    propogated_at: Date | null
    version_id: bigint | null
    _count: Banks_itemsCountAggregateOutputType | null
    _avg: Banks_itemsAvgAggregateOutputType | null
    _sum: Banks_itemsSumAggregateOutputType | null
    _min: Banks_itemsMinAggregateOutputType | null
    _max: Banks_itemsMaxAggregateOutputType | null
  }

  type GetBanks_itemsGroupByPayload<T extends banks_itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Banks_itemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Banks_itemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Banks_itemsGroupByOutputType[P]>
            : GetScalarType<T[P], Banks_itemsGroupByOutputType[P]>
        }
      >
    >


  export type banks_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    order_num?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    banks_pakets_id?: boolean
    propogated_at?: boolean
    version_id?: boolean
    banks_pakets?: boolean | banks_items$banks_paketsArgs<ExtArgs>
    banks_items_versions?: boolean | banks_items$banks_items_versionsArgs<ExtArgs>
    items?: boolean | banks_items$itemsArgs<ExtArgs>
    _count?: boolean | Banks_itemsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banks_items"]>


  export type banks_itemsSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    order_num?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    banks_pakets_id?: boolean
    propogated_at?: boolean
    version_id?: boolean
  }

  export type banks_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banks_pakets?: boolean | banks_items$banks_paketsArgs<ExtArgs>
    banks_items_versions?: boolean | banks_items$banks_items_versionsArgs<ExtArgs>
    items?: boolean | banks_items$itemsArgs<ExtArgs>
    _count?: boolean | Banks_itemsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $banks_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "banks_items"
    objects: {
      banks_pakets: Prisma.$banks_paketsPayload<ExtArgs> | null
      banks_items_versions: Prisma.$banks_items_versionsPayload<ExtArgs> | null
      items: Prisma.$itemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      order_num: number | null
      is_active: boolean
      created_at: Date | null
      updated_at: Date | null
      banks_pakets_id: number | null
      propogated_at: Date | null
      version_id: bigint | null
    }, ExtArgs["result"]["banks_items"]>
    composites: {}
  }

  type banks_itemsGetPayload<S extends boolean | null | undefined | banks_itemsDefaultArgs> = $Result.GetResult<Prisma.$banks_itemsPayload, S>

  type banks_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<banks_itemsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Banks_itemsCountAggregateInputType | true
    }

  export interface banks_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['banks_items'], meta: { name: 'banks_items' } }
    /**
     * Find zero or one Banks_items that matches the filter.
     * @param {banks_itemsFindUniqueArgs} args - Arguments to find a Banks_items
     * @example
     * // Get one Banks_items
     * const banks_items = await prisma.banks_items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends banks_itemsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, banks_itemsFindUniqueArgs<ExtArgs>>
    ): Prisma__banks_itemsClient<$Result.GetResult<Prisma.$banks_itemsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Banks_items that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {banks_itemsFindUniqueOrThrowArgs} args - Arguments to find a Banks_items
     * @example
     * // Get one Banks_items
     * const banks_items = await prisma.banks_items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends banks_itemsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, banks_itemsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__banks_itemsClient<$Result.GetResult<Prisma.$banks_itemsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Banks_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banks_itemsFindFirstArgs} args - Arguments to find a Banks_items
     * @example
     * // Get one Banks_items
     * const banks_items = await prisma.banks_items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends banks_itemsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, banks_itemsFindFirstArgs<ExtArgs>>
    ): Prisma__banks_itemsClient<$Result.GetResult<Prisma.$banks_itemsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Banks_items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banks_itemsFindFirstOrThrowArgs} args - Arguments to find a Banks_items
     * @example
     * // Get one Banks_items
     * const banks_items = await prisma.banks_items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends banks_itemsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, banks_itemsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__banks_itemsClient<$Result.GetResult<Prisma.$banks_itemsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Banks_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banks_itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banks_items
     * const banks_items = await prisma.banks_items.findMany()
     * 
     * // Get first 10 Banks_items
     * const banks_items = await prisma.banks_items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const banks_itemsWithIdOnly = await prisma.banks_items.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends banks_itemsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, banks_itemsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$banks_itemsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Banks_items.
     * @param {banks_itemsCreateArgs} args - Arguments to create a Banks_items.
     * @example
     * // Create one Banks_items
     * const Banks_items = await prisma.banks_items.create({
     *   data: {
     *     // ... data to create a Banks_items
     *   }
     * })
     * 
    **/
    create<T extends banks_itemsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, banks_itemsCreateArgs<ExtArgs>>
    ): Prisma__banks_itemsClient<$Result.GetResult<Prisma.$banks_itemsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Banks_items.
     * @param {banks_itemsCreateManyArgs} args - Arguments to create many Banks_items.
     * @example
     * // Create many Banks_items
     * const banks_items = await prisma.banks_items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends banks_itemsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, banks_itemsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Banks_items.
     * @param {banks_itemsDeleteArgs} args - Arguments to delete one Banks_items.
     * @example
     * // Delete one Banks_items
     * const Banks_items = await prisma.banks_items.delete({
     *   where: {
     *     // ... filter to delete one Banks_items
     *   }
     * })
     * 
    **/
    delete<T extends banks_itemsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, banks_itemsDeleteArgs<ExtArgs>>
    ): Prisma__banks_itemsClient<$Result.GetResult<Prisma.$banks_itemsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Banks_items.
     * @param {banks_itemsUpdateArgs} args - Arguments to update one Banks_items.
     * @example
     * // Update one Banks_items
     * const banks_items = await prisma.banks_items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends banks_itemsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, banks_itemsUpdateArgs<ExtArgs>>
    ): Prisma__banks_itemsClient<$Result.GetResult<Prisma.$banks_itemsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Banks_items.
     * @param {banks_itemsDeleteManyArgs} args - Arguments to filter Banks_items to delete.
     * @example
     * // Delete a few Banks_items
     * const { count } = await prisma.banks_items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends banks_itemsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, banks_itemsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banks_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banks_itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banks_items
     * const banks_items = await prisma.banks_items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends banks_itemsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, banks_itemsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Banks_items.
     * @param {banks_itemsUpsertArgs} args - Arguments to update or create a Banks_items.
     * @example
     * // Update or create a Banks_items
     * const banks_items = await prisma.banks_items.upsert({
     *   create: {
     *     // ... data to create a Banks_items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banks_items we want to update
     *   }
     * })
    **/
    upsert<T extends banks_itemsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, banks_itemsUpsertArgs<ExtArgs>>
    ): Prisma__banks_itemsClient<$Result.GetResult<Prisma.$banks_itemsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Banks_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banks_itemsCountArgs} args - Arguments to filter Banks_items to count.
     * @example
     * // Count the number of Banks_items
     * const count = await prisma.banks_items.count({
     *   where: {
     *     // ... the filter for the Banks_items we want to count
     *   }
     * })
    **/
    count<T extends banks_itemsCountArgs>(
      args?: Subset<T, banks_itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Banks_itemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banks_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Banks_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Banks_itemsAggregateArgs>(args: Subset<T, Banks_itemsAggregateArgs>): Prisma.PrismaPromise<GetBanks_itemsAggregateType<T>>

    /**
     * Group by Banks_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banks_itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends banks_itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: banks_itemsGroupByArgs['orderBy'] }
        : { orderBy?: banks_itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, banks_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBanks_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the banks_items model
   */
  readonly fields: banks_itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for banks_items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__banks_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    banks_pakets<T extends banks_items$banks_paketsArgs<ExtArgs> = {}>(args?: Subset<T, banks_items$banks_paketsArgs<ExtArgs>>): Prisma__banks_paketsClient<$Result.GetResult<Prisma.$banks_paketsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    banks_items_versions<T extends banks_items$banks_items_versionsArgs<ExtArgs> = {}>(args?: Subset<T, banks_items$banks_items_versionsArgs<ExtArgs>>): Prisma__banks_items_versionsClient<$Result.GetResult<Prisma.$banks_items_versionsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    items<T extends banks_items$itemsArgs<ExtArgs> = {}>(args?: Subset<T, banks_items$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the banks_items model
   */ 
  interface banks_itemsFieldRefs {
    readonly id: FieldRef<"banks_items", 'Int'>
    readonly name: FieldRef<"banks_items", 'String'>
    readonly code: FieldRef<"banks_items", 'String'>
    readonly order_num: FieldRef<"banks_items", 'Int'>
    readonly is_active: FieldRef<"banks_items", 'Boolean'>
    readonly created_at: FieldRef<"banks_items", 'DateTime'>
    readonly updated_at: FieldRef<"banks_items", 'DateTime'>
    readonly banks_pakets_id: FieldRef<"banks_items", 'Int'>
    readonly propogated_at: FieldRef<"banks_items", 'DateTime'>
    readonly version_id: FieldRef<"banks_items", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * banks_items findUnique
   */
  export type banks_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items
     */
    select?: banks_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_itemsInclude<ExtArgs> | null
    /**
     * Filter, which banks_items to fetch.
     */
    where: banks_itemsWhereUniqueInput
  }

  /**
   * banks_items findUniqueOrThrow
   */
  export type banks_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items
     */
    select?: banks_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_itemsInclude<ExtArgs> | null
    /**
     * Filter, which banks_items to fetch.
     */
    where: banks_itemsWhereUniqueInput
  }

  /**
   * banks_items findFirst
   */
  export type banks_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items
     */
    select?: banks_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_itemsInclude<ExtArgs> | null
    /**
     * Filter, which banks_items to fetch.
     */
    where?: banks_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks_items to fetch.
     */
    orderBy?: banks_itemsOrderByWithRelationInput | banks_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banks_items.
     */
    cursor?: banks_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banks_items.
     */
    distinct?: Banks_itemsScalarFieldEnum | Banks_itemsScalarFieldEnum[]
  }

  /**
   * banks_items findFirstOrThrow
   */
  export type banks_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items
     */
    select?: banks_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_itemsInclude<ExtArgs> | null
    /**
     * Filter, which banks_items to fetch.
     */
    where?: banks_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks_items to fetch.
     */
    orderBy?: banks_itemsOrderByWithRelationInput | banks_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banks_items.
     */
    cursor?: banks_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banks_items.
     */
    distinct?: Banks_itemsScalarFieldEnum | Banks_itemsScalarFieldEnum[]
  }

  /**
   * banks_items findMany
   */
  export type banks_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items
     */
    select?: banks_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_itemsInclude<ExtArgs> | null
    /**
     * Filter, which banks_items to fetch.
     */
    where?: banks_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks_items to fetch.
     */
    orderBy?: banks_itemsOrderByWithRelationInput | banks_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing banks_items.
     */
    cursor?: banks_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks_items.
     */
    skip?: number
    distinct?: Banks_itemsScalarFieldEnum | Banks_itemsScalarFieldEnum[]
  }

  /**
   * banks_items create
   */
  export type banks_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items
     */
    select?: banks_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_itemsInclude<ExtArgs> | null
    /**
     * The data needed to create a banks_items.
     */
    data: XOR<banks_itemsCreateInput, banks_itemsUncheckedCreateInput>
  }

  /**
   * banks_items createMany
   */
  export type banks_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many banks_items.
     */
    data: banks_itemsCreateManyInput | banks_itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * banks_items update
   */
  export type banks_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items
     */
    select?: banks_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_itemsInclude<ExtArgs> | null
    /**
     * The data needed to update a banks_items.
     */
    data: XOR<banks_itemsUpdateInput, banks_itemsUncheckedUpdateInput>
    /**
     * Choose, which banks_items to update.
     */
    where: banks_itemsWhereUniqueInput
  }

  /**
   * banks_items updateMany
   */
  export type banks_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update banks_items.
     */
    data: XOR<banks_itemsUpdateManyMutationInput, banks_itemsUncheckedUpdateManyInput>
    /**
     * Filter which banks_items to update
     */
    where?: banks_itemsWhereInput
  }

  /**
   * banks_items upsert
   */
  export type banks_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items
     */
    select?: banks_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_itemsInclude<ExtArgs> | null
    /**
     * The filter to search for the banks_items to update in case it exists.
     */
    where: banks_itemsWhereUniqueInput
    /**
     * In case the banks_items found by the `where` argument doesn't exist, create a new banks_items with this data.
     */
    create: XOR<banks_itemsCreateInput, banks_itemsUncheckedCreateInput>
    /**
     * In case the banks_items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<banks_itemsUpdateInput, banks_itemsUncheckedUpdateInput>
  }

  /**
   * banks_items delete
   */
  export type banks_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items
     */
    select?: banks_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_itemsInclude<ExtArgs> | null
    /**
     * Filter which banks_items to delete.
     */
    where: banks_itemsWhereUniqueInput
  }

  /**
   * banks_items deleteMany
   */
  export type banks_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which banks_items to delete
     */
    where?: banks_itemsWhereInput
  }

  /**
   * banks_items.banks_pakets
   */
  export type banks_items$banks_paketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_pakets
     */
    select?: banks_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_paketsInclude<ExtArgs> | null
    where?: banks_paketsWhereInput
  }

  /**
   * banks_items.banks_items_versions
   */
  export type banks_items$banks_items_versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items_versions
     */
    select?: banks_items_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_items_versionsInclude<ExtArgs> | null
    where?: banks_items_versionsWhereInput
  }

  /**
   * banks_items.items
   */
  export type banks_items$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    where?: itemsWhereInput
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    cursor?: itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * banks_items without action
   */
  export type banks_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items
     */
    select?: banks_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_itemsInclude<ExtArgs> | null
  }


  /**
   * Model banks_pakets
   */

  export type AggregateBanks_pakets = {
    _count: Banks_paketsCountAggregateOutputType | null
    _avg: Banks_paketsAvgAggregateOutputType | null
    _sum: Banks_paketsSumAggregateOutputType | null
    _min: Banks_paketsMinAggregateOutputType | null
    _max: Banks_paketsMaxAggregateOutputType | null
  }

  export type Banks_paketsAvgAggregateOutputType = {
    id: number | null
    order_num: number | null
  }

  export type Banks_paketsSumAggregateOutputType = {
    id: number | null
    order_num: number | null
  }

  export type Banks_paketsMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    order_num: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    propogated_at: Date | null
  }

  export type Banks_paketsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    order_num: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    propogated_at: Date | null
  }

  export type Banks_paketsCountAggregateOutputType = {
    id: number
    name: number
    code: number
    order_num: number
    is_active: number
    created_at: number
    updated_at: number
    propogated_at: number
    _all: number
  }


  export type Banks_paketsAvgAggregateInputType = {
    id?: true
    order_num?: true
  }

  export type Banks_paketsSumAggregateInputType = {
    id?: true
    order_num?: true
  }

  export type Banks_paketsMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    order_num?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    propogated_at?: true
  }

  export type Banks_paketsMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    order_num?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    propogated_at?: true
  }

  export type Banks_paketsCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    order_num?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    propogated_at?: true
    _all?: true
  }

  export type Banks_paketsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which banks_pakets to aggregate.
     */
    where?: banks_paketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks_pakets to fetch.
     */
    orderBy?: banks_paketsOrderByWithRelationInput | banks_paketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: banks_paketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks_pakets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks_pakets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned banks_pakets
    **/
    _count?: true | Banks_paketsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Banks_paketsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Banks_paketsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Banks_paketsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Banks_paketsMaxAggregateInputType
  }

  export type GetBanks_paketsAggregateType<T extends Banks_paketsAggregateArgs> = {
        [P in keyof T & keyof AggregateBanks_pakets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanks_pakets[P]>
      : GetScalarType<T[P], AggregateBanks_pakets[P]>
  }




  export type banks_paketsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: banks_paketsWhereInput
    orderBy?: banks_paketsOrderByWithAggregationInput | banks_paketsOrderByWithAggregationInput[]
    by: Banks_paketsScalarFieldEnum[] | Banks_paketsScalarFieldEnum
    having?: banks_paketsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Banks_paketsCountAggregateInputType | true
    _avg?: Banks_paketsAvgAggregateInputType
    _sum?: Banks_paketsSumAggregateInputType
    _min?: Banks_paketsMinAggregateInputType
    _max?: Banks_paketsMaxAggregateInputType
  }

  export type Banks_paketsGroupByOutputType = {
    id: number
    name: string
    code: string
    order_num: number | null
    is_active: boolean
    created_at: Date | null
    updated_at: Date | null
    propogated_at: Date | null
    _count: Banks_paketsCountAggregateOutputType | null
    _avg: Banks_paketsAvgAggregateOutputType | null
    _sum: Banks_paketsSumAggregateOutputType | null
    _min: Banks_paketsMinAggregateOutputType | null
    _max: Banks_paketsMaxAggregateOutputType | null
  }

  type GetBanks_paketsGroupByPayload<T extends banks_paketsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Banks_paketsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Banks_paketsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Banks_paketsGroupByOutputType[P]>
            : GetScalarType<T[P], Banks_paketsGroupByOutputType[P]>
        }
      >
    >


  export type banks_paketsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    order_num?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    propogated_at?: boolean
    banks_items?: boolean | banks_pakets$banks_itemsArgs<ExtArgs>
    _count?: boolean | Banks_paketsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banks_pakets"]>


  export type banks_paketsSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    order_num?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    propogated_at?: boolean
  }

  export type banks_paketsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banks_items?: boolean | banks_pakets$banks_itemsArgs<ExtArgs>
    _count?: boolean | Banks_paketsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $banks_paketsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "banks_pakets"
    objects: {
      banks_items: Prisma.$banks_itemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      order_num: number | null
      is_active: boolean
      created_at: Date | null
      updated_at: Date | null
      propogated_at: Date | null
    }, ExtArgs["result"]["banks_pakets"]>
    composites: {}
  }

  type banks_paketsGetPayload<S extends boolean | null | undefined | banks_paketsDefaultArgs> = $Result.GetResult<Prisma.$banks_paketsPayload, S>

  type banks_paketsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<banks_paketsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Banks_paketsCountAggregateInputType | true
    }

  export interface banks_paketsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['banks_pakets'], meta: { name: 'banks_pakets' } }
    /**
     * Find zero or one Banks_pakets that matches the filter.
     * @param {banks_paketsFindUniqueArgs} args - Arguments to find a Banks_pakets
     * @example
     * // Get one Banks_pakets
     * const banks_pakets = await prisma.banks_pakets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends banks_paketsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, banks_paketsFindUniqueArgs<ExtArgs>>
    ): Prisma__banks_paketsClient<$Result.GetResult<Prisma.$banks_paketsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Banks_pakets that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {banks_paketsFindUniqueOrThrowArgs} args - Arguments to find a Banks_pakets
     * @example
     * // Get one Banks_pakets
     * const banks_pakets = await prisma.banks_pakets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends banks_paketsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, banks_paketsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__banks_paketsClient<$Result.GetResult<Prisma.$banks_paketsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Banks_pakets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banks_paketsFindFirstArgs} args - Arguments to find a Banks_pakets
     * @example
     * // Get one Banks_pakets
     * const banks_pakets = await prisma.banks_pakets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends banks_paketsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, banks_paketsFindFirstArgs<ExtArgs>>
    ): Prisma__banks_paketsClient<$Result.GetResult<Prisma.$banks_paketsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Banks_pakets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banks_paketsFindFirstOrThrowArgs} args - Arguments to find a Banks_pakets
     * @example
     * // Get one Banks_pakets
     * const banks_pakets = await prisma.banks_pakets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends banks_paketsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, banks_paketsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__banks_paketsClient<$Result.GetResult<Prisma.$banks_paketsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Banks_pakets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banks_paketsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banks_pakets
     * const banks_pakets = await prisma.banks_pakets.findMany()
     * 
     * // Get first 10 Banks_pakets
     * const banks_pakets = await prisma.banks_pakets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const banks_paketsWithIdOnly = await prisma.banks_pakets.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends banks_paketsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, banks_paketsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$banks_paketsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Banks_pakets.
     * @param {banks_paketsCreateArgs} args - Arguments to create a Banks_pakets.
     * @example
     * // Create one Banks_pakets
     * const Banks_pakets = await prisma.banks_pakets.create({
     *   data: {
     *     // ... data to create a Banks_pakets
     *   }
     * })
     * 
    **/
    create<T extends banks_paketsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, banks_paketsCreateArgs<ExtArgs>>
    ): Prisma__banks_paketsClient<$Result.GetResult<Prisma.$banks_paketsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Banks_pakets.
     * @param {banks_paketsCreateManyArgs} args - Arguments to create many Banks_pakets.
     * @example
     * // Create many Banks_pakets
     * const banks_pakets = await prisma.banks_pakets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends banks_paketsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, banks_paketsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Banks_pakets.
     * @param {banks_paketsDeleteArgs} args - Arguments to delete one Banks_pakets.
     * @example
     * // Delete one Banks_pakets
     * const Banks_pakets = await prisma.banks_pakets.delete({
     *   where: {
     *     // ... filter to delete one Banks_pakets
     *   }
     * })
     * 
    **/
    delete<T extends banks_paketsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, banks_paketsDeleteArgs<ExtArgs>>
    ): Prisma__banks_paketsClient<$Result.GetResult<Prisma.$banks_paketsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Banks_pakets.
     * @param {banks_paketsUpdateArgs} args - Arguments to update one Banks_pakets.
     * @example
     * // Update one Banks_pakets
     * const banks_pakets = await prisma.banks_pakets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends banks_paketsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, banks_paketsUpdateArgs<ExtArgs>>
    ): Prisma__banks_paketsClient<$Result.GetResult<Prisma.$banks_paketsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Banks_pakets.
     * @param {banks_paketsDeleteManyArgs} args - Arguments to filter Banks_pakets to delete.
     * @example
     * // Delete a few Banks_pakets
     * const { count } = await prisma.banks_pakets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends banks_paketsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, banks_paketsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banks_pakets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banks_paketsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banks_pakets
     * const banks_pakets = await prisma.banks_pakets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends banks_paketsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, banks_paketsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Banks_pakets.
     * @param {banks_paketsUpsertArgs} args - Arguments to update or create a Banks_pakets.
     * @example
     * // Update or create a Banks_pakets
     * const banks_pakets = await prisma.banks_pakets.upsert({
     *   create: {
     *     // ... data to create a Banks_pakets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banks_pakets we want to update
     *   }
     * })
    **/
    upsert<T extends banks_paketsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, banks_paketsUpsertArgs<ExtArgs>>
    ): Prisma__banks_paketsClient<$Result.GetResult<Prisma.$banks_paketsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Banks_pakets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banks_paketsCountArgs} args - Arguments to filter Banks_pakets to count.
     * @example
     * // Count the number of Banks_pakets
     * const count = await prisma.banks_pakets.count({
     *   where: {
     *     // ... the filter for the Banks_pakets we want to count
     *   }
     * })
    **/
    count<T extends banks_paketsCountArgs>(
      args?: Subset<T, banks_paketsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Banks_paketsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banks_pakets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Banks_paketsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Banks_paketsAggregateArgs>(args: Subset<T, Banks_paketsAggregateArgs>): Prisma.PrismaPromise<GetBanks_paketsAggregateType<T>>

    /**
     * Group by Banks_pakets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banks_paketsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends banks_paketsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: banks_paketsGroupByArgs['orderBy'] }
        : { orderBy?: banks_paketsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, banks_paketsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBanks_paketsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the banks_pakets model
   */
  readonly fields: banks_paketsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for banks_pakets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__banks_paketsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    banks_items<T extends banks_pakets$banks_itemsArgs<ExtArgs> = {}>(args?: Subset<T, banks_pakets$banks_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$banks_itemsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the banks_pakets model
   */ 
  interface banks_paketsFieldRefs {
    readonly id: FieldRef<"banks_pakets", 'Int'>
    readonly name: FieldRef<"banks_pakets", 'String'>
    readonly code: FieldRef<"banks_pakets", 'String'>
    readonly order_num: FieldRef<"banks_pakets", 'Int'>
    readonly is_active: FieldRef<"banks_pakets", 'Boolean'>
    readonly created_at: FieldRef<"banks_pakets", 'DateTime'>
    readonly updated_at: FieldRef<"banks_pakets", 'DateTime'>
    readonly propogated_at: FieldRef<"banks_pakets", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * banks_pakets findUnique
   */
  export type banks_paketsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_pakets
     */
    select?: banks_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_paketsInclude<ExtArgs> | null
    /**
     * Filter, which banks_pakets to fetch.
     */
    where: banks_paketsWhereUniqueInput
  }

  /**
   * banks_pakets findUniqueOrThrow
   */
  export type banks_paketsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_pakets
     */
    select?: banks_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_paketsInclude<ExtArgs> | null
    /**
     * Filter, which banks_pakets to fetch.
     */
    where: banks_paketsWhereUniqueInput
  }

  /**
   * banks_pakets findFirst
   */
  export type banks_paketsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_pakets
     */
    select?: banks_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_paketsInclude<ExtArgs> | null
    /**
     * Filter, which banks_pakets to fetch.
     */
    where?: banks_paketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks_pakets to fetch.
     */
    orderBy?: banks_paketsOrderByWithRelationInput | banks_paketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banks_pakets.
     */
    cursor?: banks_paketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks_pakets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks_pakets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banks_pakets.
     */
    distinct?: Banks_paketsScalarFieldEnum | Banks_paketsScalarFieldEnum[]
  }

  /**
   * banks_pakets findFirstOrThrow
   */
  export type banks_paketsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_pakets
     */
    select?: banks_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_paketsInclude<ExtArgs> | null
    /**
     * Filter, which banks_pakets to fetch.
     */
    where?: banks_paketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks_pakets to fetch.
     */
    orderBy?: banks_paketsOrderByWithRelationInput | banks_paketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banks_pakets.
     */
    cursor?: banks_paketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks_pakets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks_pakets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banks_pakets.
     */
    distinct?: Banks_paketsScalarFieldEnum | Banks_paketsScalarFieldEnum[]
  }

  /**
   * banks_pakets findMany
   */
  export type banks_paketsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_pakets
     */
    select?: banks_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_paketsInclude<ExtArgs> | null
    /**
     * Filter, which banks_pakets to fetch.
     */
    where?: banks_paketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks_pakets to fetch.
     */
    orderBy?: banks_paketsOrderByWithRelationInput | banks_paketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing banks_pakets.
     */
    cursor?: banks_paketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks_pakets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks_pakets.
     */
    skip?: number
    distinct?: Banks_paketsScalarFieldEnum | Banks_paketsScalarFieldEnum[]
  }

  /**
   * banks_pakets create
   */
  export type banks_paketsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_pakets
     */
    select?: banks_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_paketsInclude<ExtArgs> | null
    /**
     * The data needed to create a banks_pakets.
     */
    data: XOR<banks_paketsCreateInput, banks_paketsUncheckedCreateInput>
  }

  /**
   * banks_pakets createMany
   */
  export type banks_paketsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many banks_pakets.
     */
    data: banks_paketsCreateManyInput | banks_paketsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * banks_pakets update
   */
  export type banks_paketsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_pakets
     */
    select?: banks_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_paketsInclude<ExtArgs> | null
    /**
     * The data needed to update a banks_pakets.
     */
    data: XOR<banks_paketsUpdateInput, banks_paketsUncheckedUpdateInput>
    /**
     * Choose, which banks_pakets to update.
     */
    where: banks_paketsWhereUniqueInput
  }

  /**
   * banks_pakets updateMany
   */
  export type banks_paketsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update banks_pakets.
     */
    data: XOR<banks_paketsUpdateManyMutationInput, banks_paketsUncheckedUpdateManyInput>
    /**
     * Filter which banks_pakets to update
     */
    where?: banks_paketsWhereInput
  }

  /**
   * banks_pakets upsert
   */
  export type banks_paketsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_pakets
     */
    select?: banks_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_paketsInclude<ExtArgs> | null
    /**
     * The filter to search for the banks_pakets to update in case it exists.
     */
    where: banks_paketsWhereUniqueInput
    /**
     * In case the banks_pakets found by the `where` argument doesn't exist, create a new banks_pakets with this data.
     */
    create: XOR<banks_paketsCreateInput, banks_paketsUncheckedCreateInput>
    /**
     * In case the banks_pakets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<banks_paketsUpdateInput, banks_paketsUncheckedUpdateInput>
  }

  /**
   * banks_pakets delete
   */
  export type banks_paketsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_pakets
     */
    select?: banks_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_paketsInclude<ExtArgs> | null
    /**
     * Filter which banks_pakets to delete.
     */
    where: banks_paketsWhereUniqueInput
  }

  /**
   * banks_pakets deleteMany
   */
  export type banks_paketsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which banks_pakets to delete
     */
    where?: banks_paketsWhereInput
  }

  /**
   * banks_pakets.banks_items
   */
  export type banks_pakets$banks_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items
     */
    select?: banks_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_itemsInclude<ExtArgs> | null
    where?: banks_itemsWhereInput
    orderBy?: banks_itemsOrderByWithRelationInput | banks_itemsOrderByWithRelationInput[]
    cursor?: banks_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Banks_itemsScalarFieldEnum | Banks_itemsScalarFieldEnum[]
  }

  /**
   * banks_pakets without action
   */
  export type banks_paketsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_pakets
     */
    select?: banks_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_paketsInclude<ExtArgs> | null
  }


  /**
   * Model blocks
   */

  export type AggregateBlocks = {
    _count: BlocksCountAggregateOutputType | null
    _avg: BlocksAvgAggregateOutputType | null
    _sum: BlocksSumAggregateOutputType | null
    _min: BlocksMinAggregateOutputType | null
    _max: BlocksMaxAggregateOutputType | null
  }

  export type BlocksAvgAggregateOutputType = {
    id: number | null
    order_num: number | null
  }

  export type BlocksSumAggregateOutputType = {
    id: number | null
    order_num: number | null
  }

  export type BlocksMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    order_num: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    propogated_at: Date | null
  }

  export type BlocksMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    order_num: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    propogated_at: Date | null
  }

  export type BlocksCountAggregateOutputType = {
    id: number
    name: number
    code: number
    order_num: number
    is_active: number
    created_at: number
    updated_at: number
    propogated_at: number
    _all: number
  }


  export type BlocksAvgAggregateInputType = {
    id?: true
    order_num?: true
  }

  export type BlocksSumAggregateInputType = {
    id?: true
    order_num?: true
  }

  export type BlocksMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    order_num?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    propogated_at?: true
  }

  export type BlocksMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    order_num?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    propogated_at?: true
  }

  export type BlocksCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    order_num?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    propogated_at?: true
    _all?: true
  }

  export type BlocksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blocks to aggregate.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blocks
    **/
    _count?: true | BlocksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlocksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlocksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlocksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlocksMaxAggregateInputType
  }

  export type GetBlocksAggregateType<T extends BlocksAggregateArgs> = {
        [P in keyof T & keyof AggregateBlocks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlocks[P]>
      : GetScalarType<T[P], AggregateBlocks[P]>
  }




  export type blocksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blocksWhereInput
    orderBy?: blocksOrderByWithAggregationInput | blocksOrderByWithAggregationInput[]
    by: BlocksScalarFieldEnum[] | BlocksScalarFieldEnum
    having?: blocksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlocksCountAggregateInputType | true
    _avg?: BlocksAvgAggregateInputType
    _sum?: BlocksSumAggregateInputType
    _min?: BlocksMinAggregateInputType
    _max?: BlocksMaxAggregateInputType
  }

  export type BlocksGroupByOutputType = {
    id: number
    name: string
    code: string
    order_num: number | null
    is_active: boolean
    created_at: Date | null
    updated_at: Date | null
    propogated_at: Date | null
    _count: BlocksCountAggregateOutputType | null
    _avg: BlocksAvgAggregateOutputType | null
    _sum: BlocksSumAggregateOutputType | null
    _min: BlocksMinAggregateOutputType | null
    _max: BlocksMaxAggregateOutputType | null
  }

  type GetBlocksGroupByPayload<T extends blocksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlocksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlocksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlocksGroupByOutputType[P]>
            : GetScalarType<T[P], BlocksGroupByOutputType[P]>
        }
      >
    >


  export type blocksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    order_num?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    propogated_at?: boolean
    pakets?: boolean | blocks$paketsArgs<ExtArgs>
    _count?: boolean | BlocksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blocks"]>


  export type blocksSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    order_num?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    propogated_at?: boolean
  }

  export type blocksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pakets?: boolean | blocks$paketsArgs<ExtArgs>
    _count?: boolean | BlocksCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $blocksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "blocks"
    objects: {
      pakets: Prisma.$paketsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      order_num: number | null
      is_active: boolean
      created_at: Date | null
      updated_at: Date | null
      propogated_at: Date | null
    }, ExtArgs["result"]["blocks"]>
    composites: {}
  }

  type blocksGetPayload<S extends boolean | null | undefined | blocksDefaultArgs> = $Result.GetResult<Prisma.$blocksPayload, S>

  type blocksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<blocksFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlocksCountAggregateInputType | true
    }

  export interface blocksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['blocks'], meta: { name: 'blocks' } }
    /**
     * Find zero or one Blocks that matches the filter.
     * @param {blocksFindUniqueArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends blocksFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, blocksFindUniqueArgs<ExtArgs>>
    ): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Blocks that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {blocksFindUniqueOrThrowArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends blocksFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, blocksFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksFindFirstArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends blocksFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, blocksFindFirstArgs<ExtArgs>>
    ): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Blocks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksFindFirstOrThrowArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends blocksFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, blocksFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.blocks.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.blocks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blocksWithIdOnly = await prisma.blocks.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends blocksFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, blocksFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Blocks.
     * @param {blocksCreateArgs} args - Arguments to create a Blocks.
     * @example
     * // Create one Blocks
     * const Blocks = await prisma.blocks.create({
     *   data: {
     *     // ... data to create a Blocks
     *   }
     * })
     * 
    **/
    create<T extends blocksCreateArgs<ExtArgs>>(
      args: SelectSubset<T, blocksCreateArgs<ExtArgs>>
    ): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Blocks.
     * @param {blocksCreateManyArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const blocks = await prisma.blocks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends blocksCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, blocksCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blocks.
     * @param {blocksDeleteArgs} args - Arguments to delete one Blocks.
     * @example
     * // Delete one Blocks
     * const Blocks = await prisma.blocks.delete({
     *   where: {
     *     // ... filter to delete one Blocks
     *   }
     * })
     * 
    **/
    delete<T extends blocksDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, blocksDeleteArgs<ExtArgs>>
    ): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Blocks.
     * @param {blocksUpdateArgs} args - Arguments to update one Blocks.
     * @example
     * // Update one Blocks
     * const blocks = await prisma.blocks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends blocksUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, blocksUpdateArgs<ExtArgs>>
    ): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Blocks.
     * @param {blocksDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.blocks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends blocksDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, blocksDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const blocks = await prisma.blocks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends blocksUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, blocksUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blocks.
     * @param {blocksUpsertArgs} args - Arguments to update or create a Blocks.
     * @example
     * // Update or create a Blocks
     * const blocks = await prisma.blocks.upsert({
     *   create: {
     *     // ... data to create a Blocks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blocks we want to update
     *   }
     * })
    **/
    upsert<T extends blocksUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, blocksUpsertArgs<ExtArgs>>
    ): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.blocks.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends blocksCountArgs>(
      args?: Subset<T, blocksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlocksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlocksAggregateArgs>(args: Subset<T, BlocksAggregateArgs>): Prisma.PrismaPromise<GetBlocksAggregateType<T>>

    /**
     * Group by Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blocksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blocksGroupByArgs['orderBy'] }
        : { orderBy?: blocksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blocksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlocksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the blocks model
   */
  readonly fields: blocksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blocks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blocksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    pakets<T extends blocks$paketsArgs<ExtArgs> = {}>(args?: Subset<T, blocks$paketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paketsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the blocks model
   */ 
  interface blocksFieldRefs {
    readonly id: FieldRef<"blocks", 'Int'>
    readonly name: FieldRef<"blocks", 'String'>
    readonly code: FieldRef<"blocks", 'String'>
    readonly order_num: FieldRef<"blocks", 'Int'>
    readonly is_active: FieldRef<"blocks", 'Boolean'>
    readonly created_at: FieldRef<"blocks", 'DateTime'>
    readonly updated_at: FieldRef<"blocks", 'DateTime'>
    readonly propogated_at: FieldRef<"blocks", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * blocks findUnique
   */
  export type blocksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where: blocksWhereUniqueInput
  }

  /**
   * blocks findUniqueOrThrow
   */
  export type blocksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where: blocksWhereUniqueInput
  }

  /**
   * blocks findFirst
   */
  export type blocksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blocks.
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blocks.
     */
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * blocks findFirstOrThrow
   */
  export type blocksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blocks.
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blocks.
     */
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * blocks findMany
   */
  export type blocksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blocks.
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * blocks create
   */
  export type blocksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * The data needed to create a blocks.
     */
    data: XOR<blocksCreateInput, blocksUncheckedCreateInput>
  }

  /**
   * blocks createMany
   */
  export type blocksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blocks.
     */
    data: blocksCreateManyInput | blocksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * blocks update
   */
  export type blocksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * The data needed to update a blocks.
     */
    data: XOR<blocksUpdateInput, blocksUncheckedUpdateInput>
    /**
     * Choose, which blocks to update.
     */
    where: blocksWhereUniqueInput
  }

  /**
   * blocks updateMany
   */
  export type blocksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blocks.
     */
    data: XOR<blocksUpdateManyMutationInput, blocksUncheckedUpdateManyInput>
    /**
     * Filter which blocks to update
     */
    where?: blocksWhereInput
  }

  /**
   * blocks upsert
   */
  export type blocksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * The filter to search for the blocks to update in case it exists.
     */
    where: blocksWhereUniqueInput
    /**
     * In case the blocks found by the `where` argument doesn't exist, create a new blocks with this data.
     */
    create: XOR<blocksCreateInput, blocksUncheckedCreateInput>
    /**
     * In case the blocks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blocksUpdateInput, blocksUncheckedUpdateInput>
  }

  /**
   * blocks delete
   */
  export type blocksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter which blocks to delete.
     */
    where: blocksWhereUniqueInput
  }

  /**
   * blocks deleteMany
   */
  export type blocksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blocks to delete
     */
    where?: blocksWhereInput
  }

  /**
   * blocks.pakets
   */
  export type blocks$paketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pakets
     */
    select?: paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paketsInclude<ExtArgs> | null
    where?: paketsWhereInput
    orderBy?: paketsOrderByWithRelationInput | paketsOrderByWithRelationInput[]
    cursor?: paketsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaketsScalarFieldEnum | PaketsScalarFieldEnum[]
  }

  /**
   * blocks without action
   */
  export type blocksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
  }


  /**
   * Model contractors
   */

  export type AggregateContractors = {
    _count: ContractorsCountAggregateOutputType | null
    _avg: ContractorsAvgAggregateOutputType | null
    _sum: ContractorsSumAggregateOutputType | null
    _min: ContractorsMinAggregateOutputType | null
    _max: ContractorsMaxAggregateOutputType | null
  }

  export type ContractorsAvgAggregateOutputType = {
    id: number | null
  }

  export type ContractorsSumAggregateOutputType = {
    id: number | null
  }

  export type ContractorsMinAggregateOutputType = {
    id: number | null
    name: string | null
    short_name: string | null
    inn: string | null
    kpp: string | null
    ogrn: string | null
    legal_address: string | null
    actual_address: string | null
    contacts: string | null
    reconciliation_link: string | null
    is_active: boolean | null
    propogated_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    phone: string | null
  }

  export type ContractorsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    short_name: string | null
    inn: string | null
    kpp: string | null
    ogrn: string | null
    legal_address: string | null
    actual_address: string | null
    contacts: string | null
    reconciliation_link: string | null
    is_active: boolean | null
    propogated_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    phone: string | null
  }

  export type ContractorsCountAggregateOutputType = {
    id: number
    name: number
    short_name: number
    inn: number
    kpp: number
    ogrn: number
    legal_address: number
    actual_address: number
    contacts: number
    reconciliation_link: number
    is_active: number
    propogated_at: number
    created_at: number
    updated_at: number
    phone: number
    _all: number
  }


  export type ContractorsAvgAggregateInputType = {
    id?: true
  }

  export type ContractorsSumAggregateInputType = {
    id?: true
  }

  export type ContractorsMinAggregateInputType = {
    id?: true
    name?: true
    short_name?: true
    inn?: true
    kpp?: true
    ogrn?: true
    legal_address?: true
    actual_address?: true
    contacts?: true
    reconciliation_link?: true
    is_active?: true
    propogated_at?: true
    created_at?: true
    updated_at?: true
    phone?: true
  }

  export type ContractorsMaxAggregateInputType = {
    id?: true
    name?: true
    short_name?: true
    inn?: true
    kpp?: true
    ogrn?: true
    legal_address?: true
    actual_address?: true
    contacts?: true
    reconciliation_link?: true
    is_active?: true
    propogated_at?: true
    created_at?: true
    updated_at?: true
    phone?: true
  }

  export type ContractorsCountAggregateInputType = {
    id?: true
    name?: true
    short_name?: true
    inn?: true
    kpp?: true
    ogrn?: true
    legal_address?: true
    actual_address?: true
    contacts?: true
    reconciliation_link?: true
    is_active?: true
    propogated_at?: true
    created_at?: true
    updated_at?: true
    phone?: true
    _all?: true
  }

  export type ContractorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contractors to aggregate.
     */
    where?: contractorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contractors to fetch.
     */
    orderBy?: contractorsOrderByWithRelationInput | contractorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contractorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contractors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contractors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contractors
    **/
    _count?: true | ContractorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractorsMaxAggregateInputType
  }

  export type GetContractorsAggregateType<T extends ContractorsAggregateArgs> = {
        [P in keyof T & keyof AggregateContractors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractors[P]>
      : GetScalarType<T[P], AggregateContractors[P]>
  }




  export type contractorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contractorsWhereInput
    orderBy?: contractorsOrderByWithAggregationInput | contractorsOrderByWithAggregationInput[]
    by: ContractorsScalarFieldEnum[] | ContractorsScalarFieldEnum
    having?: contractorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractorsCountAggregateInputType | true
    _avg?: ContractorsAvgAggregateInputType
    _sum?: ContractorsSumAggregateInputType
    _min?: ContractorsMinAggregateInputType
    _max?: ContractorsMaxAggregateInputType
  }

  export type ContractorsGroupByOutputType = {
    id: number
    name: string
    short_name: string | null
    inn: string | null
    kpp: string | null
    ogrn: string | null
    legal_address: string | null
    actual_address: string | null
    contacts: string | null
    reconciliation_link: string | null
    is_active: boolean
    propogated_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    phone: string | null
    _count: ContractorsCountAggregateOutputType | null
    _avg: ContractorsAvgAggregateOutputType | null
    _sum: ContractorsSumAggregateOutputType | null
    _min: ContractorsMinAggregateOutputType | null
    _max: ContractorsMaxAggregateOutputType | null
  }

  type GetContractorsGroupByPayload<T extends contractorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractorsGroupByOutputType[P]>
            : GetScalarType<T[P], ContractorsGroupByOutputType[P]>
        }
      >
    >


  export type contractorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    short_name?: boolean
    inn?: boolean
    kpp?: boolean
    ogrn?: boolean
    legal_address?: boolean
    actual_address?: boolean
    contacts?: boolean
    reconciliation_link?: boolean
    is_active?: boolean
    propogated_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    phone?: boolean
    accounts?: boolean | contractors$accountsArgs<ExtArgs>
    r_users_client_contractors?: boolean | contractors$r_users_client_contractorsArgs<ExtArgs>
    _count?: boolean | ContractorsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractors"]>


  export type contractorsSelectScalar = {
    id?: boolean
    name?: boolean
    short_name?: boolean
    inn?: boolean
    kpp?: boolean
    ogrn?: boolean
    legal_address?: boolean
    actual_address?: boolean
    contacts?: boolean
    reconciliation_link?: boolean
    is_active?: boolean
    propogated_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    phone?: boolean
  }

  export type contractorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | contractors$accountsArgs<ExtArgs>
    r_users_client_contractors?: boolean | contractors$r_users_client_contractorsArgs<ExtArgs>
    _count?: boolean | ContractorsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $contractorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contractors"
    objects: {
      accounts: Prisma.$accountsPayload<ExtArgs>[]
      r_users_client_contractors: Prisma.$r_users_client_contractorsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      short_name: string | null
      inn: string | null
      kpp: string | null
      ogrn: string | null
      legal_address: string | null
      actual_address: string | null
      contacts: string | null
      reconciliation_link: string | null
      is_active: boolean
      propogated_at: Date | null
      created_at: Date | null
      updated_at: Date | null
      phone: string | null
    }, ExtArgs["result"]["contractors"]>
    composites: {}
  }

  type contractorsGetPayload<S extends boolean | null | undefined | contractorsDefaultArgs> = $Result.GetResult<Prisma.$contractorsPayload, S>

  type contractorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<contractorsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContractorsCountAggregateInputType | true
    }

  export interface contractorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contractors'], meta: { name: 'contractors' } }
    /**
     * Find zero or one Contractors that matches the filter.
     * @param {contractorsFindUniqueArgs} args - Arguments to find a Contractors
     * @example
     * // Get one Contractors
     * const contractors = await prisma.contractors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends contractorsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, contractorsFindUniqueArgs<ExtArgs>>
    ): Prisma__contractorsClient<$Result.GetResult<Prisma.$contractorsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Contractors that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {contractorsFindUniqueOrThrowArgs} args - Arguments to find a Contractors
     * @example
     * // Get one Contractors
     * const contractors = await prisma.contractors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends contractorsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contractorsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__contractorsClient<$Result.GetResult<Prisma.$contractorsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Contractors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contractorsFindFirstArgs} args - Arguments to find a Contractors
     * @example
     * // Get one Contractors
     * const contractors = await prisma.contractors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends contractorsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, contractorsFindFirstArgs<ExtArgs>>
    ): Prisma__contractorsClient<$Result.GetResult<Prisma.$contractorsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Contractors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contractorsFindFirstOrThrowArgs} args - Arguments to find a Contractors
     * @example
     * // Get one Contractors
     * const contractors = await prisma.contractors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends contractorsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contractorsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__contractorsClient<$Result.GetResult<Prisma.$contractorsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contractors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contractorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contractors
     * const contractors = await prisma.contractors.findMany()
     * 
     * // Get first 10 Contractors
     * const contractors = await prisma.contractors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractorsWithIdOnly = await prisma.contractors.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends contractorsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contractorsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contractorsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Contractors.
     * @param {contractorsCreateArgs} args - Arguments to create a Contractors.
     * @example
     * // Create one Contractors
     * const Contractors = await prisma.contractors.create({
     *   data: {
     *     // ... data to create a Contractors
     *   }
     * })
     * 
    **/
    create<T extends contractorsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, contractorsCreateArgs<ExtArgs>>
    ): Prisma__contractorsClient<$Result.GetResult<Prisma.$contractorsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contractors.
     * @param {contractorsCreateManyArgs} args - Arguments to create many Contractors.
     * @example
     * // Create many Contractors
     * const contractors = await prisma.contractors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends contractorsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contractorsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contractors.
     * @param {contractorsDeleteArgs} args - Arguments to delete one Contractors.
     * @example
     * // Delete one Contractors
     * const Contractors = await prisma.contractors.delete({
     *   where: {
     *     // ... filter to delete one Contractors
     *   }
     * })
     * 
    **/
    delete<T extends contractorsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, contractorsDeleteArgs<ExtArgs>>
    ): Prisma__contractorsClient<$Result.GetResult<Prisma.$contractorsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Contractors.
     * @param {contractorsUpdateArgs} args - Arguments to update one Contractors.
     * @example
     * // Update one Contractors
     * const contractors = await prisma.contractors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends contractorsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, contractorsUpdateArgs<ExtArgs>>
    ): Prisma__contractorsClient<$Result.GetResult<Prisma.$contractorsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contractors.
     * @param {contractorsDeleteManyArgs} args - Arguments to filter Contractors to delete.
     * @example
     * // Delete a few Contractors
     * const { count } = await prisma.contractors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends contractorsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contractorsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contractors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contractorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contractors
     * const contractors = await prisma.contractors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends contractorsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, contractorsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contractors.
     * @param {contractorsUpsertArgs} args - Arguments to update or create a Contractors.
     * @example
     * // Update or create a Contractors
     * const contractors = await prisma.contractors.upsert({
     *   create: {
     *     // ... data to create a Contractors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contractors we want to update
     *   }
     * })
    **/
    upsert<T extends contractorsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, contractorsUpsertArgs<ExtArgs>>
    ): Prisma__contractorsClient<$Result.GetResult<Prisma.$contractorsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contractors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contractorsCountArgs} args - Arguments to filter Contractors to count.
     * @example
     * // Count the number of Contractors
     * const count = await prisma.contractors.count({
     *   where: {
     *     // ... the filter for the Contractors we want to count
     *   }
     * })
    **/
    count<T extends contractorsCountArgs>(
      args?: Subset<T, contractorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contractors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractorsAggregateArgs>(args: Subset<T, ContractorsAggregateArgs>): Prisma.PrismaPromise<GetContractorsAggregateType<T>>

    /**
     * Group by Contractors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contractorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contractorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contractorsGroupByArgs['orderBy'] }
        : { orderBy?: contractorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contractorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contractors model
   */
  readonly fields: contractorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contractors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contractorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    accounts<T extends contractors$accountsArgs<ExtArgs> = {}>(args?: Subset<T, contractors$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, 'findMany'> | Null>;

    r_users_client_contractors<T extends contractors$r_users_client_contractorsArgs<ExtArgs> = {}>(args?: Subset<T, contractors$r_users_client_contractorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$r_users_client_contractorsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the contractors model
   */ 
  interface contractorsFieldRefs {
    readonly id: FieldRef<"contractors", 'Int'>
    readonly name: FieldRef<"contractors", 'String'>
    readonly short_name: FieldRef<"contractors", 'String'>
    readonly inn: FieldRef<"contractors", 'String'>
    readonly kpp: FieldRef<"contractors", 'String'>
    readonly ogrn: FieldRef<"contractors", 'String'>
    readonly legal_address: FieldRef<"contractors", 'String'>
    readonly actual_address: FieldRef<"contractors", 'String'>
    readonly contacts: FieldRef<"contractors", 'String'>
    readonly reconciliation_link: FieldRef<"contractors", 'String'>
    readonly is_active: FieldRef<"contractors", 'Boolean'>
    readonly propogated_at: FieldRef<"contractors", 'DateTime'>
    readonly created_at: FieldRef<"contractors", 'DateTime'>
    readonly updated_at: FieldRef<"contractors", 'DateTime'>
    readonly phone: FieldRef<"contractors", 'String'>
  }
    

  // Custom InputTypes
  /**
   * contractors findUnique
   */
  export type contractorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contractors
     */
    select?: contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractorsInclude<ExtArgs> | null
    /**
     * Filter, which contractors to fetch.
     */
    where: contractorsWhereUniqueInput
  }

  /**
   * contractors findUniqueOrThrow
   */
  export type contractorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contractors
     */
    select?: contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractorsInclude<ExtArgs> | null
    /**
     * Filter, which contractors to fetch.
     */
    where: contractorsWhereUniqueInput
  }

  /**
   * contractors findFirst
   */
  export type contractorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contractors
     */
    select?: contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractorsInclude<ExtArgs> | null
    /**
     * Filter, which contractors to fetch.
     */
    where?: contractorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contractors to fetch.
     */
    orderBy?: contractorsOrderByWithRelationInput | contractorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contractors.
     */
    cursor?: contractorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contractors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contractors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contractors.
     */
    distinct?: ContractorsScalarFieldEnum | ContractorsScalarFieldEnum[]
  }

  /**
   * contractors findFirstOrThrow
   */
  export type contractorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contractors
     */
    select?: contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractorsInclude<ExtArgs> | null
    /**
     * Filter, which contractors to fetch.
     */
    where?: contractorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contractors to fetch.
     */
    orderBy?: contractorsOrderByWithRelationInput | contractorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contractors.
     */
    cursor?: contractorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contractors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contractors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contractors.
     */
    distinct?: ContractorsScalarFieldEnum | ContractorsScalarFieldEnum[]
  }

  /**
   * contractors findMany
   */
  export type contractorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contractors
     */
    select?: contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractorsInclude<ExtArgs> | null
    /**
     * Filter, which contractors to fetch.
     */
    where?: contractorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contractors to fetch.
     */
    orderBy?: contractorsOrderByWithRelationInput | contractorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contractors.
     */
    cursor?: contractorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contractors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contractors.
     */
    skip?: number
    distinct?: ContractorsScalarFieldEnum | ContractorsScalarFieldEnum[]
  }

  /**
   * contractors create
   */
  export type contractorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contractors
     */
    select?: contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractorsInclude<ExtArgs> | null
    /**
     * The data needed to create a contractors.
     */
    data: XOR<contractorsCreateInput, contractorsUncheckedCreateInput>
  }

  /**
   * contractors createMany
   */
  export type contractorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contractors.
     */
    data: contractorsCreateManyInput | contractorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * contractors update
   */
  export type contractorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contractors
     */
    select?: contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractorsInclude<ExtArgs> | null
    /**
     * The data needed to update a contractors.
     */
    data: XOR<contractorsUpdateInput, contractorsUncheckedUpdateInput>
    /**
     * Choose, which contractors to update.
     */
    where: contractorsWhereUniqueInput
  }

  /**
   * contractors updateMany
   */
  export type contractorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contractors.
     */
    data: XOR<contractorsUpdateManyMutationInput, contractorsUncheckedUpdateManyInput>
    /**
     * Filter which contractors to update
     */
    where?: contractorsWhereInput
  }

  /**
   * contractors upsert
   */
  export type contractorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contractors
     */
    select?: contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractorsInclude<ExtArgs> | null
    /**
     * The filter to search for the contractors to update in case it exists.
     */
    where: contractorsWhereUniqueInput
    /**
     * In case the contractors found by the `where` argument doesn't exist, create a new contractors with this data.
     */
    create: XOR<contractorsCreateInput, contractorsUncheckedCreateInput>
    /**
     * In case the contractors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contractorsUpdateInput, contractorsUncheckedUpdateInput>
  }

  /**
   * contractors delete
   */
  export type contractorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contractors
     */
    select?: contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractorsInclude<ExtArgs> | null
    /**
     * Filter which contractors to delete.
     */
    where: contractorsWhereUniqueInput
  }

  /**
   * contractors deleteMany
   */
  export type contractorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contractors to delete
     */
    where?: contractorsWhereInput
  }

  /**
   * contractors.accounts
   */
  export type contractors$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    where?: accountsWhereInput
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    cursor?: accountsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * contractors.r_users_client_contractors
   */
  export type contractors$r_users_client_contractorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_client_contractors
     */
    select?: r_users_client_contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_client_contractorsInclude<ExtArgs> | null
    where?: r_users_client_contractorsWhereInput
    orderBy?: r_users_client_contractorsOrderByWithRelationInput | r_users_client_contractorsOrderByWithRelationInput[]
    cursor?: r_users_client_contractorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: R_users_client_contractorsScalarFieldEnum | R_users_client_contractorsScalarFieldEnum[]
  }

  /**
   * contractors without action
   */
  export type contractorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contractors
     */
    select?: contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contractorsInclude<ExtArgs> | null
  }


  /**
   * Model floors
   */

  export type AggregateFloors = {
    _count: FloorsCountAggregateOutputType | null
    _avg: FloorsAvgAggregateOutputType | null
    _sum: FloorsSumAggregateOutputType | null
    _min: FloorsMinAggregateOutputType | null
    _max: FloorsMaxAggregateOutputType | null
  }

  export type FloorsAvgAggregateOutputType = {
    id: number | null
    section_id: number | null
  }

  export type FloorsSumAggregateOutputType = {
    id: number | null
    section_id: number | null
  }

  export type FloorsMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    section_id: number | null
  }

  export type FloorsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    section_id: number | null
  }

  export type FloorsCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    section_id: number
    _all: number
  }


  export type FloorsAvgAggregateInputType = {
    id?: true
    section_id?: true
  }

  export type FloorsSumAggregateInputType = {
    id?: true
    section_id?: true
  }

  export type FloorsMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    section_id?: true
  }

  export type FloorsMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    section_id?: true
  }

  export type FloorsCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    section_id?: true
    _all?: true
  }

  export type FloorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which floors to aggregate.
     */
    where?: floorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of floors to fetch.
     */
    orderBy?: floorsOrderByWithRelationInput | floorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: floorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` floors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` floors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned floors
    **/
    _count?: true | FloorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FloorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FloorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FloorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FloorsMaxAggregateInputType
  }

  export type GetFloorsAggregateType<T extends FloorsAggregateArgs> = {
        [P in keyof T & keyof AggregateFloors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFloors[P]>
      : GetScalarType<T[P], AggregateFloors[P]>
  }




  export type floorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: floorsWhereInput
    orderBy?: floorsOrderByWithAggregationInput | floorsOrderByWithAggregationInput[]
    by: FloorsScalarFieldEnum[] | FloorsScalarFieldEnum
    having?: floorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FloorsCountAggregateInputType | true
    _avg?: FloorsAvgAggregateInputType
    _sum?: FloorsSumAggregateInputType
    _min?: FloorsMinAggregateInputType
    _max?: FloorsMaxAggregateInputType
  }

  export type FloorsGroupByOutputType = {
    id: number
    name: string
    created_at: Date | null
    updated_at: Date | null
    section_id: number
    _count: FloorsCountAggregateOutputType | null
    _avg: FloorsAvgAggregateOutputType | null
    _sum: FloorsSumAggregateOutputType | null
    _min: FloorsMinAggregateOutputType | null
    _max: FloorsMaxAggregateOutputType | null
  }

  type GetFloorsGroupByPayload<T extends floorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FloorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FloorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FloorsGroupByOutputType[P]>
            : GetScalarType<T[P], FloorsGroupByOutputType[P]>
        }
      >
    >


  export type floorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    section_id?: boolean
  }, ExtArgs["result"]["floors"]>


  export type floorsSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    section_id?: boolean
  }


  export type $floorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "floors"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      created_at: Date | null
      updated_at: Date | null
      section_id: number
    }, ExtArgs["result"]["floors"]>
    composites: {}
  }

  type floorsGetPayload<S extends boolean | null | undefined | floorsDefaultArgs> = $Result.GetResult<Prisma.$floorsPayload, S>

  type floorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<floorsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FloorsCountAggregateInputType | true
    }

  export interface floorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['floors'], meta: { name: 'floors' } }
    /**
     * Find zero or one Floors that matches the filter.
     * @param {floorsFindUniqueArgs} args - Arguments to find a Floors
     * @example
     * // Get one Floors
     * const floors = await prisma.floors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends floorsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, floorsFindUniqueArgs<ExtArgs>>
    ): Prisma__floorsClient<$Result.GetResult<Prisma.$floorsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Floors that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {floorsFindUniqueOrThrowArgs} args - Arguments to find a Floors
     * @example
     * // Get one Floors
     * const floors = await prisma.floors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends floorsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, floorsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__floorsClient<$Result.GetResult<Prisma.$floorsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Floors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {floorsFindFirstArgs} args - Arguments to find a Floors
     * @example
     * // Get one Floors
     * const floors = await prisma.floors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends floorsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, floorsFindFirstArgs<ExtArgs>>
    ): Prisma__floorsClient<$Result.GetResult<Prisma.$floorsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Floors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {floorsFindFirstOrThrowArgs} args - Arguments to find a Floors
     * @example
     * // Get one Floors
     * const floors = await prisma.floors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends floorsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, floorsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__floorsClient<$Result.GetResult<Prisma.$floorsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Floors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {floorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Floors
     * const floors = await prisma.floors.findMany()
     * 
     * // Get first 10 Floors
     * const floors = await prisma.floors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const floorsWithIdOnly = await prisma.floors.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends floorsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, floorsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$floorsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Floors.
     * @param {floorsCreateArgs} args - Arguments to create a Floors.
     * @example
     * // Create one Floors
     * const Floors = await prisma.floors.create({
     *   data: {
     *     // ... data to create a Floors
     *   }
     * })
     * 
    **/
    create<T extends floorsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, floorsCreateArgs<ExtArgs>>
    ): Prisma__floorsClient<$Result.GetResult<Prisma.$floorsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Floors.
     * @param {floorsCreateManyArgs} args - Arguments to create many Floors.
     * @example
     * // Create many Floors
     * const floors = await prisma.floors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends floorsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, floorsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Floors.
     * @param {floorsDeleteArgs} args - Arguments to delete one Floors.
     * @example
     * // Delete one Floors
     * const Floors = await prisma.floors.delete({
     *   where: {
     *     // ... filter to delete one Floors
     *   }
     * })
     * 
    **/
    delete<T extends floorsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, floorsDeleteArgs<ExtArgs>>
    ): Prisma__floorsClient<$Result.GetResult<Prisma.$floorsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Floors.
     * @param {floorsUpdateArgs} args - Arguments to update one Floors.
     * @example
     * // Update one Floors
     * const floors = await prisma.floors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends floorsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, floorsUpdateArgs<ExtArgs>>
    ): Prisma__floorsClient<$Result.GetResult<Prisma.$floorsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Floors.
     * @param {floorsDeleteManyArgs} args - Arguments to filter Floors to delete.
     * @example
     * // Delete a few Floors
     * const { count } = await prisma.floors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends floorsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, floorsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Floors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {floorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Floors
     * const floors = await prisma.floors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends floorsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, floorsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Floors.
     * @param {floorsUpsertArgs} args - Arguments to update or create a Floors.
     * @example
     * // Update or create a Floors
     * const floors = await prisma.floors.upsert({
     *   create: {
     *     // ... data to create a Floors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Floors we want to update
     *   }
     * })
    **/
    upsert<T extends floorsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, floorsUpsertArgs<ExtArgs>>
    ): Prisma__floorsClient<$Result.GetResult<Prisma.$floorsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Floors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {floorsCountArgs} args - Arguments to filter Floors to count.
     * @example
     * // Count the number of Floors
     * const count = await prisma.floors.count({
     *   where: {
     *     // ... the filter for the Floors we want to count
     *   }
     * })
    **/
    count<T extends floorsCountArgs>(
      args?: Subset<T, floorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FloorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Floors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FloorsAggregateArgs>(args: Subset<T, FloorsAggregateArgs>): Prisma.PrismaPromise<GetFloorsAggregateType<T>>

    /**
     * Group by Floors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {floorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends floorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: floorsGroupByArgs['orderBy'] }
        : { orderBy?: floorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, floorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFloorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the floors model
   */
  readonly fields: floorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for floors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__floorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the floors model
   */ 
  interface floorsFieldRefs {
    readonly id: FieldRef<"floors", 'Int'>
    readonly name: FieldRef<"floors", 'String'>
    readonly created_at: FieldRef<"floors", 'DateTime'>
    readonly updated_at: FieldRef<"floors", 'DateTime'>
    readonly section_id: FieldRef<"floors", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * floors findUnique
   */
  export type floorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the floors
     */
    select?: floorsSelect<ExtArgs> | null
    /**
     * Filter, which floors to fetch.
     */
    where: floorsWhereUniqueInput
  }

  /**
   * floors findUniqueOrThrow
   */
  export type floorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the floors
     */
    select?: floorsSelect<ExtArgs> | null
    /**
     * Filter, which floors to fetch.
     */
    where: floorsWhereUniqueInput
  }

  /**
   * floors findFirst
   */
  export type floorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the floors
     */
    select?: floorsSelect<ExtArgs> | null
    /**
     * Filter, which floors to fetch.
     */
    where?: floorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of floors to fetch.
     */
    orderBy?: floorsOrderByWithRelationInput | floorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for floors.
     */
    cursor?: floorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` floors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` floors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of floors.
     */
    distinct?: FloorsScalarFieldEnum | FloorsScalarFieldEnum[]
  }

  /**
   * floors findFirstOrThrow
   */
  export type floorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the floors
     */
    select?: floorsSelect<ExtArgs> | null
    /**
     * Filter, which floors to fetch.
     */
    where?: floorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of floors to fetch.
     */
    orderBy?: floorsOrderByWithRelationInput | floorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for floors.
     */
    cursor?: floorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` floors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` floors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of floors.
     */
    distinct?: FloorsScalarFieldEnum | FloorsScalarFieldEnum[]
  }

  /**
   * floors findMany
   */
  export type floorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the floors
     */
    select?: floorsSelect<ExtArgs> | null
    /**
     * Filter, which floors to fetch.
     */
    where?: floorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of floors to fetch.
     */
    orderBy?: floorsOrderByWithRelationInput | floorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing floors.
     */
    cursor?: floorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` floors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` floors.
     */
    skip?: number
    distinct?: FloorsScalarFieldEnum | FloorsScalarFieldEnum[]
  }

  /**
   * floors create
   */
  export type floorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the floors
     */
    select?: floorsSelect<ExtArgs> | null
    /**
     * The data needed to create a floors.
     */
    data: XOR<floorsCreateInput, floorsUncheckedCreateInput>
  }

  /**
   * floors createMany
   */
  export type floorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many floors.
     */
    data: floorsCreateManyInput | floorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * floors update
   */
  export type floorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the floors
     */
    select?: floorsSelect<ExtArgs> | null
    /**
     * The data needed to update a floors.
     */
    data: XOR<floorsUpdateInput, floorsUncheckedUpdateInput>
    /**
     * Choose, which floors to update.
     */
    where: floorsWhereUniqueInput
  }

  /**
   * floors updateMany
   */
  export type floorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update floors.
     */
    data: XOR<floorsUpdateManyMutationInput, floorsUncheckedUpdateManyInput>
    /**
     * Filter which floors to update
     */
    where?: floorsWhereInput
  }

  /**
   * floors upsert
   */
  export type floorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the floors
     */
    select?: floorsSelect<ExtArgs> | null
    /**
     * The filter to search for the floors to update in case it exists.
     */
    where: floorsWhereUniqueInput
    /**
     * In case the floors found by the `where` argument doesn't exist, create a new floors with this data.
     */
    create: XOR<floorsCreateInput, floorsUncheckedCreateInput>
    /**
     * In case the floors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<floorsUpdateInput, floorsUncheckedUpdateInput>
  }

  /**
   * floors delete
   */
  export type floorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the floors
     */
    select?: floorsSelect<ExtArgs> | null
    /**
     * Filter which floors to delete.
     */
    where: floorsWhereUniqueInput
  }

  /**
   * floors deleteMany
   */
  export type floorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which floors to delete
     */
    where?: floorsWhereInput
  }

  /**
   * floors without action
   */
  export type floorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the floors
     */
    select?: floorsSelect<ExtArgs> | null
  }


  /**
   * Model items
   */

  export type AggregateItems = {
    _count: ItemsCountAggregateOutputType | null
    _avg: ItemsAvgAggregateOutputType | null
    _sum: ItemsSumAggregateOutputType | null
    _min: ItemsMinAggregateOutputType | null
    _max: ItemsMaxAggregateOutputType | null
  }

  export type ItemsAvgAggregateOutputType = {
    id: number | null
    order_num: number | null
    sub_pakets_id: number | null
    banks_items_id: number | null
  }

  export type ItemsSumAggregateOutputType = {
    id: number | null
    order_num: number | null
    sub_pakets_id: number | null
    banks_items_id: number | null
  }

  export type ItemsMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    clc_code: string | null
    order_num: number | null
    is_active: boolean | null
    sub_pakets_id: number | null
    banks_items_id: number | null
    created_at: Date | null
    updated_at: Date | null
    propogated_at: Date | null
  }

  export type ItemsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    clc_code: string | null
    order_num: number | null
    is_active: boolean | null
    sub_pakets_id: number | null
    banks_items_id: number | null
    created_at: Date | null
    updated_at: Date | null
    propogated_at: Date | null
  }

  export type ItemsCountAggregateOutputType = {
    id: number
    name: number
    code: number
    clc_code: number
    order_num: number
    is_active: number
    sub_pakets_id: number
    banks_items_id: number
    created_at: number
    updated_at: number
    propogated_at: number
    _all: number
  }


  export type ItemsAvgAggregateInputType = {
    id?: true
    order_num?: true
    sub_pakets_id?: true
    banks_items_id?: true
  }

  export type ItemsSumAggregateInputType = {
    id?: true
    order_num?: true
    sub_pakets_id?: true
    banks_items_id?: true
  }

  export type ItemsMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    clc_code?: true
    order_num?: true
    is_active?: true
    sub_pakets_id?: true
    banks_items_id?: true
    created_at?: true
    updated_at?: true
    propogated_at?: true
  }

  export type ItemsMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    clc_code?: true
    order_num?: true
    is_active?: true
    sub_pakets_id?: true
    banks_items_id?: true
    created_at?: true
    updated_at?: true
    propogated_at?: true
  }

  export type ItemsCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    clc_code?: true
    order_num?: true
    is_active?: true
    sub_pakets_id?: true
    banks_items_id?: true
    created_at?: true
    updated_at?: true
    propogated_at?: true
    _all?: true
  }

  export type ItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which items to aggregate.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned items
    **/
    _count?: true | ItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemsMaxAggregateInputType
  }

  export type GetItemsAggregateType<T extends ItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItems[P]>
      : GetScalarType<T[P], AggregateItems[P]>
  }




  export type itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemsWhereInput
    orderBy?: itemsOrderByWithAggregationInput | itemsOrderByWithAggregationInput[]
    by: ItemsScalarFieldEnum[] | ItemsScalarFieldEnum
    having?: itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemsCountAggregateInputType | true
    _avg?: ItemsAvgAggregateInputType
    _sum?: ItemsSumAggregateInputType
    _min?: ItemsMinAggregateInputType
    _max?: ItemsMaxAggregateInputType
  }

  export type ItemsGroupByOutputType = {
    id: number
    name: string
    code: string
    clc_code: string | null
    order_num: number | null
    is_active: boolean
    sub_pakets_id: number
    banks_items_id: number | null
    created_at: Date | null
    updated_at: Date | null
    propogated_at: Date | null
    _count: ItemsCountAggregateOutputType | null
    _avg: ItemsAvgAggregateOutputType | null
    _sum: ItemsSumAggregateOutputType | null
    _min: ItemsMinAggregateOutputType | null
    _max: ItemsMaxAggregateOutputType | null
  }

  type GetItemsGroupByPayload<T extends itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemsGroupByOutputType[P]>
            : GetScalarType<T[P], ItemsGroupByOutputType[P]>
        }
      >
    >


  export type itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    clc_code?: boolean
    order_num?: boolean
    is_active?: boolean
    sub_pakets_id?: boolean
    banks_items_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    propogated_at?: boolean
    sub_pakets?: boolean | sub_paketsDefaultArgs<ExtArgs>
    banks_items?: boolean | items$banks_itemsArgs<ExtArgs>
  }, ExtArgs["result"]["items"]>


  export type itemsSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    clc_code?: boolean
    order_num?: boolean
    is_active?: boolean
    sub_pakets_id?: boolean
    banks_items_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    propogated_at?: boolean
  }

  export type itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sub_pakets?: boolean | sub_paketsDefaultArgs<ExtArgs>
    banks_items?: boolean | items$banks_itemsArgs<ExtArgs>
  }

  export type $itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "items"
    objects: {
      sub_pakets: Prisma.$sub_paketsPayload<ExtArgs>
      banks_items: Prisma.$banks_itemsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      clc_code: string | null
      order_num: number | null
      is_active: boolean
      sub_pakets_id: number
      banks_items_id: number | null
      created_at: Date | null
      updated_at: Date | null
      propogated_at: Date | null
    }, ExtArgs["result"]["items"]>
    composites: {}
  }

  type itemsGetPayload<S extends boolean | null | undefined | itemsDefaultArgs> = $Result.GetResult<Prisma.$itemsPayload, S>

  type itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<itemsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemsCountAggregateInputType | true
    }

  export interface itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['items'], meta: { name: 'items' } }
    /**
     * Find zero or one Items that matches the filter.
     * @param {itemsFindUniqueArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends itemsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, itemsFindUniqueArgs<ExtArgs>>
    ): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Items that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {itemsFindUniqueOrThrowArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends itemsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, itemsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsFindFirstArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends itemsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, itemsFindFirstArgs<ExtArgs>>
    ): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsFindFirstOrThrowArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends itemsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, itemsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.items.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemsWithIdOnly = await prisma.items.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends itemsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, itemsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Items.
     * @param {itemsCreateArgs} args - Arguments to create a Items.
     * @example
     * // Create one Items
     * const Items = await prisma.items.create({
     *   data: {
     *     // ... data to create a Items
     *   }
     * })
     * 
    **/
    create<T extends itemsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, itemsCreateArgs<ExtArgs>>
    ): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Items.
     * @param {itemsCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const items = await prisma.items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends itemsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, itemsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Items.
     * @param {itemsDeleteArgs} args - Arguments to delete one Items.
     * @example
     * // Delete one Items
     * const Items = await prisma.items.delete({
     *   where: {
     *     // ... filter to delete one Items
     *   }
     * })
     * 
    **/
    delete<T extends itemsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, itemsDeleteArgs<ExtArgs>>
    ): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Items.
     * @param {itemsUpdateArgs} args - Arguments to update one Items.
     * @example
     * // Update one Items
     * const items = await prisma.items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends itemsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, itemsUpdateArgs<ExtArgs>>
    ): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Items.
     * @param {itemsDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends itemsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, itemsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const items = await prisma.items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends itemsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, itemsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Items.
     * @param {itemsUpsertArgs} args - Arguments to update or create a Items.
     * @example
     * // Update or create a Items
     * const items = await prisma.items.upsert({
     *   create: {
     *     // ... data to create a Items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Items we want to update
     *   }
     * })
    **/
    upsert<T extends itemsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, itemsUpsertArgs<ExtArgs>>
    ): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.items.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends itemsCountArgs>(
      args?: Subset<T, itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemsAggregateArgs>(args: Subset<T, ItemsAggregateArgs>): Prisma.PrismaPromise<GetItemsAggregateType<T>>

    /**
     * Group by Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: itemsGroupByArgs['orderBy'] }
        : { orderBy?: itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the items model
   */
  readonly fields: itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    sub_pakets<T extends sub_paketsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sub_paketsDefaultArgs<ExtArgs>>): Prisma__sub_paketsClient<$Result.GetResult<Prisma.$sub_paketsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    banks_items<T extends items$banks_itemsArgs<ExtArgs> = {}>(args?: Subset<T, items$banks_itemsArgs<ExtArgs>>): Prisma__banks_itemsClient<$Result.GetResult<Prisma.$banks_itemsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the items model
   */ 
  interface itemsFieldRefs {
    readonly id: FieldRef<"items", 'Int'>
    readonly name: FieldRef<"items", 'String'>
    readonly code: FieldRef<"items", 'String'>
    readonly clc_code: FieldRef<"items", 'String'>
    readonly order_num: FieldRef<"items", 'Int'>
    readonly is_active: FieldRef<"items", 'Boolean'>
    readonly sub_pakets_id: FieldRef<"items", 'Int'>
    readonly banks_items_id: FieldRef<"items", 'Int'>
    readonly created_at: FieldRef<"items", 'DateTime'>
    readonly updated_at: FieldRef<"items", 'DateTime'>
    readonly propogated_at: FieldRef<"items", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * items findUnique
   */
  export type itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items findUniqueOrThrow
   */
  export type itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items findFirst
   */
  export type itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for items.
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of items.
     */
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * items findFirstOrThrow
   */
  export type itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for items.
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of items.
     */
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * items findMany
   */
  export type itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing items.
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * items create
   */
  export type itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * The data needed to create a items.
     */
    data: XOR<itemsCreateInput, itemsUncheckedCreateInput>
  }

  /**
   * items createMany
   */
  export type itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many items.
     */
    data: itemsCreateManyInput | itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * items update
   */
  export type itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * The data needed to update a items.
     */
    data: XOR<itemsUpdateInput, itemsUncheckedUpdateInput>
    /**
     * Choose, which items to update.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items updateMany
   */
  export type itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update items.
     */
    data: XOR<itemsUpdateManyMutationInput, itemsUncheckedUpdateManyInput>
    /**
     * Filter which items to update
     */
    where?: itemsWhereInput
  }

  /**
   * items upsert
   */
  export type itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * The filter to search for the items to update in case it exists.
     */
    where: itemsWhereUniqueInput
    /**
     * In case the items found by the `where` argument doesn't exist, create a new items with this data.
     */
    create: XOR<itemsCreateInput, itemsUncheckedCreateInput>
    /**
     * In case the items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<itemsUpdateInput, itemsUncheckedUpdateInput>
  }

  /**
   * items delete
   */
  export type itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * Filter which items to delete.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items deleteMany
   */
  export type itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which items to delete
     */
    where?: itemsWhereInput
  }

  /**
   * items.banks_items
   */
  export type items$banks_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items
     */
    select?: banks_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_itemsInclude<ExtArgs> | null
    where?: banks_itemsWhereInput
  }

  /**
   * items without action
   */
  export type itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
  }


  /**
   * Model objects
   */

  export type AggregateObjects = {
    _count: ObjectsCountAggregateOutputType | null
    _avg: ObjectsAvgAggregateOutputType | null
    _sum: ObjectsSumAggregateOutputType | null
    _min: ObjectsMinAggregateOutputType | null
    _max: ObjectsMaxAggregateOutputType | null
  }

  export type ObjectsAvgAggregateOutputType = {
    id: number | null
    entity_id: number | null
  }

  export type ObjectsSumAggregateOutputType = {
    id: number | null
    entity_id: number | null
  }

  export type ObjectsMinAggregateOutputType = {
    id: number | null
    short_name: string | null
    created_at: Date | null
    updated_at: Date | null
    entity_id: number | null
  }

  export type ObjectsMaxAggregateOutputType = {
    id: number | null
    short_name: string | null
    created_at: Date | null
    updated_at: Date | null
    entity_id: number | null
  }

  export type ObjectsCountAggregateOutputType = {
    id: number
    short_name: number
    created_at: number
    updated_at: number
    entity_id: number
    _all: number
  }


  export type ObjectsAvgAggregateInputType = {
    id?: true
    entity_id?: true
  }

  export type ObjectsSumAggregateInputType = {
    id?: true
    entity_id?: true
  }

  export type ObjectsMinAggregateInputType = {
    id?: true
    short_name?: true
    created_at?: true
    updated_at?: true
    entity_id?: true
  }

  export type ObjectsMaxAggregateInputType = {
    id?: true
    short_name?: true
    created_at?: true
    updated_at?: true
    entity_id?: true
  }

  export type ObjectsCountAggregateInputType = {
    id?: true
    short_name?: true
    created_at?: true
    updated_at?: true
    entity_id?: true
    _all?: true
  }

  export type ObjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which objects to aggregate.
     */
    where?: objectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of objects to fetch.
     */
    orderBy?: objectsOrderByWithRelationInput | objectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: objectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` objects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned objects
    **/
    _count?: true | ObjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjectsMaxAggregateInputType
  }

  export type GetObjectsAggregateType<T extends ObjectsAggregateArgs> = {
        [P in keyof T & keyof AggregateObjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObjects[P]>
      : GetScalarType<T[P], AggregateObjects[P]>
  }




  export type objectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: objectsWhereInput
    orderBy?: objectsOrderByWithAggregationInput | objectsOrderByWithAggregationInput[]
    by: ObjectsScalarFieldEnum[] | ObjectsScalarFieldEnum
    having?: objectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjectsCountAggregateInputType | true
    _avg?: ObjectsAvgAggregateInputType
    _sum?: ObjectsSumAggregateInputType
    _min?: ObjectsMinAggregateInputType
    _max?: ObjectsMaxAggregateInputType
  }

  export type ObjectsGroupByOutputType = {
    id: number
    short_name: string
    created_at: Date | null
    updated_at: Date | null
    entity_id: number
    _count: ObjectsCountAggregateOutputType | null
    _avg: ObjectsAvgAggregateOutputType | null
    _sum: ObjectsSumAggregateOutputType | null
    _min: ObjectsMinAggregateOutputType | null
    _max: ObjectsMaxAggregateOutputType | null
  }

  type GetObjectsGroupByPayload<T extends objectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjectsGroupByOutputType[P]>
            : GetScalarType<T[P], ObjectsGroupByOutputType[P]>
        }
      >
    >


  export type objectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    short_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    entity_id?: boolean
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    sections?: boolean | objects$sectionsArgs<ExtArgs>
    _count?: boolean | ObjectsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objects"]>


  export type objectsSelectScalar = {
    id?: boolean
    short_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    entity_id?: boolean
  }

  export type objectsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    sections?: boolean | objects$sectionsArgs<ExtArgs>
    _count?: boolean | ObjectsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $objectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "objects"
    objects: {
      entities: Prisma.$entitiesPayload<ExtArgs>
      sections: Prisma.$sectionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      short_name: string
      created_at: Date | null
      updated_at: Date | null
      entity_id: number
    }, ExtArgs["result"]["objects"]>
    composites: {}
  }

  type objectsGetPayload<S extends boolean | null | undefined | objectsDefaultArgs> = $Result.GetResult<Prisma.$objectsPayload, S>

  type objectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<objectsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ObjectsCountAggregateInputType | true
    }

  export interface objectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['objects'], meta: { name: 'objects' } }
    /**
     * Find zero or one Objects that matches the filter.
     * @param {objectsFindUniqueArgs} args - Arguments to find a Objects
     * @example
     * // Get one Objects
     * const objects = await prisma.objects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends objectsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, objectsFindUniqueArgs<ExtArgs>>
    ): Prisma__objectsClient<$Result.GetResult<Prisma.$objectsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Objects that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {objectsFindUniqueOrThrowArgs} args - Arguments to find a Objects
     * @example
     * // Get one Objects
     * const objects = await prisma.objects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends objectsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, objectsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__objectsClient<$Result.GetResult<Prisma.$objectsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Objects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objectsFindFirstArgs} args - Arguments to find a Objects
     * @example
     * // Get one Objects
     * const objects = await prisma.objects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends objectsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, objectsFindFirstArgs<ExtArgs>>
    ): Prisma__objectsClient<$Result.GetResult<Prisma.$objectsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Objects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objectsFindFirstOrThrowArgs} args - Arguments to find a Objects
     * @example
     * // Get one Objects
     * const objects = await prisma.objects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends objectsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, objectsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__objectsClient<$Result.GetResult<Prisma.$objectsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Objects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Objects
     * const objects = await prisma.objects.findMany()
     * 
     * // Get first 10 Objects
     * const objects = await prisma.objects.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objectsWithIdOnly = await prisma.objects.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends objectsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, objectsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$objectsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Objects.
     * @param {objectsCreateArgs} args - Arguments to create a Objects.
     * @example
     * // Create one Objects
     * const Objects = await prisma.objects.create({
     *   data: {
     *     // ... data to create a Objects
     *   }
     * })
     * 
    **/
    create<T extends objectsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, objectsCreateArgs<ExtArgs>>
    ): Prisma__objectsClient<$Result.GetResult<Prisma.$objectsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Objects.
     * @param {objectsCreateManyArgs} args - Arguments to create many Objects.
     * @example
     * // Create many Objects
     * const objects = await prisma.objects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends objectsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, objectsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Objects.
     * @param {objectsDeleteArgs} args - Arguments to delete one Objects.
     * @example
     * // Delete one Objects
     * const Objects = await prisma.objects.delete({
     *   where: {
     *     // ... filter to delete one Objects
     *   }
     * })
     * 
    **/
    delete<T extends objectsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, objectsDeleteArgs<ExtArgs>>
    ): Prisma__objectsClient<$Result.GetResult<Prisma.$objectsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Objects.
     * @param {objectsUpdateArgs} args - Arguments to update one Objects.
     * @example
     * // Update one Objects
     * const objects = await prisma.objects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends objectsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, objectsUpdateArgs<ExtArgs>>
    ): Prisma__objectsClient<$Result.GetResult<Prisma.$objectsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Objects.
     * @param {objectsDeleteManyArgs} args - Arguments to filter Objects to delete.
     * @example
     * // Delete a few Objects
     * const { count } = await prisma.objects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends objectsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, objectsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Objects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Objects
     * const objects = await prisma.objects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends objectsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, objectsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Objects.
     * @param {objectsUpsertArgs} args - Arguments to update or create a Objects.
     * @example
     * // Update or create a Objects
     * const objects = await prisma.objects.upsert({
     *   create: {
     *     // ... data to create a Objects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Objects we want to update
     *   }
     * })
    **/
    upsert<T extends objectsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, objectsUpsertArgs<ExtArgs>>
    ): Prisma__objectsClient<$Result.GetResult<Prisma.$objectsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Objects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objectsCountArgs} args - Arguments to filter Objects to count.
     * @example
     * // Count the number of Objects
     * const count = await prisma.objects.count({
     *   where: {
     *     // ... the filter for the Objects we want to count
     *   }
     * })
    **/
    count<T extends objectsCountArgs>(
      args?: Subset<T, objectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Objects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjectsAggregateArgs>(args: Subset<T, ObjectsAggregateArgs>): Prisma.PrismaPromise<GetObjectsAggregateType<T>>

    /**
     * Group by Objects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends objectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: objectsGroupByArgs['orderBy'] }
        : { orderBy?: objectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, objectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the objects model
   */
  readonly fields: objectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for objects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__objectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sections<T extends objects$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, objects$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the objects model
   */ 
  interface objectsFieldRefs {
    readonly id: FieldRef<"objects", 'Int'>
    readonly short_name: FieldRef<"objects", 'String'>
    readonly created_at: FieldRef<"objects", 'DateTime'>
    readonly updated_at: FieldRef<"objects", 'DateTime'>
    readonly entity_id: FieldRef<"objects", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * objects findUnique
   */
  export type objectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objects
     */
    select?: objectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objectsInclude<ExtArgs> | null
    /**
     * Filter, which objects to fetch.
     */
    where: objectsWhereUniqueInput
  }

  /**
   * objects findUniqueOrThrow
   */
  export type objectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objects
     */
    select?: objectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objectsInclude<ExtArgs> | null
    /**
     * Filter, which objects to fetch.
     */
    where: objectsWhereUniqueInput
  }

  /**
   * objects findFirst
   */
  export type objectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objects
     */
    select?: objectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objectsInclude<ExtArgs> | null
    /**
     * Filter, which objects to fetch.
     */
    where?: objectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of objects to fetch.
     */
    orderBy?: objectsOrderByWithRelationInput | objectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for objects.
     */
    cursor?: objectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` objects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of objects.
     */
    distinct?: ObjectsScalarFieldEnum | ObjectsScalarFieldEnum[]
  }

  /**
   * objects findFirstOrThrow
   */
  export type objectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objects
     */
    select?: objectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objectsInclude<ExtArgs> | null
    /**
     * Filter, which objects to fetch.
     */
    where?: objectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of objects to fetch.
     */
    orderBy?: objectsOrderByWithRelationInput | objectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for objects.
     */
    cursor?: objectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` objects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of objects.
     */
    distinct?: ObjectsScalarFieldEnum | ObjectsScalarFieldEnum[]
  }

  /**
   * objects findMany
   */
  export type objectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objects
     */
    select?: objectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objectsInclude<ExtArgs> | null
    /**
     * Filter, which objects to fetch.
     */
    where?: objectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of objects to fetch.
     */
    orderBy?: objectsOrderByWithRelationInput | objectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing objects.
     */
    cursor?: objectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` objects.
     */
    skip?: number
    distinct?: ObjectsScalarFieldEnum | ObjectsScalarFieldEnum[]
  }

  /**
   * objects create
   */
  export type objectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objects
     */
    select?: objectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objectsInclude<ExtArgs> | null
    /**
     * The data needed to create a objects.
     */
    data: XOR<objectsCreateInput, objectsUncheckedCreateInput>
  }

  /**
   * objects createMany
   */
  export type objectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many objects.
     */
    data: objectsCreateManyInput | objectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * objects update
   */
  export type objectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objects
     */
    select?: objectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objectsInclude<ExtArgs> | null
    /**
     * The data needed to update a objects.
     */
    data: XOR<objectsUpdateInput, objectsUncheckedUpdateInput>
    /**
     * Choose, which objects to update.
     */
    where: objectsWhereUniqueInput
  }

  /**
   * objects updateMany
   */
  export type objectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update objects.
     */
    data: XOR<objectsUpdateManyMutationInput, objectsUncheckedUpdateManyInput>
    /**
     * Filter which objects to update
     */
    where?: objectsWhereInput
  }

  /**
   * objects upsert
   */
  export type objectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objects
     */
    select?: objectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objectsInclude<ExtArgs> | null
    /**
     * The filter to search for the objects to update in case it exists.
     */
    where: objectsWhereUniqueInput
    /**
     * In case the objects found by the `where` argument doesn't exist, create a new objects with this data.
     */
    create: XOR<objectsCreateInput, objectsUncheckedCreateInput>
    /**
     * In case the objects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<objectsUpdateInput, objectsUncheckedUpdateInput>
  }

  /**
   * objects delete
   */
  export type objectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objects
     */
    select?: objectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objectsInclude<ExtArgs> | null
    /**
     * Filter which objects to delete.
     */
    where: objectsWhereUniqueInput
  }

  /**
   * objects deleteMany
   */
  export type objectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which objects to delete
     */
    where?: objectsWhereInput
  }

  /**
   * objects.sections
   */
  export type objects$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    where?: sectionsWhereInput
    orderBy?: sectionsOrderByWithRelationInput | sectionsOrderByWithRelationInput[]
    cursor?: sectionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionsScalarFieldEnum | SectionsScalarFieldEnum[]
  }

  /**
   * objects without action
   */
  export type objectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objects
     */
    select?: objectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objectsInclude<ExtArgs> | null
  }


  /**
   * Model pakets
   */

  export type AggregatePakets = {
    _count: PaketsCountAggregateOutputType | null
    _avg: PaketsAvgAggregateOutputType | null
    _sum: PaketsSumAggregateOutputType | null
    _min: PaketsMinAggregateOutputType | null
    _max: PaketsMaxAggregateOutputType | null
  }

  export type PaketsAvgAggregateOutputType = {
    id: number | null
    order_num: number | null
    blocks_id: number | null
  }

  export type PaketsSumAggregateOutputType = {
    id: number | null
    order_num: number | null
    blocks_id: number | null
  }

  export type PaketsMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    order_num: number | null
    is_active: boolean | null
    blocks_id: number | null
    created_at: Date | null
    updated_at: Date | null
    propogated_at: Date | null
  }

  export type PaketsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    order_num: number | null
    is_active: boolean | null
    blocks_id: number | null
    created_at: Date | null
    updated_at: Date | null
    propogated_at: Date | null
  }

  export type PaketsCountAggregateOutputType = {
    id: number
    name: number
    code: number
    order_num: number
    is_active: number
    blocks_id: number
    created_at: number
    updated_at: number
    propogated_at: number
    _all: number
  }


  export type PaketsAvgAggregateInputType = {
    id?: true
    order_num?: true
    blocks_id?: true
  }

  export type PaketsSumAggregateInputType = {
    id?: true
    order_num?: true
    blocks_id?: true
  }

  export type PaketsMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    order_num?: true
    is_active?: true
    blocks_id?: true
    created_at?: true
    updated_at?: true
    propogated_at?: true
  }

  export type PaketsMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    order_num?: true
    is_active?: true
    blocks_id?: true
    created_at?: true
    updated_at?: true
    propogated_at?: true
  }

  export type PaketsCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    order_num?: true
    is_active?: true
    blocks_id?: true
    created_at?: true
    updated_at?: true
    propogated_at?: true
    _all?: true
  }

  export type PaketsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pakets to aggregate.
     */
    where?: paketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pakets to fetch.
     */
    orderBy?: paketsOrderByWithRelationInput | paketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pakets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pakets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pakets
    **/
    _count?: true | PaketsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaketsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaketsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaketsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaketsMaxAggregateInputType
  }

  export type GetPaketsAggregateType<T extends PaketsAggregateArgs> = {
        [P in keyof T & keyof AggregatePakets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePakets[P]>
      : GetScalarType<T[P], AggregatePakets[P]>
  }




  export type paketsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paketsWhereInput
    orderBy?: paketsOrderByWithAggregationInput | paketsOrderByWithAggregationInput[]
    by: PaketsScalarFieldEnum[] | PaketsScalarFieldEnum
    having?: paketsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaketsCountAggregateInputType | true
    _avg?: PaketsAvgAggregateInputType
    _sum?: PaketsSumAggregateInputType
    _min?: PaketsMinAggregateInputType
    _max?: PaketsMaxAggregateInputType
  }

  export type PaketsGroupByOutputType = {
    id: number
    name: string
    code: string
    order_num: number | null
    is_active: boolean
    blocks_id: number
    created_at: Date | null
    updated_at: Date | null
    propogated_at: Date | null
    _count: PaketsCountAggregateOutputType | null
    _avg: PaketsAvgAggregateOutputType | null
    _sum: PaketsSumAggregateOutputType | null
    _min: PaketsMinAggregateOutputType | null
    _max: PaketsMaxAggregateOutputType | null
  }

  type GetPaketsGroupByPayload<T extends paketsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaketsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaketsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaketsGroupByOutputType[P]>
            : GetScalarType<T[P], PaketsGroupByOutputType[P]>
        }
      >
    >


  export type paketsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    order_num?: boolean
    is_active?: boolean
    blocks_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    propogated_at?: boolean
    blocks?: boolean | blocksDefaultArgs<ExtArgs>
    sub_pakets?: boolean | pakets$sub_paketsArgs<ExtArgs>
    _count?: boolean | PaketsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pakets"]>


  export type paketsSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    order_num?: boolean
    is_active?: boolean
    blocks_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    propogated_at?: boolean
  }

  export type paketsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocks?: boolean | blocksDefaultArgs<ExtArgs>
    sub_pakets?: boolean | pakets$sub_paketsArgs<ExtArgs>
    _count?: boolean | PaketsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $paketsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pakets"
    objects: {
      blocks: Prisma.$blocksPayload<ExtArgs>
      sub_pakets: Prisma.$sub_paketsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      order_num: number | null
      is_active: boolean
      blocks_id: number
      created_at: Date | null
      updated_at: Date | null
      propogated_at: Date | null
    }, ExtArgs["result"]["pakets"]>
    composites: {}
  }

  type paketsGetPayload<S extends boolean | null | undefined | paketsDefaultArgs> = $Result.GetResult<Prisma.$paketsPayload, S>

  type paketsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<paketsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaketsCountAggregateInputType | true
    }

  export interface paketsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pakets'], meta: { name: 'pakets' } }
    /**
     * Find zero or one Pakets that matches the filter.
     * @param {paketsFindUniqueArgs} args - Arguments to find a Pakets
     * @example
     * // Get one Pakets
     * const pakets = await prisma.pakets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends paketsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, paketsFindUniqueArgs<ExtArgs>>
    ): Prisma__paketsClient<$Result.GetResult<Prisma.$paketsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pakets that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {paketsFindUniqueOrThrowArgs} args - Arguments to find a Pakets
     * @example
     * // Get one Pakets
     * const pakets = await prisma.pakets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends paketsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, paketsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__paketsClient<$Result.GetResult<Prisma.$paketsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pakets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paketsFindFirstArgs} args - Arguments to find a Pakets
     * @example
     * // Get one Pakets
     * const pakets = await prisma.pakets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends paketsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, paketsFindFirstArgs<ExtArgs>>
    ): Prisma__paketsClient<$Result.GetResult<Prisma.$paketsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pakets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paketsFindFirstOrThrowArgs} args - Arguments to find a Pakets
     * @example
     * // Get one Pakets
     * const pakets = await prisma.pakets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends paketsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, paketsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__paketsClient<$Result.GetResult<Prisma.$paketsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Pakets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paketsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pakets
     * const pakets = await prisma.pakets.findMany()
     * 
     * // Get first 10 Pakets
     * const pakets = await prisma.pakets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paketsWithIdOnly = await prisma.pakets.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends paketsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, paketsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paketsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pakets.
     * @param {paketsCreateArgs} args - Arguments to create a Pakets.
     * @example
     * // Create one Pakets
     * const Pakets = await prisma.pakets.create({
     *   data: {
     *     // ... data to create a Pakets
     *   }
     * })
     * 
    **/
    create<T extends paketsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, paketsCreateArgs<ExtArgs>>
    ): Prisma__paketsClient<$Result.GetResult<Prisma.$paketsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Pakets.
     * @param {paketsCreateManyArgs} args - Arguments to create many Pakets.
     * @example
     * // Create many Pakets
     * const pakets = await prisma.pakets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends paketsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, paketsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pakets.
     * @param {paketsDeleteArgs} args - Arguments to delete one Pakets.
     * @example
     * // Delete one Pakets
     * const Pakets = await prisma.pakets.delete({
     *   where: {
     *     // ... filter to delete one Pakets
     *   }
     * })
     * 
    **/
    delete<T extends paketsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, paketsDeleteArgs<ExtArgs>>
    ): Prisma__paketsClient<$Result.GetResult<Prisma.$paketsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pakets.
     * @param {paketsUpdateArgs} args - Arguments to update one Pakets.
     * @example
     * // Update one Pakets
     * const pakets = await prisma.pakets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends paketsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, paketsUpdateArgs<ExtArgs>>
    ): Prisma__paketsClient<$Result.GetResult<Prisma.$paketsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Pakets.
     * @param {paketsDeleteManyArgs} args - Arguments to filter Pakets to delete.
     * @example
     * // Delete a few Pakets
     * const { count } = await prisma.pakets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends paketsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, paketsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pakets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paketsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pakets
     * const pakets = await prisma.pakets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends paketsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, paketsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pakets.
     * @param {paketsUpsertArgs} args - Arguments to update or create a Pakets.
     * @example
     * // Update or create a Pakets
     * const pakets = await prisma.pakets.upsert({
     *   create: {
     *     // ... data to create a Pakets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pakets we want to update
     *   }
     * })
    **/
    upsert<T extends paketsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, paketsUpsertArgs<ExtArgs>>
    ): Prisma__paketsClient<$Result.GetResult<Prisma.$paketsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Pakets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paketsCountArgs} args - Arguments to filter Pakets to count.
     * @example
     * // Count the number of Pakets
     * const count = await prisma.pakets.count({
     *   where: {
     *     // ... the filter for the Pakets we want to count
     *   }
     * })
    **/
    count<T extends paketsCountArgs>(
      args?: Subset<T, paketsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaketsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pakets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaketsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaketsAggregateArgs>(args: Subset<T, PaketsAggregateArgs>): Prisma.PrismaPromise<GetPaketsAggregateType<T>>

    /**
     * Group by Pakets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paketsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paketsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paketsGroupByArgs['orderBy'] }
        : { orderBy?: paketsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paketsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaketsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pakets model
   */
  readonly fields: paketsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pakets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paketsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    blocks<T extends blocksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, blocksDefaultArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sub_pakets<T extends pakets$sub_paketsArgs<ExtArgs> = {}>(args?: Subset<T, pakets$sub_paketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sub_paketsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the pakets model
   */ 
  interface paketsFieldRefs {
    readonly id: FieldRef<"pakets", 'Int'>
    readonly name: FieldRef<"pakets", 'String'>
    readonly code: FieldRef<"pakets", 'String'>
    readonly order_num: FieldRef<"pakets", 'Int'>
    readonly is_active: FieldRef<"pakets", 'Boolean'>
    readonly blocks_id: FieldRef<"pakets", 'Int'>
    readonly created_at: FieldRef<"pakets", 'DateTime'>
    readonly updated_at: FieldRef<"pakets", 'DateTime'>
    readonly propogated_at: FieldRef<"pakets", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pakets findUnique
   */
  export type paketsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pakets
     */
    select?: paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paketsInclude<ExtArgs> | null
    /**
     * Filter, which pakets to fetch.
     */
    where: paketsWhereUniqueInput
  }

  /**
   * pakets findUniqueOrThrow
   */
  export type paketsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pakets
     */
    select?: paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paketsInclude<ExtArgs> | null
    /**
     * Filter, which pakets to fetch.
     */
    where: paketsWhereUniqueInput
  }

  /**
   * pakets findFirst
   */
  export type paketsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pakets
     */
    select?: paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paketsInclude<ExtArgs> | null
    /**
     * Filter, which pakets to fetch.
     */
    where?: paketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pakets to fetch.
     */
    orderBy?: paketsOrderByWithRelationInput | paketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pakets.
     */
    cursor?: paketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pakets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pakets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pakets.
     */
    distinct?: PaketsScalarFieldEnum | PaketsScalarFieldEnum[]
  }

  /**
   * pakets findFirstOrThrow
   */
  export type paketsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pakets
     */
    select?: paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paketsInclude<ExtArgs> | null
    /**
     * Filter, which pakets to fetch.
     */
    where?: paketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pakets to fetch.
     */
    orderBy?: paketsOrderByWithRelationInput | paketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pakets.
     */
    cursor?: paketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pakets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pakets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pakets.
     */
    distinct?: PaketsScalarFieldEnum | PaketsScalarFieldEnum[]
  }

  /**
   * pakets findMany
   */
  export type paketsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pakets
     */
    select?: paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paketsInclude<ExtArgs> | null
    /**
     * Filter, which pakets to fetch.
     */
    where?: paketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pakets to fetch.
     */
    orderBy?: paketsOrderByWithRelationInput | paketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pakets.
     */
    cursor?: paketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pakets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pakets.
     */
    skip?: number
    distinct?: PaketsScalarFieldEnum | PaketsScalarFieldEnum[]
  }

  /**
   * pakets create
   */
  export type paketsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pakets
     */
    select?: paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paketsInclude<ExtArgs> | null
    /**
     * The data needed to create a pakets.
     */
    data: XOR<paketsCreateInput, paketsUncheckedCreateInput>
  }

  /**
   * pakets createMany
   */
  export type paketsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pakets.
     */
    data: paketsCreateManyInput | paketsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pakets update
   */
  export type paketsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pakets
     */
    select?: paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paketsInclude<ExtArgs> | null
    /**
     * The data needed to update a pakets.
     */
    data: XOR<paketsUpdateInput, paketsUncheckedUpdateInput>
    /**
     * Choose, which pakets to update.
     */
    where: paketsWhereUniqueInput
  }

  /**
   * pakets updateMany
   */
  export type paketsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pakets.
     */
    data: XOR<paketsUpdateManyMutationInput, paketsUncheckedUpdateManyInput>
    /**
     * Filter which pakets to update
     */
    where?: paketsWhereInput
  }

  /**
   * pakets upsert
   */
  export type paketsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pakets
     */
    select?: paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paketsInclude<ExtArgs> | null
    /**
     * The filter to search for the pakets to update in case it exists.
     */
    where: paketsWhereUniqueInput
    /**
     * In case the pakets found by the `where` argument doesn't exist, create a new pakets with this data.
     */
    create: XOR<paketsCreateInput, paketsUncheckedCreateInput>
    /**
     * In case the pakets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paketsUpdateInput, paketsUncheckedUpdateInput>
  }

  /**
   * pakets delete
   */
  export type paketsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pakets
     */
    select?: paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paketsInclude<ExtArgs> | null
    /**
     * Filter which pakets to delete.
     */
    where: paketsWhereUniqueInput
  }

  /**
   * pakets deleteMany
   */
  export type paketsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pakets to delete
     */
    where?: paketsWhereInput
  }

  /**
   * pakets.sub_pakets
   */
  export type pakets$sub_paketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_pakets
     */
    select?: sub_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_paketsInclude<ExtArgs> | null
    where?: sub_paketsWhereInput
    orderBy?: sub_paketsOrderByWithRelationInput | sub_paketsOrderByWithRelationInput[]
    cursor?: sub_paketsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sub_paketsScalarFieldEnum | Sub_paketsScalarFieldEnum[]
  }

  /**
   * pakets without action
   */
  export type paketsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pakets
     */
    select?: paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paketsInclude<ExtArgs> | null
  }


  /**
   * Model r_roles_apps
   */

  export type AggregateR_roles_apps = {
    _count: R_roles_appsCountAggregateOutputType | null
    _avg: R_roles_appsAvgAggregateOutputType | null
    _sum: R_roles_appsSumAggregateOutputType | null
    _min: R_roles_appsMinAggregateOutputType | null
    _max: R_roles_appsMaxAggregateOutputType | null
  }

  export type R_roles_appsAvgAggregateOutputType = {
    role_id: number | null
  }

  export type R_roles_appsSumAggregateOutputType = {
    role_id: number | null
  }

  export type R_roles_appsMinAggregateOutputType = {
    role_id: number | null
    app_id: string | null
  }

  export type R_roles_appsMaxAggregateOutputType = {
    role_id: number | null
    app_id: string | null
  }

  export type R_roles_appsCountAggregateOutputType = {
    role_id: number
    app_id: number
    _all: number
  }


  export type R_roles_appsAvgAggregateInputType = {
    role_id?: true
  }

  export type R_roles_appsSumAggregateInputType = {
    role_id?: true
  }

  export type R_roles_appsMinAggregateInputType = {
    role_id?: true
    app_id?: true
  }

  export type R_roles_appsMaxAggregateInputType = {
    role_id?: true
    app_id?: true
  }

  export type R_roles_appsCountAggregateInputType = {
    role_id?: true
    app_id?: true
    _all?: true
  }

  export type R_roles_appsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which r_roles_apps to aggregate.
     */
    where?: r_roles_appsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of r_roles_apps to fetch.
     */
    orderBy?: r_roles_appsOrderByWithRelationInput | r_roles_appsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: r_roles_appsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` r_roles_apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` r_roles_apps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned r_roles_apps
    **/
    _count?: true | R_roles_appsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: R_roles_appsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: R_roles_appsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: R_roles_appsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: R_roles_appsMaxAggregateInputType
  }

  export type GetR_roles_appsAggregateType<T extends R_roles_appsAggregateArgs> = {
        [P in keyof T & keyof AggregateR_roles_apps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateR_roles_apps[P]>
      : GetScalarType<T[P], AggregateR_roles_apps[P]>
  }




  export type r_roles_appsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: r_roles_appsWhereInput
    orderBy?: r_roles_appsOrderByWithAggregationInput | r_roles_appsOrderByWithAggregationInput[]
    by: R_roles_appsScalarFieldEnum[] | R_roles_appsScalarFieldEnum
    having?: r_roles_appsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: R_roles_appsCountAggregateInputType | true
    _avg?: R_roles_appsAvgAggregateInputType
    _sum?: R_roles_appsSumAggregateInputType
    _min?: R_roles_appsMinAggregateInputType
    _max?: R_roles_appsMaxAggregateInputType
  }

  export type R_roles_appsGroupByOutputType = {
    role_id: number
    app_id: string
    _count: R_roles_appsCountAggregateOutputType | null
    _avg: R_roles_appsAvgAggregateOutputType | null
    _sum: R_roles_appsSumAggregateOutputType | null
    _min: R_roles_appsMinAggregateOutputType | null
    _max: R_roles_appsMaxAggregateOutputType | null
  }

  type GetR_roles_appsGroupByPayload<T extends r_roles_appsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<R_roles_appsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof R_roles_appsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], R_roles_appsGroupByOutputType[P]>
            : GetScalarType<T[P], R_roles_appsGroupByOutputType[P]>
        }
      >
    >


  export type r_roles_appsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    app_id?: boolean
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    applications?: boolean | applicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["r_roles_apps"]>


  export type r_roles_appsSelectScalar = {
    role_id?: boolean
    app_id?: boolean
  }

  export type r_roles_appsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    applications?: boolean | applicationsDefaultArgs<ExtArgs>
  }

  export type $r_roles_appsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "r_roles_apps"
    objects: {
      roles: Prisma.$rolesPayload<ExtArgs>
      applications: Prisma.$applicationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      role_id: number
      app_id: string
    }, ExtArgs["result"]["r_roles_apps"]>
    composites: {}
  }

  type r_roles_appsGetPayload<S extends boolean | null | undefined | r_roles_appsDefaultArgs> = $Result.GetResult<Prisma.$r_roles_appsPayload, S>

  type r_roles_appsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<r_roles_appsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: R_roles_appsCountAggregateInputType | true
    }

  export interface r_roles_appsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['r_roles_apps'], meta: { name: 'r_roles_apps' } }
    /**
     * Find zero or one R_roles_apps that matches the filter.
     * @param {r_roles_appsFindUniqueArgs} args - Arguments to find a R_roles_apps
     * @example
     * // Get one R_roles_apps
     * const r_roles_apps = await prisma.r_roles_apps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends r_roles_appsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, r_roles_appsFindUniqueArgs<ExtArgs>>
    ): Prisma__r_roles_appsClient<$Result.GetResult<Prisma.$r_roles_appsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one R_roles_apps that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {r_roles_appsFindUniqueOrThrowArgs} args - Arguments to find a R_roles_apps
     * @example
     * // Get one R_roles_apps
     * const r_roles_apps = await prisma.r_roles_apps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends r_roles_appsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, r_roles_appsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__r_roles_appsClient<$Result.GetResult<Prisma.$r_roles_appsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first R_roles_apps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_roles_appsFindFirstArgs} args - Arguments to find a R_roles_apps
     * @example
     * // Get one R_roles_apps
     * const r_roles_apps = await prisma.r_roles_apps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends r_roles_appsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, r_roles_appsFindFirstArgs<ExtArgs>>
    ): Prisma__r_roles_appsClient<$Result.GetResult<Prisma.$r_roles_appsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first R_roles_apps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_roles_appsFindFirstOrThrowArgs} args - Arguments to find a R_roles_apps
     * @example
     * // Get one R_roles_apps
     * const r_roles_apps = await prisma.r_roles_apps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends r_roles_appsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, r_roles_appsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__r_roles_appsClient<$Result.GetResult<Prisma.$r_roles_appsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more R_roles_apps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_roles_appsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all R_roles_apps
     * const r_roles_apps = await prisma.r_roles_apps.findMany()
     * 
     * // Get first 10 R_roles_apps
     * const r_roles_apps = await prisma.r_roles_apps.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const r_roles_appsWithRole_idOnly = await prisma.r_roles_apps.findMany({ select: { role_id: true } })
     * 
    **/
    findMany<T extends r_roles_appsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, r_roles_appsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$r_roles_appsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a R_roles_apps.
     * @param {r_roles_appsCreateArgs} args - Arguments to create a R_roles_apps.
     * @example
     * // Create one R_roles_apps
     * const R_roles_apps = await prisma.r_roles_apps.create({
     *   data: {
     *     // ... data to create a R_roles_apps
     *   }
     * })
     * 
    **/
    create<T extends r_roles_appsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, r_roles_appsCreateArgs<ExtArgs>>
    ): Prisma__r_roles_appsClient<$Result.GetResult<Prisma.$r_roles_appsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many R_roles_apps.
     * @param {r_roles_appsCreateManyArgs} args - Arguments to create many R_roles_apps.
     * @example
     * // Create many R_roles_apps
     * const r_roles_apps = await prisma.r_roles_apps.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends r_roles_appsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, r_roles_appsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a R_roles_apps.
     * @param {r_roles_appsDeleteArgs} args - Arguments to delete one R_roles_apps.
     * @example
     * // Delete one R_roles_apps
     * const R_roles_apps = await prisma.r_roles_apps.delete({
     *   where: {
     *     // ... filter to delete one R_roles_apps
     *   }
     * })
     * 
    **/
    delete<T extends r_roles_appsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, r_roles_appsDeleteArgs<ExtArgs>>
    ): Prisma__r_roles_appsClient<$Result.GetResult<Prisma.$r_roles_appsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one R_roles_apps.
     * @param {r_roles_appsUpdateArgs} args - Arguments to update one R_roles_apps.
     * @example
     * // Update one R_roles_apps
     * const r_roles_apps = await prisma.r_roles_apps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends r_roles_appsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, r_roles_appsUpdateArgs<ExtArgs>>
    ): Prisma__r_roles_appsClient<$Result.GetResult<Prisma.$r_roles_appsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more R_roles_apps.
     * @param {r_roles_appsDeleteManyArgs} args - Arguments to filter R_roles_apps to delete.
     * @example
     * // Delete a few R_roles_apps
     * const { count } = await prisma.r_roles_apps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends r_roles_appsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, r_roles_appsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more R_roles_apps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_roles_appsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many R_roles_apps
     * const r_roles_apps = await prisma.r_roles_apps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends r_roles_appsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, r_roles_appsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one R_roles_apps.
     * @param {r_roles_appsUpsertArgs} args - Arguments to update or create a R_roles_apps.
     * @example
     * // Update or create a R_roles_apps
     * const r_roles_apps = await prisma.r_roles_apps.upsert({
     *   create: {
     *     // ... data to create a R_roles_apps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the R_roles_apps we want to update
     *   }
     * })
    **/
    upsert<T extends r_roles_appsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, r_roles_appsUpsertArgs<ExtArgs>>
    ): Prisma__r_roles_appsClient<$Result.GetResult<Prisma.$r_roles_appsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of R_roles_apps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_roles_appsCountArgs} args - Arguments to filter R_roles_apps to count.
     * @example
     * // Count the number of R_roles_apps
     * const count = await prisma.r_roles_apps.count({
     *   where: {
     *     // ... the filter for the R_roles_apps we want to count
     *   }
     * })
    **/
    count<T extends r_roles_appsCountArgs>(
      args?: Subset<T, r_roles_appsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], R_roles_appsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a R_roles_apps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {R_roles_appsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends R_roles_appsAggregateArgs>(args: Subset<T, R_roles_appsAggregateArgs>): Prisma.PrismaPromise<GetR_roles_appsAggregateType<T>>

    /**
     * Group by R_roles_apps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_roles_appsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends r_roles_appsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: r_roles_appsGroupByArgs['orderBy'] }
        : { orderBy?: r_roles_appsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, r_roles_appsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetR_roles_appsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the r_roles_apps model
   */
  readonly fields: r_roles_appsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for r_roles_apps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__r_roles_appsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    applications<T extends applicationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, applicationsDefaultArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the r_roles_apps model
   */ 
  interface r_roles_appsFieldRefs {
    readonly role_id: FieldRef<"r_roles_apps", 'Int'>
    readonly app_id: FieldRef<"r_roles_apps", 'String'>
  }
    

  // Custom InputTypes
  /**
   * r_roles_apps findUnique
   */
  export type r_roles_appsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_roles_apps
     */
    select?: r_roles_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_roles_appsInclude<ExtArgs> | null
    /**
     * Filter, which r_roles_apps to fetch.
     */
    where: r_roles_appsWhereUniqueInput
  }

  /**
   * r_roles_apps findUniqueOrThrow
   */
  export type r_roles_appsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_roles_apps
     */
    select?: r_roles_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_roles_appsInclude<ExtArgs> | null
    /**
     * Filter, which r_roles_apps to fetch.
     */
    where: r_roles_appsWhereUniqueInput
  }

  /**
   * r_roles_apps findFirst
   */
  export type r_roles_appsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_roles_apps
     */
    select?: r_roles_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_roles_appsInclude<ExtArgs> | null
    /**
     * Filter, which r_roles_apps to fetch.
     */
    where?: r_roles_appsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of r_roles_apps to fetch.
     */
    orderBy?: r_roles_appsOrderByWithRelationInput | r_roles_appsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for r_roles_apps.
     */
    cursor?: r_roles_appsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` r_roles_apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` r_roles_apps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of r_roles_apps.
     */
    distinct?: R_roles_appsScalarFieldEnum | R_roles_appsScalarFieldEnum[]
  }

  /**
   * r_roles_apps findFirstOrThrow
   */
  export type r_roles_appsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_roles_apps
     */
    select?: r_roles_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_roles_appsInclude<ExtArgs> | null
    /**
     * Filter, which r_roles_apps to fetch.
     */
    where?: r_roles_appsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of r_roles_apps to fetch.
     */
    orderBy?: r_roles_appsOrderByWithRelationInput | r_roles_appsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for r_roles_apps.
     */
    cursor?: r_roles_appsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` r_roles_apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` r_roles_apps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of r_roles_apps.
     */
    distinct?: R_roles_appsScalarFieldEnum | R_roles_appsScalarFieldEnum[]
  }

  /**
   * r_roles_apps findMany
   */
  export type r_roles_appsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_roles_apps
     */
    select?: r_roles_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_roles_appsInclude<ExtArgs> | null
    /**
     * Filter, which r_roles_apps to fetch.
     */
    where?: r_roles_appsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of r_roles_apps to fetch.
     */
    orderBy?: r_roles_appsOrderByWithRelationInput | r_roles_appsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing r_roles_apps.
     */
    cursor?: r_roles_appsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` r_roles_apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` r_roles_apps.
     */
    skip?: number
    distinct?: R_roles_appsScalarFieldEnum | R_roles_appsScalarFieldEnum[]
  }

  /**
   * r_roles_apps create
   */
  export type r_roles_appsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_roles_apps
     */
    select?: r_roles_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_roles_appsInclude<ExtArgs> | null
    /**
     * The data needed to create a r_roles_apps.
     */
    data: XOR<r_roles_appsCreateInput, r_roles_appsUncheckedCreateInput>
  }

  /**
   * r_roles_apps createMany
   */
  export type r_roles_appsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many r_roles_apps.
     */
    data: r_roles_appsCreateManyInput | r_roles_appsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * r_roles_apps update
   */
  export type r_roles_appsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_roles_apps
     */
    select?: r_roles_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_roles_appsInclude<ExtArgs> | null
    /**
     * The data needed to update a r_roles_apps.
     */
    data: XOR<r_roles_appsUpdateInput, r_roles_appsUncheckedUpdateInput>
    /**
     * Choose, which r_roles_apps to update.
     */
    where: r_roles_appsWhereUniqueInput
  }

  /**
   * r_roles_apps updateMany
   */
  export type r_roles_appsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update r_roles_apps.
     */
    data: XOR<r_roles_appsUpdateManyMutationInput, r_roles_appsUncheckedUpdateManyInput>
    /**
     * Filter which r_roles_apps to update
     */
    where?: r_roles_appsWhereInput
  }

  /**
   * r_roles_apps upsert
   */
  export type r_roles_appsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_roles_apps
     */
    select?: r_roles_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_roles_appsInclude<ExtArgs> | null
    /**
     * The filter to search for the r_roles_apps to update in case it exists.
     */
    where: r_roles_appsWhereUniqueInput
    /**
     * In case the r_roles_apps found by the `where` argument doesn't exist, create a new r_roles_apps with this data.
     */
    create: XOR<r_roles_appsCreateInput, r_roles_appsUncheckedCreateInput>
    /**
     * In case the r_roles_apps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<r_roles_appsUpdateInput, r_roles_appsUncheckedUpdateInput>
  }

  /**
   * r_roles_apps delete
   */
  export type r_roles_appsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_roles_apps
     */
    select?: r_roles_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_roles_appsInclude<ExtArgs> | null
    /**
     * Filter which r_roles_apps to delete.
     */
    where: r_roles_appsWhereUniqueInput
  }

  /**
   * r_roles_apps deleteMany
   */
  export type r_roles_appsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which r_roles_apps to delete
     */
    where?: r_roles_appsWhereInput
  }

  /**
   * r_roles_apps without action
   */
  export type r_roles_appsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_roles_apps
     */
    select?: r_roles_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_roles_appsInclude<ExtArgs> | null
  }


  /**
   * Model r_users_client_contractors
   */

  export type AggregateR_users_client_contractors = {
    _count: R_users_client_contractorsCountAggregateOutputType | null
    _avg: R_users_client_contractorsAvgAggregateOutputType | null
    _sum: R_users_client_contractorsSumAggregateOutputType | null
    _min: R_users_client_contractorsMinAggregateOutputType | null
    _max: R_users_client_contractorsMaxAggregateOutputType | null
  }

  export type R_users_client_contractorsAvgAggregateOutputType = {
    id: number | null
    contractors_id: number | null
    users_client_id: number | null
  }

  export type R_users_client_contractorsSumAggregateOutputType = {
    id: number | null
    contractors_id: number | null
    users_client_id: number | null
  }

  export type R_users_client_contractorsMinAggregateOutputType = {
    id: number | null
    contractors_id: number | null
    users_client_id: number | null
  }

  export type R_users_client_contractorsMaxAggregateOutputType = {
    id: number | null
    contractors_id: number | null
    users_client_id: number | null
  }

  export type R_users_client_contractorsCountAggregateOutputType = {
    id: number
    contractors_id: number
    users_client_id: number
    _all: number
  }


  export type R_users_client_contractorsAvgAggregateInputType = {
    id?: true
    contractors_id?: true
    users_client_id?: true
  }

  export type R_users_client_contractorsSumAggregateInputType = {
    id?: true
    contractors_id?: true
    users_client_id?: true
  }

  export type R_users_client_contractorsMinAggregateInputType = {
    id?: true
    contractors_id?: true
    users_client_id?: true
  }

  export type R_users_client_contractorsMaxAggregateInputType = {
    id?: true
    contractors_id?: true
    users_client_id?: true
  }

  export type R_users_client_contractorsCountAggregateInputType = {
    id?: true
    contractors_id?: true
    users_client_id?: true
    _all?: true
  }

  export type R_users_client_contractorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which r_users_client_contractors to aggregate.
     */
    where?: r_users_client_contractorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of r_users_client_contractors to fetch.
     */
    orderBy?: r_users_client_contractorsOrderByWithRelationInput | r_users_client_contractorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: r_users_client_contractorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` r_users_client_contractors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` r_users_client_contractors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned r_users_client_contractors
    **/
    _count?: true | R_users_client_contractorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: R_users_client_contractorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: R_users_client_contractorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: R_users_client_contractorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: R_users_client_contractorsMaxAggregateInputType
  }

  export type GetR_users_client_contractorsAggregateType<T extends R_users_client_contractorsAggregateArgs> = {
        [P in keyof T & keyof AggregateR_users_client_contractors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateR_users_client_contractors[P]>
      : GetScalarType<T[P], AggregateR_users_client_contractors[P]>
  }




  export type r_users_client_contractorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: r_users_client_contractorsWhereInput
    orderBy?: r_users_client_contractorsOrderByWithAggregationInput | r_users_client_contractorsOrderByWithAggregationInput[]
    by: R_users_client_contractorsScalarFieldEnum[] | R_users_client_contractorsScalarFieldEnum
    having?: r_users_client_contractorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: R_users_client_contractorsCountAggregateInputType | true
    _avg?: R_users_client_contractorsAvgAggregateInputType
    _sum?: R_users_client_contractorsSumAggregateInputType
    _min?: R_users_client_contractorsMinAggregateInputType
    _max?: R_users_client_contractorsMaxAggregateInputType
  }

  export type R_users_client_contractorsGroupByOutputType = {
    id: number
    contractors_id: number
    users_client_id: number
    _count: R_users_client_contractorsCountAggregateOutputType | null
    _avg: R_users_client_contractorsAvgAggregateOutputType | null
    _sum: R_users_client_contractorsSumAggregateOutputType | null
    _min: R_users_client_contractorsMinAggregateOutputType | null
    _max: R_users_client_contractorsMaxAggregateOutputType | null
  }

  type GetR_users_client_contractorsGroupByPayload<T extends r_users_client_contractorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<R_users_client_contractorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof R_users_client_contractorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], R_users_client_contractorsGroupByOutputType[P]>
            : GetScalarType<T[P], R_users_client_contractorsGroupByOutputType[P]>
        }
      >
    >


  export type r_users_client_contractorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractors_id?: boolean
    users_client_id?: boolean
    contractors?: boolean | contractorsDefaultArgs<ExtArgs>
    users_client?: boolean | users_clientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["r_users_client_contractors"]>


  export type r_users_client_contractorsSelectScalar = {
    id?: boolean
    contractors_id?: boolean
    users_client_id?: boolean
  }

  export type r_users_client_contractorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractors?: boolean | contractorsDefaultArgs<ExtArgs>
    users_client?: boolean | users_clientDefaultArgs<ExtArgs>
  }

  export type $r_users_client_contractorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "r_users_client_contractors"
    objects: {
      contractors: Prisma.$contractorsPayload<ExtArgs>
      users_client: Prisma.$users_clientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contractors_id: number
      users_client_id: number
    }, ExtArgs["result"]["r_users_client_contractors"]>
    composites: {}
  }

  type r_users_client_contractorsGetPayload<S extends boolean | null | undefined | r_users_client_contractorsDefaultArgs> = $Result.GetResult<Prisma.$r_users_client_contractorsPayload, S>

  type r_users_client_contractorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<r_users_client_contractorsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: R_users_client_contractorsCountAggregateInputType | true
    }

  export interface r_users_client_contractorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['r_users_client_contractors'], meta: { name: 'r_users_client_contractors' } }
    /**
     * Find zero or one R_users_client_contractors that matches the filter.
     * @param {r_users_client_contractorsFindUniqueArgs} args - Arguments to find a R_users_client_contractors
     * @example
     * // Get one R_users_client_contractors
     * const r_users_client_contractors = await prisma.r_users_client_contractors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends r_users_client_contractorsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, r_users_client_contractorsFindUniqueArgs<ExtArgs>>
    ): Prisma__r_users_client_contractorsClient<$Result.GetResult<Prisma.$r_users_client_contractorsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one R_users_client_contractors that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {r_users_client_contractorsFindUniqueOrThrowArgs} args - Arguments to find a R_users_client_contractors
     * @example
     * // Get one R_users_client_contractors
     * const r_users_client_contractors = await prisma.r_users_client_contractors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends r_users_client_contractorsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, r_users_client_contractorsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__r_users_client_contractorsClient<$Result.GetResult<Prisma.$r_users_client_contractorsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first R_users_client_contractors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_users_client_contractorsFindFirstArgs} args - Arguments to find a R_users_client_contractors
     * @example
     * // Get one R_users_client_contractors
     * const r_users_client_contractors = await prisma.r_users_client_contractors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends r_users_client_contractorsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, r_users_client_contractorsFindFirstArgs<ExtArgs>>
    ): Prisma__r_users_client_contractorsClient<$Result.GetResult<Prisma.$r_users_client_contractorsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first R_users_client_contractors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_users_client_contractorsFindFirstOrThrowArgs} args - Arguments to find a R_users_client_contractors
     * @example
     * // Get one R_users_client_contractors
     * const r_users_client_contractors = await prisma.r_users_client_contractors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends r_users_client_contractorsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, r_users_client_contractorsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__r_users_client_contractorsClient<$Result.GetResult<Prisma.$r_users_client_contractorsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more R_users_client_contractors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_users_client_contractorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all R_users_client_contractors
     * const r_users_client_contractors = await prisma.r_users_client_contractors.findMany()
     * 
     * // Get first 10 R_users_client_contractors
     * const r_users_client_contractors = await prisma.r_users_client_contractors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const r_users_client_contractorsWithIdOnly = await prisma.r_users_client_contractors.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends r_users_client_contractorsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, r_users_client_contractorsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$r_users_client_contractorsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a R_users_client_contractors.
     * @param {r_users_client_contractorsCreateArgs} args - Arguments to create a R_users_client_contractors.
     * @example
     * // Create one R_users_client_contractors
     * const R_users_client_contractors = await prisma.r_users_client_contractors.create({
     *   data: {
     *     // ... data to create a R_users_client_contractors
     *   }
     * })
     * 
    **/
    create<T extends r_users_client_contractorsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, r_users_client_contractorsCreateArgs<ExtArgs>>
    ): Prisma__r_users_client_contractorsClient<$Result.GetResult<Prisma.$r_users_client_contractorsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many R_users_client_contractors.
     * @param {r_users_client_contractorsCreateManyArgs} args - Arguments to create many R_users_client_contractors.
     * @example
     * // Create many R_users_client_contractors
     * const r_users_client_contractors = await prisma.r_users_client_contractors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends r_users_client_contractorsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, r_users_client_contractorsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a R_users_client_contractors.
     * @param {r_users_client_contractorsDeleteArgs} args - Arguments to delete one R_users_client_contractors.
     * @example
     * // Delete one R_users_client_contractors
     * const R_users_client_contractors = await prisma.r_users_client_contractors.delete({
     *   where: {
     *     // ... filter to delete one R_users_client_contractors
     *   }
     * })
     * 
    **/
    delete<T extends r_users_client_contractorsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, r_users_client_contractorsDeleteArgs<ExtArgs>>
    ): Prisma__r_users_client_contractorsClient<$Result.GetResult<Prisma.$r_users_client_contractorsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one R_users_client_contractors.
     * @param {r_users_client_contractorsUpdateArgs} args - Arguments to update one R_users_client_contractors.
     * @example
     * // Update one R_users_client_contractors
     * const r_users_client_contractors = await prisma.r_users_client_contractors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends r_users_client_contractorsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, r_users_client_contractorsUpdateArgs<ExtArgs>>
    ): Prisma__r_users_client_contractorsClient<$Result.GetResult<Prisma.$r_users_client_contractorsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more R_users_client_contractors.
     * @param {r_users_client_contractorsDeleteManyArgs} args - Arguments to filter R_users_client_contractors to delete.
     * @example
     * // Delete a few R_users_client_contractors
     * const { count } = await prisma.r_users_client_contractors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends r_users_client_contractorsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, r_users_client_contractorsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more R_users_client_contractors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_users_client_contractorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many R_users_client_contractors
     * const r_users_client_contractors = await prisma.r_users_client_contractors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends r_users_client_contractorsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, r_users_client_contractorsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one R_users_client_contractors.
     * @param {r_users_client_contractorsUpsertArgs} args - Arguments to update or create a R_users_client_contractors.
     * @example
     * // Update or create a R_users_client_contractors
     * const r_users_client_contractors = await prisma.r_users_client_contractors.upsert({
     *   create: {
     *     // ... data to create a R_users_client_contractors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the R_users_client_contractors we want to update
     *   }
     * })
    **/
    upsert<T extends r_users_client_contractorsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, r_users_client_contractorsUpsertArgs<ExtArgs>>
    ): Prisma__r_users_client_contractorsClient<$Result.GetResult<Prisma.$r_users_client_contractorsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of R_users_client_contractors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_users_client_contractorsCountArgs} args - Arguments to filter R_users_client_contractors to count.
     * @example
     * // Count the number of R_users_client_contractors
     * const count = await prisma.r_users_client_contractors.count({
     *   where: {
     *     // ... the filter for the R_users_client_contractors we want to count
     *   }
     * })
    **/
    count<T extends r_users_client_contractorsCountArgs>(
      args?: Subset<T, r_users_client_contractorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], R_users_client_contractorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a R_users_client_contractors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {R_users_client_contractorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends R_users_client_contractorsAggregateArgs>(args: Subset<T, R_users_client_contractorsAggregateArgs>): Prisma.PrismaPromise<GetR_users_client_contractorsAggregateType<T>>

    /**
     * Group by R_users_client_contractors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_users_client_contractorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends r_users_client_contractorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: r_users_client_contractorsGroupByArgs['orderBy'] }
        : { orderBy?: r_users_client_contractorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, r_users_client_contractorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetR_users_client_contractorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the r_users_client_contractors model
   */
  readonly fields: r_users_client_contractorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for r_users_client_contractors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__r_users_client_contractorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contractors<T extends contractorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, contractorsDefaultArgs<ExtArgs>>): Prisma__contractorsClient<$Result.GetResult<Prisma.$contractorsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    users_client<T extends users_clientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_clientDefaultArgs<ExtArgs>>): Prisma__users_clientClient<$Result.GetResult<Prisma.$users_clientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the r_users_client_contractors model
   */ 
  interface r_users_client_contractorsFieldRefs {
    readonly id: FieldRef<"r_users_client_contractors", 'Int'>
    readonly contractors_id: FieldRef<"r_users_client_contractors", 'Int'>
    readonly users_client_id: FieldRef<"r_users_client_contractors", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * r_users_client_contractors findUnique
   */
  export type r_users_client_contractorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_client_contractors
     */
    select?: r_users_client_contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_client_contractorsInclude<ExtArgs> | null
    /**
     * Filter, which r_users_client_contractors to fetch.
     */
    where: r_users_client_contractorsWhereUniqueInput
  }

  /**
   * r_users_client_contractors findUniqueOrThrow
   */
  export type r_users_client_contractorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_client_contractors
     */
    select?: r_users_client_contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_client_contractorsInclude<ExtArgs> | null
    /**
     * Filter, which r_users_client_contractors to fetch.
     */
    where: r_users_client_contractorsWhereUniqueInput
  }

  /**
   * r_users_client_contractors findFirst
   */
  export type r_users_client_contractorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_client_contractors
     */
    select?: r_users_client_contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_client_contractorsInclude<ExtArgs> | null
    /**
     * Filter, which r_users_client_contractors to fetch.
     */
    where?: r_users_client_contractorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of r_users_client_contractors to fetch.
     */
    orderBy?: r_users_client_contractorsOrderByWithRelationInput | r_users_client_contractorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for r_users_client_contractors.
     */
    cursor?: r_users_client_contractorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` r_users_client_contractors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` r_users_client_contractors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of r_users_client_contractors.
     */
    distinct?: R_users_client_contractorsScalarFieldEnum | R_users_client_contractorsScalarFieldEnum[]
  }

  /**
   * r_users_client_contractors findFirstOrThrow
   */
  export type r_users_client_contractorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_client_contractors
     */
    select?: r_users_client_contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_client_contractorsInclude<ExtArgs> | null
    /**
     * Filter, which r_users_client_contractors to fetch.
     */
    where?: r_users_client_contractorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of r_users_client_contractors to fetch.
     */
    orderBy?: r_users_client_contractorsOrderByWithRelationInput | r_users_client_contractorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for r_users_client_contractors.
     */
    cursor?: r_users_client_contractorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` r_users_client_contractors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` r_users_client_contractors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of r_users_client_contractors.
     */
    distinct?: R_users_client_contractorsScalarFieldEnum | R_users_client_contractorsScalarFieldEnum[]
  }

  /**
   * r_users_client_contractors findMany
   */
  export type r_users_client_contractorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_client_contractors
     */
    select?: r_users_client_contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_client_contractorsInclude<ExtArgs> | null
    /**
     * Filter, which r_users_client_contractors to fetch.
     */
    where?: r_users_client_contractorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of r_users_client_contractors to fetch.
     */
    orderBy?: r_users_client_contractorsOrderByWithRelationInput | r_users_client_contractorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing r_users_client_contractors.
     */
    cursor?: r_users_client_contractorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` r_users_client_contractors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` r_users_client_contractors.
     */
    skip?: number
    distinct?: R_users_client_contractorsScalarFieldEnum | R_users_client_contractorsScalarFieldEnum[]
  }

  /**
   * r_users_client_contractors create
   */
  export type r_users_client_contractorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_client_contractors
     */
    select?: r_users_client_contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_client_contractorsInclude<ExtArgs> | null
    /**
     * The data needed to create a r_users_client_contractors.
     */
    data: XOR<r_users_client_contractorsCreateInput, r_users_client_contractorsUncheckedCreateInput>
  }

  /**
   * r_users_client_contractors createMany
   */
  export type r_users_client_contractorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many r_users_client_contractors.
     */
    data: r_users_client_contractorsCreateManyInput | r_users_client_contractorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * r_users_client_contractors update
   */
  export type r_users_client_contractorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_client_contractors
     */
    select?: r_users_client_contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_client_contractorsInclude<ExtArgs> | null
    /**
     * The data needed to update a r_users_client_contractors.
     */
    data: XOR<r_users_client_contractorsUpdateInput, r_users_client_contractorsUncheckedUpdateInput>
    /**
     * Choose, which r_users_client_contractors to update.
     */
    where: r_users_client_contractorsWhereUniqueInput
  }

  /**
   * r_users_client_contractors updateMany
   */
  export type r_users_client_contractorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update r_users_client_contractors.
     */
    data: XOR<r_users_client_contractorsUpdateManyMutationInput, r_users_client_contractorsUncheckedUpdateManyInput>
    /**
     * Filter which r_users_client_contractors to update
     */
    where?: r_users_client_contractorsWhereInput
  }

  /**
   * r_users_client_contractors upsert
   */
  export type r_users_client_contractorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_client_contractors
     */
    select?: r_users_client_contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_client_contractorsInclude<ExtArgs> | null
    /**
     * The filter to search for the r_users_client_contractors to update in case it exists.
     */
    where: r_users_client_contractorsWhereUniqueInput
    /**
     * In case the r_users_client_contractors found by the `where` argument doesn't exist, create a new r_users_client_contractors with this data.
     */
    create: XOR<r_users_client_contractorsCreateInput, r_users_client_contractorsUncheckedCreateInput>
    /**
     * In case the r_users_client_contractors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<r_users_client_contractorsUpdateInput, r_users_client_contractorsUncheckedUpdateInput>
  }

  /**
   * r_users_client_contractors delete
   */
  export type r_users_client_contractorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_client_contractors
     */
    select?: r_users_client_contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_client_contractorsInclude<ExtArgs> | null
    /**
     * Filter which r_users_client_contractors to delete.
     */
    where: r_users_client_contractorsWhereUniqueInput
  }

  /**
   * r_users_client_contractors deleteMany
   */
  export type r_users_client_contractorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which r_users_client_contractors to delete
     */
    where?: r_users_client_contractorsWhereInput
  }

  /**
   * r_users_client_contractors without action
   */
  export type r_users_client_contractorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_client_contractors
     */
    select?: r_users_client_contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_client_contractorsInclude<ExtArgs> | null
  }


  /**
   * Model r_users_roles
   */

  export type AggregateR_users_roles = {
    _count: R_users_rolesCountAggregateOutputType | null
    _avg: R_users_rolesAvgAggregateOutputType | null
    _sum: R_users_rolesSumAggregateOutputType | null
    _min: R_users_rolesMinAggregateOutputType | null
    _max: R_users_rolesMaxAggregateOutputType | null
  }

  export type R_users_rolesAvgAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type R_users_rolesSumAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type R_users_rolesMinAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type R_users_rolesMaxAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type R_users_rolesCountAggregateOutputType = {
    user_id: number
    role_id: number
    _all: number
  }


  export type R_users_rolesAvgAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type R_users_rolesSumAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type R_users_rolesMinAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type R_users_rolesMaxAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type R_users_rolesCountAggregateInputType = {
    user_id?: true
    role_id?: true
    _all?: true
  }

  export type R_users_rolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which r_users_roles to aggregate.
     */
    where?: r_users_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of r_users_roles to fetch.
     */
    orderBy?: r_users_rolesOrderByWithRelationInput | r_users_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: r_users_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` r_users_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` r_users_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned r_users_roles
    **/
    _count?: true | R_users_rolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: R_users_rolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: R_users_rolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: R_users_rolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: R_users_rolesMaxAggregateInputType
  }

  export type GetR_users_rolesAggregateType<T extends R_users_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateR_users_roles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateR_users_roles[P]>
      : GetScalarType<T[P], AggregateR_users_roles[P]>
  }




  export type r_users_rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: r_users_rolesWhereInput
    orderBy?: r_users_rolesOrderByWithAggregationInput | r_users_rolesOrderByWithAggregationInput[]
    by: R_users_rolesScalarFieldEnum[] | R_users_rolesScalarFieldEnum
    having?: r_users_rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: R_users_rolesCountAggregateInputType | true
    _avg?: R_users_rolesAvgAggregateInputType
    _sum?: R_users_rolesSumAggregateInputType
    _min?: R_users_rolesMinAggregateInputType
    _max?: R_users_rolesMaxAggregateInputType
  }

  export type R_users_rolesGroupByOutputType = {
    user_id: number
    role_id: number
    _count: R_users_rolesCountAggregateOutputType | null
    _avg: R_users_rolesAvgAggregateOutputType | null
    _sum: R_users_rolesSumAggregateOutputType | null
    _min: R_users_rolesMinAggregateOutputType | null
    _max: R_users_rolesMaxAggregateOutputType | null
  }

  type GetR_users_rolesGroupByPayload<T extends r_users_rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<R_users_rolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof R_users_rolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], R_users_rolesGroupByOutputType[P]>
            : GetScalarType<T[P], R_users_rolesGroupByOutputType[P]>
        }
      >
    >


  export type r_users_rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    role_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["r_users_roles"]>


  export type r_users_rolesSelectScalar = {
    user_id?: boolean
    role_id?: boolean
  }

  export type r_users_rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }

  export type $r_users_rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "r_users_roles"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      roles: Prisma.$rolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      role_id: number
    }, ExtArgs["result"]["r_users_roles"]>
    composites: {}
  }

  type r_users_rolesGetPayload<S extends boolean | null | undefined | r_users_rolesDefaultArgs> = $Result.GetResult<Prisma.$r_users_rolesPayload, S>

  type r_users_rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<r_users_rolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: R_users_rolesCountAggregateInputType | true
    }

  export interface r_users_rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['r_users_roles'], meta: { name: 'r_users_roles' } }
    /**
     * Find zero or one R_users_roles that matches the filter.
     * @param {r_users_rolesFindUniqueArgs} args - Arguments to find a R_users_roles
     * @example
     * // Get one R_users_roles
     * const r_users_roles = await prisma.r_users_roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends r_users_rolesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, r_users_rolesFindUniqueArgs<ExtArgs>>
    ): Prisma__r_users_rolesClient<$Result.GetResult<Prisma.$r_users_rolesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one R_users_roles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {r_users_rolesFindUniqueOrThrowArgs} args - Arguments to find a R_users_roles
     * @example
     * // Get one R_users_roles
     * const r_users_roles = await prisma.r_users_roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends r_users_rolesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, r_users_rolesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__r_users_rolesClient<$Result.GetResult<Prisma.$r_users_rolesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first R_users_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_users_rolesFindFirstArgs} args - Arguments to find a R_users_roles
     * @example
     * // Get one R_users_roles
     * const r_users_roles = await prisma.r_users_roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends r_users_rolesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, r_users_rolesFindFirstArgs<ExtArgs>>
    ): Prisma__r_users_rolesClient<$Result.GetResult<Prisma.$r_users_rolesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first R_users_roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_users_rolesFindFirstOrThrowArgs} args - Arguments to find a R_users_roles
     * @example
     * // Get one R_users_roles
     * const r_users_roles = await prisma.r_users_roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends r_users_rolesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, r_users_rolesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__r_users_rolesClient<$Result.GetResult<Prisma.$r_users_rolesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more R_users_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_users_rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all R_users_roles
     * const r_users_roles = await prisma.r_users_roles.findMany()
     * 
     * // Get first 10 R_users_roles
     * const r_users_roles = await prisma.r_users_roles.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const r_users_rolesWithUser_idOnly = await prisma.r_users_roles.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends r_users_rolesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, r_users_rolesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$r_users_rolesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a R_users_roles.
     * @param {r_users_rolesCreateArgs} args - Arguments to create a R_users_roles.
     * @example
     * // Create one R_users_roles
     * const R_users_roles = await prisma.r_users_roles.create({
     *   data: {
     *     // ... data to create a R_users_roles
     *   }
     * })
     * 
    **/
    create<T extends r_users_rolesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, r_users_rolesCreateArgs<ExtArgs>>
    ): Prisma__r_users_rolesClient<$Result.GetResult<Prisma.$r_users_rolesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many R_users_roles.
     * @param {r_users_rolesCreateManyArgs} args - Arguments to create many R_users_roles.
     * @example
     * // Create many R_users_roles
     * const r_users_roles = await prisma.r_users_roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends r_users_rolesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, r_users_rolesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a R_users_roles.
     * @param {r_users_rolesDeleteArgs} args - Arguments to delete one R_users_roles.
     * @example
     * // Delete one R_users_roles
     * const R_users_roles = await prisma.r_users_roles.delete({
     *   where: {
     *     // ... filter to delete one R_users_roles
     *   }
     * })
     * 
    **/
    delete<T extends r_users_rolesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, r_users_rolesDeleteArgs<ExtArgs>>
    ): Prisma__r_users_rolesClient<$Result.GetResult<Prisma.$r_users_rolesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one R_users_roles.
     * @param {r_users_rolesUpdateArgs} args - Arguments to update one R_users_roles.
     * @example
     * // Update one R_users_roles
     * const r_users_roles = await prisma.r_users_roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends r_users_rolesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, r_users_rolesUpdateArgs<ExtArgs>>
    ): Prisma__r_users_rolesClient<$Result.GetResult<Prisma.$r_users_rolesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more R_users_roles.
     * @param {r_users_rolesDeleteManyArgs} args - Arguments to filter R_users_roles to delete.
     * @example
     * // Delete a few R_users_roles
     * const { count } = await prisma.r_users_roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends r_users_rolesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, r_users_rolesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more R_users_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_users_rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many R_users_roles
     * const r_users_roles = await prisma.r_users_roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends r_users_rolesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, r_users_rolesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one R_users_roles.
     * @param {r_users_rolesUpsertArgs} args - Arguments to update or create a R_users_roles.
     * @example
     * // Update or create a R_users_roles
     * const r_users_roles = await prisma.r_users_roles.upsert({
     *   create: {
     *     // ... data to create a R_users_roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the R_users_roles we want to update
     *   }
     * })
    **/
    upsert<T extends r_users_rolesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, r_users_rolesUpsertArgs<ExtArgs>>
    ): Prisma__r_users_rolesClient<$Result.GetResult<Prisma.$r_users_rolesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of R_users_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_users_rolesCountArgs} args - Arguments to filter R_users_roles to count.
     * @example
     * // Count the number of R_users_roles
     * const count = await prisma.r_users_roles.count({
     *   where: {
     *     // ... the filter for the R_users_roles we want to count
     *   }
     * })
    **/
    count<T extends r_users_rolesCountArgs>(
      args?: Subset<T, r_users_rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], R_users_rolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a R_users_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {R_users_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends R_users_rolesAggregateArgs>(args: Subset<T, R_users_rolesAggregateArgs>): Prisma.PrismaPromise<GetR_users_rolesAggregateType<T>>

    /**
     * Group by R_users_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_users_rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends r_users_rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: r_users_rolesGroupByArgs['orderBy'] }
        : { orderBy?: r_users_rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, r_users_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetR_users_rolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the r_users_roles model
   */
  readonly fields: r_users_rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for r_users_roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__r_users_rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the r_users_roles model
   */ 
  interface r_users_rolesFieldRefs {
    readonly user_id: FieldRef<"r_users_roles", 'Int'>
    readonly role_id: FieldRef<"r_users_roles", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * r_users_roles findUnique
   */
  export type r_users_rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_roles
     */
    select?: r_users_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_rolesInclude<ExtArgs> | null
    /**
     * Filter, which r_users_roles to fetch.
     */
    where: r_users_rolesWhereUniqueInput
  }

  /**
   * r_users_roles findUniqueOrThrow
   */
  export type r_users_rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_roles
     */
    select?: r_users_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_rolesInclude<ExtArgs> | null
    /**
     * Filter, which r_users_roles to fetch.
     */
    where: r_users_rolesWhereUniqueInput
  }

  /**
   * r_users_roles findFirst
   */
  export type r_users_rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_roles
     */
    select?: r_users_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_rolesInclude<ExtArgs> | null
    /**
     * Filter, which r_users_roles to fetch.
     */
    where?: r_users_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of r_users_roles to fetch.
     */
    orderBy?: r_users_rolesOrderByWithRelationInput | r_users_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for r_users_roles.
     */
    cursor?: r_users_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` r_users_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` r_users_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of r_users_roles.
     */
    distinct?: R_users_rolesScalarFieldEnum | R_users_rolesScalarFieldEnum[]
  }

  /**
   * r_users_roles findFirstOrThrow
   */
  export type r_users_rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_roles
     */
    select?: r_users_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_rolesInclude<ExtArgs> | null
    /**
     * Filter, which r_users_roles to fetch.
     */
    where?: r_users_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of r_users_roles to fetch.
     */
    orderBy?: r_users_rolesOrderByWithRelationInput | r_users_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for r_users_roles.
     */
    cursor?: r_users_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` r_users_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` r_users_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of r_users_roles.
     */
    distinct?: R_users_rolesScalarFieldEnum | R_users_rolesScalarFieldEnum[]
  }

  /**
   * r_users_roles findMany
   */
  export type r_users_rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_roles
     */
    select?: r_users_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_rolesInclude<ExtArgs> | null
    /**
     * Filter, which r_users_roles to fetch.
     */
    where?: r_users_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of r_users_roles to fetch.
     */
    orderBy?: r_users_rolesOrderByWithRelationInput | r_users_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing r_users_roles.
     */
    cursor?: r_users_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` r_users_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` r_users_roles.
     */
    skip?: number
    distinct?: R_users_rolesScalarFieldEnum | R_users_rolesScalarFieldEnum[]
  }

  /**
   * r_users_roles create
   */
  export type r_users_rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_roles
     */
    select?: r_users_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a r_users_roles.
     */
    data: XOR<r_users_rolesCreateInput, r_users_rolesUncheckedCreateInput>
  }

  /**
   * r_users_roles createMany
   */
  export type r_users_rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many r_users_roles.
     */
    data: r_users_rolesCreateManyInput | r_users_rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * r_users_roles update
   */
  export type r_users_rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_roles
     */
    select?: r_users_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a r_users_roles.
     */
    data: XOR<r_users_rolesUpdateInput, r_users_rolesUncheckedUpdateInput>
    /**
     * Choose, which r_users_roles to update.
     */
    where: r_users_rolesWhereUniqueInput
  }

  /**
   * r_users_roles updateMany
   */
  export type r_users_rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update r_users_roles.
     */
    data: XOR<r_users_rolesUpdateManyMutationInput, r_users_rolesUncheckedUpdateManyInput>
    /**
     * Filter which r_users_roles to update
     */
    where?: r_users_rolesWhereInput
  }

  /**
   * r_users_roles upsert
   */
  export type r_users_rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_roles
     */
    select?: r_users_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the r_users_roles to update in case it exists.
     */
    where: r_users_rolesWhereUniqueInput
    /**
     * In case the r_users_roles found by the `where` argument doesn't exist, create a new r_users_roles with this data.
     */
    create: XOR<r_users_rolesCreateInput, r_users_rolesUncheckedCreateInput>
    /**
     * In case the r_users_roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<r_users_rolesUpdateInput, r_users_rolesUncheckedUpdateInput>
  }

  /**
   * r_users_roles delete
   */
  export type r_users_rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_roles
     */
    select?: r_users_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_rolesInclude<ExtArgs> | null
    /**
     * Filter which r_users_roles to delete.
     */
    where: r_users_rolesWhereUniqueInput
  }

  /**
   * r_users_roles deleteMany
   */
  export type r_users_rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which r_users_roles to delete
     */
    where?: r_users_rolesWhereInput
  }

  /**
   * r_users_roles without action
   */
  export type r_users_rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_roles
     */
    select?: r_users_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_rolesInclude<ExtArgs> | null
  }


  /**
   * Model roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithAggregationInput | rolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: number
    name: string
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    r_roles_apps?: boolean | roles$r_roles_appsArgs<ExtArgs>
    r_users_roles?: boolean | roles$r_users_rolesArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>


  export type rolesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    r_roles_apps?: boolean | roles$r_roles_appsArgs<ExtArgs>
    r_users_roles?: boolean | roles$r_users_rolesArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles"
    objects: {
      r_roles_apps: Prisma.$r_roles_appsPayload<ExtArgs>[]
      r_users_roles: Prisma.$r_users_rolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type rolesGetPayload<S extends boolean | null | undefined | rolesDefaultArgs> = $Result.GetResult<Prisma.$rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rolesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>
    ): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rolesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>
    ): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends rolesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
    **/
    create<T extends rolesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, rolesCreateArgs<ExtArgs>>
    ): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends rolesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
    **/
    delete<T extends rolesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>
    ): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rolesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>
    ): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rolesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rolesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
    **/
    upsert<T extends rolesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>
    ): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesGroupByArgs['orderBy'] }
        : { orderBy?: rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles model
   */
  readonly fields: rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    r_roles_apps<T extends roles$r_roles_appsArgs<ExtArgs> = {}>(args?: Subset<T, roles$r_roles_appsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$r_roles_appsPayload<ExtArgs>, T, 'findMany'> | Null>;

    r_users_roles<T extends roles$r_users_rolesArgs<ExtArgs> = {}>(args?: Subset<T, roles$r_users_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$r_users_rolesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the roles model
   */ 
  interface rolesFieldRefs {
    readonly id: FieldRef<"roles", 'Int'>
    readonly name: FieldRef<"roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * roles findUnique
   */
  export type rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findFirst
   */
  export type rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }

  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
  }

  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }

  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
  }

  /**
   * roles.r_roles_apps
   */
  export type roles$r_roles_appsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_roles_apps
     */
    select?: r_roles_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_roles_appsInclude<ExtArgs> | null
    where?: r_roles_appsWhereInput
    orderBy?: r_roles_appsOrderByWithRelationInput | r_roles_appsOrderByWithRelationInput[]
    cursor?: r_roles_appsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: R_roles_appsScalarFieldEnum | R_roles_appsScalarFieldEnum[]
  }

  /**
   * roles.r_users_roles
   */
  export type roles$r_users_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_roles
     */
    select?: r_users_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_rolesInclude<ExtArgs> | null
    where?: r_users_rolesWhereInput
    orderBy?: r_users_rolesOrderByWithRelationInput | r_users_rolesOrderByWithRelationInput[]
    cursor?: r_users_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: R_users_rolesScalarFieldEnum | R_users_rolesScalarFieldEnum[]
  }

  /**
   * roles without action
   */
  export type rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
  }


  /**
   * Model roles_client
   */

  export type AggregateRoles_client = {
    _count: Roles_clientCountAggregateOutputType | null
    _avg: Roles_clientAvgAggregateOutputType | null
    _sum: Roles_clientSumAggregateOutputType | null
    _min: Roles_clientMinAggregateOutputType | null
    _max: Roles_clientMaxAggregateOutputType | null
  }

  export type Roles_clientAvgAggregateOutputType = {
    id: number | null
  }

  export type Roles_clientSumAggregateOutputType = {
    id: number | null
  }

  export type Roles_clientMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Roles_clientMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Roles_clientCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Roles_clientAvgAggregateInputType = {
    id?: true
  }

  export type Roles_clientSumAggregateInputType = {
    id?: true
  }

  export type Roles_clientMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Roles_clientMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Roles_clientCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Roles_clientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles_client to aggregate.
     */
    where?: roles_clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles_clients to fetch.
     */
    orderBy?: roles_clientOrderByWithRelationInput | roles_clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roles_clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles_clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles_clients
    **/
    _count?: true | Roles_clientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Roles_clientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Roles_clientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Roles_clientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Roles_clientMaxAggregateInputType
  }

  export type GetRoles_clientAggregateType<T extends Roles_clientAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles_client]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles_client[P]>
      : GetScalarType<T[P], AggregateRoles_client[P]>
  }




  export type roles_clientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roles_clientWhereInput
    orderBy?: roles_clientOrderByWithAggregationInput | roles_clientOrderByWithAggregationInput[]
    by: Roles_clientScalarFieldEnum[] | Roles_clientScalarFieldEnum
    having?: roles_clientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Roles_clientCountAggregateInputType | true
    _avg?: Roles_clientAvgAggregateInputType
    _sum?: Roles_clientSumAggregateInputType
    _min?: Roles_clientMinAggregateInputType
    _max?: Roles_clientMaxAggregateInputType
  }

  export type Roles_clientGroupByOutputType = {
    id: number
    name: string
    _count: Roles_clientCountAggregateOutputType | null
    _avg: Roles_clientAvgAggregateOutputType | null
    _sum: Roles_clientSumAggregateOutputType | null
    _min: Roles_clientMinAggregateOutputType | null
    _max: Roles_clientMaxAggregateOutputType | null
  }

  type GetRoles_clientGroupByPayload<T extends roles_clientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Roles_clientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Roles_clientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Roles_clientGroupByOutputType[P]>
            : GetScalarType<T[P], Roles_clientGroupByOutputType[P]>
        }
      >
    >


  export type roles_clientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    users_client?: boolean | roles_client$users_clientArgs<ExtArgs>
    _count?: boolean | Roles_clientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles_client"]>


  export type roles_clientSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type roles_clientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_client?: boolean | roles_client$users_clientArgs<ExtArgs>
    _count?: boolean | Roles_clientCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $roles_clientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles_client"
    objects: {
      users_client: Prisma.$users_clientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["roles_client"]>
    composites: {}
  }

  type roles_clientGetPayload<S extends boolean | null | undefined | roles_clientDefaultArgs> = $Result.GetResult<Prisma.$roles_clientPayload, S>

  type roles_clientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<roles_clientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Roles_clientCountAggregateInputType | true
    }

  export interface roles_clientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles_client'], meta: { name: 'roles_client' } }
    /**
     * Find zero or one Roles_client that matches the filter.
     * @param {roles_clientFindUniqueArgs} args - Arguments to find a Roles_client
     * @example
     * // Get one Roles_client
     * const roles_client = await prisma.roles_client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends roles_clientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, roles_clientFindUniqueArgs<ExtArgs>>
    ): Prisma__roles_clientClient<$Result.GetResult<Prisma.$roles_clientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Roles_client that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {roles_clientFindUniqueOrThrowArgs} args - Arguments to find a Roles_client
     * @example
     * // Get one Roles_client
     * const roles_client = await prisma.roles_client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends roles_clientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, roles_clientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__roles_clientClient<$Result.GetResult<Prisma.$roles_clientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Roles_client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roles_clientFindFirstArgs} args - Arguments to find a Roles_client
     * @example
     * // Get one Roles_client
     * const roles_client = await prisma.roles_client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends roles_clientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, roles_clientFindFirstArgs<ExtArgs>>
    ): Prisma__roles_clientClient<$Result.GetResult<Prisma.$roles_clientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Roles_client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roles_clientFindFirstOrThrowArgs} args - Arguments to find a Roles_client
     * @example
     * // Get one Roles_client
     * const roles_client = await prisma.roles_client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends roles_clientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, roles_clientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__roles_clientClient<$Result.GetResult<Prisma.$roles_clientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Roles_clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roles_clientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles_clients
     * const roles_clients = await prisma.roles_client.findMany()
     * 
     * // Get first 10 Roles_clients
     * const roles_clients = await prisma.roles_client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roles_clientWithIdOnly = await prisma.roles_client.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends roles_clientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, roles_clientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$roles_clientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Roles_client.
     * @param {roles_clientCreateArgs} args - Arguments to create a Roles_client.
     * @example
     * // Create one Roles_client
     * const Roles_client = await prisma.roles_client.create({
     *   data: {
     *     // ... data to create a Roles_client
     *   }
     * })
     * 
    **/
    create<T extends roles_clientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, roles_clientCreateArgs<ExtArgs>>
    ): Prisma__roles_clientClient<$Result.GetResult<Prisma.$roles_clientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Roles_clients.
     * @param {roles_clientCreateManyArgs} args - Arguments to create many Roles_clients.
     * @example
     * // Create many Roles_clients
     * const roles_client = await prisma.roles_client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends roles_clientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, roles_clientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles_client.
     * @param {roles_clientDeleteArgs} args - Arguments to delete one Roles_client.
     * @example
     * // Delete one Roles_client
     * const Roles_client = await prisma.roles_client.delete({
     *   where: {
     *     // ... filter to delete one Roles_client
     *   }
     * })
     * 
    **/
    delete<T extends roles_clientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, roles_clientDeleteArgs<ExtArgs>>
    ): Prisma__roles_clientClient<$Result.GetResult<Prisma.$roles_clientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Roles_client.
     * @param {roles_clientUpdateArgs} args - Arguments to update one Roles_client.
     * @example
     * // Update one Roles_client
     * const roles_client = await prisma.roles_client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends roles_clientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, roles_clientUpdateArgs<ExtArgs>>
    ): Prisma__roles_clientClient<$Result.GetResult<Prisma.$roles_clientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Roles_clients.
     * @param {roles_clientDeleteManyArgs} args - Arguments to filter Roles_clients to delete.
     * @example
     * // Delete a few Roles_clients
     * const { count } = await prisma.roles_client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends roles_clientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, roles_clientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles_clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roles_clientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles_clients
     * const roles_client = await prisma.roles_client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends roles_clientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, roles_clientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles_client.
     * @param {roles_clientUpsertArgs} args - Arguments to update or create a Roles_client.
     * @example
     * // Update or create a Roles_client
     * const roles_client = await prisma.roles_client.upsert({
     *   create: {
     *     // ... data to create a Roles_client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles_client we want to update
     *   }
     * })
    **/
    upsert<T extends roles_clientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, roles_clientUpsertArgs<ExtArgs>>
    ): Prisma__roles_clientClient<$Result.GetResult<Prisma.$roles_clientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Roles_clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roles_clientCountArgs} args - Arguments to filter Roles_clients to count.
     * @example
     * // Count the number of Roles_clients
     * const count = await prisma.roles_client.count({
     *   where: {
     *     // ... the filter for the Roles_clients we want to count
     *   }
     * })
    **/
    count<T extends roles_clientCountArgs>(
      args?: Subset<T, roles_clientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Roles_clientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles_client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_clientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Roles_clientAggregateArgs>(args: Subset<T, Roles_clientAggregateArgs>): Prisma.PrismaPromise<GetRoles_clientAggregateType<T>>

    /**
     * Group by Roles_client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roles_clientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roles_clientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roles_clientGroupByArgs['orderBy'] }
        : { orderBy?: roles_clientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roles_clientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoles_clientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles_client model
   */
  readonly fields: roles_clientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles_client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roles_clientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users_client<T extends roles_client$users_clientArgs<ExtArgs> = {}>(args?: Subset<T, roles_client$users_clientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$users_clientPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the roles_client model
   */ 
  interface roles_clientFieldRefs {
    readonly id: FieldRef<"roles_client", 'Int'>
    readonly name: FieldRef<"roles_client", 'String'>
  }
    

  // Custom InputTypes
  /**
   * roles_client findUnique
   */
  export type roles_clientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles_client
     */
    select?: roles_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roles_clientInclude<ExtArgs> | null
    /**
     * Filter, which roles_client to fetch.
     */
    where: roles_clientWhereUniqueInput
  }

  /**
   * roles_client findUniqueOrThrow
   */
  export type roles_clientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles_client
     */
    select?: roles_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roles_clientInclude<ExtArgs> | null
    /**
     * Filter, which roles_client to fetch.
     */
    where: roles_clientWhereUniqueInput
  }

  /**
   * roles_client findFirst
   */
  export type roles_clientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles_client
     */
    select?: roles_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roles_clientInclude<ExtArgs> | null
    /**
     * Filter, which roles_client to fetch.
     */
    where?: roles_clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles_clients to fetch.
     */
    orderBy?: roles_clientOrderByWithRelationInput | roles_clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles_clients.
     */
    cursor?: roles_clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles_clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles_clients.
     */
    distinct?: Roles_clientScalarFieldEnum | Roles_clientScalarFieldEnum[]
  }

  /**
   * roles_client findFirstOrThrow
   */
  export type roles_clientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles_client
     */
    select?: roles_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roles_clientInclude<ExtArgs> | null
    /**
     * Filter, which roles_client to fetch.
     */
    where?: roles_clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles_clients to fetch.
     */
    orderBy?: roles_clientOrderByWithRelationInput | roles_clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles_clients.
     */
    cursor?: roles_clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles_clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles_clients.
     */
    distinct?: Roles_clientScalarFieldEnum | Roles_clientScalarFieldEnum[]
  }

  /**
   * roles_client findMany
   */
  export type roles_clientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles_client
     */
    select?: roles_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roles_clientInclude<ExtArgs> | null
    /**
     * Filter, which roles_clients to fetch.
     */
    where?: roles_clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles_clients to fetch.
     */
    orderBy?: roles_clientOrderByWithRelationInput | roles_clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles_clients.
     */
    cursor?: roles_clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles_clients.
     */
    skip?: number
    distinct?: Roles_clientScalarFieldEnum | Roles_clientScalarFieldEnum[]
  }

  /**
   * roles_client create
   */
  export type roles_clientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles_client
     */
    select?: roles_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roles_clientInclude<ExtArgs> | null
    /**
     * The data needed to create a roles_client.
     */
    data: XOR<roles_clientCreateInput, roles_clientUncheckedCreateInput>
  }

  /**
   * roles_client createMany
   */
  export type roles_clientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles_clients.
     */
    data: roles_clientCreateManyInput | roles_clientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles_client update
   */
  export type roles_clientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles_client
     */
    select?: roles_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roles_clientInclude<ExtArgs> | null
    /**
     * The data needed to update a roles_client.
     */
    data: XOR<roles_clientUpdateInput, roles_clientUncheckedUpdateInput>
    /**
     * Choose, which roles_client to update.
     */
    where: roles_clientWhereUniqueInput
  }

  /**
   * roles_client updateMany
   */
  export type roles_clientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles_clients.
     */
    data: XOR<roles_clientUpdateManyMutationInput, roles_clientUncheckedUpdateManyInput>
    /**
     * Filter which roles_clients to update
     */
    where?: roles_clientWhereInput
  }

  /**
   * roles_client upsert
   */
  export type roles_clientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles_client
     */
    select?: roles_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roles_clientInclude<ExtArgs> | null
    /**
     * The filter to search for the roles_client to update in case it exists.
     */
    where: roles_clientWhereUniqueInput
    /**
     * In case the roles_client found by the `where` argument doesn't exist, create a new roles_client with this data.
     */
    create: XOR<roles_clientCreateInput, roles_clientUncheckedCreateInput>
    /**
     * In case the roles_client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roles_clientUpdateInput, roles_clientUncheckedUpdateInput>
  }

  /**
   * roles_client delete
   */
  export type roles_clientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles_client
     */
    select?: roles_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roles_clientInclude<ExtArgs> | null
    /**
     * Filter which roles_client to delete.
     */
    where: roles_clientWhereUniqueInput
  }

  /**
   * roles_client deleteMany
   */
  export type roles_clientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles_clients to delete
     */
    where?: roles_clientWhereInput
  }

  /**
   * roles_client.users_client
   */
  export type roles_client$users_clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_client
     */
    select?: users_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_clientInclude<ExtArgs> | null
    where?: users_clientWhereInput
    orderBy?: users_clientOrderByWithRelationInput | users_clientOrderByWithRelationInput[]
    cursor?: users_clientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Users_clientScalarFieldEnum | Users_clientScalarFieldEnum[]
  }

  /**
   * roles_client without action
   */
  export type roles_clientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles_client
     */
    select?: roles_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roles_clientInclude<ExtArgs> | null
  }


  /**
   * Model sections
   */

  export type AggregateSections = {
    _count: SectionsCountAggregateOutputType | null
    _avg: SectionsAvgAggregateOutputType | null
    _sum: SectionsSumAggregateOutputType | null
    _min: SectionsMinAggregateOutputType | null
    _max: SectionsMaxAggregateOutputType | null
  }

  export type SectionsAvgAggregateOutputType = {
    id: number | null
    object_id: number | null
  }

  export type SectionsSumAggregateOutputType = {
    id: number | null
    object_id: number | null
  }

  export type SectionsMinAggregateOutputType = {
    id: number | null
    name: string | null
    object_id: number | null
    created_at: Date | null
    updated_ad: Date | null
  }

  export type SectionsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    object_id: number | null
    created_at: Date | null
    updated_ad: Date | null
  }

  export type SectionsCountAggregateOutputType = {
    id: number
    name: number
    object_id: number
    created_at: number
    updated_ad: number
    _all: number
  }


  export type SectionsAvgAggregateInputType = {
    id?: true
    object_id?: true
  }

  export type SectionsSumAggregateInputType = {
    id?: true
    object_id?: true
  }

  export type SectionsMinAggregateInputType = {
    id?: true
    name?: true
    object_id?: true
    created_at?: true
    updated_ad?: true
  }

  export type SectionsMaxAggregateInputType = {
    id?: true
    name?: true
    object_id?: true
    created_at?: true
    updated_ad?: true
  }

  export type SectionsCountAggregateInputType = {
    id?: true
    name?: true
    object_id?: true
    created_at?: true
    updated_ad?: true
    _all?: true
  }

  export type SectionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sections to aggregate.
     */
    where?: sectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sections to fetch.
     */
    orderBy?: sectionsOrderByWithRelationInput | sectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sections
    **/
    _count?: true | SectionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionsMaxAggregateInputType
  }

  export type GetSectionsAggregateType<T extends SectionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSections]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSections[P]>
      : GetScalarType<T[P], AggregateSections[P]>
  }




  export type sectionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sectionsWhereInput
    orderBy?: sectionsOrderByWithAggregationInput | sectionsOrderByWithAggregationInput[]
    by: SectionsScalarFieldEnum[] | SectionsScalarFieldEnum
    having?: sectionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionsCountAggregateInputType | true
    _avg?: SectionsAvgAggregateInputType
    _sum?: SectionsSumAggregateInputType
    _min?: SectionsMinAggregateInputType
    _max?: SectionsMaxAggregateInputType
  }

  export type SectionsGroupByOutputType = {
    id: number
    name: string
    object_id: number
    created_at: Date | null
    updated_ad: Date | null
    _count: SectionsCountAggregateOutputType | null
    _avg: SectionsAvgAggregateOutputType | null
    _sum: SectionsSumAggregateOutputType | null
    _min: SectionsMinAggregateOutputType | null
    _max: SectionsMaxAggregateOutputType | null
  }

  type GetSectionsGroupByPayload<T extends sectionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionsGroupByOutputType[P]>
            : GetScalarType<T[P], SectionsGroupByOutputType[P]>
        }
      >
    >


  export type sectionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    object_id?: boolean
    created_at?: boolean
    updated_ad?: boolean
    objects?: boolean | objectsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sections"]>


  export type sectionsSelectScalar = {
    id?: boolean
    name?: boolean
    object_id?: boolean
    created_at?: boolean
    updated_ad?: boolean
  }

  export type sectionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    objects?: boolean | objectsDefaultArgs<ExtArgs>
  }

  export type $sectionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sections"
    objects: {
      objects: Prisma.$objectsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      object_id: number
      created_at: Date | null
      updated_ad: Date | null
    }, ExtArgs["result"]["sections"]>
    composites: {}
  }

  type sectionsGetPayload<S extends boolean | null | undefined | sectionsDefaultArgs> = $Result.GetResult<Prisma.$sectionsPayload, S>

  type sectionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<sectionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SectionsCountAggregateInputType | true
    }

  export interface sectionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sections'], meta: { name: 'sections' } }
    /**
     * Find zero or one Sections that matches the filter.
     * @param {sectionsFindUniqueArgs} args - Arguments to find a Sections
     * @example
     * // Get one Sections
     * const sections = await prisma.sections.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sectionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, sectionsFindUniqueArgs<ExtArgs>>
    ): Prisma__sectionsClient<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sections that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {sectionsFindUniqueOrThrowArgs} args - Arguments to find a Sections
     * @example
     * // Get one Sections
     * const sections = await prisma.sections.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sectionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sectionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__sectionsClient<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectionsFindFirstArgs} args - Arguments to find a Sections
     * @example
     * // Get one Sections
     * const sections = await prisma.sections.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sectionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, sectionsFindFirstArgs<ExtArgs>>
    ): Prisma__sectionsClient<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sections that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectionsFindFirstOrThrowArgs} args - Arguments to find a Sections
     * @example
     * // Get one Sections
     * const sections = await prisma.sections.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sectionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sectionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__sectionsClient<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sections
     * const sections = await prisma.sections.findMany()
     * 
     * // Get first 10 Sections
     * const sections = await prisma.sections.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectionsWithIdOnly = await prisma.sections.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends sectionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sectionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sections.
     * @param {sectionsCreateArgs} args - Arguments to create a Sections.
     * @example
     * // Create one Sections
     * const Sections = await prisma.sections.create({
     *   data: {
     *     // ... data to create a Sections
     *   }
     * })
     * 
    **/
    create<T extends sectionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, sectionsCreateArgs<ExtArgs>>
    ): Prisma__sectionsClient<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sections.
     * @param {sectionsCreateManyArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const sections = await prisma.sections.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends sectionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sectionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sections.
     * @param {sectionsDeleteArgs} args - Arguments to delete one Sections.
     * @example
     * // Delete one Sections
     * const Sections = await prisma.sections.delete({
     *   where: {
     *     // ... filter to delete one Sections
     *   }
     * })
     * 
    **/
    delete<T extends sectionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, sectionsDeleteArgs<ExtArgs>>
    ): Prisma__sectionsClient<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sections.
     * @param {sectionsUpdateArgs} args - Arguments to update one Sections.
     * @example
     * // Update one Sections
     * const sections = await prisma.sections.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sectionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, sectionsUpdateArgs<ExtArgs>>
    ): Prisma__sectionsClient<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sections.
     * @param {sectionsDeleteManyArgs} args - Arguments to filter Sections to delete.
     * @example
     * // Delete a few Sections
     * const { count } = await prisma.sections.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sectionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sectionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sections
     * const sections = await prisma.sections.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sectionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, sectionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sections.
     * @param {sectionsUpsertArgs} args - Arguments to update or create a Sections.
     * @example
     * // Update or create a Sections
     * const sections = await prisma.sections.upsert({
     *   create: {
     *     // ... data to create a Sections
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sections we want to update
     *   }
     * })
    **/
    upsert<T extends sectionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, sectionsUpsertArgs<ExtArgs>>
    ): Prisma__sectionsClient<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectionsCountArgs} args - Arguments to filter Sections to count.
     * @example
     * // Count the number of Sections
     * const count = await prisma.sections.count({
     *   where: {
     *     // ... the filter for the Sections we want to count
     *   }
     * })
    **/
    count<T extends sectionsCountArgs>(
      args?: Subset<T, sectionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionsAggregateArgs>(args: Subset<T, SectionsAggregateArgs>): Prisma.PrismaPromise<GetSectionsAggregateType<T>>

    /**
     * Group by Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sectionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sectionsGroupByArgs['orderBy'] }
        : { orderBy?: sectionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sectionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sections model
   */
  readonly fields: sectionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sections.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sectionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    objects<T extends objectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, objectsDefaultArgs<ExtArgs>>): Prisma__objectsClient<$Result.GetResult<Prisma.$objectsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the sections model
   */ 
  interface sectionsFieldRefs {
    readonly id: FieldRef<"sections", 'Int'>
    readonly name: FieldRef<"sections", 'String'>
    readonly object_id: FieldRef<"sections", 'Int'>
    readonly created_at: FieldRef<"sections", 'DateTime'>
    readonly updated_ad: FieldRef<"sections", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sections findUnique
   */
  export type sectionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    /**
     * Filter, which sections to fetch.
     */
    where: sectionsWhereUniqueInput
  }

  /**
   * sections findUniqueOrThrow
   */
  export type sectionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    /**
     * Filter, which sections to fetch.
     */
    where: sectionsWhereUniqueInput
  }

  /**
   * sections findFirst
   */
  export type sectionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    /**
     * Filter, which sections to fetch.
     */
    where?: sectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sections to fetch.
     */
    orderBy?: sectionsOrderByWithRelationInput | sectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sections.
     */
    cursor?: sectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sections.
     */
    distinct?: SectionsScalarFieldEnum | SectionsScalarFieldEnum[]
  }

  /**
   * sections findFirstOrThrow
   */
  export type sectionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    /**
     * Filter, which sections to fetch.
     */
    where?: sectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sections to fetch.
     */
    orderBy?: sectionsOrderByWithRelationInput | sectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sections.
     */
    cursor?: sectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sections.
     */
    distinct?: SectionsScalarFieldEnum | SectionsScalarFieldEnum[]
  }

  /**
   * sections findMany
   */
  export type sectionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    /**
     * Filter, which sections to fetch.
     */
    where?: sectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sections to fetch.
     */
    orderBy?: sectionsOrderByWithRelationInput | sectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sections.
     */
    cursor?: sectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sections.
     */
    skip?: number
    distinct?: SectionsScalarFieldEnum | SectionsScalarFieldEnum[]
  }

  /**
   * sections create
   */
  export type sectionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    /**
     * The data needed to create a sections.
     */
    data: XOR<sectionsCreateInput, sectionsUncheckedCreateInput>
  }

  /**
   * sections createMany
   */
  export type sectionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sections.
     */
    data: sectionsCreateManyInput | sectionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sections update
   */
  export type sectionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    /**
     * The data needed to update a sections.
     */
    data: XOR<sectionsUpdateInput, sectionsUncheckedUpdateInput>
    /**
     * Choose, which sections to update.
     */
    where: sectionsWhereUniqueInput
  }

  /**
   * sections updateMany
   */
  export type sectionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sections.
     */
    data: XOR<sectionsUpdateManyMutationInput, sectionsUncheckedUpdateManyInput>
    /**
     * Filter which sections to update
     */
    where?: sectionsWhereInput
  }

  /**
   * sections upsert
   */
  export type sectionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    /**
     * The filter to search for the sections to update in case it exists.
     */
    where: sectionsWhereUniqueInput
    /**
     * In case the sections found by the `where` argument doesn't exist, create a new sections with this data.
     */
    create: XOR<sectionsCreateInput, sectionsUncheckedCreateInput>
    /**
     * In case the sections was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sectionsUpdateInput, sectionsUncheckedUpdateInput>
  }

  /**
   * sections delete
   */
  export type sectionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    /**
     * Filter which sections to delete.
     */
    where: sectionsWhereUniqueInput
  }

  /**
   * sections deleteMany
   */
  export type sectionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sections to delete
     */
    where?: sectionsWhereInput
  }

  /**
   * sections without action
   */
  export type sectionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
  }


  /**
   * Model sub_pakets
   */

  export type AggregateSub_pakets = {
    _count: Sub_paketsCountAggregateOutputType | null
    _avg: Sub_paketsAvgAggregateOutputType | null
    _sum: Sub_paketsSumAggregateOutputType | null
    _min: Sub_paketsMinAggregateOutputType | null
    _max: Sub_paketsMaxAggregateOutputType | null
  }

  export type Sub_paketsAvgAggregateOutputType = {
    id: number | null
    order_num: number | null
    pakets_id: number | null
  }

  export type Sub_paketsSumAggregateOutputType = {
    id: number | null
    order_num: number | null
    pakets_id: number | null
  }

  export type Sub_paketsMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    order_num: number | null
    is_active: boolean | null
    pakets_id: number | null
    created_at: Date | null
    updated_at: Date | null
    propogated_at: Date | null
  }

  export type Sub_paketsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    order_num: number | null
    is_active: boolean | null
    pakets_id: number | null
    created_at: Date | null
    updated_at: Date | null
    propogated_at: Date | null
  }

  export type Sub_paketsCountAggregateOutputType = {
    id: number
    name: number
    code: number
    order_num: number
    is_active: number
    pakets_id: number
    created_at: number
    updated_at: number
    propogated_at: number
    _all: number
  }


  export type Sub_paketsAvgAggregateInputType = {
    id?: true
    order_num?: true
    pakets_id?: true
  }

  export type Sub_paketsSumAggregateInputType = {
    id?: true
    order_num?: true
    pakets_id?: true
  }

  export type Sub_paketsMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    order_num?: true
    is_active?: true
    pakets_id?: true
    created_at?: true
    updated_at?: true
    propogated_at?: true
  }

  export type Sub_paketsMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    order_num?: true
    is_active?: true
    pakets_id?: true
    created_at?: true
    updated_at?: true
    propogated_at?: true
  }

  export type Sub_paketsCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    order_num?: true
    is_active?: true
    pakets_id?: true
    created_at?: true
    updated_at?: true
    propogated_at?: true
    _all?: true
  }

  export type Sub_paketsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sub_pakets to aggregate.
     */
    where?: sub_paketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_pakets to fetch.
     */
    orderBy?: sub_paketsOrderByWithRelationInput | sub_paketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sub_paketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_pakets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_pakets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sub_pakets
    **/
    _count?: true | Sub_paketsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sub_paketsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sub_paketsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sub_paketsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sub_paketsMaxAggregateInputType
  }

  export type GetSub_paketsAggregateType<T extends Sub_paketsAggregateArgs> = {
        [P in keyof T & keyof AggregateSub_pakets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSub_pakets[P]>
      : GetScalarType<T[P], AggregateSub_pakets[P]>
  }




  export type sub_paketsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sub_paketsWhereInput
    orderBy?: sub_paketsOrderByWithAggregationInput | sub_paketsOrderByWithAggregationInput[]
    by: Sub_paketsScalarFieldEnum[] | Sub_paketsScalarFieldEnum
    having?: sub_paketsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sub_paketsCountAggregateInputType | true
    _avg?: Sub_paketsAvgAggregateInputType
    _sum?: Sub_paketsSumAggregateInputType
    _min?: Sub_paketsMinAggregateInputType
    _max?: Sub_paketsMaxAggregateInputType
  }

  export type Sub_paketsGroupByOutputType = {
    id: number
    name: string
    code: string
    order_num: number | null
    is_active: boolean
    pakets_id: number
    created_at: Date | null
    updated_at: Date | null
    propogated_at: Date | null
    _count: Sub_paketsCountAggregateOutputType | null
    _avg: Sub_paketsAvgAggregateOutputType | null
    _sum: Sub_paketsSumAggregateOutputType | null
    _min: Sub_paketsMinAggregateOutputType | null
    _max: Sub_paketsMaxAggregateOutputType | null
  }

  type GetSub_paketsGroupByPayload<T extends sub_paketsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sub_paketsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sub_paketsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sub_paketsGroupByOutputType[P]>
            : GetScalarType<T[P], Sub_paketsGroupByOutputType[P]>
        }
      >
    >


  export type sub_paketsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    order_num?: boolean
    is_active?: boolean
    pakets_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    propogated_at?: boolean
    items?: boolean | sub_pakets$itemsArgs<ExtArgs>
    pakets?: boolean | paketsDefaultArgs<ExtArgs>
    _count?: boolean | Sub_paketsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sub_pakets"]>


  export type sub_paketsSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    order_num?: boolean
    is_active?: boolean
    pakets_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    propogated_at?: boolean
  }

  export type sub_paketsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | sub_pakets$itemsArgs<ExtArgs>
    pakets?: boolean | paketsDefaultArgs<ExtArgs>
    _count?: boolean | Sub_paketsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $sub_paketsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sub_pakets"
    objects: {
      items: Prisma.$itemsPayload<ExtArgs>[]
      pakets: Prisma.$paketsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      order_num: number | null
      is_active: boolean
      pakets_id: number
      created_at: Date | null
      updated_at: Date | null
      propogated_at: Date | null
    }, ExtArgs["result"]["sub_pakets"]>
    composites: {}
  }

  type sub_paketsGetPayload<S extends boolean | null | undefined | sub_paketsDefaultArgs> = $Result.GetResult<Prisma.$sub_paketsPayload, S>

  type sub_paketsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<sub_paketsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Sub_paketsCountAggregateInputType | true
    }

  export interface sub_paketsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sub_pakets'], meta: { name: 'sub_pakets' } }
    /**
     * Find zero or one Sub_pakets that matches the filter.
     * @param {sub_paketsFindUniqueArgs} args - Arguments to find a Sub_pakets
     * @example
     * // Get one Sub_pakets
     * const sub_pakets = await prisma.sub_pakets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sub_paketsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, sub_paketsFindUniqueArgs<ExtArgs>>
    ): Prisma__sub_paketsClient<$Result.GetResult<Prisma.$sub_paketsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sub_pakets that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {sub_paketsFindUniqueOrThrowArgs} args - Arguments to find a Sub_pakets
     * @example
     * // Get one Sub_pakets
     * const sub_pakets = await prisma.sub_pakets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sub_paketsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sub_paketsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__sub_paketsClient<$Result.GetResult<Prisma.$sub_paketsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sub_pakets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_paketsFindFirstArgs} args - Arguments to find a Sub_pakets
     * @example
     * // Get one Sub_pakets
     * const sub_pakets = await prisma.sub_pakets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sub_paketsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, sub_paketsFindFirstArgs<ExtArgs>>
    ): Prisma__sub_paketsClient<$Result.GetResult<Prisma.$sub_paketsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sub_pakets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_paketsFindFirstOrThrowArgs} args - Arguments to find a Sub_pakets
     * @example
     * // Get one Sub_pakets
     * const sub_pakets = await prisma.sub_pakets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sub_paketsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sub_paketsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__sub_paketsClient<$Result.GetResult<Prisma.$sub_paketsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sub_pakets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_paketsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sub_pakets
     * const sub_pakets = await prisma.sub_pakets.findMany()
     * 
     * // Get first 10 Sub_pakets
     * const sub_pakets = await prisma.sub_pakets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sub_paketsWithIdOnly = await prisma.sub_pakets.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends sub_paketsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sub_paketsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sub_paketsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sub_pakets.
     * @param {sub_paketsCreateArgs} args - Arguments to create a Sub_pakets.
     * @example
     * // Create one Sub_pakets
     * const Sub_pakets = await prisma.sub_pakets.create({
     *   data: {
     *     // ... data to create a Sub_pakets
     *   }
     * })
     * 
    **/
    create<T extends sub_paketsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, sub_paketsCreateArgs<ExtArgs>>
    ): Prisma__sub_paketsClient<$Result.GetResult<Prisma.$sub_paketsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sub_pakets.
     * @param {sub_paketsCreateManyArgs} args - Arguments to create many Sub_pakets.
     * @example
     * // Create many Sub_pakets
     * const sub_pakets = await prisma.sub_pakets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends sub_paketsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sub_paketsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sub_pakets.
     * @param {sub_paketsDeleteArgs} args - Arguments to delete one Sub_pakets.
     * @example
     * // Delete one Sub_pakets
     * const Sub_pakets = await prisma.sub_pakets.delete({
     *   where: {
     *     // ... filter to delete one Sub_pakets
     *   }
     * })
     * 
    **/
    delete<T extends sub_paketsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, sub_paketsDeleteArgs<ExtArgs>>
    ): Prisma__sub_paketsClient<$Result.GetResult<Prisma.$sub_paketsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sub_pakets.
     * @param {sub_paketsUpdateArgs} args - Arguments to update one Sub_pakets.
     * @example
     * // Update one Sub_pakets
     * const sub_pakets = await prisma.sub_pakets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sub_paketsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, sub_paketsUpdateArgs<ExtArgs>>
    ): Prisma__sub_paketsClient<$Result.GetResult<Prisma.$sub_paketsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sub_pakets.
     * @param {sub_paketsDeleteManyArgs} args - Arguments to filter Sub_pakets to delete.
     * @example
     * // Delete a few Sub_pakets
     * const { count } = await prisma.sub_pakets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sub_paketsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sub_paketsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sub_pakets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_paketsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sub_pakets
     * const sub_pakets = await prisma.sub_pakets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sub_paketsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, sub_paketsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sub_pakets.
     * @param {sub_paketsUpsertArgs} args - Arguments to update or create a Sub_pakets.
     * @example
     * // Update or create a Sub_pakets
     * const sub_pakets = await prisma.sub_pakets.upsert({
     *   create: {
     *     // ... data to create a Sub_pakets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sub_pakets we want to update
     *   }
     * })
    **/
    upsert<T extends sub_paketsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, sub_paketsUpsertArgs<ExtArgs>>
    ): Prisma__sub_paketsClient<$Result.GetResult<Prisma.$sub_paketsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sub_pakets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_paketsCountArgs} args - Arguments to filter Sub_pakets to count.
     * @example
     * // Count the number of Sub_pakets
     * const count = await prisma.sub_pakets.count({
     *   where: {
     *     // ... the filter for the Sub_pakets we want to count
     *   }
     * })
    **/
    count<T extends sub_paketsCountArgs>(
      args?: Subset<T, sub_paketsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sub_paketsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sub_pakets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sub_paketsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sub_paketsAggregateArgs>(args: Subset<T, Sub_paketsAggregateArgs>): Prisma.PrismaPromise<GetSub_paketsAggregateType<T>>

    /**
     * Group by Sub_pakets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_paketsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sub_paketsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sub_paketsGroupByArgs['orderBy'] }
        : { orderBy?: sub_paketsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sub_paketsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSub_paketsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sub_pakets model
   */
  readonly fields: sub_paketsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sub_pakets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sub_paketsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    items<T extends sub_pakets$itemsArgs<ExtArgs> = {}>(args?: Subset<T, sub_pakets$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, 'findMany'> | Null>;

    pakets<T extends paketsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, paketsDefaultArgs<ExtArgs>>): Prisma__paketsClient<$Result.GetResult<Prisma.$paketsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the sub_pakets model
   */ 
  interface sub_paketsFieldRefs {
    readonly id: FieldRef<"sub_pakets", 'Int'>
    readonly name: FieldRef<"sub_pakets", 'String'>
    readonly code: FieldRef<"sub_pakets", 'String'>
    readonly order_num: FieldRef<"sub_pakets", 'Int'>
    readonly is_active: FieldRef<"sub_pakets", 'Boolean'>
    readonly pakets_id: FieldRef<"sub_pakets", 'Int'>
    readonly created_at: FieldRef<"sub_pakets", 'DateTime'>
    readonly updated_at: FieldRef<"sub_pakets", 'DateTime'>
    readonly propogated_at: FieldRef<"sub_pakets", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sub_pakets findUnique
   */
  export type sub_paketsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_pakets
     */
    select?: sub_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_paketsInclude<ExtArgs> | null
    /**
     * Filter, which sub_pakets to fetch.
     */
    where: sub_paketsWhereUniqueInput
  }

  /**
   * sub_pakets findUniqueOrThrow
   */
  export type sub_paketsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_pakets
     */
    select?: sub_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_paketsInclude<ExtArgs> | null
    /**
     * Filter, which sub_pakets to fetch.
     */
    where: sub_paketsWhereUniqueInput
  }

  /**
   * sub_pakets findFirst
   */
  export type sub_paketsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_pakets
     */
    select?: sub_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_paketsInclude<ExtArgs> | null
    /**
     * Filter, which sub_pakets to fetch.
     */
    where?: sub_paketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_pakets to fetch.
     */
    orderBy?: sub_paketsOrderByWithRelationInput | sub_paketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sub_pakets.
     */
    cursor?: sub_paketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_pakets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_pakets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sub_pakets.
     */
    distinct?: Sub_paketsScalarFieldEnum | Sub_paketsScalarFieldEnum[]
  }

  /**
   * sub_pakets findFirstOrThrow
   */
  export type sub_paketsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_pakets
     */
    select?: sub_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_paketsInclude<ExtArgs> | null
    /**
     * Filter, which sub_pakets to fetch.
     */
    where?: sub_paketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_pakets to fetch.
     */
    orderBy?: sub_paketsOrderByWithRelationInput | sub_paketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sub_pakets.
     */
    cursor?: sub_paketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_pakets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_pakets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sub_pakets.
     */
    distinct?: Sub_paketsScalarFieldEnum | Sub_paketsScalarFieldEnum[]
  }

  /**
   * sub_pakets findMany
   */
  export type sub_paketsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_pakets
     */
    select?: sub_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_paketsInclude<ExtArgs> | null
    /**
     * Filter, which sub_pakets to fetch.
     */
    where?: sub_paketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_pakets to fetch.
     */
    orderBy?: sub_paketsOrderByWithRelationInput | sub_paketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sub_pakets.
     */
    cursor?: sub_paketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_pakets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_pakets.
     */
    skip?: number
    distinct?: Sub_paketsScalarFieldEnum | Sub_paketsScalarFieldEnum[]
  }

  /**
   * sub_pakets create
   */
  export type sub_paketsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_pakets
     */
    select?: sub_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_paketsInclude<ExtArgs> | null
    /**
     * The data needed to create a sub_pakets.
     */
    data: XOR<sub_paketsCreateInput, sub_paketsUncheckedCreateInput>
  }

  /**
   * sub_pakets createMany
   */
  export type sub_paketsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sub_pakets.
     */
    data: sub_paketsCreateManyInput | sub_paketsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sub_pakets update
   */
  export type sub_paketsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_pakets
     */
    select?: sub_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_paketsInclude<ExtArgs> | null
    /**
     * The data needed to update a sub_pakets.
     */
    data: XOR<sub_paketsUpdateInput, sub_paketsUncheckedUpdateInput>
    /**
     * Choose, which sub_pakets to update.
     */
    where: sub_paketsWhereUniqueInput
  }

  /**
   * sub_pakets updateMany
   */
  export type sub_paketsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sub_pakets.
     */
    data: XOR<sub_paketsUpdateManyMutationInput, sub_paketsUncheckedUpdateManyInput>
    /**
     * Filter which sub_pakets to update
     */
    where?: sub_paketsWhereInput
  }

  /**
   * sub_pakets upsert
   */
  export type sub_paketsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_pakets
     */
    select?: sub_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_paketsInclude<ExtArgs> | null
    /**
     * The filter to search for the sub_pakets to update in case it exists.
     */
    where: sub_paketsWhereUniqueInput
    /**
     * In case the sub_pakets found by the `where` argument doesn't exist, create a new sub_pakets with this data.
     */
    create: XOR<sub_paketsCreateInput, sub_paketsUncheckedCreateInput>
    /**
     * In case the sub_pakets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sub_paketsUpdateInput, sub_paketsUncheckedUpdateInput>
  }

  /**
   * sub_pakets delete
   */
  export type sub_paketsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_pakets
     */
    select?: sub_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_paketsInclude<ExtArgs> | null
    /**
     * Filter which sub_pakets to delete.
     */
    where: sub_paketsWhereUniqueInput
  }

  /**
   * sub_pakets deleteMany
   */
  export type sub_paketsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sub_pakets to delete
     */
    where?: sub_paketsWhereInput
  }

  /**
   * sub_pakets.items
   */
  export type sub_pakets$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    where?: itemsWhereInput
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    cursor?: itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * sub_pakets without action
   */
  export type sub_paketsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_pakets
     */
    select?: sub_paketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_paketsInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    name: string | null
    password: string | null
    email: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    password: string | null
    email: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    password: number
    email: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    password?: true
    email?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    password?: true
    email?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    password?: true
    email?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    name: string
    password: string
    email: string
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    password?: boolean
    email?: boolean
    r_users_roles?: boolean | users$r_users_rolesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>


  export type usersSelectScalar = {
    id?: boolean
    name?: boolean
    password?: boolean
    email?: boolean
  }

  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    r_users_roles?: boolean | users$r_users_rolesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      r_users_roles: Prisma.$r_users_rolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      password: string
      email: string
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, usersCreateArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends usersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, usersDeleteArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpdateArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpsertArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    r_users_roles<T extends users$r_users_rolesArgs<ExtArgs> = {}>(args?: Subset<T, users$r_users_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$r_users_rolesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly name: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users.r_users_roles
   */
  export type users$r_users_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_roles
     */
    select?: r_users_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_rolesInclude<ExtArgs> | null
    where?: r_users_rolesWhereInput
    orderBy?: r_users_rolesOrderByWithRelationInput | r_users_rolesOrderByWithRelationInput[]
    cursor?: r_users_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: R_users_rolesScalarFieldEnum | R_users_rolesScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model users_client
   */

  export type AggregateUsers_client = {
    _count: Users_clientCountAggregateOutputType | null
    _avg: Users_clientAvgAggregateOutputType | null
    _sum: Users_clientSumAggregateOutputType | null
    _min: Users_clientMinAggregateOutputType | null
    _max: Users_clientMaxAggregateOutputType | null
  }

  export type Users_clientAvgAggregateOutputType = {
    id: number | null
    role_id: number | null
  }

  export type Users_clientSumAggregateOutputType = {
    id: number | null
    role_id: number | null
  }

  export type Users_clientMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    role_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Users_clientMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    role_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Users_clientCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    role_id: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Users_clientAvgAggregateInputType = {
    id?: true
    role_id?: true
  }

  export type Users_clientSumAggregateInputType = {
    id?: true
    role_id?: true
  }

  export type Users_clientMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    role_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Users_clientMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    role_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Users_clientCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    role_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Users_clientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users_client to aggregate.
     */
    where?: users_clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_clients to fetch.
     */
    orderBy?: users_clientOrderByWithRelationInput | users_clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: users_clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users_clients
    **/
    _count?: true | Users_clientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Users_clientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Users_clientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Users_clientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Users_clientMaxAggregateInputType
  }

  export type GetUsers_clientAggregateType<T extends Users_clientAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers_client]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers_client[P]>
      : GetScalarType<T[P], AggregateUsers_client[P]>
  }




  export type users_clientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: users_clientWhereInput
    orderBy?: users_clientOrderByWithAggregationInput | users_clientOrderByWithAggregationInput[]
    by: Users_clientScalarFieldEnum[] | Users_clientScalarFieldEnum
    having?: users_clientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Users_clientCountAggregateInputType | true
    _avg?: Users_clientAvgAggregateInputType
    _sum?: Users_clientSumAggregateInputType
    _min?: Users_clientMinAggregateInputType
    _max?: Users_clientMaxAggregateInputType
  }

  export type Users_clientGroupByOutputType = {
    id: number
    name: string
    email: string
    phone: string
    role_id: number
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: Users_clientCountAggregateOutputType | null
    _avg: Users_clientAvgAggregateOutputType | null
    _sum: Users_clientSumAggregateOutputType | null
    _min: Users_clientMinAggregateOutputType | null
    _max: Users_clientMaxAggregateOutputType | null
  }

  type GetUsers_clientGroupByPayload<T extends users_clientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Users_clientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Users_clientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Users_clientGroupByOutputType[P]>
            : GetScalarType<T[P], Users_clientGroupByOutputType[P]>
        }
      >
    >


  export type users_clientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    role_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    r_users_client_contractors?: boolean | users_client$r_users_client_contractorsArgs<ExtArgs>
    roles_client?: boolean | roles_clientDefaultArgs<ExtArgs>
    _count?: boolean | Users_clientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users_client"]>


  export type users_clientSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    role_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type users_clientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    r_users_client_contractors?: boolean | users_client$r_users_client_contractorsArgs<ExtArgs>
    roles_client?: boolean | roles_clientDefaultArgs<ExtArgs>
    _count?: boolean | Users_clientCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $users_clientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users_client"
    objects: {
      r_users_client_contractors: Prisma.$r_users_client_contractorsPayload<ExtArgs>[]
      roles_client: Prisma.$roles_clientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      phone: string
      role_id: number
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["users_client"]>
    composites: {}
  }

  type users_clientGetPayload<S extends boolean | null | undefined | users_clientDefaultArgs> = $Result.GetResult<Prisma.$users_clientPayload, S>

  type users_clientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<users_clientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Users_clientCountAggregateInputType | true
    }

  export interface users_clientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users_client'], meta: { name: 'users_client' } }
    /**
     * Find zero or one Users_client that matches the filter.
     * @param {users_clientFindUniqueArgs} args - Arguments to find a Users_client
     * @example
     * // Get one Users_client
     * const users_client = await prisma.users_client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends users_clientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, users_clientFindUniqueArgs<ExtArgs>>
    ): Prisma__users_clientClient<$Result.GetResult<Prisma.$users_clientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Users_client that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {users_clientFindUniqueOrThrowArgs} args - Arguments to find a Users_client
     * @example
     * // Get one Users_client
     * const users_client = await prisma.users_client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends users_clientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, users_clientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__users_clientClient<$Result.GetResult<Prisma.$users_clientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Users_client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_clientFindFirstArgs} args - Arguments to find a Users_client
     * @example
     * // Get one Users_client
     * const users_client = await prisma.users_client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends users_clientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, users_clientFindFirstArgs<ExtArgs>>
    ): Prisma__users_clientClient<$Result.GetResult<Prisma.$users_clientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Users_client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_clientFindFirstOrThrowArgs} args - Arguments to find a Users_client
     * @example
     * // Get one Users_client
     * const users_client = await prisma.users_client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends users_clientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, users_clientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__users_clientClient<$Result.GetResult<Prisma.$users_clientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users_clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_clientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users_clients
     * const users_clients = await prisma.users_client.findMany()
     * 
     * // Get first 10 Users_clients
     * const users_clients = await prisma.users_client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const users_clientWithIdOnly = await prisma.users_client.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends users_clientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, users_clientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$users_clientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Users_client.
     * @param {users_clientCreateArgs} args - Arguments to create a Users_client.
     * @example
     * // Create one Users_client
     * const Users_client = await prisma.users_client.create({
     *   data: {
     *     // ... data to create a Users_client
     *   }
     * })
     * 
    **/
    create<T extends users_clientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, users_clientCreateArgs<ExtArgs>>
    ): Prisma__users_clientClient<$Result.GetResult<Prisma.$users_clientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users_clients.
     * @param {users_clientCreateManyArgs} args - Arguments to create many Users_clients.
     * @example
     * // Create many Users_clients
     * const users_client = await prisma.users_client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends users_clientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, users_clientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users_client.
     * @param {users_clientDeleteArgs} args - Arguments to delete one Users_client.
     * @example
     * // Delete one Users_client
     * const Users_client = await prisma.users_client.delete({
     *   where: {
     *     // ... filter to delete one Users_client
     *   }
     * })
     * 
    **/
    delete<T extends users_clientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, users_clientDeleteArgs<ExtArgs>>
    ): Prisma__users_clientClient<$Result.GetResult<Prisma.$users_clientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Users_client.
     * @param {users_clientUpdateArgs} args - Arguments to update one Users_client.
     * @example
     * // Update one Users_client
     * const users_client = await prisma.users_client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends users_clientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, users_clientUpdateArgs<ExtArgs>>
    ): Prisma__users_clientClient<$Result.GetResult<Prisma.$users_clientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users_clients.
     * @param {users_clientDeleteManyArgs} args - Arguments to filter Users_clients to delete.
     * @example
     * // Delete a few Users_clients
     * const { count } = await prisma.users_client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends users_clientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, users_clientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users_clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_clientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users_clients
     * const users_client = await prisma.users_client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends users_clientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, users_clientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users_client.
     * @param {users_clientUpsertArgs} args - Arguments to update or create a Users_client.
     * @example
     * // Update or create a Users_client
     * const users_client = await prisma.users_client.upsert({
     *   create: {
     *     // ... data to create a Users_client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users_client we want to update
     *   }
     * })
    **/
    upsert<T extends users_clientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, users_clientUpsertArgs<ExtArgs>>
    ): Prisma__users_clientClient<$Result.GetResult<Prisma.$users_clientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users_clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_clientCountArgs} args - Arguments to filter Users_clients to count.
     * @example
     * // Count the number of Users_clients
     * const count = await prisma.users_client.count({
     *   where: {
     *     // ... the filter for the Users_clients we want to count
     *   }
     * })
    **/
    count<T extends users_clientCountArgs>(
      args?: Subset<T, users_clientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Users_clientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users_client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_clientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Users_clientAggregateArgs>(args: Subset<T, Users_clientAggregateArgs>): Prisma.PrismaPromise<GetUsers_clientAggregateType<T>>

    /**
     * Group by Users_client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_clientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends users_clientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: users_clientGroupByArgs['orderBy'] }
        : { orderBy?: users_clientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, users_clientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsers_clientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users_client model
   */
  readonly fields: users_clientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users_client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__users_clientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    r_users_client_contractors<T extends users_client$r_users_client_contractorsArgs<ExtArgs> = {}>(args?: Subset<T, users_client$r_users_client_contractorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$r_users_client_contractorsPayload<ExtArgs>, T, 'findMany'> | Null>;

    roles_client<T extends roles_clientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roles_clientDefaultArgs<ExtArgs>>): Prisma__roles_clientClient<$Result.GetResult<Prisma.$roles_clientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the users_client model
   */ 
  interface users_clientFieldRefs {
    readonly id: FieldRef<"users_client", 'Int'>
    readonly name: FieldRef<"users_client", 'String'>
    readonly email: FieldRef<"users_client", 'String'>
    readonly phone: FieldRef<"users_client", 'String'>
    readonly role_id: FieldRef<"users_client", 'Int'>
    readonly created_at: FieldRef<"users_client", 'DateTime'>
    readonly updated_at: FieldRef<"users_client", 'DateTime'>
    readonly deleted_at: FieldRef<"users_client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users_client findUnique
   */
  export type users_clientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_client
     */
    select?: users_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_clientInclude<ExtArgs> | null
    /**
     * Filter, which users_client to fetch.
     */
    where: users_clientWhereUniqueInput
  }

  /**
   * users_client findUniqueOrThrow
   */
  export type users_clientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_client
     */
    select?: users_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_clientInclude<ExtArgs> | null
    /**
     * Filter, which users_client to fetch.
     */
    where: users_clientWhereUniqueInput
  }

  /**
   * users_client findFirst
   */
  export type users_clientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_client
     */
    select?: users_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_clientInclude<ExtArgs> | null
    /**
     * Filter, which users_client to fetch.
     */
    where?: users_clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_clients to fetch.
     */
    orderBy?: users_clientOrderByWithRelationInput | users_clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_clients.
     */
    cursor?: users_clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_clients.
     */
    distinct?: Users_clientScalarFieldEnum | Users_clientScalarFieldEnum[]
  }

  /**
   * users_client findFirstOrThrow
   */
  export type users_clientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_client
     */
    select?: users_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_clientInclude<ExtArgs> | null
    /**
     * Filter, which users_client to fetch.
     */
    where?: users_clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_clients to fetch.
     */
    orderBy?: users_clientOrderByWithRelationInput | users_clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_clients.
     */
    cursor?: users_clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_clients.
     */
    distinct?: Users_clientScalarFieldEnum | Users_clientScalarFieldEnum[]
  }

  /**
   * users_client findMany
   */
  export type users_clientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_client
     */
    select?: users_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_clientInclude<ExtArgs> | null
    /**
     * Filter, which users_clients to fetch.
     */
    where?: users_clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_clients to fetch.
     */
    orderBy?: users_clientOrderByWithRelationInput | users_clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users_clients.
     */
    cursor?: users_clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_clients.
     */
    skip?: number
    distinct?: Users_clientScalarFieldEnum | Users_clientScalarFieldEnum[]
  }

  /**
   * users_client create
   */
  export type users_clientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_client
     */
    select?: users_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_clientInclude<ExtArgs> | null
    /**
     * The data needed to create a users_client.
     */
    data: XOR<users_clientCreateInput, users_clientUncheckedCreateInput>
  }

  /**
   * users_client createMany
   */
  export type users_clientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users_clients.
     */
    data: users_clientCreateManyInput | users_clientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users_client update
   */
  export type users_clientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_client
     */
    select?: users_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_clientInclude<ExtArgs> | null
    /**
     * The data needed to update a users_client.
     */
    data: XOR<users_clientUpdateInput, users_clientUncheckedUpdateInput>
    /**
     * Choose, which users_client to update.
     */
    where: users_clientWhereUniqueInput
  }

  /**
   * users_client updateMany
   */
  export type users_clientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users_clients.
     */
    data: XOR<users_clientUpdateManyMutationInput, users_clientUncheckedUpdateManyInput>
    /**
     * Filter which users_clients to update
     */
    where?: users_clientWhereInput
  }

  /**
   * users_client upsert
   */
  export type users_clientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_client
     */
    select?: users_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_clientInclude<ExtArgs> | null
    /**
     * The filter to search for the users_client to update in case it exists.
     */
    where: users_clientWhereUniqueInput
    /**
     * In case the users_client found by the `where` argument doesn't exist, create a new users_client with this data.
     */
    create: XOR<users_clientCreateInput, users_clientUncheckedCreateInput>
    /**
     * In case the users_client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<users_clientUpdateInput, users_clientUncheckedUpdateInput>
  }

  /**
   * users_client delete
   */
  export type users_clientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_client
     */
    select?: users_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_clientInclude<ExtArgs> | null
    /**
     * Filter which users_client to delete.
     */
    where: users_clientWhereUniqueInput
  }

  /**
   * users_client deleteMany
   */
  export type users_clientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users_clients to delete
     */
    where?: users_clientWhereInput
  }

  /**
   * users_client.r_users_client_contractors
   */
  export type users_client$r_users_client_contractorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_users_client_contractors
     */
    select?: r_users_client_contractorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: r_users_client_contractorsInclude<ExtArgs> | null
    where?: r_users_client_contractorsWhereInput
    orderBy?: r_users_client_contractorsOrderByWithRelationInput | r_users_client_contractorsOrderByWithRelationInput[]
    cursor?: r_users_client_contractorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: R_users_client_contractorsScalarFieldEnum | R_users_client_contractorsScalarFieldEnum[]
  }

  /**
   * users_client without action
   */
  export type users_clientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_client
     */
    select?: users_clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_clientInclude<ExtArgs> | null
  }


  /**
   * Model banks_items_versions
   */

  export type AggregateBanks_items_versions = {
    _count: Banks_items_versionsCountAggregateOutputType | null
    _avg: Banks_items_versionsAvgAggregateOutputType | null
    _sum: Banks_items_versionsSumAggregateOutputType | null
    _min: Banks_items_versionsMinAggregateOutputType | null
    _max: Banks_items_versionsMaxAggregateOutputType | null
  }

  export type Banks_items_versionsAvgAggregateOutputType = {
    id: number | null
    bank_id: number | null
  }

  export type Banks_items_versionsSumAggregateOutputType = {
    id: bigint | null
    bank_id: number | null
  }

  export type Banks_items_versionsMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    is_active: boolean | null
    bank_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Banks_items_versionsMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    is_active: boolean | null
    bank_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Banks_items_versionsCountAggregateOutputType = {
    id: number
    name: number
    is_active: number
    bank_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Banks_items_versionsAvgAggregateInputType = {
    id?: true
    bank_id?: true
  }

  export type Banks_items_versionsSumAggregateInputType = {
    id?: true
    bank_id?: true
  }

  export type Banks_items_versionsMinAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    bank_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Banks_items_versionsMaxAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    bank_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Banks_items_versionsCountAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    bank_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Banks_items_versionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which banks_items_versions to aggregate.
     */
    where?: banks_items_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks_items_versions to fetch.
     */
    orderBy?: banks_items_versionsOrderByWithRelationInput | banks_items_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: banks_items_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks_items_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks_items_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned banks_items_versions
    **/
    _count?: true | Banks_items_versionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Banks_items_versionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Banks_items_versionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Banks_items_versionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Banks_items_versionsMaxAggregateInputType
  }

  export type GetBanks_items_versionsAggregateType<T extends Banks_items_versionsAggregateArgs> = {
        [P in keyof T & keyof AggregateBanks_items_versions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanks_items_versions[P]>
      : GetScalarType<T[P], AggregateBanks_items_versions[P]>
  }




  export type banks_items_versionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: banks_items_versionsWhereInput
    orderBy?: banks_items_versionsOrderByWithAggregationInput | banks_items_versionsOrderByWithAggregationInput[]
    by: Banks_items_versionsScalarFieldEnum[] | Banks_items_versionsScalarFieldEnum
    having?: banks_items_versionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Banks_items_versionsCountAggregateInputType | true
    _avg?: Banks_items_versionsAvgAggregateInputType
    _sum?: Banks_items_versionsSumAggregateInputType
    _min?: Banks_items_versionsMinAggregateInputType
    _max?: Banks_items_versionsMaxAggregateInputType
  }

  export type Banks_items_versionsGroupByOutputType = {
    id: bigint
    name: string
    is_active: boolean
    bank_id: number
    created_at: Date
    updated_at: Date
    _count: Banks_items_versionsCountAggregateOutputType | null
    _avg: Banks_items_versionsAvgAggregateOutputType | null
    _sum: Banks_items_versionsSumAggregateOutputType | null
    _min: Banks_items_versionsMinAggregateOutputType | null
    _max: Banks_items_versionsMaxAggregateOutputType | null
  }

  type GetBanks_items_versionsGroupByPayload<T extends banks_items_versionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Banks_items_versionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Banks_items_versionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Banks_items_versionsGroupByOutputType[P]>
            : GetScalarType<T[P], Banks_items_versionsGroupByOutputType[P]>
        }
      >
    >


  export type banks_items_versionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    bank_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    banks_items?: boolean | banks_items_versions$banks_itemsArgs<ExtArgs>
    banks?: boolean | banksDefaultArgs<ExtArgs>
    _count?: boolean | Banks_items_versionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banks_items_versions"]>


  export type banks_items_versionsSelectScalar = {
    id?: boolean
    name?: boolean
    is_active?: boolean
    bank_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type banks_items_versionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banks_items?: boolean | banks_items_versions$banks_itemsArgs<ExtArgs>
    banks?: boolean | banksDefaultArgs<ExtArgs>
    _count?: boolean | Banks_items_versionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $banks_items_versionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "banks_items_versions"
    objects: {
      banks_items: Prisma.$banks_itemsPayload<ExtArgs>[]
      banks: Prisma.$banksPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      is_active: boolean
      bank_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["banks_items_versions"]>
    composites: {}
  }

  type banks_items_versionsGetPayload<S extends boolean | null | undefined | banks_items_versionsDefaultArgs> = $Result.GetResult<Prisma.$banks_items_versionsPayload, S>

  type banks_items_versionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<banks_items_versionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Banks_items_versionsCountAggregateInputType | true
    }

  export interface banks_items_versionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['banks_items_versions'], meta: { name: 'banks_items_versions' } }
    /**
     * Find zero or one Banks_items_versions that matches the filter.
     * @param {banks_items_versionsFindUniqueArgs} args - Arguments to find a Banks_items_versions
     * @example
     * // Get one Banks_items_versions
     * const banks_items_versions = await prisma.banks_items_versions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends banks_items_versionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, banks_items_versionsFindUniqueArgs<ExtArgs>>
    ): Prisma__banks_items_versionsClient<$Result.GetResult<Prisma.$banks_items_versionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Banks_items_versions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {banks_items_versionsFindUniqueOrThrowArgs} args - Arguments to find a Banks_items_versions
     * @example
     * // Get one Banks_items_versions
     * const banks_items_versions = await prisma.banks_items_versions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends banks_items_versionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, banks_items_versionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__banks_items_versionsClient<$Result.GetResult<Prisma.$banks_items_versionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Banks_items_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banks_items_versionsFindFirstArgs} args - Arguments to find a Banks_items_versions
     * @example
     * // Get one Banks_items_versions
     * const banks_items_versions = await prisma.banks_items_versions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends banks_items_versionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, banks_items_versionsFindFirstArgs<ExtArgs>>
    ): Prisma__banks_items_versionsClient<$Result.GetResult<Prisma.$banks_items_versionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Banks_items_versions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banks_items_versionsFindFirstOrThrowArgs} args - Arguments to find a Banks_items_versions
     * @example
     * // Get one Banks_items_versions
     * const banks_items_versions = await prisma.banks_items_versions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends banks_items_versionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, banks_items_versionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__banks_items_versionsClient<$Result.GetResult<Prisma.$banks_items_versionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Banks_items_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banks_items_versionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banks_items_versions
     * const banks_items_versions = await prisma.banks_items_versions.findMany()
     * 
     * // Get first 10 Banks_items_versions
     * const banks_items_versions = await prisma.banks_items_versions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const banks_items_versionsWithIdOnly = await prisma.banks_items_versions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends banks_items_versionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, banks_items_versionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$banks_items_versionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Banks_items_versions.
     * @param {banks_items_versionsCreateArgs} args - Arguments to create a Banks_items_versions.
     * @example
     * // Create one Banks_items_versions
     * const Banks_items_versions = await prisma.banks_items_versions.create({
     *   data: {
     *     // ... data to create a Banks_items_versions
     *   }
     * })
     * 
    **/
    create<T extends banks_items_versionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, banks_items_versionsCreateArgs<ExtArgs>>
    ): Prisma__banks_items_versionsClient<$Result.GetResult<Prisma.$banks_items_versionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Banks_items_versions.
     * @param {banks_items_versionsCreateManyArgs} args - Arguments to create many Banks_items_versions.
     * @example
     * // Create many Banks_items_versions
     * const banks_items_versions = await prisma.banks_items_versions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends banks_items_versionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, banks_items_versionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Banks_items_versions.
     * @param {banks_items_versionsDeleteArgs} args - Arguments to delete one Banks_items_versions.
     * @example
     * // Delete one Banks_items_versions
     * const Banks_items_versions = await prisma.banks_items_versions.delete({
     *   where: {
     *     // ... filter to delete one Banks_items_versions
     *   }
     * })
     * 
    **/
    delete<T extends banks_items_versionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, banks_items_versionsDeleteArgs<ExtArgs>>
    ): Prisma__banks_items_versionsClient<$Result.GetResult<Prisma.$banks_items_versionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Banks_items_versions.
     * @param {banks_items_versionsUpdateArgs} args - Arguments to update one Banks_items_versions.
     * @example
     * // Update one Banks_items_versions
     * const banks_items_versions = await prisma.banks_items_versions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends banks_items_versionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, banks_items_versionsUpdateArgs<ExtArgs>>
    ): Prisma__banks_items_versionsClient<$Result.GetResult<Prisma.$banks_items_versionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Banks_items_versions.
     * @param {banks_items_versionsDeleteManyArgs} args - Arguments to filter Banks_items_versions to delete.
     * @example
     * // Delete a few Banks_items_versions
     * const { count } = await prisma.banks_items_versions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends banks_items_versionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, banks_items_versionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banks_items_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banks_items_versionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banks_items_versions
     * const banks_items_versions = await prisma.banks_items_versions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends banks_items_versionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, banks_items_versionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Banks_items_versions.
     * @param {banks_items_versionsUpsertArgs} args - Arguments to update or create a Banks_items_versions.
     * @example
     * // Update or create a Banks_items_versions
     * const banks_items_versions = await prisma.banks_items_versions.upsert({
     *   create: {
     *     // ... data to create a Banks_items_versions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banks_items_versions we want to update
     *   }
     * })
    **/
    upsert<T extends banks_items_versionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, banks_items_versionsUpsertArgs<ExtArgs>>
    ): Prisma__banks_items_versionsClient<$Result.GetResult<Prisma.$banks_items_versionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Banks_items_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banks_items_versionsCountArgs} args - Arguments to filter Banks_items_versions to count.
     * @example
     * // Count the number of Banks_items_versions
     * const count = await prisma.banks_items_versions.count({
     *   where: {
     *     // ... the filter for the Banks_items_versions we want to count
     *   }
     * })
    **/
    count<T extends banks_items_versionsCountArgs>(
      args?: Subset<T, banks_items_versionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Banks_items_versionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banks_items_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Banks_items_versionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Banks_items_versionsAggregateArgs>(args: Subset<T, Banks_items_versionsAggregateArgs>): Prisma.PrismaPromise<GetBanks_items_versionsAggregateType<T>>

    /**
     * Group by Banks_items_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banks_items_versionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends banks_items_versionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: banks_items_versionsGroupByArgs['orderBy'] }
        : { orderBy?: banks_items_versionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, banks_items_versionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBanks_items_versionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the banks_items_versions model
   */
  readonly fields: banks_items_versionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for banks_items_versions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__banks_items_versionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    banks_items<T extends banks_items_versions$banks_itemsArgs<ExtArgs> = {}>(args?: Subset<T, banks_items_versions$banks_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$banks_itemsPayload<ExtArgs>, T, 'findMany'> | Null>;

    banks<T extends banksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, banksDefaultArgs<ExtArgs>>): Prisma__banksClient<$Result.GetResult<Prisma.$banksPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the banks_items_versions model
   */ 
  interface banks_items_versionsFieldRefs {
    readonly id: FieldRef<"banks_items_versions", 'BigInt'>
    readonly name: FieldRef<"banks_items_versions", 'String'>
    readonly is_active: FieldRef<"banks_items_versions", 'Boolean'>
    readonly bank_id: FieldRef<"banks_items_versions", 'Int'>
    readonly created_at: FieldRef<"banks_items_versions", 'DateTime'>
    readonly updated_at: FieldRef<"banks_items_versions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * banks_items_versions findUnique
   */
  export type banks_items_versionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items_versions
     */
    select?: banks_items_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_items_versionsInclude<ExtArgs> | null
    /**
     * Filter, which banks_items_versions to fetch.
     */
    where: banks_items_versionsWhereUniqueInput
  }

  /**
   * banks_items_versions findUniqueOrThrow
   */
  export type banks_items_versionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items_versions
     */
    select?: banks_items_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_items_versionsInclude<ExtArgs> | null
    /**
     * Filter, which banks_items_versions to fetch.
     */
    where: banks_items_versionsWhereUniqueInput
  }

  /**
   * banks_items_versions findFirst
   */
  export type banks_items_versionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items_versions
     */
    select?: banks_items_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_items_versionsInclude<ExtArgs> | null
    /**
     * Filter, which banks_items_versions to fetch.
     */
    where?: banks_items_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks_items_versions to fetch.
     */
    orderBy?: banks_items_versionsOrderByWithRelationInput | banks_items_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banks_items_versions.
     */
    cursor?: banks_items_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks_items_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks_items_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banks_items_versions.
     */
    distinct?: Banks_items_versionsScalarFieldEnum | Banks_items_versionsScalarFieldEnum[]
  }

  /**
   * banks_items_versions findFirstOrThrow
   */
  export type banks_items_versionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items_versions
     */
    select?: banks_items_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_items_versionsInclude<ExtArgs> | null
    /**
     * Filter, which banks_items_versions to fetch.
     */
    where?: banks_items_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks_items_versions to fetch.
     */
    orderBy?: banks_items_versionsOrderByWithRelationInput | banks_items_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banks_items_versions.
     */
    cursor?: banks_items_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks_items_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks_items_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banks_items_versions.
     */
    distinct?: Banks_items_versionsScalarFieldEnum | Banks_items_versionsScalarFieldEnum[]
  }

  /**
   * banks_items_versions findMany
   */
  export type banks_items_versionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items_versions
     */
    select?: banks_items_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_items_versionsInclude<ExtArgs> | null
    /**
     * Filter, which banks_items_versions to fetch.
     */
    where?: banks_items_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks_items_versions to fetch.
     */
    orderBy?: banks_items_versionsOrderByWithRelationInput | banks_items_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing banks_items_versions.
     */
    cursor?: banks_items_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks_items_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks_items_versions.
     */
    skip?: number
    distinct?: Banks_items_versionsScalarFieldEnum | Banks_items_versionsScalarFieldEnum[]
  }

  /**
   * banks_items_versions create
   */
  export type banks_items_versionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items_versions
     */
    select?: banks_items_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_items_versionsInclude<ExtArgs> | null
    /**
     * The data needed to create a banks_items_versions.
     */
    data: XOR<banks_items_versionsCreateInput, banks_items_versionsUncheckedCreateInput>
  }

  /**
   * banks_items_versions createMany
   */
  export type banks_items_versionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many banks_items_versions.
     */
    data: banks_items_versionsCreateManyInput | banks_items_versionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * banks_items_versions update
   */
  export type banks_items_versionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items_versions
     */
    select?: banks_items_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_items_versionsInclude<ExtArgs> | null
    /**
     * The data needed to update a banks_items_versions.
     */
    data: XOR<banks_items_versionsUpdateInput, banks_items_versionsUncheckedUpdateInput>
    /**
     * Choose, which banks_items_versions to update.
     */
    where: banks_items_versionsWhereUniqueInput
  }

  /**
   * banks_items_versions updateMany
   */
  export type banks_items_versionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update banks_items_versions.
     */
    data: XOR<banks_items_versionsUpdateManyMutationInput, banks_items_versionsUncheckedUpdateManyInput>
    /**
     * Filter which banks_items_versions to update
     */
    where?: banks_items_versionsWhereInput
  }

  /**
   * banks_items_versions upsert
   */
  export type banks_items_versionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items_versions
     */
    select?: banks_items_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_items_versionsInclude<ExtArgs> | null
    /**
     * The filter to search for the banks_items_versions to update in case it exists.
     */
    where: banks_items_versionsWhereUniqueInput
    /**
     * In case the banks_items_versions found by the `where` argument doesn't exist, create a new banks_items_versions with this data.
     */
    create: XOR<banks_items_versionsCreateInput, banks_items_versionsUncheckedCreateInput>
    /**
     * In case the banks_items_versions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<banks_items_versionsUpdateInput, banks_items_versionsUncheckedUpdateInput>
  }

  /**
   * banks_items_versions delete
   */
  export type banks_items_versionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items_versions
     */
    select?: banks_items_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_items_versionsInclude<ExtArgs> | null
    /**
     * Filter which banks_items_versions to delete.
     */
    where: banks_items_versionsWhereUniqueInput
  }

  /**
   * banks_items_versions deleteMany
   */
  export type banks_items_versionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which banks_items_versions to delete
     */
    where?: banks_items_versionsWhereInput
  }

  /**
   * banks_items_versions.banks_items
   */
  export type banks_items_versions$banks_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items
     */
    select?: banks_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_itemsInclude<ExtArgs> | null
    where?: banks_itemsWhereInput
    orderBy?: banks_itemsOrderByWithRelationInput | banks_itemsOrderByWithRelationInput[]
    cursor?: banks_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Banks_itemsScalarFieldEnum | Banks_itemsScalarFieldEnum[]
  }

  /**
   * banks_items_versions without action
   */
  export type banks_items_versionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banks_items_versions
     */
    select?: banks_items_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banks_items_versionsInclude<ExtArgs> | null
  }


  /**
   * Model entities
   */

  export type AggregateEntities = {
    _count: EntitiesCountAggregateOutputType | null
    _avg: EntitiesAvgAggregateOutputType | null
    _sum: EntitiesSumAggregateOutputType | null
    _min: EntitiesMinAggregateOutputType | null
    _max: EntitiesMaxAggregateOutputType | null
  }

  export type EntitiesAvgAggregateOutputType = {
    id: number | null
  }

  export type EntitiesSumAggregateOutputType = {
    id: number | null
  }

  export type EntitiesMinAggregateOutputType = {
    id: number | null
    str_id: string | null
    name: string | null
    short_name: string | null
    display_name: string | null
    inn: string | null
    kpp: string | null
    ogrn: string | null
    db_name: string | null
  }

  export type EntitiesMaxAggregateOutputType = {
    id: number | null
    str_id: string | null
    name: string | null
    short_name: string | null
    display_name: string | null
    inn: string | null
    kpp: string | null
    ogrn: string | null
    db_name: string | null
  }

  export type EntitiesCountAggregateOutputType = {
    id: number
    str_id: number
    name: number
    short_name: number
    display_name: number
    inn: number
    kpp: number
    ogrn: number
    db_name: number
    _all: number
  }


  export type EntitiesAvgAggregateInputType = {
    id?: true
  }

  export type EntitiesSumAggregateInputType = {
    id?: true
  }

  export type EntitiesMinAggregateInputType = {
    id?: true
    str_id?: true
    name?: true
    short_name?: true
    display_name?: true
    inn?: true
    kpp?: true
    ogrn?: true
    db_name?: true
  }

  export type EntitiesMaxAggregateInputType = {
    id?: true
    str_id?: true
    name?: true
    short_name?: true
    display_name?: true
    inn?: true
    kpp?: true
    ogrn?: true
    db_name?: true
  }

  export type EntitiesCountAggregateInputType = {
    id?: true
    str_id?: true
    name?: true
    short_name?: true
    display_name?: true
    inn?: true
    kpp?: true
    ogrn?: true
    db_name?: true
    _all?: true
  }

  export type EntitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entities to aggregate.
     */
    where?: entitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities to fetch.
     */
    orderBy?: entitiesOrderByWithRelationInput | entitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: entitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned entities
    **/
    _count?: true | EntitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntitiesMaxAggregateInputType
  }

  export type GetEntitiesAggregateType<T extends EntitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateEntities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntities[P]>
      : GetScalarType<T[P], AggregateEntities[P]>
  }




  export type entitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entitiesWhereInput
    orderBy?: entitiesOrderByWithAggregationInput | entitiesOrderByWithAggregationInput[]
    by: EntitiesScalarFieldEnum[] | EntitiesScalarFieldEnum
    having?: entitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntitiesCountAggregateInputType | true
    _avg?: EntitiesAvgAggregateInputType
    _sum?: EntitiesSumAggregateInputType
    _min?: EntitiesMinAggregateInputType
    _max?: EntitiesMaxAggregateInputType
  }

  export type EntitiesGroupByOutputType = {
    id: number
    str_id: string
    name: string
    short_name: string
    display_name: string
    inn: string
    kpp: string
    ogrn: string
    db_name: string
    _count: EntitiesCountAggregateOutputType | null
    _avg: EntitiesAvgAggregateOutputType | null
    _sum: EntitiesSumAggregateOutputType | null
    _min: EntitiesMinAggregateOutputType | null
    _max: EntitiesMaxAggregateOutputType | null
  }

  type GetEntitiesGroupByPayload<T extends entitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntitiesGroupByOutputType[P]>
            : GetScalarType<T[P], EntitiesGroupByOutputType[P]>
        }
      >
    >


  export type entitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    str_id?: boolean
    name?: boolean
    short_name?: boolean
    display_name?: boolean
    inn?: boolean
    kpp?: boolean
    ogrn?: boolean
    db_name?: boolean
    objects?: boolean | entities$objectsArgs<ExtArgs>
    _count?: boolean | EntitiesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entities"]>


  export type entitiesSelectScalar = {
    id?: boolean
    str_id?: boolean
    name?: boolean
    short_name?: boolean
    display_name?: boolean
    inn?: boolean
    kpp?: boolean
    ogrn?: boolean
    db_name?: boolean
  }

  export type entitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    objects?: boolean | entities$objectsArgs<ExtArgs>
    _count?: boolean | EntitiesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $entitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "entities"
    objects: {
      objects: Prisma.$objectsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      str_id: string
      name: string
      short_name: string
      display_name: string
      inn: string
      kpp: string
      ogrn: string
      db_name: string
    }, ExtArgs["result"]["entities"]>
    composites: {}
  }

  type entitiesGetPayload<S extends boolean | null | undefined | entitiesDefaultArgs> = $Result.GetResult<Prisma.$entitiesPayload, S>

  type entitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<entitiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntitiesCountAggregateInputType | true
    }

  export interface entitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['entities'], meta: { name: 'entities' } }
    /**
     * Find zero or one Entities that matches the filter.
     * @param {entitiesFindUniqueArgs} args - Arguments to find a Entities
     * @example
     * // Get one Entities
     * const entities = await prisma.entities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends entitiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, entitiesFindUniqueArgs<ExtArgs>>
    ): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Entities that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {entitiesFindUniqueOrThrowArgs} args - Arguments to find a Entities
     * @example
     * // Get one Entities
     * const entities = await prisma.entities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends entitiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, entitiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Entities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entitiesFindFirstArgs} args - Arguments to find a Entities
     * @example
     * // Get one Entities
     * const entities = await prisma.entities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends entitiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, entitiesFindFirstArgs<ExtArgs>>
    ): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Entities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entitiesFindFirstOrThrowArgs} args - Arguments to find a Entities
     * @example
     * // Get one Entities
     * const entities = await prisma.entities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends entitiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, entitiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Entities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entities
     * const entities = await prisma.entities.findMany()
     * 
     * // Get first 10 Entities
     * const entities = await prisma.entities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entitiesWithIdOnly = await prisma.entities.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends entitiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, entitiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Entities.
     * @param {entitiesCreateArgs} args - Arguments to create a Entities.
     * @example
     * // Create one Entities
     * const Entities = await prisma.entities.create({
     *   data: {
     *     // ... data to create a Entities
     *   }
     * })
     * 
    **/
    create<T extends entitiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, entitiesCreateArgs<ExtArgs>>
    ): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Entities.
     * @param {entitiesCreateManyArgs} args - Arguments to create many Entities.
     * @example
     * // Create many Entities
     * const entities = await prisma.entities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends entitiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, entitiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Entities.
     * @param {entitiesDeleteArgs} args - Arguments to delete one Entities.
     * @example
     * // Delete one Entities
     * const Entities = await prisma.entities.delete({
     *   where: {
     *     // ... filter to delete one Entities
     *   }
     * })
     * 
    **/
    delete<T extends entitiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, entitiesDeleteArgs<ExtArgs>>
    ): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Entities.
     * @param {entitiesUpdateArgs} args - Arguments to update one Entities.
     * @example
     * // Update one Entities
     * const entities = await prisma.entities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends entitiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, entitiesUpdateArgs<ExtArgs>>
    ): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Entities.
     * @param {entitiesDeleteManyArgs} args - Arguments to filter Entities to delete.
     * @example
     * // Delete a few Entities
     * const { count } = await prisma.entities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends entitiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, entitiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entities
     * const entities = await prisma.entities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends entitiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, entitiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entities.
     * @param {entitiesUpsertArgs} args - Arguments to update or create a Entities.
     * @example
     * // Update or create a Entities
     * const entities = await prisma.entities.upsert({
     *   create: {
     *     // ... data to create a Entities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entities we want to update
     *   }
     * })
    **/
    upsert<T extends entitiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, entitiesUpsertArgs<ExtArgs>>
    ): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entitiesCountArgs} args - Arguments to filter Entities to count.
     * @example
     * // Count the number of Entities
     * const count = await prisma.entities.count({
     *   where: {
     *     // ... the filter for the Entities we want to count
     *   }
     * })
    **/
    count<T extends entitiesCountArgs>(
      args?: Subset<T, entitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntitiesAggregateArgs>(args: Subset<T, EntitiesAggregateArgs>): Prisma.PrismaPromise<GetEntitiesAggregateType<T>>

    /**
     * Group by Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends entitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: entitiesGroupByArgs['orderBy'] }
        : { orderBy?: entitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, entitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the entities model
   */
  readonly fields: entitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for entities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__entitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    objects<T extends entities$objectsArgs<ExtArgs> = {}>(args?: Subset<T, entities$objectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$objectsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the entities model
   */ 
  interface entitiesFieldRefs {
    readonly id: FieldRef<"entities", 'Int'>
    readonly str_id: FieldRef<"entities", 'String'>
    readonly name: FieldRef<"entities", 'String'>
    readonly short_name: FieldRef<"entities", 'String'>
    readonly display_name: FieldRef<"entities", 'String'>
    readonly inn: FieldRef<"entities", 'String'>
    readonly kpp: FieldRef<"entities", 'String'>
    readonly ogrn: FieldRef<"entities", 'String'>
    readonly db_name: FieldRef<"entities", 'String'>
  }
    

  // Custom InputTypes
  /**
   * entities findUnique
   */
  export type entitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * Filter, which entities to fetch.
     */
    where: entitiesWhereUniqueInput
  }

  /**
   * entities findUniqueOrThrow
   */
  export type entitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * Filter, which entities to fetch.
     */
    where: entitiesWhereUniqueInput
  }

  /**
   * entities findFirst
   */
  export type entitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * Filter, which entities to fetch.
     */
    where?: entitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities to fetch.
     */
    orderBy?: entitiesOrderByWithRelationInput | entitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entities.
     */
    cursor?: entitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entities.
     */
    distinct?: EntitiesScalarFieldEnum | EntitiesScalarFieldEnum[]
  }

  /**
   * entities findFirstOrThrow
   */
  export type entitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * Filter, which entities to fetch.
     */
    where?: entitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities to fetch.
     */
    orderBy?: entitiesOrderByWithRelationInput | entitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entities.
     */
    cursor?: entitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entities.
     */
    distinct?: EntitiesScalarFieldEnum | EntitiesScalarFieldEnum[]
  }

  /**
   * entities findMany
   */
  export type entitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * Filter, which entities to fetch.
     */
    where?: entitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities to fetch.
     */
    orderBy?: entitiesOrderByWithRelationInput | entitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing entities.
     */
    cursor?: entitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities.
     */
    skip?: number
    distinct?: EntitiesScalarFieldEnum | EntitiesScalarFieldEnum[]
  }

  /**
   * entities create
   */
  export type entitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a entities.
     */
    data: XOR<entitiesCreateInput, entitiesUncheckedCreateInput>
  }

  /**
   * entities createMany
   */
  export type entitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many entities.
     */
    data: entitiesCreateManyInput | entitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * entities update
   */
  export type entitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a entities.
     */
    data: XOR<entitiesUpdateInput, entitiesUncheckedUpdateInput>
    /**
     * Choose, which entities to update.
     */
    where: entitiesWhereUniqueInput
  }

  /**
   * entities updateMany
   */
  export type entitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update entities.
     */
    data: XOR<entitiesUpdateManyMutationInput, entitiesUncheckedUpdateManyInput>
    /**
     * Filter which entities to update
     */
    where?: entitiesWhereInput
  }

  /**
   * entities upsert
   */
  export type entitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the entities to update in case it exists.
     */
    where: entitiesWhereUniqueInput
    /**
     * In case the entities found by the `where` argument doesn't exist, create a new entities with this data.
     */
    create: XOR<entitiesCreateInput, entitiesUncheckedCreateInput>
    /**
     * In case the entities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<entitiesUpdateInput, entitiesUncheckedUpdateInput>
  }

  /**
   * entities delete
   */
  export type entitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * Filter which entities to delete.
     */
    where: entitiesWhereUniqueInput
  }

  /**
   * entities deleteMany
   */
  export type entitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entities to delete
     */
    where?: entitiesWhereInput
  }

  /**
   * entities.objects
   */
  export type entities$objectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objects
     */
    select?: objectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objectsInclude<ExtArgs> | null
    where?: objectsWhereInput
    orderBy?: objectsOrderByWithRelationInput | objectsOrderByWithRelationInput[]
    cursor?: objectsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectsScalarFieldEnum | ObjectsScalarFieldEnum[]
  }

  /**
   * entities without action
   */
  export type entitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
  }


  /**
   * Model r_items_banks_items
   */

  export type AggregateR_items_banks_items = {
    _count: R_items_banks_itemsCountAggregateOutputType | null
    _avg: R_items_banks_itemsAvgAggregateOutputType | null
    _sum: R_items_banks_itemsSumAggregateOutputType | null
    _min: R_items_banks_itemsMinAggregateOutputType | null
    _max: R_items_banks_itemsMaxAggregateOutputType | null
  }

  export type R_items_banks_itemsAvgAggregateOutputType = {
    item_id: number | null
    bank_item_id: number | null
  }

  export type R_items_banks_itemsSumAggregateOutputType = {
    item_id: number | null
    bank_item_id: number | null
  }

  export type R_items_banks_itemsMinAggregateOutputType = {
    item_id: number | null
    bank_item_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type R_items_banks_itemsMaxAggregateOutputType = {
    item_id: number | null
    bank_item_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type R_items_banks_itemsCountAggregateOutputType = {
    item_id: number
    bank_item_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type R_items_banks_itemsAvgAggregateInputType = {
    item_id?: true
    bank_item_id?: true
  }

  export type R_items_banks_itemsSumAggregateInputType = {
    item_id?: true
    bank_item_id?: true
  }

  export type R_items_banks_itemsMinAggregateInputType = {
    item_id?: true
    bank_item_id?: true
    created_at?: true
    updated_at?: true
  }

  export type R_items_banks_itemsMaxAggregateInputType = {
    item_id?: true
    bank_item_id?: true
    created_at?: true
    updated_at?: true
  }

  export type R_items_banks_itemsCountAggregateInputType = {
    item_id?: true
    bank_item_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type R_items_banks_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which r_items_banks_items to aggregate.
     */
    where?: r_items_banks_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of r_items_banks_items to fetch.
     */
    orderBy?: r_items_banks_itemsOrderByWithRelationInput | r_items_banks_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: r_items_banks_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` r_items_banks_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` r_items_banks_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned r_items_banks_items
    **/
    _count?: true | R_items_banks_itemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: R_items_banks_itemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: R_items_banks_itemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: R_items_banks_itemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: R_items_banks_itemsMaxAggregateInputType
  }

  export type GetR_items_banks_itemsAggregateType<T extends R_items_banks_itemsAggregateArgs> = {
        [P in keyof T & keyof AggregateR_items_banks_items]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateR_items_banks_items[P]>
      : GetScalarType<T[P], AggregateR_items_banks_items[P]>
  }




  export type r_items_banks_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: r_items_banks_itemsWhereInput
    orderBy?: r_items_banks_itemsOrderByWithAggregationInput | r_items_banks_itemsOrderByWithAggregationInput[]
    by: R_items_banks_itemsScalarFieldEnum[] | R_items_banks_itemsScalarFieldEnum
    having?: r_items_banks_itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: R_items_banks_itemsCountAggregateInputType | true
    _avg?: R_items_banks_itemsAvgAggregateInputType
    _sum?: R_items_banks_itemsSumAggregateInputType
    _min?: R_items_banks_itemsMinAggregateInputType
    _max?: R_items_banks_itemsMaxAggregateInputType
  }

  export type R_items_banks_itemsGroupByOutputType = {
    item_id: number
    bank_item_id: number
    created_at: Date | null
    updated_at: Date | null
    _count: R_items_banks_itemsCountAggregateOutputType | null
    _avg: R_items_banks_itemsAvgAggregateOutputType | null
    _sum: R_items_banks_itemsSumAggregateOutputType | null
    _min: R_items_banks_itemsMinAggregateOutputType | null
    _max: R_items_banks_itemsMaxAggregateOutputType | null
  }

  type GetR_items_banks_itemsGroupByPayload<T extends r_items_banks_itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<R_items_banks_itemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof R_items_banks_itemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], R_items_banks_itemsGroupByOutputType[P]>
            : GetScalarType<T[P], R_items_banks_itemsGroupByOutputType[P]>
        }
      >
    >


  export type r_items_banks_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    item_id?: boolean
    bank_item_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["r_items_banks_items"]>


  export type r_items_banks_itemsSelectScalar = {
    item_id?: boolean
    bank_item_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $r_items_banks_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "r_items_banks_items"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      item_id: number
      bank_item_id: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["r_items_banks_items"]>
    composites: {}
  }

  type r_items_banks_itemsGetPayload<S extends boolean | null | undefined | r_items_banks_itemsDefaultArgs> = $Result.GetResult<Prisma.$r_items_banks_itemsPayload, S>

  type r_items_banks_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<r_items_banks_itemsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: R_items_banks_itemsCountAggregateInputType | true
    }

  export interface r_items_banks_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['r_items_banks_items'], meta: { name: 'r_items_banks_items' } }
    /**
     * Find zero or one R_items_banks_items that matches the filter.
     * @param {r_items_banks_itemsFindUniqueArgs} args - Arguments to find a R_items_banks_items
     * @example
     * // Get one R_items_banks_items
     * const r_items_banks_items = await prisma.r_items_banks_items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends r_items_banks_itemsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, r_items_banks_itemsFindUniqueArgs<ExtArgs>>
    ): Prisma__r_items_banks_itemsClient<$Result.GetResult<Prisma.$r_items_banks_itemsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one R_items_banks_items that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {r_items_banks_itemsFindUniqueOrThrowArgs} args - Arguments to find a R_items_banks_items
     * @example
     * // Get one R_items_banks_items
     * const r_items_banks_items = await prisma.r_items_banks_items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends r_items_banks_itemsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, r_items_banks_itemsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__r_items_banks_itemsClient<$Result.GetResult<Prisma.$r_items_banks_itemsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first R_items_banks_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_items_banks_itemsFindFirstArgs} args - Arguments to find a R_items_banks_items
     * @example
     * // Get one R_items_banks_items
     * const r_items_banks_items = await prisma.r_items_banks_items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends r_items_banks_itemsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, r_items_banks_itemsFindFirstArgs<ExtArgs>>
    ): Prisma__r_items_banks_itemsClient<$Result.GetResult<Prisma.$r_items_banks_itemsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first R_items_banks_items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_items_banks_itemsFindFirstOrThrowArgs} args - Arguments to find a R_items_banks_items
     * @example
     * // Get one R_items_banks_items
     * const r_items_banks_items = await prisma.r_items_banks_items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends r_items_banks_itemsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, r_items_banks_itemsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__r_items_banks_itemsClient<$Result.GetResult<Prisma.$r_items_banks_itemsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more R_items_banks_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_items_banks_itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all R_items_banks_items
     * const r_items_banks_items = await prisma.r_items_banks_items.findMany()
     * 
     * // Get first 10 R_items_banks_items
     * const r_items_banks_items = await prisma.r_items_banks_items.findMany({ take: 10 })
     * 
     * // Only select the `item_id`
     * const r_items_banks_itemsWithItem_idOnly = await prisma.r_items_banks_items.findMany({ select: { item_id: true } })
     * 
    **/
    findMany<T extends r_items_banks_itemsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, r_items_banks_itemsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$r_items_banks_itemsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a R_items_banks_items.
     * @param {r_items_banks_itemsCreateArgs} args - Arguments to create a R_items_banks_items.
     * @example
     * // Create one R_items_banks_items
     * const R_items_banks_items = await prisma.r_items_banks_items.create({
     *   data: {
     *     // ... data to create a R_items_banks_items
     *   }
     * })
     * 
    **/
    create<T extends r_items_banks_itemsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, r_items_banks_itemsCreateArgs<ExtArgs>>
    ): Prisma__r_items_banks_itemsClient<$Result.GetResult<Prisma.$r_items_banks_itemsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many R_items_banks_items.
     * @param {r_items_banks_itemsCreateManyArgs} args - Arguments to create many R_items_banks_items.
     * @example
     * // Create many R_items_banks_items
     * const r_items_banks_items = await prisma.r_items_banks_items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends r_items_banks_itemsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, r_items_banks_itemsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a R_items_banks_items.
     * @param {r_items_banks_itemsDeleteArgs} args - Arguments to delete one R_items_banks_items.
     * @example
     * // Delete one R_items_banks_items
     * const R_items_banks_items = await prisma.r_items_banks_items.delete({
     *   where: {
     *     // ... filter to delete one R_items_banks_items
     *   }
     * })
     * 
    **/
    delete<T extends r_items_banks_itemsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, r_items_banks_itemsDeleteArgs<ExtArgs>>
    ): Prisma__r_items_banks_itemsClient<$Result.GetResult<Prisma.$r_items_banks_itemsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one R_items_banks_items.
     * @param {r_items_banks_itemsUpdateArgs} args - Arguments to update one R_items_banks_items.
     * @example
     * // Update one R_items_banks_items
     * const r_items_banks_items = await prisma.r_items_banks_items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends r_items_banks_itemsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, r_items_banks_itemsUpdateArgs<ExtArgs>>
    ): Prisma__r_items_banks_itemsClient<$Result.GetResult<Prisma.$r_items_banks_itemsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more R_items_banks_items.
     * @param {r_items_banks_itemsDeleteManyArgs} args - Arguments to filter R_items_banks_items to delete.
     * @example
     * // Delete a few R_items_banks_items
     * const { count } = await prisma.r_items_banks_items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends r_items_banks_itemsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, r_items_banks_itemsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more R_items_banks_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_items_banks_itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many R_items_banks_items
     * const r_items_banks_items = await prisma.r_items_banks_items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends r_items_banks_itemsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, r_items_banks_itemsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one R_items_banks_items.
     * @param {r_items_banks_itemsUpsertArgs} args - Arguments to update or create a R_items_banks_items.
     * @example
     * // Update or create a R_items_banks_items
     * const r_items_banks_items = await prisma.r_items_banks_items.upsert({
     *   create: {
     *     // ... data to create a R_items_banks_items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the R_items_banks_items we want to update
     *   }
     * })
    **/
    upsert<T extends r_items_banks_itemsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, r_items_banks_itemsUpsertArgs<ExtArgs>>
    ): Prisma__r_items_banks_itemsClient<$Result.GetResult<Prisma.$r_items_banks_itemsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of R_items_banks_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_items_banks_itemsCountArgs} args - Arguments to filter R_items_banks_items to count.
     * @example
     * // Count the number of R_items_banks_items
     * const count = await prisma.r_items_banks_items.count({
     *   where: {
     *     // ... the filter for the R_items_banks_items we want to count
     *   }
     * })
    **/
    count<T extends r_items_banks_itemsCountArgs>(
      args?: Subset<T, r_items_banks_itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], R_items_banks_itemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a R_items_banks_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {R_items_banks_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends R_items_banks_itemsAggregateArgs>(args: Subset<T, R_items_banks_itemsAggregateArgs>): Prisma.PrismaPromise<GetR_items_banks_itemsAggregateType<T>>

    /**
     * Group by R_items_banks_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {r_items_banks_itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends r_items_banks_itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: r_items_banks_itemsGroupByArgs['orderBy'] }
        : { orderBy?: r_items_banks_itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, r_items_banks_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetR_items_banks_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the r_items_banks_items model
   */
  readonly fields: r_items_banks_itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for r_items_banks_items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__r_items_banks_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the r_items_banks_items model
   */ 
  interface r_items_banks_itemsFieldRefs {
    readonly item_id: FieldRef<"r_items_banks_items", 'Int'>
    readonly bank_item_id: FieldRef<"r_items_banks_items", 'Int'>
    readonly created_at: FieldRef<"r_items_banks_items", 'DateTime'>
    readonly updated_at: FieldRef<"r_items_banks_items", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * r_items_banks_items findUnique
   */
  export type r_items_banks_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_items_banks_items
     */
    select?: r_items_banks_itemsSelect<ExtArgs> | null
    /**
     * Filter, which r_items_banks_items to fetch.
     */
    where: r_items_banks_itemsWhereUniqueInput
  }

  /**
   * r_items_banks_items findUniqueOrThrow
   */
  export type r_items_banks_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_items_banks_items
     */
    select?: r_items_banks_itemsSelect<ExtArgs> | null
    /**
     * Filter, which r_items_banks_items to fetch.
     */
    where: r_items_banks_itemsWhereUniqueInput
  }

  /**
   * r_items_banks_items findFirst
   */
  export type r_items_banks_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_items_banks_items
     */
    select?: r_items_banks_itemsSelect<ExtArgs> | null
    /**
     * Filter, which r_items_banks_items to fetch.
     */
    where?: r_items_banks_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of r_items_banks_items to fetch.
     */
    orderBy?: r_items_banks_itemsOrderByWithRelationInput | r_items_banks_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for r_items_banks_items.
     */
    cursor?: r_items_banks_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` r_items_banks_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` r_items_banks_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of r_items_banks_items.
     */
    distinct?: R_items_banks_itemsScalarFieldEnum | R_items_banks_itemsScalarFieldEnum[]
  }

  /**
   * r_items_banks_items findFirstOrThrow
   */
  export type r_items_banks_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_items_banks_items
     */
    select?: r_items_banks_itemsSelect<ExtArgs> | null
    /**
     * Filter, which r_items_banks_items to fetch.
     */
    where?: r_items_banks_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of r_items_banks_items to fetch.
     */
    orderBy?: r_items_banks_itemsOrderByWithRelationInput | r_items_banks_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for r_items_banks_items.
     */
    cursor?: r_items_banks_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` r_items_banks_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` r_items_banks_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of r_items_banks_items.
     */
    distinct?: R_items_banks_itemsScalarFieldEnum | R_items_banks_itemsScalarFieldEnum[]
  }

  /**
   * r_items_banks_items findMany
   */
  export type r_items_banks_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_items_banks_items
     */
    select?: r_items_banks_itemsSelect<ExtArgs> | null
    /**
     * Filter, which r_items_banks_items to fetch.
     */
    where?: r_items_banks_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of r_items_banks_items to fetch.
     */
    orderBy?: r_items_banks_itemsOrderByWithRelationInput | r_items_banks_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing r_items_banks_items.
     */
    cursor?: r_items_banks_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` r_items_banks_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` r_items_banks_items.
     */
    skip?: number
    distinct?: R_items_banks_itemsScalarFieldEnum | R_items_banks_itemsScalarFieldEnum[]
  }

  /**
   * r_items_banks_items create
   */
  export type r_items_banks_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_items_banks_items
     */
    select?: r_items_banks_itemsSelect<ExtArgs> | null
    /**
     * The data needed to create a r_items_banks_items.
     */
    data: XOR<r_items_banks_itemsCreateInput, r_items_banks_itemsUncheckedCreateInput>
  }

  /**
   * r_items_banks_items createMany
   */
  export type r_items_banks_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many r_items_banks_items.
     */
    data: r_items_banks_itemsCreateManyInput | r_items_banks_itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * r_items_banks_items update
   */
  export type r_items_banks_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_items_banks_items
     */
    select?: r_items_banks_itemsSelect<ExtArgs> | null
    /**
     * The data needed to update a r_items_banks_items.
     */
    data: XOR<r_items_banks_itemsUpdateInput, r_items_banks_itemsUncheckedUpdateInput>
    /**
     * Choose, which r_items_banks_items to update.
     */
    where: r_items_banks_itemsWhereUniqueInput
  }

  /**
   * r_items_banks_items updateMany
   */
  export type r_items_banks_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update r_items_banks_items.
     */
    data: XOR<r_items_banks_itemsUpdateManyMutationInput, r_items_banks_itemsUncheckedUpdateManyInput>
    /**
     * Filter which r_items_banks_items to update
     */
    where?: r_items_banks_itemsWhereInput
  }

  /**
   * r_items_banks_items upsert
   */
  export type r_items_banks_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_items_banks_items
     */
    select?: r_items_banks_itemsSelect<ExtArgs> | null
    /**
     * The filter to search for the r_items_banks_items to update in case it exists.
     */
    where: r_items_banks_itemsWhereUniqueInput
    /**
     * In case the r_items_banks_items found by the `where` argument doesn't exist, create a new r_items_banks_items with this data.
     */
    create: XOR<r_items_banks_itemsCreateInput, r_items_banks_itemsUncheckedCreateInput>
    /**
     * In case the r_items_banks_items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<r_items_banks_itemsUpdateInput, r_items_banks_itemsUncheckedUpdateInput>
  }

  /**
   * r_items_banks_items delete
   */
  export type r_items_banks_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_items_banks_items
     */
    select?: r_items_banks_itemsSelect<ExtArgs> | null
    /**
     * Filter which r_items_banks_items to delete.
     */
    where: r_items_banks_itemsWhereUniqueInput
  }

  /**
   * r_items_banks_items deleteMany
   */
  export type r_items_banks_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which r_items_banks_items to delete
     */
    where?: r_items_banks_itemsWhereInput
  }

  /**
   * r_items_banks_items without action
   */
  export type r_items_banks_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the r_items_banks_items
     */
    select?: r_items_banks_itemsSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountsScalarFieldEnum: {
    id: 'id',
    number: 'number',
    bank_id: 'bank_id',
    contractors_id: 'contractors_id'
  };

  export type AccountsScalarFieldEnum = (typeof AccountsScalarFieldEnum)[keyof typeof AccountsScalarFieldEnum]


  export const App_groupsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type App_groupsScalarFieldEnum = (typeof App_groupsScalarFieldEnum)[keyof typeof App_groupsScalarFieldEnum]


  export const ApplicationsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    active: 'active',
    type: 'type',
    path: 'path',
    description: 'description',
    app_group_id: 'app_group_id'
  };

  export type ApplicationsScalarFieldEnum = (typeof ApplicationsScalarFieldEnum)[keyof typeof ApplicationsScalarFieldEnum]


  export const BanksScalarFieldEnum: {
    id: 'id',
    name: 'name',
    city: 'city',
    bik: 'bik',
    correspondent_number: 'correspondent_number'
  };

  export type BanksScalarFieldEnum = (typeof BanksScalarFieldEnum)[keyof typeof BanksScalarFieldEnum]


  export const Banks_itemsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    order_num: 'order_num',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at',
    banks_pakets_id: 'banks_pakets_id',
    propogated_at: 'propogated_at',
    version_id: 'version_id'
  };

  export type Banks_itemsScalarFieldEnum = (typeof Banks_itemsScalarFieldEnum)[keyof typeof Banks_itemsScalarFieldEnum]


  export const Banks_paketsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    order_num: 'order_num',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at',
    propogated_at: 'propogated_at'
  };

  export type Banks_paketsScalarFieldEnum = (typeof Banks_paketsScalarFieldEnum)[keyof typeof Banks_paketsScalarFieldEnum]


  export const BlocksScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    order_num: 'order_num',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at',
    propogated_at: 'propogated_at'
  };

  export type BlocksScalarFieldEnum = (typeof BlocksScalarFieldEnum)[keyof typeof BlocksScalarFieldEnum]


  export const ContractorsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    short_name: 'short_name',
    inn: 'inn',
    kpp: 'kpp',
    ogrn: 'ogrn',
    legal_address: 'legal_address',
    actual_address: 'actual_address',
    contacts: 'contacts',
    reconciliation_link: 'reconciliation_link',
    is_active: 'is_active',
    propogated_at: 'propogated_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    phone: 'phone'
  };

  export type ContractorsScalarFieldEnum = (typeof ContractorsScalarFieldEnum)[keyof typeof ContractorsScalarFieldEnum]


  export const FloorsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    section_id: 'section_id'
  };

  export type FloorsScalarFieldEnum = (typeof FloorsScalarFieldEnum)[keyof typeof FloorsScalarFieldEnum]


  export const ItemsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    clc_code: 'clc_code',
    order_num: 'order_num',
    is_active: 'is_active',
    sub_pakets_id: 'sub_pakets_id',
    banks_items_id: 'banks_items_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    propogated_at: 'propogated_at'
  };

  export type ItemsScalarFieldEnum = (typeof ItemsScalarFieldEnum)[keyof typeof ItemsScalarFieldEnum]


  export const ObjectsScalarFieldEnum: {
    id: 'id',
    short_name: 'short_name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    entity_id: 'entity_id'
  };

  export type ObjectsScalarFieldEnum = (typeof ObjectsScalarFieldEnum)[keyof typeof ObjectsScalarFieldEnum]


  export const PaketsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    order_num: 'order_num',
    is_active: 'is_active',
    blocks_id: 'blocks_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    propogated_at: 'propogated_at'
  };

  export type PaketsScalarFieldEnum = (typeof PaketsScalarFieldEnum)[keyof typeof PaketsScalarFieldEnum]


  export const R_roles_appsScalarFieldEnum: {
    role_id: 'role_id',
    app_id: 'app_id'
  };

  export type R_roles_appsScalarFieldEnum = (typeof R_roles_appsScalarFieldEnum)[keyof typeof R_roles_appsScalarFieldEnum]


  export const R_users_client_contractorsScalarFieldEnum: {
    id: 'id',
    contractors_id: 'contractors_id',
    users_client_id: 'users_client_id'
  };

  export type R_users_client_contractorsScalarFieldEnum = (typeof R_users_client_contractorsScalarFieldEnum)[keyof typeof R_users_client_contractorsScalarFieldEnum]


  export const R_users_rolesScalarFieldEnum: {
    user_id: 'user_id',
    role_id: 'role_id'
  };

  export type R_users_rolesScalarFieldEnum = (typeof R_users_rolesScalarFieldEnum)[keyof typeof R_users_rolesScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const Roles_clientScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Roles_clientScalarFieldEnum = (typeof Roles_clientScalarFieldEnum)[keyof typeof Roles_clientScalarFieldEnum]


  export const SectionsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    object_id: 'object_id',
    created_at: 'created_at',
    updated_ad: 'updated_ad'
  };

  export type SectionsScalarFieldEnum = (typeof SectionsScalarFieldEnum)[keyof typeof SectionsScalarFieldEnum]


  export const Sub_paketsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    order_num: 'order_num',
    is_active: 'is_active',
    pakets_id: 'pakets_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    propogated_at: 'propogated_at'
  };

  export type Sub_paketsScalarFieldEnum = (typeof Sub_paketsScalarFieldEnum)[keyof typeof Sub_paketsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    password: 'password',
    email: 'email'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const Users_clientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    role_id: 'role_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Users_clientScalarFieldEnum = (typeof Users_clientScalarFieldEnum)[keyof typeof Users_clientScalarFieldEnum]


  export const Banks_items_versionsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    is_active: 'is_active',
    bank_id: 'bank_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Banks_items_versionsScalarFieldEnum = (typeof Banks_items_versionsScalarFieldEnum)[keyof typeof Banks_items_versionsScalarFieldEnum]


  export const EntitiesScalarFieldEnum: {
    id: 'id',
    str_id: 'str_id',
    name: 'name',
    short_name: 'short_name',
    display_name: 'display_name',
    inn: 'inn',
    kpp: 'kpp',
    ogrn: 'ogrn',
    db_name: 'db_name'
  };

  export type EntitiesScalarFieldEnum = (typeof EntitiesScalarFieldEnum)[keyof typeof EntitiesScalarFieldEnum]


  export const R_items_banks_itemsScalarFieldEnum: {
    item_id: 'item_id',
    bank_item_id: 'bank_item_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type R_items_banks_itemsScalarFieldEnum = (typeof R_items_banks_itemsScalarFieldEnum)[keyof typeof R_items_banks_itemsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'applications_type'
   */
  export type Enumapplications_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'applications_type'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type accountsWhereInput = {
    AND?: accountsWhereInput | accountsWhereInput[]
    OR?: accountsWhereInput[]
    NOT?: accountsWhereInput | accountsWhereInput[]
    id?: IntFilter<"accounts"> | number
    number?: StringFilter<"accounts"> | string
    bank_id?: IntFilter<"accounts"> | number
    contractors_id?: IntFilter<"accounts"> | number
    banks?: XOR<BanksRelationFilter, banksWhereInput>
    contractors?: XOR<ContractorsRelationFilter, contractorsWhereInput>
  }

  export type accountsOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    bank_id?: SortOrder
    contractors_id?: SortOrder
    banks?: banksOrderByWithRelationInput
    contractors?: contractorsOrderByWithRelationInput
  }

  export type accountsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: accountsWhereInput | accountsWhereInput[]
    OR?: accountsWhereInput[]
    NOT?: accountsWhereInput | accountsWhereInput[]
    number?: StringFilter<"accounts"> | string
    bank_id?: IntFilter<"accounts"> | number
    contractors_id?: IntFilter<"accounts"> | number
    banks?: XOR<BanksRelationFilter, banksWhereInput>
    contractors?: XOR<ContractorsRelationFilter, contractorsWhereInput>
  }, "id">

  export type accountsOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    bank_id?: SortOrder
    contractors_id?: SortOrder
    _count?: accountsCountOrderByAggregateInput
    _avg?: accountsAvgOrderByAggregateInput
    _max?: accountsMaxOrderByAggregateInput
    _min?: accountsMinOrderByAggregateInput
    _sum?: accountsSumOrderByAggregateInput
  }

  export type accountsScalarWhereWithAggregatesInput = {
    AND?: accountsScalarWhereWithAggregatesInput | accountsScalarWhereWithAggregatesInput[]
    OR?: accountsScalarWhereWithAggregatesInput[]
    NOT?: accountsScalarWhereWithAggregatesInput | accountsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"accounts"> | number
    number?: StringWithAggregatesFilter<"accounts"> | string
    bank_id?: IntWithAggregatesFilter<"accounts"> | number
    contractors_id?: IntWithAggregatesFilter<"accounts"> | number
  }

  export type app_groupsWhereInput = {
    AND?: app_groupsWhereInput | app_groupsWhereInput[]
    OR?: app_groupsWhereInput[]
    NOT?: app_groupsWhereInput | app_groupsWhereInput[]
    id?: IntFilter<"app_groups"> | number
    name?: StringFilter<"app_groups"> | string
    applications?: ApplicationsListRelationFilter
  }

  export type app_groupsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    applications?: applicationsOrderByRelationAggregateInput
  }

  export type app_groupsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: app_groupsWhereInput | app_groupsWhereInput[]
    OR?: app_groupsWhereInput[]
    NOT?: app_groupsWhereInput | app_groupsWhereInput[]
    applications?: ApplicationsListRelationFilter
  }, "id" | "name">

  export type app_groupsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: app_groupsCountOrderByAggregateInput
    _avg?: app_groupsAvgOrderByAggregateInput
    _max?: app_groupsMaxOrderByAggregateInput
    _min?: app_groupsMinOrderByAggregateInput
    _sum?: app_groupsSumOrderByAggregateInput
  }

  export type app_groupsScalarWhereWithAggregatesInput = {
    AND?: app_groupsScalarWhereWithAggregatesInput | app_groupsScalarWhereWithAggregatesInput[]
    OR?: app_groupsScalarWhereWithAggregatesInput[]
    NOT?: app_groupsScalarWhereWithAggregatesInput | app_groupsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"app_groups"> | number
    name?: StringWithAggregatesFilter<"app_groups"> | string
  }

  export type applicationsWhereInput = {
    AND?: applicationsWhereInput | applicationsWhereInput[]
    OR?: applicationsWhereInput[]
    NOT?: applicationsWhereInput | applicationsWhereInput[]
    id?: StringFilter<"applications"> | string
    name?: StringFilter<"applications"> | string
    active?: BoolNullableFilter<"applications"> | boolean | null
    type?: Enumapplications_typeFilter<"applications"> | $Enums.applications_type
    path?: StringNullableFilter<"applications"> | string | null
    description?: StringNullableFilter<"applications"> | string | null
    app_group_id?: IntFilter<"applications"> | number
    app_groups?: XOR<App_groupsRelationFilter, app_groupsWhereInput>
    r_roles_apps?: R_roles_appsListRelationFilter
  }

  export type applicationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrderInput | SortOrder
    type?: SortOrder
    path?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    app_group_id?: SortOrder
    app_groups?: app_groupsOrderByWithRelationInput
    r_roles_apps?: r_roles_appsOrderByRelationAggregateInput
  }

  export type applicationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: applicationsWhereInput | applicationsWhereInput[]
    OR?: applicationsWhereInput[]
    NOT?: applicationsWhereInput | applicationsWhereInput[]
    active?: BoolNullableFilter<"applications"> | boolean | null
    type?: Enumapplications_typeFilter<"applications"> | $Enums.applications_type
    path?: StringNullableFilter<"applications"> | string | null
    description?: StringNullableFilter<"applications"> | string | null
    app_group_id?: IntFilter<"applications"> | number
    app_groups?: XOR<App_groupsRelationFilter, app_groupsWhereInput>
    r_roles_apps?: R_roles_appsListRelationFilter
  }, "id" | "name">

  export type applicationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrderInput | SortOrder
    type?: SortOrder
    path?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    app_group_id?: SortOrder
    _count?: applicationsCountOrderByAggregateInput
    _avg?: applicationsAvgOrderByAggregateInput
    _max?: applicationsMaxOrderByAggregateInput
    _min?: applicationsMinOrderByAggregateInput
    _sum?: applicationsSumOrderByAggregateInput
  }

  export type applicationsScalarWhereWithAggregatesInput = {
    AND?: applicationsScalarWhereWithAggregatesInput | applicationsScalarWhereWithAggregatesInput[]
    OR?: applicationsScalarWhereWithAggregatesInput[]
    NOT?: applicationsScalarWhereWithAggregatesInput | applicationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"applications"> | string
    name?: StringWithAggregatesFilter<"applications"> | string
    active?: BoolNullableWithAggregatesFilter<"applications"> | boolean | null
    type?: Enumapplications_typeWithAggregatesFilter<"applications"> | $Enums.applications_type
    path?: StringNullableWithAggregatesFilter<"applications"> | string | null
    description?: StringNullableWithAggregatesFilter<"applications"> | string | null
    app_group_id?: IntWithAggregatesFilter<"applications"> | number
  }

  export type banksWhereInput = {
    AND?: banksWhereInput | banksWhereInput[]
    OR?: banksWhereInput[]
    NOT?: banksWhereInput | banksWhereInput[]
    id?: IntFilter<"banks"> | number
    name?: StringFilter<"banks"> | string
    city?: StringNullableFilter<"banks"> | string | null
    bik?: StringFilter<"banks"> | string
    correspondent_number?: StringNullableFilter<"banks"> | string | null
    accounts?: AccountsListRelationFilter
    banks_items_versions?: Banks_items_versionsListRelationFilter
  }

  export type banksOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrderInput | SortOrder
    bik?: SortOrder
    correspondent_number?: SortOrderInput | SortOrder
    accounts?: accountsOrderByRelationAggregateInput
    banks_items_versions?: banks_items_versionsOrderByRelationAggregateInput
  }

  export type banksWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bik?: string
    AND?: banksWhereInput | banksWhereInput[]
    OR?: banksWhereInput[]
    NOT?: banksWhereInput | banksWhereInput[]
    name?: StringFilter<"banks"> | string
    city?: StringNullableFilter<"banks"> | string | null
    correspondent_number?: StringNullableFilter<"banks"> | string | null
    accounts?: AccountsListRelationFilter
    banks_items_versions?: Banks_items_versionsListRelationFilter
  }, "id" | "bik">

  export type banksOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrderInput | SortOrder
    bik?: SortOrder
    correspondent_number?: SortOrderInput | SortOrder
    _count?: banksCountOrderByAggregateInput
    _avg?: banksAvgOrderByAggregateInput
    _max?: banksMaxOrderByAggregateInput
    _min?: banksMinOrderByAggregateInput
    _sum?: banksSumOrderByAggregateInput
  }

  export type banksScalarWhereWithAggregatesInput = {
    AND?: banksScalarWhereWithAggregatesInput | banksScalarWhereWithAggregatesInput[]
    OR?: banksScalarWhereWithAggregatesInput[]
    NOT?: banksScalarWhereWithAggregatesInput | banksScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"banks"> | number
    name?: StringWithAggregatesFilter<"banks"> | string
    city?: StringNullableWithAggregatesFilter<"banks"> | string | null
    bik?: StringWithAggregatesFilter<"banks"> | string
    correspondent_number?: StringNullableWithAggregatesFilter<"banks"> | string | null
  }

  export type banks_itemsWhereInput = {
    AND?: banks_itemsWhereInput | banks_itemsWhereInput[]
    OR?: banks_itemsWhereInput[]
    NOT?: banks_itemsWhereInput | banks_itemsWhereInput[]
    id?: IntFilter<"banks_items"> | number
    name?: StringFilter<"banks_items"> | string
    code?: StringFilter<"banks_items"> | string
    order_num?: IntNullableFilter<"banks_items"> | number | null
    is_active?: BoolFilter<"banks_items"> | boolean
    created_at?: DateTimeNullableFilter<"banks_items"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"banks_items"> | Date | string | null
    banks_pakets_id?: IntNullableFilter<"banks_items"> | number | null
    propogated_at?: DateTimeNullableFilter<"banks_items"> | Date | string | null
    version_id?: BigIntNullableFilter<"banks_items"> | bigint | number | null
    banks_pakets?: XOR<Banks_paketsNullableRelationFilter, banks_paketsWhereInput> | null
    banks_items_versions?: XOR<Banks_items_versionsNullableRelationFilter, banks_items_versionsWhereInput> | null
    items?: ItemsListRelationFilter
  }

  export type banks_itemsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    banks_pakets_id?: SortOrderInput | SortOrder
    propogated_at?: SortOrderInput | SortOrder
    version_id?: SortOrderInput | SortOrder
    banks_pakets?: banks_paketsOrderByWithRelationInput
    banks_items_versions?: banks_items_versionsOrderByWithRelationInput
    items?: itemsOrderByRelationAggregateInput
  }

  export type banks_itemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: banks_itemsWhereInput | banks_itemsWhereInput[]
    OR?: banks_itemsWhereInput[]
    NOT?: banks_itemsWhereInput | banks_itemsWhereInput[]
    name?: StringFilter<"banks_items"> | string
    code?: StringFilter<"banks_items"> | string
    order_num?: IntNullableFilter<"banks_items"> | number | null
    is_active?: BoolFilter<"banks_items"> | boolean
    created_at?: DateTimeNullableFilter<"banks_items"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"banks_items"> | Date | string | null
    banks_pakets_id?: IntNullableFilter<"banks_items"> | number | null
    propogated_at?: DateTimeNullableFilter<"banks_items"> | Date | string | null
    version_id?: BigIntNullableFilter<"banks_items"> | bigint | number | null
    banks_pakets?: XOR<Banks_paketsNullableRelationFilter, banks_paketsWhereInput> | null
    banks_items_versions?: XOR<Banks_items_versionsNullableRelationFilter, banks_items_versionsWhereInput> | null
    items?: ItemsListRelationFilter
  }, "id">

  export type banks_itemsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    banks_pakets_id?: SortOrderInput | SortOrder
    propogated_at?: SortOrderInput | SortOrder
    version_id?: SortOrderInput | SortOrder
    _count?: banks_itemsCountOrderByAggregateInput
    _avg?: banks_itemsAvgOrderByAggregateInput
    _max?: banks_itemsMaxOrderByAggregateInput
    _min?: banks_itemsMinOrderByAggregateInput
    _sum?: banks_itemsSumOrderByAggregateInput
  }

  export type banks_itemsScalarWhereWithAggregatesInput = {
    AND?: banks_itemsScalarWhereWithAggregatesInput | banks_itemsScalarWhereWithAggregatesInput[]
    OR?: banks_itemsScalarWhereWithAggregatesInput[]
    NOT?: banks_itemsScalarWhereWithAggregatesInput | banks_itemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"banks_items"> | number
    name?: StringWithAggregatesFilter<"banks_items"> | string
    code?: StringWithAggregatesFilter<"banks_items"> | string
    order_num?: IntNullableWithAggregatesFilter<"banks_items"> | number | null
    is_active?: BoolWithAggregatesFilter<"banks_items"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"banks_items"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"banks_items"> | Date | string | null
    banks_pakets_id?: IntNullableWithAggregatesFilter<"banks_items"> | number | null
    propogated_at?: DateTimeNullableWithAggregatesFilter<"banks_items"> | Date | string | null
    version_id?: BigIntNullableWithAggregatesFilter<"banks_items"> | bigint | number | null
  }

  export type banks_paketsWhereInput = {
    AND?: banks_paketsWhereInput | banks_paketsWhereInput[]
    OR?: banks_paketsWhereInput[]
    NOT?: banks_paketsWhereInput | banks_paketsWhereInput[]
    id?: IntFilter<"banks_pakets"> | number
    name?: StringFilter<"banks_pakets"> | string
    code?: StringFilter<"banks_pakets"> | string
    order_num?: IntNullableFilter<"banks_pakets"> | number | null
    is_active?: BoolFilter<"banks_pakets"> | boolean
    created_at?: DateTimeNullableFilter<"banks_pakets"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"banks_pakets"> | Date | string | null
    propogated_at?: DateTimeNullableFilter<"banks_pakets"> | Date | string | null
    banks_items?: Banks_itemsListRelationFilter
  }

  export type banks_paketsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    propogated_at?: SortOrderInput | SortOrder
    banks_items?: banks_itemsOrderByRelationAggregateInput
  }

  export type banks_paketsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: banks_paketsWhereInput | banks_paketsWhereInput[]
    OR?: banks_paketsWhereInput[]
    NOT?: banks_paketsWhereInput | banks_paketsWhereInput[]
    name?: StringFilter<"banks_pakets"> | string
    code?: StringFilter<"banks_pakets"> | string
    order_num?: IntNullableFilter<"banks_pakets"> | number | null
    is_active?: BoolFilter<"banks_pakets"> | boolean
    created_at?: DateTimeNullableFilter<"banks_pakets"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"banks_pakets"> | Date | string | null
    propogated_at?: DateTimeNullableFilter<"banks_pakets"> | Date | string | null
    banks_items?: Banks_itemsListRelationFilter
  }, "id">

  export type banks_paketsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    propogated_at?: SortOrderInput | SortOrder
    _count?: banks_paketsCountOrderByAggregateInput
    _avg?: banks_paketsAvgOrderByAggregateInput
    _max?: banks_paketsMaxOrderByAggregateInput
    _min?: banks_paketsMinOrderByAggregateInput
    _sum?: banks_paketsSumOrderByAggregateInput
  }

  export type banks_paketsScalarWhereWithAggregatesInput = {
    AND?: banks_paketsScalarWhereWithAggregatesInput | banks_paketsScalarWhereWithAggregatesInput[]
    OR?: banks_paketsScalarWhereWithAggregatesInput[]
    NOT?: banks_paketsScalarWhereWithAggregatesInput | banks_paketsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"banks_pakets"> | number
    name?: StringWithAggregatesFilter<"banks_pakets"> | string
    code?: StringWithAggregatesFilter<"banks_pakets"> | string
    order_num?: IntNullableWithAggregatesFilter<"banks_pakets"> | number | null
    is_active?: BoolWithAggregatesFilter<"banks_pakets"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"banks_pakets"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"banks_pakets"> | Date | string | null
    propogated_at?: DateTimeNullableWithAggregatesFilter<"banks_pakets"> | Date | string | null
  }

  export type blocksWhereInput = {
    AND?: blocksWhereInput | blocksWhereInput[]
    OR?: blocksWhereInput[]
    NOT?: blocksWhereInput | blocksWhereInput[]
    id?: IntFilter<"blocks"> | number
    name?: StringFilter<"blocks"> | string
    code?: StringFilter<"blocks"> | string
    order_num?: IntNullableFilter<"blocks"> | number | null
    is_active?: BoolFilter<"blocks"> | boolean
    created_at?: DateTimeNullableFilter<"blocks"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"blocks"> | Date | string | null
    propogated_at?: DateTimeNullableFilter<"blocks"> | Date | string | null
    pakets?: PaketsListRelationFilter
  }

  export type blocksOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    propogated_at?: SortOrderInput | SortOrder
    pakets?: paketsOrderByRelationAggregateInput
  }

  export type blocksWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: blocksWhereInput | blocksWhereInput[]
    OR?: blocksWhereInput[]
    NOT?: blocksWhereInput | blocksWhereInput[]
    code?: StringFilter<"blocks"> | string
    order_num?: IntNullableFilter<"blocks"> | number | null
    is_active?: BoolFilter<"blocks"> | boolean
    created_at?: DateTimeNullableFilter<"blocks"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"blocks"> | Date | string | null
    propogated_at?: DateTimeNullableFilter<"blocks"> | Date | string | null
    pakets?: PaketsListRelationFilter
  }, "id" | "name">

  export type blocksOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    propogated_at?: SortOrderInput | SortOrder
    _count?: blocksCountOrderByAggregateInput
    _avg?: blocksAvgOrderByAggregateInput
    _max?: blocksMaxOrderByAggregateInput
    _min?: blocksMinOrderByAggregateInput
    _sum?: blocksSumOrderByAggregateInput
  }

  export type blocksScalarWhereWithAggregatesInput = {
    AND?: blocksScalarWhereWithAggregatesInput | blocksScalarWhereWithAggregatesInput[]
    OR?: blocksScalarWhereWithAggregatesInput[]
    NOT?: blocksScalarWhereWithAggregatesInput | blocksScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"blocks"> | number
    name?: StringWithAggregatesFilter<"blocks"> | string
    code?: StringWithAggregatesFilter<"blocks"> | string
    order_num?: IntNullableWithAggregatesFilter<"blocks"> | number | null
    is_active?: BoolWithAggregatesFilter<"blocks"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"blocks"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"blocks"> | Date | string | null
    propogated_at?: DateTimeNullableWithAggregatesFilter<"blocks"> | Date | string | null
  }

  export type contractorsWhereInput = {
    AND?: contractorsWhereInput | contractorsWhereInput[]
    OR?: contractorsWhereInput[]
    NOT?: contractorsWhereInput | contractorsWhereInput[]
    id?: IntFilter<"contractors"> | number
    name?: StringFilter<"contractors"> | string
    short_name?: StringNullableFilter<"contractors"> | string | null
    inn?: StringNullableFilter<"contractors"> | string | null
    kpp?: StringNullableFilter<"contractors"> | string | null
    ogrn?: StringNullableFilter<"contractors"> | string | null
    legal_address?: StringNullableFilter<"contractors"> | string | null
    actual_address?: StringNullableFilter<"contractors"> | string | null
    contacts?: StringNullableFilter<"contractors"> | string | null
    reconciliation_link?: StringNullableFilter<"contractors"> | string | null
    is_active?: BoolFilter<"contractors"> | boolean
    propogated_at?: DateTimeNullableFilter<"contractors"> | Date | string | null
    created_at?: DateTimeNullableFilter<"contractors"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"contractors"> | Date | string | null
    phone?: StringNullableFilter<"contractors"> | string | null
    accounts?: AccountsListRelationFilter
    r_users_client_contractors?: R_users_client_contractorsListRelationFilter
  }

  export type contractorsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    short_name?: SortOrderInput | SortOrder
    inn?: SortOrderInput | SortOrder
    kpp?: SortOrderInput | SortOrder
    ogrn?: SortOrderInput | SortOrder
    legal_address?: SortOrderInput | SortOrder
    actual_address?: SortOrderInput | SortOrder
    contacts?: SortOrderInput | SortOrder
    reconciliation_link?: SortOrderInput | SortOrder
    is_active?: SortOrder
    propogated_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    accounts?: accountsOrderByRelationAggregateInput
    r_users_client_contractors?: r_users_client_contractorsOrderByRelationAggregateInput
  }

  export type contractorsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: contractorsWhereInput | contractorsWhereInput[]
    OR?: contractorsWhereInput[]
    NOT?: contractorsWhereInput | contractorsWhereInput[]
    name?: StringFilter<"contractors"> | string
    short_name?: StringNullableFilter<"contractors"> | string | null
    inn?: StringNullableFilter<"contractors"> | string | null
    kpp?: StringNullableFilter<"contractors"> | string | null
    ogrn?: StringNullableFilter<"contractors"> | string | null
    legal_address?: StringNullableFilter<"contractors"> | string | null
    actual_address?: StringNullableFilter<"contractors"> | string | null
    contacts?: StringNullableFilter<"contractors"> | string | null
    reconciliation_link?: StringNullableFilter<"contractors"> | string | null
    is_active?: BoolFilter<"contractors"> | boolean
    propogated_at?: DateTimeNullableFilter<"contractors"> | Date | string | null
    created_at?: DateTimeNullableFilter<"contractors"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"contractors"> | Date | string | null
    phone?: StringNullableFilter<"contractors"> | string | null
    accounts?: AccountsListRelationFilter
    r_users_client_contractors?: R_users_client_contractorsListRelationFilter
  }, "id">

  export type contractorsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    short_name?: SortOrderInput | SortOrder
    inn?: SortOrderInput | SortOrder
    kpp?: SortOrderInput | SortOrder
    ogrn?: SortOrderInput | SortOrder
    legal_address?: SortOrderInput | SortOrder
    actual_address?: SortOrderInput | SortOrder
    contacts?: SortOrderInput | SortOrder
    reconciliation_link?: SortOrderInput | SortOrder
    is_active?: SortOrder
    propogated_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    _count?: contractorsCountOrderByAggregateInput
    _avg?: contractorsAvgOrderByAggregateInput
    _max?: contractorsMaxOrderByAggregateInput
    _min?: contractorsMinOrderByAggregateInput
    _sum?: contractorsSumOrderByAggregateInput
  }

  export type contractorsScalarWhereWithAggregatesInput = {
    AND?: contractorsScalarWhereWithAggregatesInput | contractorsScalarWhereWithAggregatesInput[]
    OR?: contractorsScalarWhereWithAggregatesInput[]
    NOT?: contractorsScalarWhereWithAggregatesInput | contractorsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"contractors"> | number
    name?: StringWithAggregatesFilter<"contractors"> | string
    short_name?: StringNullableWithAggregatesFilter<"contractors"> | string | null
    inn?: StringNullableWithAggregatesFilter<"contractors"> | string | null
    kpp?: StringNullableWithAggregatesFilter<"contractors"> | string | null
    ogrn?: StringNullableWithAggregatesFilter<"contractors"> | string | null
    legal_address?: StringNullableWithAggregatesFilter<"contractors"> | string | null
    actual_address?: StringNullableWithAggregatesFilter<"contractors"> | string | null
    contacts?: StringNullableWithAggregatesFilter<"contractors"> | string | null
    reconciliation_link?: StringNullableWithAggregatesFilter<"contractors"> | string | null
    is_active?: BoolWithAggregatesFilter<"contractors"> | boolean
    propogated_at?: DateTimeNullableWithAggregatesFilter<"contractors"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"contractors"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"contractors"> | Date | string | null
    phone?: StringNullableWithAggregatesFilter<"contractors"> | string | null
  }

  export type floorsWhereInput = {
    AND?: floorsWhereInput | floorsWhereInput[]
    OR?: floorsWhereInput[]
    NOT?: floorsWhereInput | floorsWhereInput[]
    id?: IntFilter<"floors"> | number
    name?: StringFilter<"floors"> | string
    created_at?: DateTimeNullableFilter<"floors"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"floors"> | Date | string | null
    section_id?: IntFilter<"floors"> | number
  }

  export type floorsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    section_id?: SortOrder
  }

  export type floorsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: floorsWhereInput | floorsWhereInput[]
    OR?: floorsWhereInput[]
    NOT?: floorsWhereInput | floorsWhereInput[]
    name?: StringFilter<"floors"> | string
    created_at?: DateTimeNullableFilter<"floors"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"floors"> | Date | string | null
    section_id?: IntFilter<"floors"> | number
  }, "id">

  export type floorsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    section_id?: SortOrder
    _count?: floorsCountOrderByAggregateInput
    _avg?: floorsAvgOrderByAggregateInput
    _max?: floorsMaxOrderByAggregateInput
    _min?: floorsMinOrderByAggregateInput
    _sum?: floorsSumOrderByAggregateInput
  }

  export type floorsScalarWhereWithAggregatesInput = {
    AND?: floorsScalarWhereWithAggregatesInput | floorsScalarWhereWithAggregatesInput[]
    OR?: floorsScalarWhereWithAggregatesInput[]
    NOT?: floorsScalarWhereWithAggregatesInput | floorsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"floors"> | number
    name?: StringWithAggregatesFilter<"floors"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"floors"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"floors"> | Date | string | null
    section_id?: IntWithAggregatesFilter<"floors"> | number
  }

  export type itemsWhereInput = {
    AND?: itemsWhereInput | itemsWhereInput[]
    OR?: itemsWhereInput[]
    NOT?: itemsWhereInput | itemsWhereInput[]
    id?: IntFilter<"items"> | number
    name?: StringFilter<"items"> | string
    code?: StringFilter<"items"> | string
    clc_code?: StringNullableFilter<"items"> | string | null
    order_num?: IntNullableFilter<"items"> | number | null
    is_active?: BoolFilter<"items"> | boolean
    sub_pakets_id?: IntFilter<"items"> | number
    banks_items_id?: IntNullableFilter<"items"> | number | null
    created_at?: DateTimeNullableFilter<"items"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"items"> | Date | string | null
    propogated_at?: DateTimeNullableFilter<"items"> | Date | string | null
    sub_pakets?: XOR<Sub_paketsRelationFilter, sub_paketsWhereInput>
    banks_items?: XOR<Banks_itemsNullableRelationFilter, banks_itemsWhereInput> | null
  }

  export type itemsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    clc_code?: SortOrderInput | SortOrder
    order_num?: SortOrderInput | SortOrder
    is_active?: SortOrder
    sub_pakets_id?: SortOrder
    banks_items_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    propogated_at?: SortOrderInput | SortOrder
    sub_pakets?: sub_paketsOrderByWithRelationInput
    banks_items?: banks_itemsOrderByWithRelationInput
  }

  export type itemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: itemsWhereInput | itemsWhereInput[]
    OR?: itemsWhereInput[]
    NOT?: itemsWhereInput | itemsWhereInput[]
    name?: StringFilter<"items"> | string
    clc_code?: StringNullableFilter<"items"> | string | null
    order_num?: IntNullableFilter<"items"> | number | null
    is_active?: BoolFilter<"items"> | boolean
    sub_pakets_id?: IntFilter<"items"> | number
    banks_items_id?: IntNullableFilter<"items"> | number | null
    created_at?: DateTimeNullableFilter<"items"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"items"> | Date | string | null
    propogated_at?: DateTimeNullableFilter<"items"> | Date | string | null
    sub_pakets?: XOR<Sub_paketsRelationFilter, sub_paketsWhereInput>
    banks_items?: XOR<Banks_itemsNullableRelationFilter, banks_itemsWhereInput> | null
  }, "id" | "code">

  export type itemsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    clc_code?: SortOrderInput | SortOrder
    order_num?: SortOrderInput | SortOrder
    is_active?: SortOrder
    sub_pakets_id?: SortOrder
    banks_items_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    propogated_at?: SortOrderInput | SortOrder
    _count?: itemsCountOrderByAggregateInput
    _avg?: itemsAvgOrderByAggregateInput
    _max?: itemsMaxOrderByAggregateInput
    _min?: itemsMinOrderByAggregateInput
    _sum?: itemsSumOrderByAggregateInput
  }

  export type itemsScalarWhereWithAggregatesInput = {
    AND?: itemsScalarWhereWithAggregatesInput | itemsScalarWhereWithAggregatesInput[]
    OR?: itemsScalarWhereWithAggregatesInput[]
    NOT?: itemsScalarWhereWithAggregatesInput | itemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"items"> | number
    name?: StringWithAggregatesFilter<"items"> | string
    code?: StringWithAggregatesFilter<"items"> | string
    clc_code?: StringNullableWithAggregatesFilter<"items"> | string | null
    order_num?: IntNullableWithAggregatesFilter<"items"> | number | null
    is_active?: BoolWithAggregatesFilter<"items"> | boolean
    sub_pakets_id?: IntWithAggregatesFilter<"items"> | number
    banks_items_id?: IntNullableWithAggregatesFilter<"items"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"items"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"items"> | Date | string | null
    propogated_at?: DateTimeNullableWithAggregatesFilter<"items"> | Date | string | null
  }

  export type objectsWhereInput = {
    AND?: objectsWhereInput | objectsWhereInput[]
    OR?: objectsWhereInput[]
    NOT?: objectsWhereInput | objectsWhereInput[]
    id?: IntFilter<"objects"> | number
    short_name?: StringFilter<"objects"> | string
    created_at?: DateTimeNullableFilter<"objects"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"objects"> | Date | string | null
    entity_id?: IntFilter<"objects"> | number
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    sections?: SectionsListRelationFilter
  }

  export type objectsOrderByWithRelationInput = {
    id?: SortOrder
    short_name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    entity_id?: SortOrder
    entities?: entitiesOrderByWithRelationInput
    sections?: sectionsOrderByRelationAggregateInput
  }

  export type objectsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: objectsWhereInput | objectsWhereInput[]
    OR?: objectsWhereInput[]
    NOT?: objectsWhereInput | objectsWhereInput[]
    short_name?: StringFilter<"objects"> | string
    created_at?: DateTimeNullableFilter<"objects"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"objects"> | Date | string | null
    entity_id?: IntFilter<"objects"> | number
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    sections?: SectionsListRelationFilter
  }, "id">

  export type objectsOrderByWithAggregationInput = {
    id?: SortOrder
    short_name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    entity_id?: SortOrder
    _count?: objectsCountOrderByAggregateInput
    _avg?: objectsAvgOrderByAggregateInput
    _max?: objectsMaxOrderByAggregateInput
    _min?: objectsMinOrderByAggregateInput
    _sum?: objectsSumOrderByAggregateInput
  }

  export type objectsScalarWhereWithAggregatesInput = {
    AND?: objectsScalarWhereWithAggregatesInput | objectsScalarWhereWithAggregatesInput[]
    OR?: objectsScalarWhereWithAggregatesInput[]
    NOT?: objectsScalarWhereWithAggregatesInput | objectsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"objects"> | number
    short_name?: StringWithAggregatesFilter<"objects"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"objects"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"objects"> | Date | string | null
    entity_id?: IntWithAggregatesFilter<"objects"> | number
  }

  export type paketsWhereInput = {
    AND?: paketsWhereInput | paketsWhereInput[]
    OR?: paketsWhereInput[]
    NOT?: paketsWhereInput | paketsWhereInput[]
    id?: IntFilter<"pakets"> | number
    name?: StringFilter<"pakets"> | string
    code?: StringFilter<"pakets"> | string
    order_num?: IntNullableFilter<"pakets"> | number | null
    is_active?: BoolFilter<"pakets"> | boolean
    blocks_id?: IntFilter<"pakets"> | number
    created_at?: DateTimeNullableFilter<"pakets"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"pakets"> | Date | string | null
    propogated_at?: DateTimeNullableFilter<"pakets"> | Date | string | null
    blocks?: XOR<BlocksRelationFilter, blocksWhereInput>
    sub_pakets?: Sub_paketsListRelationFilter
  }

  export type paketsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrderInput | SortOrder
    is_active?: SortOrder
    blocks_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    propogated_at?: SortOrderInput | SortOrder
    blocks?: blocksOrderByWithRelationInput
    sub_pakets?: sub_paketsOrderByRelationAggregateInput
  }

  export type paketsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: paketsWhereInput | paketsWhereInput[]
    OR?: paketsWhereInput[]
    NOT?: paketsWhereInput | paketsWhereInput[]
    name?: StringFilter<"pakets"> | string
    code?: StringFilter<"pakets"> | string
    order_num?: IntNullableFilter<"pakets"> | number | null
    is_active?: BoolFilter<"pakets"> | boolean
    blocks_id?: IntFilter<"pakets"> | number
    created_at?: DateTimeNullableFilter<"pakets"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"pakets"> | Date | string | null
    propogated_at?: DateTimeNullableFilter<"pakets"> | Date | string | null
    blocks?: XOR<BlocksRelationFilter, blocksWhereInput>
    sub_pakets?: Sub_paketsListRelationFilter
  }, "id">

  export type paketsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrderInput | SortOrder
    is_active?: SortOrder
    blocks_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    propogated_at?: SortOrderInput | SortOrder
    _count?: paketsCountOrderByAggregateInput
    _avg?: paketsAvgOrderByAggregateInput
    _max?: paketsMaxOrderByAggregateInput
    _min?: paketsMinOrderByAggregateInput
    _sum?: paketsSumOrderByAggregateInput
  }

  export type paketsScalarWhereWithAggregatesInput = {
    AND?: paketsScalarWhereWithAggregatesInput | paketsScalarWhereWithAggregatesInput[]
    OR?: paketsScalarWhereWithAggregatesInput[]
    NOT?: paketsScalarWhereWithAggregatesInput | paketsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pakets"> | number
    name?: StringWithAggregatesFilter<"pakets"> | string
    code?: StringWithAggregatesFilter<"pakets"> | string
    order_num?: IntNullableWithAggregatesFilter<"pakets"> | number | null
    is_active?: BoolWithAggregatesFilter<"pakets"> | boolean
    blocks_id?: IntWithAggregatesFilter<"pakets"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"pakets"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"pakets"> | Date | string | null
    propogated_at?: DateTimeNullableWithAggregatesFilter<"pakets"> | Date | string | null
  }

  export type r_roles_appsWhereInput = {
    AND?: r_roles_appsWhereInput | r_roles_appsWhereInput[]
    OR?: r_roles_appsWhereInput[]
    NOT?: r_roles_appsWhereInput | r_roles_appsWhereInput[]
    role_id?: IntFilter<"r_roles_apps"> | number
    app_id?: StringFilter<"r_roles_apps"> | string
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
    applications?: XOR<ApplicationsRelationFilter, applicationsWhereInput>
  }

  export type r_roles_appsOrderByWithRelationInput = {
    role_id?: SortOrder
    app_id?: SortOrder
    roles?: rolesOrderByWithRelationInput
    applications?: applicationsOrderByWithRelationInput
  }

  export type r_roles_appsWhereUniqueInput = Prisma.AtLeast<{
    role_id_app_id?: r_roles_appsRole_idApp_idCompoundUniqueInput
    AND?: r_roles_appsWhereInput | r_roles_appsWhereInput[]
    OR?: r_roles_appsWhereInput[]
    NOT?: r_roles_appsWhereInput | r_roles_appsWhereInput[]
    role_id?: IntFilter<"r_roles_apps"> | number
    app_id?: StringFilter<"r_roles_apps"> | string
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
    applications?: XOR<ApplicationsRelationFilter, applicationsWhereInput>
  }, "role_id_app_id">

  export type r_roles_appsOrderByWithAggregationInput = {
    role_id?: SortOrder
    app_id?: SortOrder
    _count?: r_roles_appsCountOrderByAggregateInput
    _avg?: r_roles_appsAvgOrderByAggregateInput
    _max?: r_roles_appsMaxOrderByAggregateInput
    _min?: r_roles_appsMinOrderByAggregateInput
    _sum?: r_roles_appsSumOrderByAggregateInput
  }

  export type r_roles_appsScalarWhereWithAggregatesInput = {
    AND?: r_roles_appsScalarWhereWithAggregatesInput | r_roles_appsScalarWhereWithAggregatesInput[]
    OR?: r_roles_appsScalarWhereWithAggregatesInput[]
    NOT?: r_roles_appsScalarWhereWithAggregatesInput | r_roles_appsScalarWhereWithAggregatesInput[]
    role_id?: IntWithAggregatesFilter<"r_roles_apps"> | number
    app_id?: StringWithAggregatesFilter<"r_roles_apps"> | string
  }

  export type r_users_client_contractorsWhereInput = {
    AND?: r_users_client_contractorsWhereInput | r_users_client_contractorsWhereInput[]
    OR?: r_users_client_contractorsWhereInput[]
    NOT?: r_users_client_contractorsWhereInput | r_users_client_contractorsWhereInput[]
    id?: IntFilter<"r_users_client_contractors"> | number
    contractors_id?: IntFilter<"r_users_client_contractors"> | number
    users_client_id?: IntFilter<"r_users_client_contractors"> | number
    contractors?: XOR<ContractorsRelationFilter, contractorsWhereInput>
    users_client?: XOR<Users_clientRelationFilter, users_clientWhereInput>
  }

  export type r_users_client_contractorsOrderByWithRelationInput = {
    id?: SortOrder
    contractors_id?: SortOrder
    users_client_id?: SortOrder
    contractors?: contractorsOrderByWithRelationInput
    users_client?: users_clientOrderByWithRelationInput
  }

  export type r_users_client_contractorsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: r_users_client_contractorsWhereInput | r_users_client_contractorsWhereInput[]
    OR?: r_users_client_contractorsWhereInput[]
    NOT?: r_users_client_contractorsWhereInput | r_users_client_contractorsWhereInput[]
    contractors_id?: IntFilter<"r_users_client_contractors"> | number
    users_client_id?: IntFilter<"r_users_client_contractors"> | number
    contractors?: XOR<ContractorsRelationFilter, contractorsWhereInput>
    users_client?: XOR<Users_clientRelationFilter, users_clientWhereInput>
  }, "id">

  export type r_users_client_contractorsOrderByWithAggregationInput = {
    id?: SortOrder
    contractors_id?: SortOrder
    users_client_id?: SortOrder
    _count?: r_users_client_contractorsCountOrderByAggregateInput
    _avg?: r_users_client_contractorsAvgOrderByAggregateInput
    _max?: r_users_client_contractorsMaxOrderByAggregateInput
    _min?: r_users_client_contractorsMinOrderByAggregateInput
    _sum?: r_users_client_contractorsSumOrderByAggregateInput
  }

  export type r_users_client_contractorsScalarWhereWithAggregatesInput = {
    AND?: r_users_client_contractorsScalarWhereWithAggregatesInput | r_users_client_contractorsScalarWhereWithAggregatesInput[]
    OR?: r_users_client_contractorsScalarWhereWithAggregatesInput[]
    NOT?: r_users_client_contractorsScalarWhereWithAggregatesInput | r_users_client_contractorsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"r_users_client_contractors"> | number
    contractors_id?: IntWithAggregatesFilter<"r_users_client_contractors"> | number
    users_client_id?: IntWithAggregatesFilter<"r_users_client_contractors"> | number
  }

  export type r_users_rolesWhereInput = {
    AND?: r_users_rolesWhereInput | r_users_rolesWhereInput[]
    OR?: r_users_rolesWhereInput[]
    NOT?: r_users_rolesWhereInput | r_users_rolesWhereInput[]
    user_id?: IntFilter<"r_users_roles"> | number
    role_id?: IntFilter<"r_users_roles"> | number
    users?: XOR<UsersRelationFilter, usersWhereInput>
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
  }

  export type r_users_rolesOrderByWithRelationInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    users?: usersOrderByWithRelationInput
    roles?: rolesOrderByWithRelationInput
  }

  export type r_users_rolesWhereUniqueInput = Prisma.AtLeast<{
    user_id_role_id?: r_users_rolesUser_idRole_idCompoundUniqueInput
    AND?: r_users_rolesWhereInput | r_users_rolesWhereInput[]
    OR?: r_users_rolesWhereInput[]
    NOT?: r_users_rolesWhereInput | r_users_rolesWhereInput[]
    user_id?: IntFilter<"r_users_roles"> | number
    role_id?: IntFilter<"r_users_roles"> | number
    users?: XOR<UsersRelationFilter, usersWhereInput>
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
  }, "user_id_role_id">

  export type r_users_rolesOrderByWithAggregationInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    _count?: r_users_rolesCountOrderByAggregateInput
    _avg?: r_users_rolesAvgOrderByAggregateInput
    _max?: r_users_rolesMaxOrderByAggregateInput
    _min?: r_users_rolesMinOrderByAggregateInput
    _sum?: r_users_rolesSumOrderByAggregateInput
  }

  export type r_users_rolesScalarWhereWithAggregatesInput = {
    AND?: r_users_rolesScalarWhereWithAggregatesInput | r_users_rolesScalarWhereWithAggregatesInput[]
    OR?: r_users_rolesScalarWhereWithAggregatesInput[]
    NOT?: r_users_rolesScalarWhereWithAggregatesInput | r_users_rolesScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"r_users_roles"> | number
    role_id?: IntWithAggregatesFilter<"r_users_roles"> | number
  }

  export type rolesWhereInput = {
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    id?: IntFilter<"roles"> | number
    name?: StringFilter<"roles"> | string
    r_roles_apps?: R_roles_appsListRelationFilter
    r_users_roles?: R_users_rolesListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    r_roles_apps?: r_roles_appsOrderByRelationAggregateInput
    r_users_roles?: r_users_rolesOrderByRelationAggregateInput
  }

  export type rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    r_roles_apps?: R_roles_appsListRelationFilter
    r_users_roles?: R_users_rolesListRelationFilter
  }, "id" | "name">

  export type rolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    OR?: rolesScalarWhereWithAggregatesInput[]
    NOT?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"roles"> | number
    name?: StringWithAggregatesFilter<"roles"> | string
  }

  export type roles_clientWhereInput = {
    AND?: roles_clientWhereInput | roles_clientWhereInput[]
    OR?: roles_clientWhereInput[]
    NOT?: roles_clientWhereInput | roles_clientWhereInput[]
    id?: IntFilter<"roles_client"> | number
    name?: StringFilter<"roles_client"> | string
    users_client?: Users_clientListRelationFilter
  }

  export type roles_clientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    users_client?: users_clientOrderByRelationAggregateInput
  }

  export type roles_clientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: roles_clientWhereInput | roles_clientWhereInput[]
    OR?: roles_clientWhereInput[]
    NOT?: roles_clientWhereInput | roles_clientWhereInput[]
    users_client?: Users_clientListRelationFilter
  }, "id" | "name">

  export type roles_clientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: roles_clientCountOrderByAggregateInput
    _avg?: roles_clientAvgOrderByAggregateInput
    _max?: roles_clientMaxOrderByAggregateInput
    _min?: roles_clientMinOrderByAggregateInput
    _sum?: roles_clientSumOrderByAggregateInput
  }

  export type roles_clientScalarWhereWithAggregatesInput = {
    AND?: roles_clientScalarWhereWithAggregatesInput | roles_clientScalarWhereWithAggregatesInput[]
    OR?: roles_clientScalarWhereWithAggregatesInput[]
    NOT?: roles_clientScalarWhereWithAggregatesInput | roles_clientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"roles_client"> | number
    name?: StringWithAggregatesFilter<"roles_client"> | string
  }

  export type sectionsWhereInput = {
    AND?: sectionsWhereInput | sectionsWhereInput[]
    OR?: sectionsWhereInput[]
    NOT?: sectionsWhereInput | sectionsWhereInput[]
    id?: IntFilter<"sections"> | number
    name?: StringFilter<"sections"> | string
    object_id?: IntFilter<"sections"> | number
    created_at?: DateTimeNullableFilter<"sections"> | Date | string | null
    updated_ad?: DateTimeNullableFilter<"sections"> | Date | string | null
    objects?: XOR<ObjectsRelationFilter, objectsWhereInput>
  }

  export type sectionsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    object_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_ad?: SortOrderInput | SortOrder
    objects?: objectsOrderByWithRelationInput
  }

  export type sectionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: sectionsWhereInput | sectionsWhereInput[]
    OR?: sectionsWhereInput[]
    NOT?: sectionsWhereInput | sectionsWhereInput[]
    name?: StringFilter<"sections"> | string
    object_id?: IntFilter<"sections"> | number
    created_at?: DateTimeNullableFilter<"sections"> | Date | string | null
    updated_ad?: DateTimeNullableFilter<"sections"> | Date | string | null
    objects?: XOR<ObjectsRelationFilter, objectsWhereInput>
  }, "id">

  export type sectionsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    object_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_ad?: SortOrderInput | SortOrder
    _count?: sectionsCountOrderByAggregateInput
    _avg?: sectionsAvgOrderByAggregateInput
    _max?: sectionsMaxOrderByAggregateInput
    _min?: sectionsMinOrderByAggregateInput
    _sum?: sectionsSumOrderByAggregateInput
  }

  export type sectionsScalarWhereWithAggregatesInput = {
    AND?: sectionsScalarWhereWithAggregatesInput | sectionsScalarWhereWithAggregatesInput[]
    OR?: sectionsScalarWhereWithAggregatesInput[]
    NOT?: sectionsScalarWhereWithAggregatesInput | sectionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sections"> | number
    name?: StringWithAggregatesFilter<"sections"> | string
    object_id?: IntWithAggregatesFilter<"sections"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"sections"> | Date | string | null
    updated_ad?: DateTimeNullableWithAggregatesFilter<"sections"> | Date | string | null
  }

  export type sub_paketsWhereInput = {
    AND?: sub_paketsWhereInput | sub_paketsWhereInput[]
    OR?: sub_paketsWhereInput[]
    NOT?: sub_paketsWhereInput | sub_paketsWhereInput[]
    id?: IntFilter<"sub_pakets"> | number
    name?: StringFilter<"sub_pakets"> | string
    code?: StringFilter<"sub_pakets"> | string
    order_num?: IntNullableFilter<"sub_pakets"> | number | null
    is_active?: BoolFilter<"sub_pakets"> | boolean
    pakets_id?: IntFilter<"sub_pakets"> | number
    created_at?: DateTimeNullableFilter<"sub_pakets"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"sub_pakets"> | Date | string | null
    propogated_at?: DateTimeNullableFilter<"sub_pakets"> | Date | string | null
    items?: ItemsListRelationFilter
    pakets?: XOR<PaketsRelationFilter, paketsWhereInput>
  }

  export type sub_paketsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrderInput | SortOrder
    is_active?: SortOrder
    pakets_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    propogated_at?: SortOrderInput | SortOrder
    items?: itemsOrderByRelationAggregateInput
    pakets?: paketsOrderByWithRelationInput
  }

  export type sub_paketsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: sub_paketsWhereInput | sub_paketsWhereInput[]
    OR?: sub_paketsWhereInput[]
    NOT?: sub_paketsWhereInput | sub_paketsWhereInput[]
    name?: StringFilter<"sub_pakets"> | string
    code?: StringFilter<"sub_pakets"> | string
    order_num?: IntNullableFilter<"sub_pakets"> | number | null
    is_active?: BoolFilter<"sub_pakets"> | boolean
    pakets_id?: IntFilter<"sub_pakets"> | number
    created_at?: DateTimeNullableFilter<"sub_pakets"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"sub_pakets"> | Date | string | null
    propogated_at?: DateTimeNullableFilter<"sub_pakets"> | Date | string | null
    items?: ItemsListRelationFilter
    pakets?: XOR<PaketsRelationFilter, paketsWhereInput>
  }, "id">

  export type sub_paketsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrderInput | SortOrder
    is_active?: SortOrder
    pakets_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    propogated_at?: SortOrderInput | SortOrder
    _count?: sub_paketsCountOrderByAggregateInput
    _avg?: sub_paketsAvgOrderByAggregateInput
    _max?: sub_paketsMaxOrderByAggregateInput
    _min?: sub_paketsMinOrderByAggregateInput
    _sum?: sub_paketsSumOrderByAggregateInput
  }

  export type sub_paketsScalarWhereWithAggregatesInput = {
    AND?: sub_paketsScalarWhereWithAggregatesInput | sub_paketsScalarWhereWithAggregatesInput[]
    OR?: sub_paketsScalarWhereWithAggregatesInput[]
    NOT?: sub_paketsScalarWhereWithAggregatesInput | sub_paketsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sub_pakets"> | number
    name?: StringWithAggregatesFilter<"sub_pakets"> | string
    code?: StringWithAggregatesFilter<"sub_pakets"> | string
    order_num?: IntNullableWithAggregatesFilter<"sub_pakets"> | number | null
    is_active?: BoolWithAggregatesFilter<"sub_pakets"> | boolean
    pakets_id?: IntWithAggregatesFilter<"sub_pakets"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"sub_pakets"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"sub_pakets"> | Date | string | null
    propogated_at?: DateTimeNullableWithAggregatesFilter<"sub_pakets"> | Date | string | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    name?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    r_users_roles?: R_users_rolesListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    email?: SortOrder
    r_users_roles?: r_users_rolesOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    password?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringFilter<"users"> | string
    r_users_roles?: R_users_rolesListRelationFilter
  }, "id" | "password" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    email?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    name?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
  }

  export type users_clientWhereInput = {
    AND?: users_clientWhereInput | users_clientWhereInput[]
    OR?: users_clientWhereInput[]
    NOT?: users_clientWhereInput | users_clientWhereInput[]
    id?: IntFilter<"users_client"> | number
    name?: StringFilter<"users_client"> | string
    email?: StringFilter<"users_client"> | string
    phone?: StringFilter<"users_client"> | string
    role_id?: IntFilter<"users_client"> | number
    created_at?: DateTimeFilter<"users_client"> | Date | string
    updated_at?: DateTimeFilter<"users_client"> | Date | string
    deleted_at?: DateTimeNullableFilter<"users_client"> | Date | string | null
    r_users_client_contractors?: R_users_client_contractorsListRelationFilter
    roles_client?: XOR<Roles_clientRelationFilter, roles_clientWhereInput>
  }

  export type users_clientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    r_users_client_contractors?: r_users_client_contractorsOrderByRelationAggregateInput
    roles_client?: roles_clientOrderByWithRelationInput
  }

  export type users_clientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: users_clientWhereInput | users_clientWhereInput[]
    OR?: users_clientWhereInput[]
    NOT?: users_clientWhereInput | users_clientWhereInput[]
    name?: StringFilter<"users_client"> | string
    email?: StringFilter<"users_client"> | string
    phone?: StringFilter<"users_client"> | string
    role_id?: IntFilter<"users_client"> | number
    created_at?: DateTimeFilter<"users_client"> | Date | string
    updated_at?: DateTimeFilter<"users_client"> | Date | string
    deleted_at?: DateTimeNullableFilter<"users_client"> | Date | string | null
    r_users_client_contractors?: R_users_client_contractorsListRelationFilter
    roles_client?: XOR<Roles_clientRelationFilter, roles_clientWhereInput>
  }, "id">

  export type users_clientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: users_clientCountOrderByAggregateInput
    _avg?: users_clientAvgOrderByAggregateInput
    _max?: users_clientMaxOrderByAggregateInput
    _min?: users_clientMinOrderByAggregateInput
    _sum?: users_clientSumOrderByAggregateInput
  }

  export type users_clientScalarWhereWithAggregatesInput = {
    AND?: users_clientScalarWhereWithAggregatesInput | users_clientScalarWhereWithAggregatesInput[]
    OR?: users_clientScalarWhereWithAggregatesInput[]
    NOT?: users_clientScalarWhereWithAggregatesInput | users_clientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users_client"> | number
    name?: StringWithAggregatesFilter<"users_client"> | string
    email?: StringWithAggregatesFilter<"users_client"> | string
    phone?: StringWithAggregatesFilter<"users_client"> | string
    role_id?: IntWithAggregatesFilter<"users_client"> | number
    created_at?: DateTimeWithAggregatesFilter<"users_client"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"users_client"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"users_client"> | Date | string | null
  }

  export type banks_items_versionsWhereInput = {
    AND?: banks_items_versionsWhereInput | banks_items_versionsWhereInput[]
    OR?: banks_items_versionsWhereInput[]
    NOT?: banks_items_versionsWhereInput | banks_items_versionsWhereInput[]
    id?: BigIntFilter<"banks_items_versions"> | bigint | number
    name?: StringFilter<"banks_items_versions"> | string
    is_active?: BoolFilter<"banks_items_versions"> | boolean
    bank_id?: IntFilter<"banks_items_versions"> | number
    created_at?: DateTimeFilter<"banks_items_versions"> | Date | string
    updated_at?: DateTimeFilter<"banks_items_versions"> | Date | string
    banks_items?: Banks_itemsListRelationFilter
    banks?: XOR<BanksRelationFilter, banksWhereInput>
  }

  export type banks_items_versionsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    bank_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    banks_items?: banks_itemsOrderByRelationAggregateInput
    banks?: banksOrderByWithRelationInput
  }

  export type banks_items_versionsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: banks_items_versionsWhereInput | banks_items_versionsWhereInput[]
    OR?: banks_items_versionsWhereInput[]
    NOT?: banks_items_versionsWhereInput | banks_items_versionsWhereInput[]
    name?: StringFilter<"banks_items_versions"> | string
    is_active?: BoolFilter<"banks_items_versions"> | boolean
    bank_id?: IntFilter<"banks_items_versions"> | number
    created_at?: DateTimeFilter<"banks_items_versions"> | Date | string
    updated_at?: DateTimeFilter<"banks_items_versions"> | Date | string
    banks_items?: Banks_itemsListRelationFilter
    banks?: XOR<BanksRelationFilter, banksWhereInput>
  }, "id">

  export type banks_items_versionsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    bank_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: banks_items_versionsCountOrderByAggregateInput
    _avg?: banks_items_versionsAvgOrderByAggregateInput
    _max?: banks_items_versionsMaxOrderByAggregateInput
    _min?: banks_items_versionsMinOrderByAggregateInput
    _sum?: banks_items_versionsSumOrderByAggregateInput
  }

  export type banks_items_versionsScalarWhereWithAggregatesInput = {
    AND?: banks_items_versionsScalarWhereWithAggregatesInput | banks_items_versionsScalarWhereWithAggregatesInput[]
    OR?: banks_items_versionsScalarWhereWithAggregatesInput[]
    NOT?: banks_items_versionsScalarWhereWithAggregatesInput | banks_items_versionsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"banks_items_versions"> | bigint | number
    name?: StringWithAggregatesFilter<"banks_items_versions"> | string
    is_active?: BoolWithAggregatesFilter<"banks_items_versions"> | boolean
    bank_id?: IntWithAggregatesFilter<"banks_items_versions"> | number
    created_at?: DateTimeWithAggregatesFilter<"banks_items_versions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"banks_items_versions"> | Date | string
  }

  export type entitiesWhereInput = {
    AND?: entitiesWhereInput | entitiesWhereInput[]
    OR?: entitiesWhereInput[]
    NOT?: entitiesWhereInput | entitiesWhereInput[]
    id?: IntFilter<"entities"> | number
    str_id?: StringFilter<"entities"> | string
    name?: StringFilter<"entities"> | string
    short_name?: StringFilter<"entities"> | string
    display_name?: StringFilter<"entities"> | string
    inn?: StringFilter<"entities"> | string
    kpp?: StringFilter<"entities"> | string
    ogrn?: StringFilter<"entities"> | string
    db_name?: StringFilter<"entities"> | string
    objects?: ObjectsListRelationFilter
  }

  export type entitiesOrderByWithRelationInput = {
    id?: SortOrder
    str_id?: SortOrder
    name?: SortOrder
    short_name?: SortOrder
    display_name?: SortOrder
    inn?: SortOrder
    kpp?: SortOrder
    ogrn?: SortOrder
    db_name?: SortOrder
    objects?: objectsOrderByRelationAggregateInput
  }

  export type entitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    str_id?: string
    name?: string
    AND?: entitiesWhereInput | entitiesWhereInput[]
    OR?: entitiesWhereInput[]
    NOT?: entitiesWhereInput | entitiesWhereInput[]
    short_name?: StringFilter<"entities"> | string
    display_name?: StringFilter<"entities"> | string
    inn?: StringFilter<"entities"> | string
    kpp?: StringFilter<"entities"> | string
    ogrn?: StringFilter<"entities"> | string
    db_name?: StringFilter<"entities"> | string
    objects?: ObjectsListRelationFilter
  }, "id" | "str_id" | "name">

  export type entitiesOrderByWithAggregationInput = {
    id?: SortOrder
    str_id?: SortOrder
    name?: SortOrder
    short_name?: SortOrder
    display_name?: SortOrder
    inn?: SortOrder
    kpp?: SortOrder
    ogrn?: SortOrder
    db_name?: SortOrder
    _count?: entitiesCountOrderByAggregateInput
    _avg?: entitiesAvgOrderByAggregateInput
    _max?: entitiesMaxOrderByAggregateInput
    _min?: entitiesMinOrderByAggregateInput
    _sum?: entitiesSumOrderByAggregateInput
  }

  export type entitiesScalarWhereWithAggregatesInput = {
    AND?: entitiesScalarWhereWithAggregatesInput | entitiesScalarWhereWithAggregatesInput[]
    OR?: entitiesScalarWhereWithAggregatesInput[]
    NOT?: entitiesScalarWhereWithAggregatesInput | entitiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"entities"> | number
    str_id?: StringWithAggregatesFilter<"entities"> | string
    name?: StringWithAggregatesFilter<"entities"> | string
    short_name?: StringWithAggregatesFilter<"entities"> | string
    display_name?: StringWithAggregatesFilter<"entities"> | string
    inn?: StringWithAggregatesFilter<"entities"> | string
    kpp?: StringWithAggregatesFilter<"entities"> | string
    ogrn?: StringWithAggregatesFilter<"entities"> | string
    db_name?: StringWithAggregatesFilter<"entities"> | string
  }

  export type r_items_banks_itemsWhereInput = {
    AND?: r_items_banks_itemsWhereInput | r_items_banks_itemsWhereInput[]
    OR?: r_items_banks_itemsWhereInput[]
    NOT?: r_items_banks_itemsWhereInput | r_items_banks_itemsWhereInput[]
    item_id?: IntFilter<"r_items_banks_items"> | number
    bank_item_id?: IntFilter<"r_items_banks_items"> | number
    created_at?: DateTimeNullableFilter<"r_items_banks_items"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"r_items_banks_items"> | Date | string | null
  }

  export type r_items_banks_itemsOrderByWithRelationInput = {
    item_id?: SortOrder
    bank_item_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type r_items_banks_itemsWhereUniqueInput = Prisma.AtLeast<{
    item_id_bank_item_id?: r_items_banks_itemsItem_idBank_item_idCompoundUniqueInput
    AND?: r_items_banks_itemsWhereInput | r_items_banks_itemsWhereInput[]
    OR?: r_items_banks_itemsWhereInput[]
    NOT?: r_items_banks_itemsWhereInput | r_items_banks_itemsWhereInput[]
    item_id?: IntFilter<"r_items_banks_items"> | number
    bank_item_id?: IntFilter<"r_items_banks_items"> | number
    created_at?: DateTimeNullableFilter<"r_items_banks_items"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"r_items_banks_items"> | Date | string | null
  }, "item_id_bank_item_id">

  export type r_items_banks_itemsOrderByWithAggregationInput = {
    item_id?: SortOrder
    bank_item_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: r_items_banks_itemsCountOrderByAggregateInput
    _avg?: r_items_banks_itemsAvgOrderByAggregateInput
    _max?: r_items_banks_itemsMaxOrderByAggregateInput
    _min?: r_items_banks_itemsMinOrderByAggregateInput
    _sum?: r_items_banks_itemsSumOrderByAggregateInput
  }

  export type r_items_banks_itemsScalarWhereWithAggregatesInput = {
    AND?: r_items_banks_itemsScalarWhereWithAggregatesInput | r_items_banks_itemsScalarWhereWithAggregatesInput[]
    OR?: r_items_banks_itemsScalarWhereWithAggregatesInput[]
    NOT?: r_items_banks_itemsScalarWhereWithAggregatesInput | r_items_banks_itemsScalarWhereWithAggregatesInput[]
    item_id?: IntWithAggregatesFilter<"r_items_banks_items"> | number
    bank_item_id?: IntWithAggregatesFilter<"r_items_banks_items"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"r_items_banks_items"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"r_items_banks_items"> | Date | string | null
  }

  export type accountsCreateInput = {
    number: string
    banks: banksCreateNestedOneWithoutAccountsInput
    contractors: contractorsCreateNestedOneWithoutAccountsInput
  }

  export type accountsUncheckedCreateInput = {
    id?: number
    number: string
    bank_id: number
    contractors_id: number
  }

  export type accountsUpdateInput = {
    number?: StringFieldUpdateOperationsInput | string
    banks?: banksUpdateOneRequiredWithoutAccountsNestedInput
    contractors?: contractorsUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type accountsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    bank_id?: IntFieldUpdateOperationsInput | number
    contractors_id?: IntFieldUpdateOperationsInput | number
  }

  export type accountsCreateManyInput = {
    id?: number
    number: string
    bank_id: number
    contractors_id: number
  }

  export type accountsUpdateManyMutationInput = {
    number?: StringFieldUpdateOperationsInput | string
  }

  export type accountsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    bank_id?: IntFieldUpdateOperationsInput | number
    contractors_id?: IntFieldUpdateOperationsInput | number
  }

  export type app_groupsCreateInput = {
    name: string
    applications?: applicationsCreateNestedManyWithoutApp_groupsInput
  }

  export type app_groupsUncheckedCreateInput = {
    id?: number
    name: string
    applications?: applicationsUncheckedCreateNestedManyWithoutApp_groupsInput
  }

  export type app_groupsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    applications?: applicationsUpdateManyWithoutApp_groupsNestedInput
  }

  export type app_groupsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    applications?: applicationsUncheckedUpdateManyWithoutApp_groupsNestedInput
  }

  export type app_groupsCreateManyInput = {
    id?: number
    name: string
  }

  export type app_groupsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type app_groupsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type applicationsCreateInput = {
    id: string
    name: string
    active?: boolean | null
    type?: $Enums.applications_type
    path?: string | null
    description?: string | null
    app_groups?: app_groupsCreateNestedOneWithoutApplicationsInput
    r_roles_apps?: r_roles_appsCreateNestedManyWithoutApplicationsInput
  }

  export type applicationsUncheckedCreateInput = {
    id: string
    name: string
    active?: boolean | null
    type?: $Enums.applications_type
    path?: string | null
    description?: string | null
    app_group_id?: number
    r_roles_apps?: r_roles_appsUncheckedCreateNestedManyWithoutApplicationsInput
  }

  export type applicationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: Enumapplications_typeFieldUpdateOperationsInput | $Enums.applications_type
    path?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    app_groups?: app_groupsUpdateOneRequiredWithoutApplicationsNestedInput
    r_roles_apps?: r_roles_appsUpdateManyWithoutApplicationsNestedInput
  }

  export type applicationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: Enumapplications_typeFieldUpdateOperationsInput | $Enums.applications_type
    path?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    app_group_id?: IntFieldUpdateOperationsInput | number
    r_roles_apps?: r_roles_appsUncheckedUpdateManyWithoutApplicationsNestedInput
  }

  export type applicationsCreateManyInput = {
    id: string
    name: string
    active?: boolean | null
    type?: $Enums.applications_type
    path?: string | null
    description?: string | null
    app_group_id?: number
  }

  export type applicationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: Enumapplications_typeFieldUpdateOperationsInput | $Enums.applications_type
    path?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: Enumapplications_typeFieldUpdateOperationsInput | $Enums.applications_type
    path?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    app_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type banksCreateInput = {
    name: string
    city?: string | null
    bik: string
    correspondent_number?: string | null
    accounts?: accountsCreateNestedManyWithoutBanksInput
    banks_items_versions?: banks_items_versionsCreateNestedManyWithoutBanksInput
  }

  export type banksUncheckedCreateInput = {
    id?: number
    name: string
    city?: string | null
    bik: string
    correspondent_number?: string | null
    accounts?: accountsUncheckedCreateNestedManyWithoutBanksInput
    banks_items_versions?: banks_items_versionsUncheckedCreateNestedManyWithoutBanksInput
  }

  export type banksUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bik?: StringFieldUpdateOperationsInput | string
    correspondent_number?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUpdateManyWithoutBanksNestedInput
    banks_items_versions?: banks_items_versionsUpdateManyWithoutBanksNestedInput
  }

  export type banksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bik?: StringFieldUpdateOperationsInput | string
    correspondent_number?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUncheckedUpdateManyWithoutBanksNestedInput
    banks_items_versions?: banks_items_versionsUncheckedUpdateManyWithoutBanksNestedInput
  }

  export type banksCreateManyInput = {
    id?: number
    name: string
    city?: string | null
    bik: string
    correspondent_number?: string | null
  }

  export type banksUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bik?: StringFieldUpdateOperationsInput | string
    correspondent_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type banksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bik?: StringFieldUpdateOperationsInput | string
    correspondent_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type banks_itemsCreateInput = {
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    banks_pakets?: banks_paketsCreateNestedOneWithoutBanks_itemsInput
    banks_items_versions?: banks_items_versionsCreateNestedOneWithoutBanks_itemsInput
    items?: itemsCreateNestedManyWithoutBanks_itemsInput
  }

  export type banks_itemsUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    banks_pakets_id?: number | null
    propogated_at?: Date | string | null
    version_id?: bigint | number | null
    items?: itemsUncheckedCreateNestedManyWithoutBanks_itemsInput
  }

  export type banks_itemsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banks_pakets?: banks_paketsUpdateOneWithoutBanks_itemsNestedInput
    banks_items_versions?: banks_items_versionsUpdateOneWithoutBanks_itemsNestedInput
    items?: itemsUpdateManyWithoutBanks_itemsNestedInput
  }

  export type banks_itemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banks_pakets_id?: NullableIntFieldUpdateOperationsInput | number | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    items?: itemsUncheckedUpdateManyWithoutBanks_itemsNestedInput
  }

  export type banks_itemsCreateManyInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    banks_pakets_id?: number | null
    propogated_at?: Date | string | null
    version_id?: bigint | number | null
  }

  export type banks_itemsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type banks_itemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banks_pakets_id?: NullableIntFieldUpdateOperationsInput | number | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type banks_paketsCreateInput = {
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    banks_items?: banks_itemsCreateNestedManyWithoutBanks_paketsInput
  }

  export type banks_paketsUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    banks_items?: banks_itemsUncheckedCreateNestedManyWithoutBanks_paketsInput
  }

  export type banks_paketsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banks_items?: banks_itemsUpdateManyWithoutBanks_paketsNestedInput
  }

  export type banks_paketsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banks_items?: banks_itemsUncheckedUpdateManyWithoutBanks_paketsNestedInput
  }

  export type banks_paketsCreateManyInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
  }

  export type banks_paketsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type banks_paketsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blocksCreateInput = {
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    pakets?: paketsCreateNestedManyWithoutBlocksInput
  }

  export type blocksUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    pakets?: paketsUncheckedCreateNestedManyWithoutBlocksInput
  }

  export type blocksUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pakets?: paketsUpdateManyWithoutBlocksNestedInput
  }

  export type blocksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pakets?: paketsUncheckedUpdateManyWithoutBlocksNestedInput
  }

  export type blocksCreateManyInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
  }

  export type blocksUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blocksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contractorsCreateInput = {
    name: string
    short_name?: string | null
    inn?: string | null
    kpp?: string | null
    ogrn?: string | null
    legal_address?: string | null
    actual_address?: string | null
    contacts?: string | null
    reconciliation_link?: string | null
    is_active?: boolean
    propogated_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    accounts?: accountsCreateNestedManyWithoutContractorsInput
    r_users_client_contractors?: r_users_client_contractorsCreateNestedManyWithoutContractorsInput
  }

  export type contractorsUncheckedCreateInput = {
    id?: number
    name: string
    short_name?: string | null
    inn?: string | null
    kpp?: string | null
    ogrn?: string | null
    legal_address?: string | null
    actual_address?: string | null
    contacts?: string | null
    reconciliation_link?: string | null
    is_active?: boolean
    propogated_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    accounts?: accountsUncheckedCreateNestedManyWithoutContractorsInput
    r_users_client_contractors?: r_users_client_contractorsUncheckedCreateNestedManyWithoutContractorsInput
  }

  export type contractorsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    ogrn?: NullableStringFieldUpdateOperationsInput | string | null
    legal_address?: NullableStringFieldUpdateOperationsInput | string | null
    actual_address?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: NullableStringFieldUpdateOperationsInput | string | null
    reconciliation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUpdateManyWithoutContractorsNestedInput
    r_users_client_contractors?: r_users_client_contractorsUpdateManyWithoutContractorsNestedInput
  }

  export type contractorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    ogrn?: NullableStringFieldUpdateOperationsInput | string | null
    legal_address?: NullableStringFieldUpdateOperationsInput | string | null
    actual_address?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: NullableStringFieldUpdateOperationsInput | string | null
    reconciliation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUncheckedUpdateManyWithoutContractorsNestedInput
    r_users_client_contractors?: r_users_client_contractorsUncheckedUpdateManyWithoutContractorsNestedInput
  }

  export type contractorsCreateManyInput = {
    id?: number
    name: string
    short_name?: string | null
    inn?: string | null
    kpp?: string | null
    ogrn?: string | null
    legal_address?: string | null
    actual_address?: string | null
    contacts?: string | null
    reconciliation_link?: string | null
    is_active?: boolean
    propogated_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
  }

  export type contractorsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    ogrn?: NullableStringFieldUpdateOperationsInput | string | null
    legal_address?: NullableStringFieldUpdateOperationsInput | string | null
    actual_address?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: NullableStringFieldUpdateOperationsInput | string | null
    reconciliation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contractorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    ogrn?: NullableStringFieldUpdateOperationsInput | string | null
    legal_address?: NullableStringFieldUpdateOperationsInput | string | null
    actual_address?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: NullableStringFieldUpdateOperationsInput | string | null
    reconciliation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type floorsCreateInput = {
    name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    section_id: number
  }

  export type floorsUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    section_id: number
  }

  export type floorsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    section_id?: IntFieldUpdateOperationsInput | number
  }

  export type floorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    section_id?: IntFieldUpdateOperationsInput | number
  }

  export type floorsCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    section_id: number
  }

  export type floorsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    section_id?: IntFieldUpdateOperationsInput | number
  }

  export type floorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    section_id?: IntFieldUpdateOperationsInput | number
  }

  export type itemsCreateInput = {
    name: string
    code: string
    clc_code?: string | null
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    sub_pakets: sub_paketsCreateNestedOneWithoutItemsInput
    banks_items?: banks_itemsCreateNestedOneWithoutItemsInput
  }

  export type itemsUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    clc_code?: string | null
    order_num?: number | null
    is_active?: boolean
    sub_pakets_id: number
    banks_items_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
  }

  export type itemsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clc_code?: NullableStringFieldUpdateOperationsInput | string | null
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_pakets?: sub_paketsUpdateOneRequiredWithoutItemsNestedInput
    banks_items?: banks_itemsUpdateOneWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clc_code?: NullableStringFieldUpdateOperationsInput | string | null
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sub_pakets_id?: IntFieldUpdateOperationsInput | number
    banks_items_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itemsCreateManyInput = {
    id?: number
    name: string
    code: string
    clc_code?: string | null
    order_num?: number | null
    is_active?: boolean
    sub_pakets_id: number
    banks_items_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
  }

  export type itemsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clc_code?: NullableStringFieldUpdateOperationsInput | string | null
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clc_code?: NullableStringFieldUpdateOperationsInput | string | null
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sub_pakets_id?: IntFieldUpdateOperationsInput | number
    banks_items_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type objectsCreateInput = {
    short_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    entities: entitiesCreateNestedOneWithoutObjectsInput
    sections?: sectionsCreateNestedManyWithoutObjectsInput
  }

  export type objectsUncheckedCreateInput = {
    id?: number
    short_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    entity_id: number
    sections?: sectionsUncheckedCreateNestedManyWithoutObjectsInput
  }

  export type objectsUpdateInput = {
    short_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entities?: entitiesUpdateOneRequiredWithoutObjectsNestedInput
    sections?: sectionsUpdateManyWithoutObjectsNestedInput
  }

  export type objectsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    short_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entity_id?: IntFieldUpdateOperationsInput | number
    sections?: sectionsUncheckedUpdateManyWithoutObjectsNestedInput
  }

  export type objectsCreateManyInput = {
    id?: number
    short_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    entity_id: number
  }

  export type objectsUpdateManyMutationInput = {
    short_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type objectsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    short_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entity_id?: IntFieldUpdateOperationsInput | number
  }

  export type paketsCreateInput = {
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    blocks: blocksCreateNestedOneWithoutPaketsInput
    sub_pakets?: sub_paketsCreateNestedManyWithoutPaketsInput
  }

  export type paketsUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    blocks_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    sub_pakets?: sub_paketsUncheckedCreateNestedManyWithoutPaketsInput
  }

  export type paketsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blocks?: blocksUpdateOneRequiredWithoutPaketsNestedInput
    sub_pakets?: sub_paketsUpdateManyWithoutPaketsNestedInput
  }

  export type paketsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    blocks_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_pakets?: sub_paketsUncheckedUpdateManyWithoutPaketsNestedInput
  }

  export type paketsCreateManyInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    blocks_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
  }

  export type paketsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paketsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    blocks_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type r_roles_appsCreateInput = {
    roles: rolesCreateNestedOneWithoutR_roles_appsInput
    applications: applicationsCreateNestedOneWithoutR_roles_appsInput
  }

  export type r_roles_appsUncheckedCreateInput = {
    role_id: number
    app_id: string
  }

  export type r_roles_appsUpdateInput = {
    roles?: rolesUpdateOneRequiredWithoutR_roles_appsNestedInput
    applications?: applicationsUpdateOneRequiredWithoutR_roles_appsNestedInput
  }

  export type r_roles_appsUncheckedUpdateInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    app_id?: StringFieldUpdateOperationsInput | string
  }

  export type r_roles_appsCreateManyInput = {
    role_id: number
    app_id: string
  }

  export type r_roles_appsUpdateManyMutationInput = {

  }

  export type r_roles_appsUncheckedUpdateManyInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    app_id?: StringFieldUpdateOperationsInput | string
  }

  export type r_users_client_contractorsCreateInput = {
    contractors: contractorsCreateNestedOneWithoutR_users_client_contractorsInput
    users_client: users_clientCreateNestedOneWithoutR_users_client_contractorsInput
  }

  export type r_users_client_contractorsUncheckedCreateInput = {
    id?: number
    contractors_id: number
    users_client_id: number
  }

  export type r_users_client_contractorsUpdateInput = {
    contractors?: contractorsUpdateOneRequiredWithoutR_users_client_contractorsNestedInput
    users_client?: users_clientUpdateOneRequiredWithoutR_users_client_contractorsNestedInput
  }

  export type r_users_client_contractorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractors_id?: IntFieldUpdateOperationsInput | number
    users_client_id?: IntFieldUpdateOperationsInput | number
  }

  export type r_users_client_contractorsCreateManyInput = {
    id?: number
    contractors_id: number
    users_client_id: number
  }

  export type r_users_client_contractorsUpdateManyMutationInput = {

  }

  export type r_users_client_contractorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractors_id?: IntFieldUpdateOperationsInput | number
    users_client_id?: IntFieldUpdateOperationsInput | number
  }

  export type r_users_rolesCreateInput = {
    users: usersCreateNestedOneWithoutR_users_rolesInput
    roles: rolesCreateNestedOneWithoutR_users_rolesInput
  }

  export type r_users_rolesUncheckedCreateInput = {
    user_id: number
    role_id: number
  }

  export type r_users_rolesUpdateInput = {
    users?: usersUpdateOneRequiredWithoutR_users_rolesNestedInput
    roles?: rolesUpdateOneRequiredWithoutR_users_rolesNestedInput
  }

  export type r_users_rolesUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type r_users_rolesCreateManyInput = {
    user_id: number
    role_id: number
  }

  export type r_users_rolesUpdateManyMutationInput = {

  }

  export type r_users_rolesUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type rolesCreateInput = {
    name: string
    r_roles_apps?: r_roles_appsCreateNestedManyWithoutRolesInput
    r_users_roles?: r_users_rolesCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateInput = {
    id?: number
    name: string
    r_roles_apps?: r_roles_appsUncheckedCreateNestedManyWithoutRolesInput
    r_users_roles?: r_users_rolesUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    r_roles_apps?: r_roles_appsUpdateManyWithoutRolesNestedInput
    r_users_roles?: r_users_rolesUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    r_roles_apps?: r_roles_appsUncheckedUpdateManyWithoutRolesNestedInput
    r_users_roles?: r_users_rolesUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type rolesCreateManyInput = {
    id?: number
    name: string
  }

  export type rolesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type rolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type roles_clientCreateInput = {
    name: string
    users_client?: users_clientCreateNestedManyWithoutRoles_clientInput
  }

  export type roles_clientUncheckedCreateInput = {
    id?: number
    name: string
    users_client?: users_clientUncheckedCreateNestedManyWithoutRoles_clientInput
  }

  export type roles_clientUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    users_client?: users_clientUpdateManyWithoutRoles_clientNestedInput
  }

  export type roles_clientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    users_client?: users_clientUncheckedUpdateManyWithoutRoles_clientNestedInput
  }

  export type roles_clientCreateManyInput = {
    id?: number
    name: string
  }

  export type roles_clientUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type roles_clientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type sectionsCreateInput = {
    name: string
    created_at?: Date | string | null
    updated_ad?: Date | string | null
    objects: objectsCreateNestedOneWithoutSectionsInput
  }

  export type sectionsUncheckedCreateInput = {
    id?: number
    name: string
    object_id: number
    created_at?: Date | string | null
    updated_ad?: Date | string | null
  }

  export type sectionsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_ad?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    objects?: objectsUpdateOneRequiredWithoutSectionsNestedInput
  }

  export type sectionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    object_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_ad?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sectionsCreateManyInput = {
    id?: number
    name: string
    object_id: number
    created_at?: Date | string | null
    updated_ad?: Date | string | null
  }

  export type sectionsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_ad?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sectionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    object_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_ad?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sub_paketsCreateInput = {
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    items?: itemsCreateNestedManyWithoutSub_paketsInput
    pakets: paketsCreateNestedOneWithoutSub_paketsInput
  }

  export type sub_paketsUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    pakets_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    items?: itemsUncheckedCreateNestedManyWithoutSub_paketsInput
  }

  export type sub_paketsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: itemsUpdateManyWithoutSub_paketsNestedInput
    pakets?: paketsUpdateOneRequiredWithoutSub_paketsNestedInput
  }

  export type sub_paketsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    pakets_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: itemsUncheckedUpdateManyWithoutSub_paketsNestedInput
  }

  export type sub_paketsCreateManyInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    pakets_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
  }

  export type sub_paketsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sub_paketsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    pakets_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateInput = {
    name: string
    password: string
    email: string
    r_users_roles?: r_users_rolesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    name: string
    password: string
    email: string
    r_users_roles?: r_users_rolesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    r_users_roles?: r_users_rolesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    r_users_roles?: r_users_rolesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    name: string
    password: string
    email: string
  }

  export type usersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type users_clientCreateInput = {
    name: string
    email: string
    phone: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    r_users_client_contractors?: r_users_client_contractorsCreateNestedManyWithoutUsers_clientInput
    roles_client?: roles_clientCreateNestedOneWithoutUsers_clientInput
  }

  export type users_clientUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    phone: string
    role_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    r_users_client_contractors?: r_users_client_contractorsUncheckedCreateNestedManyWithoutUsers_clientInput
  }

  export type users_clientUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    r_users_client_contractors?: r_users_client_contractorsUpdateManyWithoutUsers_clientNestedInput
    roles_client?: roles_clientUpdateOneRequiredWithoutUsers_clientNestedInput
  }

  export type users_clientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    r_users_client_contractors?: r_users_client_contractorsUncheckedUpdateManyWithoutUsers_clientNestedInput
  }

  export type users_clientCreateManyInput = {
    id?: number
    name: string
    email: string
    phone: string
    role_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type users_clientUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type users_clientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type banks_items_versionsCreateInput = {
    id?: bigint | number
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    banks_items?: banks_itemsCreateNestedManyWithoutBanks_items_versionsInput
    banks: banksCreateNestedOneWithoutBanks_items_versionsInput
  }

  export type banks_items_versionsUncheckedCreateInput = {
    id?: bigint | number
    name: string
    is_active?: boolean
    bank_id: number
    created_at?: Date | string
    updated_at?: Date | string
    banks_items?: banks_itemsUncheckedCreateNestedManyWithoutBanks_items_versionsInput
  }

  export type banks_items_versionsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    banks_items?: banks_itemsUpdateManyWithoutBanks_items_versionsNestedInput
    banks?: banksUpdateOneRequiredWithoutBanks_items_versionsNestedInput
  }

  export type banks_items_versionsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    bank_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    banks_items?: banks_itemsUncheckedUpdateManyWithoutBanks_items_versionsNestedInput
  }

  export type banks_items_versionsCreateManyInput = {
    id?: bigint | number
    name: string
    is_active?: boolean
    bank_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type banks_items_versionsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type banks_items_versionsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    bank_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type entitiesCreateInput = {
    str_id: string
    name: string
    short_name: string
    display_name: string
    inn: string
    kpp: string
    ogrn: string
    db_name: string
    objects?: objectsCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateInput = {
    id?: number
    str_id: string
    name: string
    short_name: string
    display_name: string
    inn: string
    kpp: string
    ogrn: string
    db_name: string
    objects?: objectsUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUpdateInput = {
    str_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short_name?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    inn?: StringFieldUpdateOperationsInput | string
    kpp?: StringFieldUpdateOperationsInput | string
    ogrn?: StringFieldUpdateOperationsInput | string
    db_name?: StringFieldUpdateOperationsInput | string
    objects?: objectsUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    str_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short_name?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    inn?: StringFieldUpdateOperationsInput | string
    kpp?: StringFieldUpdateOperationsInput | string
    ogrn?: StringFieldUpdateOperationsInput | string
    db_name?: StringFieldUpdateOperationsInput | string
    objects?: objectsUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesCreateManyInput = {
    id?: number
    str_id: string
    name: string
    short_name: string
    display_name: string
    inn: string
    kpp: string
    ogrn: string
    db_name: string
  }

  export type entitiesUpdateManyMutationInput = {
    str_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short_name?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    inn?: StringFieldUpdateOperationsInput | string
    kpp?: StringFieldUpdateOperationsInput | string
    ogrn?: StringFieldUpdateOperationsInput | string
    db_name?: StringFieldUpdateOperationsInput | string
  }

  export type entitiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    str_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short_name?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    inn?: StringFieldUpdateOperationsInput | string
    kpp?: StringFieldUpdateOperationsInput | string
    ogrn?: StringFieldUpdateOperationsInput | string
    db_name?: StringFieldUpdateOperationsInput | string
  }

  export type r_items_banks_itemsCreateInput = {
    item_id: number
    bank_item_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type r_items_banks_itemsUncheckedCreateInput = {
    item_id: number
    bank_item_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type r_items_banks_itemsUpdateInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    bank_item_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type r_items_banks_itemsUncheckedUpdateInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    bank_item_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type r_items_banks_itemsCreateManyInput = {
    item_id: number
    bank_item_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type r_items_banks_itemsUpdateManyMutationInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    bank_item_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type r_items_banks_itemsUncheckedUpdateManyInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    bank_item_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BanksRelationFilter = {
    is?: banksWhereInput
    isNot?: banksWhereInput
  }

  export type ContractorsRelationFilter = {
    is?: contractorsWhereInput
    isNot?: contractorsWhereInput
  }

  export type accountsCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    bank_id?: SortOrder
    contractors_id?: SortOrder
  }

  export type accountsAvgOrderByAggregateInput = {
    id?: SortOrder
    bank_id?: SortOrder
    contractors_id?: SortOrder
  }

  export type accountsMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    bank_id?: SortOrder
    contractors_id?: SortOrder
  }

  export type accountsMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    bank_id?: SortOrder
    contractors_id?: SortOrder
  }

  export type accountsSumOrderByAggregateInput = {
    id?: SortOrder
    bank_id?: SortOrder
    contractors_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type ApplicationsListRelationFilter = {
    every?: applicationsWhereInput
    some?: applicationsWhereInput
    none?: applicationsWhereInput
  }

  export type applicationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type app_groupsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type app_groupsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type app_groupsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type app_groupsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type app_groupsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type Enumapplications_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.applications_type | Enumapplications_typeFieldRefInput<$PrismaModel>
    in?: $Enums.applications_type[]
    notIn?: $Enums.applications_type[]
    not?: NestedEnumapplications_typeFilter<$PrismaModel> | $Enums.applications_type
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type App_groupsRelationFilter = {
    is?: app_groupsWhereInput
    isNot?: app_groupsWhereInput
  }

  export type R_roles_appsListRelationFilter = {
    every?: r_roles_appsWhereInput
    some?: r_roles_appsWhereInput
    none?: r_roles_appsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type r_roles_appsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type applicationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    type?: SortOrder
    path?: SortOrder
    description?: SortOrder
    app_group_id?: SortOrder
  }

  export type applicationsAvgOrderByAggregateInput = {
    app_group_id?: SortOrder
  }

  export type applicationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    type?: SortOrder
    path?: SortOrder
    description?: SortOrder
    app_group_id?: SortOrder
  }

  export type applicationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    type?: SortOrder
    path?: SortOrder
    description?: SortOrder
    app_group_id?: SortOrder
  }

  export type applicationsSumOrderByAggregateInput = {
    app_group_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type Enumapplications_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.applications_type | Enumapplications_typeFieldRefInput<$PrismaModel>
    in?: $Enums.applications_type[]
    notIn?: $Enums.applications_type[]
    not?: NestedEnumapplications_typeWithAggregatesFilter<$PrismaModel> | $Enums.applications_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumapplications_typeFilter<$PrismaModel>
    _max?: NestedEnumapplications_typeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type AccountsListRelationFilter = {
    every?: accountsWhereInput
    some?: accountsWhereInput
    none?: accountsWhereInput
  }

  export type Banks_items_versionsListRelationFilter = {
    every?: banks_items_versionsWhereInput
    some?: banks_items_versionsWhereInput
    none?: banks_items_versionsWhereInput
  }

  export type accountsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type banks_items_versionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type banksCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    bik?: SortOrder
    correspondent_number?: SortOrder
  }

  export type banksAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type banksMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    bik?: SortOrder
    correspondent_number?: SortOrder
  }

  export type banksMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    bik?: SortOrder
    correspondent_number?: SortOrder
  }

  export type banksSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type Banks_paketsNullableRelationFilter = {
    is?: banks_paketsWhereInput | null
    isNot?: banks_paketsWhereInput | null
  }

  export type Banks_items_versionsNullableRelationFilter = {
    is?: banks_items_versionsWhereInput | null
    isNot?: banks_items_versionsWhereInput | null
  }

  export type ItemsListRelationFilter = {
    every?: itemsWhereInput
    some?: itemsWhereInput
    none?: itemsWhereInput
  }

  export type itemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type banks_itemsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    banks_pakets_id?: SortOrder
    propogated_at?: SortOrder
    version_id?: SortOrder
  }

  export type banks_itemsAvgOrderByAggregateInput = {
    id?: SortOrder
    order_num?: SortOrder
    banks_pakets_id?: SortOrder
    version_id?: SortOrder
  }

  export type banks_itemsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    banks_pakets_id?: SortOrder
    propogated_at?: SortOrder
    version_id?: SortOrder
  }

  export type banks_itemsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    banks_pakets_id?: SortOrder
    propogated_at?: SortOrder
    version_id?: SortOrder
  }

  export type banks_itemsSumOrderByAggregateInput = {
    id?: SortOrder
    order_num?: SortOrder
    banks_pakets_id?: SortOrder
    version_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type Banks_itemsListRelationFilter = {
    every?: banks_itemsWhereInput
    some?: banks_itemsWhereInput
    none?: banks_itemsWhereInput
  }

  export type banks_itemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type banks_paketsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    propogated_at?: SortOrder
  }

  export type banks_paketsAvgOrderByAggregateInput = {
    id?: SortOrder
    order_num?: SortOrder
  }

  export type banks_paketsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    propogated_at?: SortOrder
  }

  export type banks_paketsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    propogated_at?: SortOrder
  }

  export type banks_paketsSumOrderByAggregateInput = {
    id?: SortOrder
    order_num?: SortOrder
  }

  export type PaketsListRelationFilter = {
    every?: paketsWhereInput
    some?: paketsWhereInput
    none?: paketsWhereInput
  }

  export type paketsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type blocksCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    propogated_at?: SortOrder
  }

  export type blocksAvgOrderByAggregateInput = {
    id?: SortOrder
    order_num?: SortOrder
  }

  export type blocksMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    propogated_at?: SortOrder
  }

  export type blocksMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    propogated_at?: SortOrder
  }

  export type blocksSumOrderByAggregateInput = {
    id?: SortOrder
    order_num?: SortOrder
  }

  export type R_users_client_contractorsListRelationFilter = {
    every?: r_users_client_contractorsWhereInput
    some?: r_users_client_contractorsWhereInput
    none?: r_users_client_contractorsWhereInput
  }

  export type r_users_client_contractorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type contractorsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    short_name?: SortOrder
    inn?: SortOrder
    kpp?: SortOrder
    ogrn?: SortOrder
    legal_address?: SortOrder
    actual_address?: SortOrder
    contacts?: SortOrder
    reconciliation_link?: SortOrder
    is_active?: SortOrder
    propogated_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    phone?: SortOrder
  }

  export type contractorsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type contractorsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    short_name?: SortOrder
    inn?: SortOrder
    kpp?: SortOrder
    ogrn?: SortOrder
    legal_address?: SortOrder
    actual_address?: SortOrder
    contacts?: SortOrder
    reconciliation_link?: SortOrder
    is_active?: SortOrder
    propogated_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    phone?: SortOrder
  }

  export type contractorsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    short_name?: SortOrder
    inn?: SortOrder
    kpp?: SortOrder
    ogrn?: SortOrder
    legal_address?: SortOrder
    actual_address?: SortOrder
    contacts?: SortOrder
    reconciliation_link?: SortOrder
    is_active?: SortOrder
    propogated_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    phone?: SortOrder
  }

  export type contractorsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type floorsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    section_id?: SortOrder
  }

  export type floorsAvgOrderByAggregateInput = {
    id?: SortOrder
    section_id?: SortOrder
  }

  export type floorsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    section_id?: SortOrder
  }

  export type floorsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    section_id?: SortOrder
  }

  export type floorsSumOrderByAggregateInput = {
    id?: SortOrder
    section_id?: SortOrder
  }

  export type Sub_paketsRelationFilter = {
    is?: sub_paketsWhereInput
    isNot?: sub_paketsWhereInput
  }

  export type Banks_itemsNullableRelationFilter = {
    is?: banks_itemsWhereInput | null
    isNot?: banks_itemsWhereInput | null
  }

  export type itemsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    clc_code?: SortOrder
    order_num?: SortOrder
    is_active?: SortOrder
    sub_pakets_id?: SortOrder
    banks_items_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    propogated_at?: SortOrder
  }

  export type itemsAvgOrderByAggregateInput = {
    id?: SortOrder
    order_num?: SortOrder
    sub_pakets_id?: SortOrder
    banks_items_id?: SortOrder
  }

  export type itemsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    clc_code?: SortOrder
    order_num?: SortOrder
    is_active?: SortOrder
    sub_pakets_id?: SortOrder
    banks_items_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    propogated_at?: SortOrder
  }

  export type itemsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    clc_code?: SortOrder
    order_num?: SortOrder
    is_active?: SortOrder
    sub_pakets_id?: SortOrder
    banks_items_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    propogated_at?: SortOrder
  }

  export type itemsSumOrderByAggregateInput = {
    id?: SortOrder
    order_num?: SortOrder
    sub_pakets_id?: SortOrder
    banks_items_id?: SortOrder
  }

  export type EntitiesRelationFilter = {
    is?: entitiesWhereInput
    isNot?: entitiesWhereInput
  }

  export type SectionsListRelationFilter = {
    every?: sectionsWhereInput
    some?: sectionsWhereInput
    none?: sectionsWhereInput
  }

  export type sectionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type objectsCountOrderByAggregateInput = {
    id?: SortOrder
    short_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    entity_id?: SortOrder
  }

  export type objectsAvgOrderByAggregateInput = {
    id?: SortOrder
    entity_id?: SortOrder
  }

  export type objectsMaxOrderByAggregateInput = {
    id?: SortOrder
    short_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    entity_id?: SortOrder
  }

  export type objectsMinOrderByAggregateInput = {
    id?: SortOrder
    short_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    entity_id?: SortOrder
  }

  export type objectsSumOrderByAggregateInput = {
    id?: SortOrder
    entity_id?: SortOrder
  }

  export type BlocksRelationFilter = {
    is?: blocksWhereInput
    isNot?: blocksWhereInput
  }

  export type Sub_paketsListRelationFilter = {
    every?: sub_paketsWhereInput
    some?: sub_paketsWhereInput
    none?: sub_paketsWhereInput
  }

  export type sub_paketsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paketsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrder
    is_active?: SortOrder
    blocks_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    propogated_at?: SortOrder
  }

  export type paketsAvgOrderByAggregateInput = {
    id?: SortOrder
    order_num?: SortOrder
    blocks_id?: SortOrder
  }

  export type paketsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrder
    is_active?: SortOrder
    blocks_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    propogated_at?: SortOrder
  }

  export type paketsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrder
    is_active?: SortOrder
    blocks_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    propogated_at?: SortOrder
  }

  export type paketsSumOrderByAggregateInput = {
    id?: SortOrder
    order_num?: SortOrder
    blocks_id?: SortOrder
  }

  export type RolesRelationFilter = {
    is?: rolesWhereInput
    isNot?: rolesWhereInput
  }

  export type ApplicationsRelationFilter = {
    is?: applicationsWhereInput
    isNot?: applicationsWhereInput
  }

  export type r_roles_appsRole_idApp_idCompoundUniqueInput = {
    role_id: number
    app_id: string
  }

  export type r_roles_appsCountOrderByAggregateInput = {
    role_id?: SortOrder
    app_id?: SortOrder
  }

  export type r_roles_appsAvgOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type r_roles_appsMaxOrderByAggregateInput = {
    role_id?: SortOrder
    app_id?: SortOrder
  }

  export type r_roles_appsMinOrderByAggregateInput = {
    role_id?: SortOrder
    app_id?: SortOrder
  }

  export type r_roles_appsSumOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type Users_clientRelationFilter = {
    is?: users_clientWhereInput
    isNot?: users_clientWhereInput
  }

  export type r_users_client_contractorsCountOrderByAggregateInput = {
    id?: SortOrder
    contractors_id?: SortOrder
    users_client_id?: SortOrder
  }

  export type r_users_client_contractorsAvgOrderByAggregateInput = {
    id?: SortOrder
    contractors_id?: SortOrder
    users_client_id?: SortOrder
  }

  export type r_users_client_contractorsMaxOrderByAggregateInput = {
    id?: SortOrder
    contractors_id?: SortOrder
    users_client_id?: SortOrder
  }

  export type r_users_client_contractorsMinOrderByAggregateInput = {
    id?: SortOrder
    contractors_id?: SortOrder
    users_client_id?: SortOrder
  }

  export type r_users_client_contractorsSumOrderByAggregateInput = {
    id?: SortOrder
    contractors_id?: SortOrder
    users_client_id?: SortOrder
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type r_users_rolesUser_idRole_idCompoundUniqueInput = {
    user_id: number
    role_id: number
  }

  export type r_users_rolesCountOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type r_users_rolesAvgOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type r_users_rolesMaxOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type r_users_rolesMinOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type r_users_rolesSumOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type R_users_rolesListRelationFilter = {
    every?: r_users_rolesWhereInput
    some?: r_users_rolesWhereInput
    none?: r_users_rolesWhereInput
  }

  export type r_users_rolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Users_clientListRelationFilter = {
    every?: users_clientWhereInput
    some?: users_clientWhereInput
    none?: users_clientWhereInput
  }

  export type users_clientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type roles_clientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type roles_clientAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type roles_clientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type roles_clientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type roles_clientSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ObjectsRelationFilter = {
    is?: objectsWhereInput
    isNot?: objectsWhereInput
  }

  export type sectionsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    object_id?: SortOrder
    created_at?: SortOrder
    updated_ad?: SortOrder
  }

  export type sectionsAvgOrderByAggregateInput = {
    id?: SortOrder
    object_id?: SortOrder
  }

  export type sectionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    object_id?: SortOrder
    created_at?: SortOrder
    updated_ad?: SortOrder
  }

  export type sectionsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    object_id?: SortOrder
    created_at?: SortOrder
    updated_ad?: SortOrder
  }

  export type sectionsSumOrderByAggregateInput = {
    id?: SortOrder
    object_id?: SortOrder
  }

  export type PaketsRelationFilter = {
    is?: paketsWhereInput
    isNot?: paketsWhereInput
  }

  export type sub_paketsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrder
    is_active?: SortOrder
    pakets_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    propogated_at?: SortOrder
  }

  export type sub_paketsAvgOrderByAggregateInput = {
    id?: SortOrder
    order_num?: SortOrder
    pakets_id?: SortOrder
  }

  export type sub_paketsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrder
    is_active?: SortOrder
    pakets_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    propogated_at?: SortOrder
  }

  export type sub_paketsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    order_num?: SortOrder
    is_active?: SortOrder
    pakets_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    propogated_at?: SortOrder
  }

  export type sub_paketsSumOrderByAggregateInput = {
    id?: SortOrder
    order_num?: SortOrder
    pakets_id?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    email?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    email?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    email?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type Roles_clientRelationFilter = {
    is?: roles_clientWhereInput
    isNot?: roles_clientWhereInput
  }

  export type users_clientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type users_clientAvgOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
  }

  export type users_clientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type users_clientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type users_clientSumOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type banks_items_versionsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    bank_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type banks_items_versionsAvgOrderByAggregateInput = {
    id?: SortOrder
    bank_id?: SortOrder
  }

  export type banks_items_versionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    bank_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type banks_items_versionsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    bank_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type banks_items_versionsSumOrderByAggregateInput = {
    id?: SortOrder
    bank_id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type ObjectsListRelationFilter = {
    every?: objectsWhereInput
    some?: objectsWhereInput
    none?: objectsWhereInput
  }

  export type objectsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type entitiesCountOrderByAggregateInput = {
    id?: SortOrder
    str_id?: SortOrder
    name?: SortOrder
    short_name?: SortOrder
    display_name?: SortOrder
    inn?: SortOrder
    kpp?: SortOrder
    ogrn?: SortOrder
    db_name?: SortOrder
  }

  export type entitiesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type entitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    str_id?: SortOrder
    name?: SortOrder
    short_name?: SortOrder
    display_name?: SortOrder
    inn?: SortOrder
    kpp?: SortOrder
    ogrn?: SortOrder
    db_name?: SortOrder
  }

  export type entitiesMinOrderByAggregateInput = {
    id?: SortOrder
    str_id?: SortOrder
    name?: SortOrder
    short_name?: SortOrder
    display_name?: SortOrder
    inn?: SortOrder
    kpp?: SortOrder
    ogrn?: SortOrder
    db_name?: SortOrder
  }

  export type entitiesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type r_items_banks_itemsItem_idBank_item_idCompoundUniqueInput = {
    item_id: number
    bank_item_id: number
  }

  export type r_items_banks_itemsCountOrderByAggregateInput = {
    item_id?: SortOrder
    bank_item_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type r_items_banks_itemsAvgOrderByAggregateInput = {
    item_id?: SortOrder
    bank_item_id?: SortOrder
  }

  export type r_items_banks_itemsMaxOrderByAggregateInput = {
    item_id?: SortOrder
    bank_item_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type r_items_banks_itemsMinOrderByAggregateInput = {
    item_id?: SortOrder
    bank_item_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type r_items_banks_itemsSumOrderByAggregateInput = {
    item_id?: SortOrder
    bank_item_id?: SortOrder
  }

  export type banksCreateNestedOneWithoutAccountsInput = {
    create?: XOR<banksCreateWithoutAccountsInput, banksUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: banksCreateOrConnectWithoutAccountsInput
    connect?: banksWhereUniqueInput
  }

  export type contractorsCreateNestedOneWithoutAccountsInput = {
    create?: XOR<contractorsCreateWithoutAccountsInput, contractorsUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: contractorsCreateOrConnectWithoutAccountsInput
    connect?: contractorsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type banksUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<banksCreateWithoutAccountsInput, banksUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: banksCreateOrConnectWithoutAccountsInput
    upsert?: banksUpsertWithoutAccountsInput
    connect?: banksWhereUniqueInput
    update?: XOR<XOR<banksUpdateToOneWithWhereWithoutAccountsInput, banksUpdateWithoutAccountsInput>, banksUncheckedUpdateWithoutAccountsInput>
  }

  export type contractorsUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<contractorsCreateWithoutAccountsInput, contractorsUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: contractorsCreateOrConnectWithoutAccountsInput
    upsert?: contractorsUpsertWithoutAccountsInput
    connect?: contractorsWhereUniqueInput
    update?: XOR<XOR<contractorsUpdateToOneWithWhereWithoutAccountsInput, contractorsUpdateWithoutAccountsInput>, contractorsUncheckedUpdateWithoutAccountsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type applicationsCreateNestedManyWithoutApp_groupsInput = {
    create?: XOR<applicationsCreateWithoutApp_groupsInput, applicationsUncheckedCreateWithoutApp_groupsInput> | applicationsCreateWithoutApp_groupsInput[] | applicationsUncheckedCreateWithoutApp_groupsInput[]
    connectOrCreate?: applicationsCreateOrConnectWithoutApp_groupsInput | applicationsCreateOrConnectWithoutApp_groupsInput[]
    createMany?: applicationsCreateManyApp_groupsInputEnvelope
    connect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
  }

  export type applicationsUncheckedCreateNestedManyWithoutApp_groupsInput = {
    create?: XOR<applicationsCreateWithoutApp_groupsInput, applicationsUncheckedCreateWithoutApp_groupsInput> | applicationsCreateWithoutApp_groupsInput[] | applicationsUncheckedCreateWithoutApp_groupsInput[]
    connectOrCreate?: applicationsCreateOrConnectWithoutApp_groupsInput | applicationsCreateOrConnectWithoutApp_groupsInput[]
    createMany?: applicationsCreateManyApp_groupsInputEnvelope
    connect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
  }

  export type applicationsUpdateManyWithoutApp_groupsNestedInput = {
    create?: XOR<applicationsCreateWithoutApp_groupsInput, applicationsUncheckedCreateWithoutApp_groupsInput> | applicationsCreateWithoutApp_groupsInput[] | applicationsUncheckedCreateWithoutApp_groupsInput[]
    connectOrCreate?: applicationsCreateOrConnectWithoutApp_groupsInput | applicationsCreateOrConnectWithoutApp_groupsInput[]
    upsert?: applicationsUpsertWithWhereUniqueWithoutApp_groupsInput | applicationsUpsertWithWhereUniqueWithoutApp_groupsInput[]
    createMany?: applicationsCreateManyApp_groupsInputEnvelope
    set?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    disconnect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    delete?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    connect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    update?: applicationsUpdateWithWhereUniqueWithoutApp_groupsInput | applicationsUpdateWithWhereUniqueWithoutApp_groupsInput[]
    updateMany?: applicationsUpdateManyWithWhereWithoutApp_groupsInput | applicationsUpdateManyWithWhereWithoutApp_groupsInput[]
    deleteMany?: applicationsScalarWhereInput | applicationsScalarWhereInput[]
  }

  export type applicationsUncheckedUpdateManyWithoutApp_groupsNestedInput = {
    create?: XOR<applicationsCreateWithoutApp_groupsInput, applicationsUncheckedCreateWithoutApp_groupsInput> | applicationsCreateWithoutApp_groupsInput[] | applicationsUncheckedCreateWithoutApp_groupsInput[]
    connectOrCreate?: applicationsCreateOrConnectWithoutApp_groupsInput | applicationsCreateOrConnectWithoutApp_groupsInput[]
    upsert?: applicationsUpsertWithWhereUniqueWithoutApp_groupsInput | applicationsUpsertWithWhereUniqueWithoutApp_groupsInput[]
    createMany?: applicationsCreateManyApp_groupsInputEnvelope
    set?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    disconnect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    delete?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    connect?: applicationsWhereUniqueInput | applicationsWhereUniqueInput[]
    update?: applicationsUpdateWithWhereUniqueWithoutApp_groupsInput | applicationsUpdateWithWhereUniqueWithoutApp_groupsInput[]
    updateMany?: applicationsUpdateManyWithWhereWithoutApp_groupsInput | applicationsUpdateManyWithWhereWithoutApp_groupsInput[]
    deleteMany?: applicationsScalarWhereInput | applicationsScalarWhereInput[]
  }

  export type app_groupsCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<app_groupsCreateWithoutApplicationsInput, app_groupsUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: app_groupsCreateOrConnectWithoutApplicationsInput
    connect?: app_groupsWhereUniqueInput
  }

  export type r_roles_appsCreateNestedManyWithoutApplicationsInput = {
    create?: XOR<r_roles_appsCreateWithoutApplicationsInput, r_roles_appsUncheckedCreateWithoutApplicationsInput> | r_roles_appsCreateWithoutApplicationsInput[] | r_roles_appsUncheckedCreateWithoutApplicationsInput[]
    connectOrCreate?: r_roles_appsCreateOrConnectWithoutApplicationsInput | r_roles_appsCreateOrConnectWithoutApplicationsInput[]
    createMany?: r_roles_appsCreateManyApplicationsInputEnvelope
    connect?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
  }

  export type r_roles_appsUncheckedCreateNestedManyWithoutApplicationsInput = {
    create?: XOR<r_roles_appsCreateWithoutApplicationsInput, r_roles_appsUncheckedCreateWithoutApplicationsInput> | r_roles_appsCreateWithoutApplicationsInput[] | r_roles_appsUncheckedCreateWithoutApplicationsInput[]
    connectOrCreate?: r_roles_appsCreateOrConnectWithoutApplicationsInput | r_roles_appsCreateOrConnectWithoutApplicationsInput[]
    createMany?: r_roles_appsCreateManyApplicationsInputEnvelope
    connect?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type Enumapplications_typeFieldUpdateOperationsInput = {
    set?: $Enums.applications_type
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type app_groupsUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<app_groupsCreateWithoutApplicationsInput, app_groupsUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: app_groupsCreateOrConnectWithoutApplicationsInput
    upsert?: app_groupsUpsertWithoutApplicationsInput
    connect?: app_groupsWhereUniqueInput
    update?: XOR<XOR<app_groupsUpdateToOneWithWhereWithoutApplicationsInput, app_groupsUpdateWithoutApplicationsInput>, app_groupsUncheckedUpdateWithoutApplicationsInput>
  }

  export type r_roles_appsUpdateManyWithoutApplicationsNestedInput = {
    create?: XOR<r_roles_appsCreateWithoutApplicationsInput, r_roles_appsUncheckedCreateWithoutApplicationsInput> | r_roles_appsCreateWithoutApplicationsInput[] | r_roles_appsUncheckedCreateWithoutApplicationsInput[]
    connectOrCreate?: r_roles_appsCreateOrConnectWithoutApplicationsInput | r_roles_appsCreateOrConnectWithoutApplicationsInput[]
    upsert?: r_roles_appsUpsertWithWhereUniqueWithoutApplicationsInput | r_roles_appsUpsertWithWhereUniqueWithoutApplicationsInput[]
    createMany?: r_roles_appsCreateManyApplicationsInputEnvelope
    set?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
    disconnect?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
    delete?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
    connect?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
    update?: r_roles_appsUpdateWithWhereUniqueWithoutApplicationsInput | r_roles_appsUpdateWithWhereUniqueWithoutApplicationsInput[]
    updateMany?: r_roles_appsUpdateManyWithWhereWithoutApplicationsInput | r_roles_appsUpdateManyWithWhereWithoutApplicationsInput[]
    deleteMany?: r_roles_appsScalarWhereInput | r_roles_appsScalarWhereInput[]
  }

  export type r_roles_appsUncheckedUpdateManyWithoutApplicationsNestedInput = {
    create?: XOR<r_roles_appsCreateWithoutApplicationsInput, r_roles_appsUncheckedCreateWithoutApplicationsInput> | r_roles_appsCreateWithoutApplicationsInput[] | r_roles_appsUncheckedCreateWithoutApplicationsInput[]
    connectOrCreate?: r_roles_appsCreateOrConnectWithoutApplicationsInput | r_roles_appsCreateOrConnectWithoutApplicationsInput[]
    upsert?: r_roles_appsUpsertWithWhereUniqueWithoutApplicationsInput | r_roles_appsUpsertWithWhereUniqueWithoutApplicationsInput[]
    createMany?: r_roles_appsCreateManyApplicationsInputEnvelope
    set?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
    disconnect?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
    delete?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
    connect?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
    update?: r_roles_appsUpdateWithWhereUniqueWithoutApplicationsInput | r_roles_appsUpdateWithWhereUniqueWithoutApplicationsInput[]
    updateMany?: r_roles_appsUpdateManyWithWhereWithoutApplicationsInput | r_roles_appsUpdateManyWithWhereWithoutApplicationsInput[]
    deleteMany?: r_roles_appsScalarWhereInput | r_roles_appsScalarWhereInput[]
  }

  export type accountsCreateNestedManyWithoutBanksInput = {
    create?: XOR<accountsCreateWithoutBanksInput, accountsUncheckedCreateWithoutBanksInput> | accountsCreateWithoutBanksInput[] | accountsUncheckedCreateWithoutBanksInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutBanksInput | accountsCreateOrConnectWithoutBanksInput[]
    createMany?: accountsCreateManyBanksInputEnvelope
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
  }

  export type banks_items_versionsCreateNestedManyWithoutBanksInput = {
    create?: XOR<banks_items_versionsCreateWithoutBanksInput, banks_items_versionsUncheckedCreateWithoutBanksInput> | banks_items_versionsCreateWithoutBanksInput[] | banks_items_versionsUncheckedCreateWithoutBanksInput[]
    connectOrCreate?: banks_items_versionsCreateOrConnectWithoutBanksInput | banks_items_versionsCreateOrConnectWithoutBanksInput[]
    createMany?: banks_items_versionsCreateManyBanksInputEnvelope
    connect?: banks_items_versionsWhereUniqueInput | banks_items_versionsWhereUniqueInput[]
  }

  export type accountsUncheckedCreateNestedManyWithoutBanksInput = {
    create?: XOR<accountsCreateWithoutBanksInput, accountsUncheckedCreateWithoutBanksInput> | accountsCreateWithoutBanksInput[] | accountsUncheckedCreateWithoutBanksInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutBanksInput | accountsCreateOrConnectWithoutBanksInput[]
    createMany?: accountsCreateManyBanksInputEnvelope
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
  }

  export type banks_items_versionsUncheckedCreateNestedManyWithoutBanksInput = {
    create?: XOR<banks_items_versionsCreateWithoutBanksInput, banks_items_versionsUncheckedCreateWithoutBanksInput> | banks_items_versionsCreateWithoutBanksInput[] | banks_items_versionsUncheckedCreateWithoutBanksInput[]
    connectOrCreate?: banks_items_versionsCreateOrConnectWithoutBanksInput | banks_items_versionsCreateOrConnectWithoutBanksInput[]
    createMany?: banks_items_versionsCreateManyBanksInputEnvelope
    connect?: banks_items_versionsWhereUniqueInput | banks_items_versionsWhereUniqueInput[]
  }

  export type accountsUpdateManyWithoutBanksNestedInput = {
    create?: XOR<accountsCreateWithoutBanksInput, accountsUncheckedCreateWithoutBanksInput> | accountsCreateWithoutBanksInput[] | accountsUncheckedCreateWithoutBanksInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutBanksInput | accountsCreateOrConnectWithoutBanksInput[]
    upsert?: accountsUpsertWithWhereUniqueWithoutBanksInput | accountsUpsertWithWhereUniqueWithoutBanksInput[]
    createMany?: accountsCreateManyBanksInputEnvelope
    set?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    disconnect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    delete?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    update?: accountsUpdateWithWhereUniqueWithoutBanksInput | accountsUpdateWithWhereUniqueWithoutBanksInput[]
    updateMany?: accountsUpdateManyWithWhereWithoutBanksInput | accountsUpdateManyWithWhereWithoutBanksInput[]
    deleteMany?: accountsScalarWhereInput | accountsScalarWhereInput[]
  }

  export type banks_items_versionsUpdateManyWithoutBanksNestedInput = {
    create?: XOR<banks_items_versionsCreateWithoutBanksInput, banks_items_versionsUncheckedCreateWithoutBanksInput> | banks_items_versionsCreateWithoutBanksInput[] | banks_items_versionsUncheckedCreateWithoutBanksInput[]
    connectOrCreate?: banks_items_versionsCreateOrConnectWithoutBanksInput | banks_items_versionsCreateOrConnectWithoutBanksInput[]
    upsert?: banks_items_versionsUpsertWithWhereUniqueWithoutBanksInput | banks_items_versionsUpsertWithWhereUniqueWithoutBanksInput[]
    createMany?: banks_items_versionsCreateManyBanksInputEnvelope
    set?: banks_items_versionsWhereUniqueInput | banks_items_versionsWhereUniqueInput[]
    disconnect?: banks_items_versionsWhereUniqueInput | banks_items_versionsWhereUniqueInput[]
    delete?: banks_items_versionsWhereUniqueInput | banks_items_versionsWhereUniqueInput[]
    connect?: banks_items_versionsWhereUniqueInput | banks_items_versionsWhereUniqueInput[]
    update?: banks_items_versionsUpdateWithWhereUniqueWithoutBanksInput | banks_items_versionsUpdateWithWhereUniqueWithoutBanksInput[]
    updateMany?: banks_items_versionsUpdateManyWithWhereWithoutBanksInput | banks_items_versionsUpdateManyWithWhereWithoutBanksInput[]
    deleteMany?: banks_items_versionsScalarWhereInput | banks_items_versionsScalarWhereInput[]
  }

  export type accountsUncheckedUpdateManyWithoutBanksNestedInput = {
    create?: XOR<accountsCreateWithoutBanksInput, accountsUncheckedCreateWithoutBanksInput> | accountsCreateWithoutBanksInput[] | accountsUncheckedCreateWithoutBanksInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutBanksInput | accountsCreateOrConnectWithoutBanksInput[]
    upsert?: accountsUpsertWithWhereUniqueWithoutBanksInput | accountsUpsertWithWhereUniqueWithoutBanksInput[]
    createMany?: accountsCreateManyBanksInputEnvelope
    set?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    disconnect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    delete?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    update?: accountsUpdateWithWhereUniqueWithoutBanksInput | accountsUpdateWithWhereUniqueWithoutBanksInput[]
    updateMany?: accountsUpdateManyWithWhereWithoutBanksInput | accountsUpdateManyWithWhereWithoutBanksInput[]
    deleteMany?: accountsScalarWhereInput | accountsScalarWhereInput[]
  }

  export type banks_items_versionsUncheckedUpdateManyWithoutBanksNestedInput = {
    create?: XOR<banks_items_versionsCreateWithoutBanksInput, banks_items_versionsUncheckedCreateWithoutBanksInput> | banks_items_versionsCreateWithoutBanksInput[] | banks_items_versionsUncheckedCreateWithoutBanksInput[]
    connectOrCreate?: banks_items_versionsCreateOrConnectWithoutBanksInput | banks_items_versionsCreateOrConnectWithoutBanksInput[]
    upsert?: banks_items_versionsUpsertWithWhereUniqueWithoutBanksInput | banks_items_versionsUpsertWithWhereUniqueWithoutBanksInput[]
    createMany?: banks_items_versionsCreateManyBanksInputEnvelope
    set?: banks_items_versionsWhereUniqueInput | banks_items_versionsWhereUniqueInput[]
    disconnect?: banks_items_versionsWhereUniqueInput | banks_items_versionsWhereUniqueInput[]
    delete?: banks_items_versionsWhereUniqueInput | banks_items_versionsWhereUniqueInput[]
    connect?: banks_items_versionsWhereUniqueInput | banks_items_versionsWhereUniqueInput[]
    update?: banks_items_versionsUpdateWithWhereUniqueWithoutBanksInput | banks_items_versionsUpdateWithWhereUniqueWithoutBanksInput[]
    updateMany?: banks_items_versionsUpdateManyWithWhereWithoutBanksInput | banks_items_versionsUpdateManyWithWhereWithoutBanksInput[]
    deleteMany?: banks_items_versionsScalarWhereInput | banks_items_versionsScalarWhereInput[]
  }

  export type banks_paketsCreateNestedOneWithoutBanks_itemsInput = {
    create?: XOR<banks_paketsCreateWithoutBanks_itemsInput, banks_paketsUncheckedCreateWithoutBanks_itemsInput>
    connectOrCreate?: banks_paketsCreateOrConnectWithoutBanks_itemsInput
    connect?: banks_paketsWhereUniqueInput
  }

  export type banks_items_versionsCreateNestedOneWithoutBanks_itemsInput = {
    create?: XOR<banks_items_versionsCreateWithoutBanks_itemsInput, banks_items_versionsUncheckedCreateWithoutBanks_itemsInput>
    connectOrCreate?: banks_items_versionsCreateOrConnectWithoutBanks_itemsInput
    connect?: banks_items_versionsWhereUniqueInput
  }

  export type itemsCreateNestedManyWithoutBanks_itemsInput = {
    create?: XOR<itemsCreateWithoutBanks_itemsInput, itemsUncheckedCreateWithoutBanks_itemsInput> | itemsCreateWithoutBanks_itemsInput[] | itemsUncheckedCreateWithoutBanks_itemsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutBanks_itemsInput | itemsCreateOrConnectWithoutBanks_itemsInput[]
    createMany?: itemsCreateManyBanks_itemsInputEnvelope
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
  }

  export type itemsUncheckedCreateNestedManyWithoutBanks_itemsInput = {
    create?: XOR<itemsCreateWithoutBanks_itemsInput, itemsUncheckedCreateWithoutBanks_itemsInput> | itemsCreateWithoutBanks_itemsInput[] | itemsUncheckedCreateWithoutBanks_itemsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutBanks_itemsInput | itemsCreateOrConnectWithoutBanks_itemsInput[]
    createMany?: itemsCreateManyBanks_itemsInputEnvelope
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type banks_paketsUpdateOneWithoutBanks_itemsNestedInput = {
    create?: XOR<banks_paketsCreateWithoutBanks_itemsInput, banks_paketsUncheckedCreateWithoutBanks_itemsInput>
    connectOrCreate?: banks_paketsCreateOrConnectWithoutBanks_itemsInput
    upsert?: banks_paketsUpsertWithoutBanks_itemsInput
    disconnect?: banks_paketsWhereInput | boolean
    delete?: banks_paketsWhereInput | boolean
    connect?: banks_paketsWhereUniqueInput
    update?: XOR<XOR<banks_paketsUpdateToOneWithWhereWithoutBanks_itemsInput, banks_paketsUpdateWithoutBanks_itemsInput>, banks_paketsUncheckedUpdateWithoutBanks_itemsInput>
  }

  export type banks_items_versionsUpdateOneWithoutBanks_itemsNestedInput = {
    create?: XOR<banks_items_versionsCreateWithoutBanks_itemsInput, banks_items_versionsUncheckedCreateWithoutBanks_itemsInput>
    connectOrCreate?: banks_items_versionsCreateOrConnectWithoutBanks_itemsInput
    upsert?: banks_items_versionsUpsertWithoutBanks_itemsInput
    disconnect?: banks_items_versionsWhereInput | boolean
    delete?: banks_items_versionsWhereInput | boolean
    connect?: banks_items_versionsWhereUniqueInput
    update?: XOR<XOR<banks_items_versionsUpdateToOneWithWhereWithoutBanks_itemsInput, banks_items_versionsUpdateWithoutBanks_itemsInput>, banks_items_versionsUncheckedUpdateWithoutBanks_itemsInput>
  }

  export type itemsUpdateManyWithoutBanks_itemsNestedInput = {
    create?: XOR<itemsCreateWithoutBanks_itemsInput, itemsUncheckedCreateWithoutBanks_itemsInput> | itemsCreateWithoutBanks_itemsInput[] | itemsUncheckedCreateWithoutBanks_itemsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutBanks_itemsInput | itemsCreateOrConnectWithoutBanks_itemsInput[]
    upsert?: itemsUpsertWithWhereUniqueWithoutBanks_itemsInput | itemsUpsertWithWhereUniqueWithoutBanks_itemsInput[]
    createMany?: itemsCreateManyBanks_itemsInputEnvelope
    set?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    disconnect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    delete?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    update?: itemsUpdateWithWhereUniqueWithoutBanks_itemsInput | itemsUpdateWithWhereUniqueWithoutBanks_itemsInput[]
    updateMany?: itemsUpdateManyWithWhereWithoutBanks_itemsInput | itemsUpdateManyWithWhereWithoutBanks_itemsInput[]
    deleteMany?: itemsScalarWhereInput | itemsScalarWhereInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type itemsUncheckedUpdateManyWithoutBanks_itemsNestedInput = {
    create?: XOR<itemsCreateWithoutBanks_itemsInput, itemsUncheckedCreateWithoutBanks_itemsInput> | itemsCreateWithoutBanks_itemsInput[] | itemsUncheckedCreateWithoutBanks_itemsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutBanks_itemsInput | itemsCreateOrConnectWithoutBanks_itemsInput[]
    upsert?: itemsUpsertWithWhereUniqueWithoutBanks_itemsInput | itemsUpsertWithWhereUniqueWithoutBanks_itemsInput[]
    createMany?: itemsCreateManyBanks_itemsInputEnvelope
    set?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    disconnect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    delete?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    update?: itemsUpdateWithWhereUniqueWithoutBanks_itemsInput | itemsUpdateWithWhereUniqueWithoutBanks_itemsInput[]
    updateMany?: itemsUpdateManyWithWhereWithoutBanks_itemsInput | itemsUpdateManyWithWhereWithoutBanks_itemsInput[]
    deleteMany?: itemsScalarWhereInput | itemsScalarWhereInput[]
  }

  export type banks_itemsCreateNestedManyWithoutBanks_paketsInput = {
    create?: XOR<banks_itemsCreateWithoutBanks_paketsInput, banks_itemsUncheckedCreateWithoutBanks_paketsInput> | banks_itemsCreateWithoutBanks_paketsInput[] | banks_itemsUncheckedCreateWithoutBanks_paketsInput[]
    connectOrCreate?: banks_itemsCreateOrConnectWithoutBanks_paketsInput | banks_itemsCreateOrConnectWithoutBanks_paketsInput[]
    createMany?: banks_itemsCreateManyBanks_paketsInputEnvelope
    connect?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
  }

  export type banks_itemsUncheckedCreateNestedManyWithoutBanks_paketsInput = {
    create?: XOR<banks_itemsCreateWithoutBanks_paketsInput, banks_itemsUncheckedCreateWithoutBanks_paketsInput> | banks_itemsCreateWithoutBanks_paketsInput[] | banks_itemsUncheckedCreateWithoutBanks_paketsInput[]
    connectOrCreate?: banks_itemsCreateOrConnectWithoutBanks_paketsInput | banks_itemsCreateOrConnectWithoutBanks_paketsInput[]
    createMany?: banks_itemsCreateManyBanks_paketsInputEnvelope
    connect?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
  }

  export type banks_itemsUpdateManyWithoutBanks_paketsNestedInput = {
    create?: XOR<banks_itemsCreateWithoutBanks_paketsInput, banks_itemsUncheckedCreateWithoutBanks_paketsInput> | banks_itemsCreateWithoutBanks_paketsInput[] | banks_itemsUncheckedCreateWithoutBanks_paketsInput[]
    connectOrCreate?: banks_itemsCreateOrConnectWithoutBanks_paketsInput | banks_itemsCreateOrConnectWithoutBanks_paketsInput[]
    upsert?: banks_itemsUpsertWithWhereUniqueWithoutBanks_paketsInput | banks_itemsUpsertWithWhereUniqueWithoutBanks_paketsInput[]
    createMany?: banks_itemsCreateManyBanks_paketsInputEnvelope
    set?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
    disconnect?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
    delete?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
    connect?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
    update?: banks_itemsUpdateWithWhereUniqueWithoutBanks_paketsInput | banks_itemsUpdateWithWhereUniqueWithoutBanks_paketsInput[]
    updateMany?: banks_itemsUpdateManyWithWhereWithoutBanks_paketsInput | banks_itemsUpdateManyWithWhereWithoutBanks_paketsInput[]
    deleteMany?: banks_itemsScalarWhereInput | banks_itemsScalarWhereInput[]
  }

  export type banks_itemsUncheckedUpdateManyWithoutBanks_paketsNestedInput = {
    create?: XOR<banks_itemsCreateWithoutBanks_paketsInput, banks_itemsUncheckedCreateWithoutBanks_paketsInput> | banks_itemsCreateWithoutBanks_paketsInput[] | banks_itemsUncheckedCreateWithoutBanks_paketsInput[]
    connectOrCreate?: banks_itemsCreateOrConnectWithoutBanks_paketsInput | banks_itemsCreateOrConnectWithoutBanks_paketsInput[]
    upsert?: banks_itemsUpsertWithWhereUniqueWithoutBanks_paketsInput | banks_itemsUpsertWithWhereUniqueWithoutBanks_paketsInput[]
    createMany?: banks_itemsCreateManyBanks_paketsInputEnvelope
    set?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
    disconnect?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
    delete?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
    connect?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
    update?: banks_itemsUpdateWithWhereUniqueWithoutBanks_paketsInput | banks_itemsUpdateWithWhereUniqueWithoutBanks_paketsInput[]
    updateMany?: banks_itemsUpdateManyWithWhereWithoutBanks_paketsInput | banks_itemsUpdateManyWithWhereWithoutBanks_paketsInput[]
    deleteMany?: banks_itemsScalarWhereInput | banks_itemsScalarWhereInput[]
  }

  export type paketsCreateNestedManyWithoutBlocksInput = {
    create?: XOR<paketsCreateWithoutBlocksInput, paketsUncheckedCreateWithoutBlocksInput> | paketsCreateWithoutBlocksInput[] | paketsUncheckedCreateWithoutBlocksInput[]
    connectOrCreate?: paketsCreateOrConnectWithoutBlocksInput | paketsCreateOrConnectWithoutBlocksInput[]
    createMany?: paketsCreateManyBlocksInputEnvelope
    connect?: paketsWhereUniqueInput | paketsWhereUniqueInput[]
  }

  export type paketsUncheckedCreateNestedManyWithoutBlocksInput = {
    create?: XOR<paketsCreateWithoutBlocksInput, paketsUncheckedCreateWithoutBlocksInput> | paketsCreateWithoutBlocksInput[] | paketsUncheckedCreateWithoutBlocksInput[]
    connectOrCreate?: paketsCreateOrConnectWithoutBlocksInput | paketsCreateOrConnectWithoutBlocksInput[]
    createMany?: paketsCreateManyBlocksInputEnvelope
    connect?: paketsWhereUniqueInput | paketsWhereUniqueInput[]
  }

  export type paketsUpdateManyWithoutBlocksNestedInput = {
    create?: XOR<paketsCreateWithoutBlocksInput, paketsUncheckedCreateWithoutBlocksInput> | paketsCreateWithoutBlocksInput[] | paketsUncheckedCreateWithoutBlocksInput[]
    connectOrCreate?: paketsCreateOrConnectWithoutBlocksInput | paketsCreateOrConnectWithoutBlocksInput[]
    upsert?: paketsUpsertWithWhereUniqueWithoutBlocksInput | paketsUpsertWithWhereUniqueWithoutBlocksInput[]
    createMany?: paketsCreateManyBlocksInputEnvelope
    set?: paketsWhereUniqueInput | paketsWhereUniqueInput[]
    disconnect?: paketsWhereUniqueInput | paketsWhereUniqueInput[]
    delete?: paketsWhereUniqueInput | paketsWhereUniqueInput[]
    connect?: paketsWhereUniqueInput | paketsWhereUniqueInput[]
    update?: paketsUpdateWithWhereUniqueWithoutBlocksInput | paketsUpdateWithWhereUniqueWithoutBlocksInput[]
    updateMany?: paketsUpdateManyWithWhereWithoutBlocksInput | paketsUpdateManyWithWhereWithoutBlocksInput[]
    deleteMany?: paketsScalarWhereInput | paketsScalarWhereInput[]
  }

  export type paketsUncheckedUpdateManyWithoutBlocksNestedInput = {
    create?: XOR<paketsCreateWithoutBlocksInput, paketsUncheckedCreateWithoutBlocksInput> | paketsCreateWithoutBlocksInput[] | paketsUncheckedCreateWithoutBlocksInput[]
    connectOrCreate?: paketsCreateOrConnectWithoutBlocksInput | paketsCreateOrConnectWithoutBlocksInput[]
    upsert?: paketsUpsertWithWhereUniqueWithoutBlocksInput | paketsUpsertWithWhereUniqueWithoutBlocksInput[]
    createMany?: paketsCreateManyBlocksInputEnvelope
    set?: paketsWhereUniqueInput | paketsWhereUniqueInput[]
    disconnect?: paketsWhereUniqueInput | paketsWhereUniqueInput[]
    delete?: paketsWhereUniqueInput | paketsWhereUniqueInput[]
    connect?: paketsWhereUniqueInput | paketsWhereUniqueInput[]
    update?: paketsUpdateWithWhereUniqueWithoutBlocksInput | paketsUpdateWithWhereUniqueWithoutBlocksInput[]
    updateMany?: paketsUpdateManyWithWhereWithoutBlocksInput | paketsUpdateManyWithWhereWithoutBlocksInput[]
    deleteMany?: paketsScalarWhereInput | paketsScalarWhereInput[]
  }

  export type accountsCreateNestedManyWithoutContractorsInput = {
    create?: XOR<accountsCreateWithoutContractorsInput, accountsUncheckedCreateWithoutContractorsInput> | accountsCreateWithoutContractorsInput[] | accountsUncheckedCreateWithoutContractorsInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutContractorsInput | accountsCreateOrConnectWithoutContractorsInput[]
    createMany?: accountsCreateManyContractorsInputEnvelope
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
  }

  export type r_users_client_contractorsCreateNestedManyWithoutContractorsInput = {
    create?: XOR<r_users_client_contractorsCreateWithoutContractorsInput, r_users_client_contractorsUncheckedCreateWithoutContractorsInput> | r_users_client_contractorsCreateWithoutContractorsInput[] | r_users_client_contractorsUncheckedCreateWithoutContractorsInput[]
    connectOrCreate?: r_users_client_contractorsCreateOrConnectWithoutContractorsInput | r_users_client_contractorsCreateOrConnectWithoutContractorsInput[]
    createMany?: r_users_client_contractorsCreateManyContractorsInputEnvelope
    connect?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
  }

  export type accountsUncheckedCreateNestedManyWithoutContractorsInput = {
    create?: XOR<accountsCreateWithoutContractorsInput, accountsUncheckedCreateWithoutContractorsInput> | accountsCreateWithoutContractorsInput[] | accountsUncheckedCreateWithoutContractorsInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutContractorsInput | accountsCreateOrConnectWithoutContractorsInput[]
    createMany?: accountsCreateManyContractorsInputEnvelope
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
  }

  export type r_users_client_contractorsUncheckedCreateNestedManyWithoutContractorsInput = {
    create?: XOR<r_users_client_contractorsCreateWithoutContractorsInput, r_users_client_contractorsUncheckedCreateWithoutContractorsInput> | r_users_client_contractorsCreateWithoutContractorsInput[] | r_users_client_contractorsUncheckedCreateWithoutContractorsInput[]
    connectOrCreate?: r_users_client_contractorsCreateOrConnectWithoutContractorsInput | r_users_client_contractorsCreateOrConnectWithoutContractorsInput[]
    createMany?: r_users_client_contractorsCreateManyContractorsInputEnvelope
    connect?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
  }

  export type accountsUpdateManyWithoutContractorsNestedInput = {
    create?: XOR<accountsCreateWithoutContractorsInput, accountsUncheckedCreateWithoutContractorsInput> | accountsCreateWithoutContractorsInput[] | accountsUncheckedCreateWithoutContractorsInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutContractorsInput | accountsCreateOrConnectWithoutContractorsInput[]
    upsert?: accountsUpsertWithWhereUniqueWithoutContractorsInput | accountsUpsertWithWhereUniqueWithoutContractorsInput[]
    createMany?: accountsCreateManyContractorsInputEnvelope
    set?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    disconnect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    delete?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    update?: accountsUpdateWithWhereUniqueWithoutContractorsInput | accountsUpdateWithWhereUniqueWithoutContractorsInput[]
    updateMany?: accountsUpdateManyWithWhereWithoutContractorsInput | accountsUpdateManyWithWhereWithoutContractorsInput[]
    deleteMany?: accountsScalarWhereInput | accountsScalarWhereInput[]
  }

  export type r_users_client_contractorsUpdateManyWithoutContractorsNestedInput = {
    create?: XOR<r_users_client_contractorsCreateWithoutContractorsInput, r_users_client_contractorsUncheckedCreateWithoutContractorsInput> | r_users_client_contractorsCreateWithoutContractorsInput[] | r_users_client_contractorsUncheckedCreateWithoutContractorsInput[]
    connectOrCreate?: r_users_client_contractorsCreateOrConnectWithoutContractorsInput | r_users_client_contractorsCreateOrConnectWithoutContractorsInput[]
    upsert?: r_users_client_contractorsUpsertWithWhereUniqueWithoutContractorsInput | r_users_client_contractorsUpsertWithWhereUniqueWithoutContractorsInput[]
    createMany?: r_users_client_contractorsCreateManyContractorsInputEnvelope
    set?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
    disconnect?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
    delete?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
    connect?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
    update?: r_users_client_contractorsUpdateWithWhereUniqueWithoutContractorsInput | r_users_client_contractorsUpdateWithWhereUniqueWithoutContractorsInput[]
    updateMany?: r_users_client_contractorsUpdateManyWithWhereWithoutContractorsInput | r_users_client_contractorsUpdateManyWithWhereWithoutContractorsInput[]
    deleteMany?: r_users_client_contractorsScalarWhereInput | r_users_client_contractorsScalarWhereInput[]
  }

  export type accountsUncheckedUpdateManyWithoutContractorsNestedInput = {
    create?: XOR<accountsCreateWithoutContractorsInput, accountsUncheckedCreateWithoutContractorsInput> | accountsCreateWithoutContractorsInput[] | accountsUncheckedCreateWithoutContractorsInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutContractorsInput | accountsCreateOrConnectWithoutContractorsInput[]
    upsert?: accountsUpsertWithWhereUniqueWithoutContractorsInput | accountsUpsertWithWhereUniqueWithoutContractorsInput[]
    createMany?: accountsCreateManyContractorsInputEnvelope
    set?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    disconnect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    delete?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    update?: accountsUpdateWithWhereUniqueWithoutContractorsInput | accountsUpdateWithWhereUniqueWithoutContractorsInput[]
    updateMany?: accountsUpdateManyWithWhereWithoutContractorsInput | accountsUpdateManyWithWhereWithoutContractorsInput[]
    deleteMany?: accountsScalarWhereInput | accountsScalarWhereInput[]
  }

  export type r_users_client_contractorsUncheckedUpdateManyWithoutContractorsNestedInput = {
    create?: XOR<r_users_client_contractorsCreateWithoutContractorsInput, r_users_client_contractorsUncheckedCreateWithoutContractorsInput> | r_users_client_contractorsCreateWithoutContractorsInput[] | r_users_client_contractorsUncheckedCreateWithoutContractorsInput[]
    connectOrCreate?: r_users_client_contractorsCreateOrConnectWithoutContractorsInput | r_users_client_contractorsCreateOrConnectWithoutContractorsInput[]
    upsert?: r_users_client_contractorsUpsertWithWhereUniqueWithoutContractorsInput | r_users_client_contractorsUpsertWithWhereUniqueWithoutContractorsInput[]
    createMany?: r_users_client_contractorsCreateManyContractorsInputEnvelope
    set?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
    disconnect?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
    delete?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
    connect?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
    update?: r_users_client_contractorsUpdateWithWhereUniqueWithoutContractorsInput | r_users_client_contractorsUpdateWithWhereUniqueWithoutContractorsInput[]
    updateMany?: r_users_client_contractorsUpdateManyWithWhereWithoutContractorsInput | r_users_client_contractorsUpdateManyWithWhereWithoutContractorsInput[]
    deleteMany?: r_users_client_contractorsScalarWhereInput | r_users_client_contractorsScalarWhereInput[]
  }

  export type sub_paketsCreateNestedOneWithoutItemsInput = {
    create?: XOR<sub_paketsCreateWithoutItemsInput, sub_paketsUncheckedCreateWithoutItemsInput>
    connectOrCreate?: sub_paketsCreateOrConnectWithoutItemsInput
    connect?: sub_paketsWhereUniqueInput
  }

  export type banks_itemsCreateNestedOneWithoutItemsInput = {
    create?: XOR<banks_itemsCreateWithoutItemsInput, banks_itemsUncheckedCreateWithoutItemsInput>
    connectOrCreate?: banks_itemsCreateOrConnectWithoutItemsInput
    connect?: banks_itemsWhereUniqueInput
  }

  export type sub_paketsUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<sub_paketsCreateWithoutItemsInput, sub_paketsUncheckedCreateWithoutItemsInput>
    connectOrCreate?: sub_paketsCreateOrConnectWithoutItemsInput
    upsert?: sub_paketsUpsertWithoutItemsInput
    connect?: sub_paketsWhereUniqueInput
    update?: XOR<XOR<sub_paketsUpdateToOneWithWhereWithoutItemsInput, sub_paketsUpdateWithoutItemsInput>, sub_paketsUncheckedUpdateWithoutItemsInput>
  }

  export type banks_itemsUpdateOneWithoutItemsNestedInput = {
    create?: XOR<banks_itemsCreateWithoutItemsInput, banks_itemsUncheckedCreateWithoutItemsInput>
    connectOrCreate?: banks_itemsCreateOrConnectWithoutItemsInput
    upsert?: banks_itemsUpsertWithoutItemsInput
    disconnect?: banks_itemsWhereInput | boolean
    delete?: banks_itemsWhereInput | boolean
    connect?: banks_itemsWhereUniqueInput
    update?: XOR<XOR<banks_itemsUpdateToOneWithWhereWithoutItemsInput, banks_itemsUpdateWithoutItemsInput>, banks_itemsUncheckedUpdateWithoutItemsInput>
  }

  export type entitiesCreateNestedOneWithoutObjectsInput = {
    create?: XOR<entitiesCreateWithoutObjectsInput, entitiesUncheckedCreateWithoutObjectsInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutObjectsInput
    connect?: entitiesWhereUniqueInput
  }

  export type sectionsCreateNestedManyWithoutObjectsInput = {
    create?: XOR<sectionsCreateWithoutObjectsInput, sectionsUncheckedCreateWithoutObjectsInput> | sectionsCreateWithoutObjectsInput[] | sectionsUncheckedCreateWithoutObjectsInput[]
    connectOrCreate?: sectionsCreateOrConnectWithoutObjectsInput | sectionsCreateOrConnectWithoutObjectsInput[]
    createMany?: sectionsCreateManyObjectsInputEnvelope
    connect?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
  }

  export type sectionsUncheckedCreateNestedManyWithoutObjectsInput = {
    create?: XOR<sectionsCreateWithoutObjectsInput, sectionsUncheckedCreateWithoutObjectsInput> | sectionsCreateWithoutObjectsInput[] | sectionsUncheckedCreateWithoutObjectsInput[]
    connectOrCreate?: sectionsCreateOrConnectWithoutObjectsInput | sectionsCreateOrConnectWithoutObjectsInput[]
    createMany?: sectionsCreateManyObjectsInputEnvelope
    connect?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
  }

  export type entitiesUpdateOneRequiredWithoutObjectsNestedInput = {
    create?: XOR<entitiesCreateWithoutObjectsInput, entitiesUncheckedCreateWithoutObjectsInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutObjectsInput
    upsert?: entitiesUpsertWithoutObjectsInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutObjectsInput, entitiesUpdateWithoutObjectsInput>, entitiesUncheckedUpdateWithoutObjectsInput>
  }

  export type sectionsUpdateManyWithoutObjectsNestedInput = {
    create?: XOR<sectionsCreateWithoutObjectsInput, sectionsUncheckedCreateWithoutObjectsInput> | sectionsCreateWithoutObjectsInput[] | sectionsUncheckedCreateWithoutObjectsInput[]
    connectOrCreate?: sectionsCreateOrConnectWithoutObjectsInput | sectionsCreateOrConnectWithoutObjectsInput[]
    upsert?: sectionsUpsertWithWhereUniqueWithoutObjectsInput | sectionsUpsertWithWhereUniqueWithoutObjectsInput[]
    createMany?: sectionsCreateManyObjectsInputEnvelope
    set?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
    disconnect?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
    delete?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
    connect?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
    update?: sectionsUpdateWithWhereUniqueWithoutObjectsInput | sectionsUpdateWithWhereUniqueWithoutObjectsInput[]
    updateMany?: sectionsUpdateManyWithWhereWithoutObjectsInput | sectionsUpdateManyWithWhereWithoutObjectsInput[]
    deleteMany?: sectionsScalarWhereInput | sectionsScalarWhereInput[]
  }

  export type sectionsUncheckedUpdateManyWithoutObjectsNestedInput = {
    create?: XOR<sectionsCreateWithoutObjectsInput, sectionsUncheckedCreateWithoutObjectsInput> | sectionsCreateWithoutObjectsInput[] | sectionsUncheckedCreateWithoutObjectsInput[]
    connectOrCreate?: sectionsCreateOrConnectWithoutObjectsInput | sectionsCreateOrConnectWithoutObjectsInput[]
    upsert?: sectionsUpsertWithWhereUniqueWithoutObjectsInput | sectionsUpsertWithWhereUniqueWithoutObjectsInput[]
    createMany?: sectionsCreateManyObjectsInputEnvelope
    set?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
    disconnect?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
    delete?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
    connect?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
    update?: sectionsUpdateWithWhereUniqueWithoutObjectsInput | sectionsUpdateWithWhereUniqueWithoutObjectsInput[]
    updateMany?: sectionsUpdateManyWithWhereWithoutObjectsInput | sectionsUpdateManyWithWhereWithoutObjectsInput[]
    deleteMany?: sectionsScalarWhereInput | sectionsScalarWhereInput[]
  }

  export type blocksCreateNestedOneWithoutPaketsInput = {
    create?: XOR<blocksCreateWithoutPaketsInput, blocksUncheckedCreateWithoutPaketsInput>
    connectOrCreate?: blocksCreateOrConnectWithoutPaketsInput
    connect?: blocksWhereUniqueInput
  }

  export type sub_paketsCreateNestedManyWithoutPaketsInput = {
    create?: XOR<sub_paketsCreateWithoutPaketsInput, sub_paketsUncheckedCreateWithoutPaketsInput> | sub_paketsCreateWithoutPaketsInput[] | sub_paketsUncheckedCreateWithoutPaketsInput[]
    connectOrCreate?: sub_paketsCreateOrConnectWithoutPaketsInput | sub_paketsCreateOrConnectWithoutPaketsInput[]
    createMany?: sub_paketsCreateManyPaketsInputEnvelope
    connect?: sub_paketsWhereUniqueInput | sub_paketsWhereUniqueInput[]
  }

  export type sub_paketsUncheckedCreateNestedManyWithoutPaketsInput = {
    create?: XOR<sub_paketsCreateWithoutPaketsInput, sub_paketsUncheckedCreateWithoutPaketsInput> | sub_paketsCreateWithoutPaketsInput[] | sub_paketsUncheckedCreateWithoutPaketsInput[]
    connectOrCreate?: sub_paketsCreateOrConnectWithoutPaketsInput | sub_paketsCreateOrConnectWithoutPaketsInput[]
    createMany?: sub_paketsCreateManyPaketsInputEnvelope
    connect?: sub_paketsWhereUniqueInput | sub_paketsWhereUniqueInput[]
  }

  export type blocksUpdateOneRequiredWithoutPaketsNestedInput = {
    create?: XOR<blocksCreateWithoutPaketsInput, blocksUncheckedCreateWithoutPaketsInput>
    connectOrCreate?: blocksCreateOrConnectWithoutPaketsInput
    upsert?: blocksUpsertWithoutPaketsInput
    connect?: blocksWhereUniqueInput
    update?: XOR<XOR<blocksUpdateToOneWithWhereWithoutPaketsInput, blocksUpdateWithoutPaketsInput>, blocksUncheckedUpdateWithoutPaketsInput>
  }

  export type sub_paketsUpdateManyWithoutPaketsNestedInput = {
    create?: XOR<sub_paketsCreateWithoutPaketsInput, sub_paketsUncheckedCreateWithoutPaketsInput> | sub_paketsCreateWithoutPaketsInput[] | sub_paketsUncheckedCreateWithoutPaketsInput[]
    connectOrCreate?: sub_paketsCreateOrConnectWithoutPaketsInput | sub_paketsCreateOrConnectWithoutPaketsInput[]
    upsert?: sub_paketsUpsertWithWhereUniqueWithoutPaketsInput | sub_paketsUpsertWithWhereUniqueWithoutPaketsInput[]
    createMany?: sub_paketsCreateManyPaketsInputEnvelope
    set?: sub_paketsWhereUniqueInput | sub_paketsWhereUniqueInput[]
    disconnect?: sub_paketsWhereUniqueInput | sub_paketsWhereUniqueInput[]
    delete?: sub_paketsWhereUniqueInput | sub_paketsWhereUniqueInput[]
    connect?: sub_paketsWhereUniqueInput | sub_paketsWhereUniqueInput[]
    update?: sub_paketsUpdateWithWhereUniqueWithoutPaketsInput | sub_paketsUpdateWithWhereUniqueWithoutPaketsInput[]
    updateMany?: sub_paketsUpdateManyWithWhereWithoutPaketsInput | sub_paketsUpdateManyWithWhereWithoutPaketsInput[]
    deleteMany?: sub_paketsScalarWhereInput | sub_paketsScalarWhereInput[]
  }

  export type sub_paketsUncheckedUpdateManyWithoutPaketsNestedInput = {
    create?: XOR<sub_paketsCreateWithoutPaketsInput, sub_paketsUncheckedCreateWithoutPaketsInput> | sub_paketsCreateWithoutPaketsInput[] | sub_paketsUncheckedCreateWithoutPaketsInput[]
    connectOrCreate?: sub_paketsCreateOrConnectWithoutPaketsInput | sub_paketsCreateOrConnectWithoutPaketsInput[]
    upsert?: sub_paketsUpsertWithWhereUniqueWithoutPaketsInput | sub_paketsUpsertWithWhereUniqueWithoutPaketsInput[]
    createMany?: sub_paketsCreateManyPaketsInputEnvelope
    set?: sub_paketsWhereUniqueInput | sub_paketsWhereUniqueInput[]
    disconnect?: sub_paketsWhereUniqueInput | sub_paketsWhereUniqueInput[]
    delete?: sub_paketsWhereUniqueInput | sub_paketsWhereUniqueInput[]
    connect?: sub_paketsWhereUniqueInput | sub_paketsWhereUniqueInput[]
    update?: sub_paketsUpdateWithWhereUniqueWithoutPaketsInput | sub_paketsUpdateWithWhereUniqueWithoutPaketsInput[]
    updateMany?: sub_paketsUpdateManyWithWhereWithoutPaketsInput | sub_paketsUpdateManyWithWhereWithoutPaketsInput[]
    deleteMany?: sub_paketsScalarWhereInput | sub_paketsScalarWhereInput[]
  }

  export type rolesCreateNestedOneWithoutR_roles_appsInput = {
    create?: XOR<rolesCreateWithoutR_roles_appsInput, rolesUncheckedCreateWithoutR_roles_appsInput>
    connectOrCreate?: rolesCreateOrConnectWithoutR_roles_appsInput
    connect?: rolesWhereUniqueInput
  }

  export type applicationsCreateNestedOneWithoutR_roles_appsInput = {
    create?: XOR<applicationsCreateWithoutR_roles_appsInput, applicationsUncheckedCreateWithoutR_roles_appsInput>
    connectOrCreate?: applicationsCreateOrConnectWithoutR_roles_appsInput
    connect?: applicationsWhereUniqueInput
  }

  export type rolesUpdateOneRequiredWithoutR_roles_appsNestedInput = {
    create?: XOR<rolesCreateWithoutR_roles_appsInput, rolesUncheckedCreateWithoutR_roles_appsInput>
    connectOrCreate?: rolesCreateOrConnectWithoutR_roles_appsInput
    upsert?: rolesUpsertWithoutR_roles_appsInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutR_roles_appsInput, rolesUpdateWithoutR_roles_appsInput>, rolesUncheckedUpdateWithoutR_roles_appsInput>
  }

  export type applicationsUpdateOneRequiredWithoutR_roles_appsNestedInput = {
    create?: XOR<applicationsCreateWithoutR_roles_appsInput, applicationsUncheckedCreateWithoutR_roles_appsInput>
    connectOrCreate?: applicationsCreateOrConnectWithoutR_roles_appsInput
    upsert?: applicationsUpsertWithoutR_roles_appsInput
    connect?: applicationsWhereUniqueInput
    update?: XOR<XOR<applicationsUpdateToOneWithWhereWithoutR_roles_appsInput, applicationsUpdateWithoutR_roles_appsInput>, applicationsUncheckedUpdateWithoutR_roles_appsInput>
  }

  export type contractorsCreateNestedOneWithoutR_users_client_contractorsInput = {
    create?: XOR<contractorsCreateWithoutR_users_client_contractorsInput, contractorsUncheckedCreateWithoutR_users_client_contractorsInput>
    connectOrCreate?: contractorsCreateOrConnectWithoutR_users_client_contractorsInput
    connect?: contractorsWhereUniqueInput
  }

  export type users_clientCreateNestedOneWithoutR_users_client_contractorsInput = {
    create?: XOR<users_clientCreateWithoutR_users_client_contractorsInput, users_clientUncheckedCreateWithoutR_users_client_contractorsInput>
    connectOrCreate?: users_clientCreateOrConnectWithoutR_users_client_contractorsInput
    connect?: users_clientWhereUniqueInput
  }

  export type contractorsUpdateOneRequiredWithoutR_users_client_contractorsNestedInput = {
    create?: XOR<contractorsCreateWithoutR_users_client_contractorsInput, contractorsUncheckedCreateWithoutR_users_client_contractorsInput>
    connectOrCreate?: contractorsCreateOrConnectWithoutR_users_client_contractorsInput
    upsert?: contractorsUpsertWithoutR_users_client_contractorsInput
    connect?: contractorsWhereUniqueInput
    update?: XOR<XOR<contractorsUpdateToOneWithWhereWithoutR_users_client_contractorsInput, contractorsUpdateWithoutR_users_client_contractorsInput>, contractorsUncheckedUpdateWithoutR_users_client_contractorsInput>
  }

  export type users_clientUpdateOneRequiredWithoutR_users_client_contractorsNestedInput = {
    create?: XOR<users_clientCreateWithoutR_users_client_contractorsInput, users_clientUncheckedCreateWithoutR_users_client_contractorsInput>
    connectOrCreate?: users_clientCreateOrConnectWithoutR_users_client_contractorsInput
    upsert?: users_clientUpsertWithoutR_users_client_contractorsInput
    connect?: users_clientWhereUniqueInput
    update?: XOR<XOR<users_clientUpdateToOneWithWhereWithoutR_users_client_contractorsInput, users_clientUpdateWithoutR_users_client_contractorsInput>, users_clientUncheckedUpdateWithoutR_users_client_contractorsInput>
  }

  export type usersCreateNestedOneWithoutR_users_rolesInput = {
    create?: XOR<usersCreateWithoutR_users_rolesInput, usersUncheckedCreateWithoutR_users_rolesInput>
    connectOrCreate?: usersCreateOrConnectWithoutR_users_rolesInput
    connect?: usersWhereUniqueInput
  }

  export type rolesCreateNestedOneWithoutR_users_rolesInput = {
    create?: XOR<rolesCreateWithoutR_users_rolesInput, rolesUncheckedCreateWithoutR_users_rolesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutR_users_rolesInput
    connect?: rolesWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutR_users_rolesNestedInput = {
    create?: XOR<usersCreateWithoutR_users_rolesInput, usersUncheckedCreateWithoutR_users_rolesInput>
    connectOrCreate?: usersCreateOrConnectWithoutR_users_rolesInput
    upsert?: usersUpsertWithoutR_users_rolesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutR_users_rolesInput, usersUpdateWithoutR_users_rolesInput>, usersUncheckedUpdateWithoutR_users_rolesInput>
  }

  export type rolesUpdateOneRequiredWithoutR_users_rolesNestedInput = {
    create?: XOR<rolesCreateWithoutR_users_rolesInput, rolesUncheckedCreateWithoutR_users_rolesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutR_users_rolesInput
    upsert?: rolesUpsertWithoutR_users_rolesInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutR_users_rolesInput, rolesUpdateWithoutR_users_rolesInput>, rolesUncheckedUpdateWithoutR_users_rolesInput>
  }

  export type r_roles_appsCreateNestedManyWithoutRolesInput = {
    create?: XOR<r_roles_appsCreateWithoutRolesInput, r_roles_appsUncheckedCreateWithoutRolesInput> | r_roles_appsCreateWithoutRolesInput[] | r_roles_appsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: r_roles_appsCreateOrConnectWithoutRolesInput | r_roles_appsCreateOrConnectWithoutRolesInput[]
    createMany?: r_roles_appsCreateManyRolesInputEnvelope
    connect?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
  }

  export type r_users_rolesCreateNestedManyWithoutRolesInput = {
    create?: XOR<r_users_rolesCreateWithoutRolesInput, r_users_rolesUncheckedCreateWithoutRolesInput> | r_users_rolesCreateWithoutRolesInput[] | r_users_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: r_users_rolesCreateOrConnectWithoutRolesInput | r_users_rolesCreateOrConnectWithoutRolesInput[]
    createMany?: r_users_rolesCreateManyRolesInputEnvelope
    connect?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
  }

  export type r_roles_appsUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<r_roles_appsCreateWithoutRolesInput, r_roles_appsUncheckedCreateWithoutRolesInput> | r_roles_appsCreateWithoutRolesInput[] | r_roles_appsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: r_roles_appsCreateOrConnectWithoutRolesInput | r_roles_appsCreateOrConnectWithoutRolesInput[]
    createMany?: r_roles_appsCreateManyRolesInputEnvelope
    connect?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
  }

  export type r_users_rolesUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<r_users_rolesCreateWithoutRolesInput, r_users_rolesUncheckedCreateWithoutRolesInput> | r_users_rolesCreateWithoutRolesInput[] | r_users_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: r_users_rolesCreateOrConnectWithoutRolesInput | r_users_rolesCreateOrConnectWithoutRolesInput[]
    createMany?: r_users_rolesCreateManyRolesInputEnvelope
    connect?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
  }

  export type r_roles_appsUpdateManyWithoutRolesNestedInput = {
    create?: XOR<r_roles_appsCreateWithoutRolesInput, r_roles_appsUncheckedCreateWithoutRolesInput> | r_roles_appsCreateWithoutRolesInput[] | r_roles_appsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: r_roles_appsCreateOrConnectWithoutRolesInput | r_roles_appsCreateOrConnectWithoutRolesInput[]
    upsert?: r_roles_appsUpsertWithWhereUniqueWithoutRolesInput | r_roles_appsUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: r_roles_appsCreateManyRolesInputEnvelope
    set?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
    disconnect?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
    delete?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
    connect?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
    update?: r_roles_appsUpdateWithWhereUniqueWithoutRolesInput | r_roles_appsUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: r_roles_appsUpdateManyWithWhereWithoutRolesInput | r_roles_appsUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: r_roles_appsScalarWhereInput | r_roles_appsScalarWhereInput[]
  }

  export type r_users_rolesUpdateManyWithoutRolesNestedInput = {
    create?: XOR<r_users_rolesCreateWithoutRolesInput, r_users_rolesUncheckedCreateWithoutRolesInput> | r_users_rolesCreateWithoutRolesInput[] | r_users_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: r_users_rolesCreateOrConnectWithoutRolesInput | r_users_rolesCreateOrConnectWithoutRolesInput[]
    upsert?: r_users_rolesUpsertWithWhereUniqueWithoutRolesInput | r_users_rolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: r_users_rolesCreateManyRolesInputEnvelope
    set?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
    disconnect?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
    delete?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
    connect?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
    update?: r_users_rolesUpdateWithWhereUniqueWithoutRolesInput | r_users_rolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: r_users_rolesUpdateManyWithWhereWithoutRolesInput | r_users_rolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: r_users_rolesScalarWhereInput | r_users_rolesScalarWhereInput[]
  }

  export type r_roles_appsUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<r_roles_appsCreateWithoutRolesInput, r_roles_appsUncheckedCreateWithoutRolesInput> | r_roles_appsCreateWithoutRolesInput[] | r_roles_appsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: r_roles_appsCreateOrConnectWithoutRolesInput | r_roles_appsCreateOrConnectWithoutRolesInput[]
    upsert?: r_roles_appsUpsertWithWhereUniqueWithoutRolesInput | r_roles_appsUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: r_roles_appsCreateManyRolesInputEnvelope
    set?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
    disconnect?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
    delete?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
    connect?: r_roles_appsWhereUniqueInput | r_roles_appsWhereUniqueInput[]
    update?: r_roles_appsUpdateWithWhereUniqueWithoutRolesInput | r_roles_appsUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: r_roles_appsUpdateManyWithWhereWithoutRolesInput | r_roles_appsUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: r_roles_appsScalarWhereInput | r_roles_appsScalarWhereInput[]
  }

  export type r_users_rolesUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<r_users_rolesCreateWithoutRolesInput, r_users_rolesUncheckedCreateWithoutRolesInput> | r_users_rolesCreateWithoutRolesInput[] | r_users_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: r_users_rolesCreateOrConnectWithoutRolesInput | r_users_rolesCreateOrConnectWithoutRolesInput[]
    upsert?: r_users_rolesUpsertWithWhereUniqueWithoutRolesInput | r_users_rolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: r_users_rolesCreateManyRolesInputEnvelope
    set?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
    disconnect?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
    delete?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
    connect?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
    update?: r_users_rolesUpdateWithWhereUniqueWithoutRolesInput | r_users_rolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: r_users_rolesUpdateManyWithWhereWithoutRolesInput | r_users_rolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: r_users_rolesScalarWhereInput | r_users_rolesScalarWhereInput[]
  }

  export type users_clientCreateNestedManyWithoutRoles_clientInput = {
    create?: XOR<users_clientCreateWithoutRoles_clientInput, users_clientUncheckedCreateWithoutRoles_clientInput> | users_clientCreateWithoutRoles_clientInput[] | users_clientUncheckedCreateWithoutRoles_clientInput[]
    connectOrCreate?: users_clientCreateOrConnectWithoutRoles_clientInput | users_clientCreateOrConnectWithoutRoles_clientInput[]
    createMany?: users_clientCreateManyRoles_clientInputEnvelope
    connect?: users_clientWhereUniqueInput | users_clientWhereUniqueInput[]
  }

  export type users_clientUncheckedCreateNestedManyWithoutRoles_clientInput = {
    create?: XOR<users_clientCreateWithoutRoles_clientInput, users_clientUncheckedCreateWithoutRoles_clientInput> | users_clientCreateWithoutRoles_clientInput[] | users_clientUncheckedCreateWithoutRoles_clientInput[]
    connectOrCreate?: users_clientCreateOrConnectWithoutRoles_clientInput | users_clientCreateOrConnectWithoutRoles_clientInput[]
    createMany?: users_clientCreateManyRoles_clientInputEnvelope
    connect?: users_clientWhereUniqueInput | users_clientWhereUniqueInput[]
  }

  export type users_clientUpdateManyWithoutRoles_clientNestedInput = {
    create?: XOR<users_clientCreateWithoutRoles_clientInput, users_clientUncheckedCreateWithoutRoles_clientInput> | users_clientCreateWithoutRoles_clientInput[] | users_clientUncheckedCreateWithoutRoles_clientInput[]
    connectOrCreate?: users_clientCreateOrConnectWithoutRoles_clientInput | users_clientCreateOrConnectWithoutRoles_clientInput[]
    upsert?: users_clientUpsertWithWhereUniqueWithoutRoles_clientInput | users_clientUpsertWithWhereUniqueWithoutRoles_clientInput[]
    createMany?: users_clientCreateManyRoles_clientInputEnvelope
    set?: users_clientWhereUniqueInput | users_clientWhereUniqueInput[]
    disconnect?: users_clientWhereUniqueInput | users_clientWhereUniqueInput[]
    delete?: users_clientWhereUniqueInput | users_clientWhereUniqueInput[]
    connect?: users_clientWhereUniqueInput | users_clientWhereUniqueInput[]
    update?: users_clientUpdateWithWhereUniqueWithoutRoles_clientInput | users_clientUpdateWithWhereUniqueWithoutRoles_clientInput[]
    updateMany?: users_clientUpdateManyWithWhereWithoutRoles_clientInput | users_clientUpdateManyWithWhereWithoutRoles_clientInput[]
    deleteMany?: users_clientScalarWhereInput | users_clientScalarWhereInput[]
  }

  export type users_clientUncheckedUpdateManyWithoutRoles_clientNestedInput = {
    create?: XOR<users_clientCreateWithoutRoles_clientInput, users_clientUncheckedCreateWithoutRoles_clientInput> | users_clientCreateWithoutRoles_clientInput[] | users_clientUncheckedCreateWithoutRoles_clientInput[]
    connectOrCreate?: users_clientCreateOrConnectWithoutRoles_clientInput | users_clientCreateOrConnectWithoutRoles_clientInput[]
    upsert?: users_clientUpsertWithWhereUniqueWithoutRoles_clientInput | users_clientUpsertWithWhereUniqueWithoutRoles_clientInput[]
    createMany?: users_clientCreateManyRoles_clientInputEnvelope
    set?: users_clientWhereUniqueInput | users_clientWhereUniqueInput[]
    disconnect?: users_clientWhereUniqueInput | users_clientWhereUniqueInput[]
    delete?: users_clientWhereUniqueInput | users_clientWhereUniqueInput[]
    connect?: users_clientWhereUniqueInput | users_clientWhereUniqueInput[]
    update?: users_clientUpdateWithWhereUniqueWithoutRoles_clientInput | users_clientUpdateWithWhereUniqueWithoutRoles_clientInput[]
    updateMany?: users_clientUpdateManyWithWhereWithoutRoles_clientInput | users_clientUpdateManyWithWhereWithoutRoles_clientInput[]
    deleteMany?: users_clientScalarWhereInput | users_clientScalarWhereInput[]
  }

  export type objectsCreateNestedOneWithoutSectionsInput = {
    create?: XOR<objectsCreateWithoutSectionsInput, objectsUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: objectsCreateOrConnectWithoutSectionsInput
    connect?: objectsWhereUniqueInput
  }

  export type objectsUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<objectsCreateWithoutSectionsInput, objectsUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: objectsCreateOrConnectWithoutSectionsInput
    upsert?: objectsUpsertWithoutSectionsInput
    connect?: objectsWhereUniqueInput
    update?: XOR<XOR<objectsUpdateToOneWithWhereWithoutSectionsInput, objectsUpdateWithoutSectionsInput>, objectsUncheckedUpdateWithoutSectionsInput>
  }

  export type itemsCreateNestedManyWithoutSub_paketsInput = {
    create?: XOR<itemsCreateWithoutSub_paketsInput, itemsUncheckedCreateWithoutSub_paketsInput> | itemsCreateWithoutSub_paketsInput[] | itemsUncheckedCreateWithoutSub_paketsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutSub_paketsInput | itemsCreateOrConnectWithoutSub_paketsInput[]
    createMany?: itemsCreateManySub_paketsInputEnvelope
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
  }

  export type paketsCreateNestedOneWithoutSub_paketsInput = {
    create?: XOR<paketsCreateWithoutSub_paketsInput, paketsUncheckedCreateWithoutSub_paketsInput>
    connectOrCreate?: paketsCreateOrConnectWithoutSub_paketsInput
    connect?: paketsWhereUniqueInput
  }

  export type itemsUncheckedCreateNestedManyWithoutSub_paketsInput = {
    create?: XOR<itemsCreateWithoutSub_paketsInput, itemsUncheckedCreateWithoutSub_paketsInput> | itemsCreateWithoutSub_paketsInput[] | itemsUncheckedCreateWithoutSub_paketsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutSub_paketsInput | itemsCreateOrConnectWithoutSub_paketsInput[]
    createMany?: itemsCreateManySub_paketsInputEnvelope
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
  }

  export type itemsUpdateManyWithoutSub_paketsNestedInput = {
    create?: XOR<itemsCreateWithoutSub_paketsInput, itemsUncheckedCreateWithoutSub_paketsInput> | itemsCreateWithoutSub_paketsInput[] | itemsUncheckedCreateWithoutSub_paketsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutSub_paketsInput | itemsCreateOrConnectWithoutSub_paketsInput[]
    upsert?: itemsUpsertWithWhereUniqueWithoutSub_paketsInput | itemsUpsertWithWhereUniqueWithoutSub_paketsInput[]
    createMany?: itemsCreateManySub_paketsInputEnvelope
    set?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    disconnect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    delete?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    update?: itemsUpdateWithWhereUniqueWithoutSub_paketsInput | itemsUpdateWithWhereUniqueWithoutSub_paketsInput[]
    updateMany?: itemsUpdateManyWithWhereWithoutSub_paketsInput | itemsUpdateManyWithWhereWithoutSub_paketsInput[]
    deleteMany?: itemsScalarWhereInput | itemsScalarWhereInput[]
  }

  export type paketsUpdateOneRequiredWithoutSub_paketsNestedInput = {
    create?: XOR<paketsCreateWithoutSub_paketsInput, paketsUncheckedCreateWithoutSub_paketsInput>
    connectOrCreate?: paketsCreateOrConnectWithoutSub_paketsInput
    upsert?: paketsUpsertWithoutSub_paketsInput
    connect?: paketsWhereUniqueInput
    update?: XOR<XOR<paketsUpdateToOneWithWhereWithoutSub_paketsInput, paketsUpdateWithoutSub_paketsInput>, paketsUncheckedUpdateWithoutSub_paketsInput>
  }

  export type itemsUncheckedUpdateManyWithoutSub_paketsNestedInput = {
    create?: XOR<itemsCreateWithoutSub_paketsInput, itemsUncheckedCreateWithoutSub_paketsInput> | itemsCreateWithoutSub_paketsInput[] | itemsUncheckedCreateWithoutSub_paketsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutSub_paketsInput | itemsCreateOrConnectWithoutSub_paketsInput[]
    upsert?: itemsUpsertWithWhereUniqueWithoutSub_paketsInput | itemsUpsertWithWhereUniqueWithoutSub_paketsInput[]
    createMany?: itemsCreateManySub_paketsInputEnvelope
    set?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    disconnect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    delete?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    update?: itemsUpdateWithWhereUniqueWithoutSub_paketsInput | itemsUpdateWithWhereUniqueWithoutSub_paketsInput[]
    updateMany?: itemsUpdateManyWithWhereWithoutSub_paketsInput | itemsUpdateManyWithWhereWithoutSub_paketsInput[]
    deleteMany?: itemsScalarWhereInput | itemsScalarWhereInput[]
  }

  export type r_users_rolesCreateNestedManyWithoutUsersInput = {
    create?: XOR<r_users_rolesCreateWithoutUsersInput, r_users_rolesUncheckedCreateWithoutUsersInput> | r_users_rolesCreateWithoutUsersInput[] | r_users_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: r_users_rolesCreateOrConnectWithoutUsersInput | r_users_rolesCreateOrConnectWithoutUsersInput[]
    createMany?: r_users_rolesCreateManyUsersInputEnvelope
    connect?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
  }

  export type r_users_rolesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<r_users_rolesCreateWithoutUsersInput, r_users_rolesUncheckedCreateWithoutUsersInput> | r_users_rolesCreateWithoutUsersInput[] | r_users_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: r_users_rolesCreateOrConnectWithoutUsersInput | r_users_rolesCreateOrConnectWithoutUsersInput[]
    createMany?: r_users_rolesCreateManyUsersInputEnvelope
    connect?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
  }

  export type r_users_rolesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<r_users_rolesCreateWithoutUsersInput, r_users_rolesUncheckedCreateWithoutUsersInput> | r_users_rolesCreateWithoutUsersInput[] | r_users_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: r_users_rolesCreateOrConnectWithoutUsersInput | r_users_rolesCreateOrConnectWithoutUsersInput[]
    upsert?: r_users_rolesUpsertWithWhereUniqueWithoutUsersInput | r_users_rolesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: r_users_rolesCreateManyUsersInputEnvelope
    set?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
    disconnect?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
    delete?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
    connect?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
    update?: r_users_rolesUpdateWithWhereUniqueWithoutUsersInput | r_users_rolesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: r_users_rolesUpdateManyWithWhereWithoutUsersInput | r_users_rolesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: r_users_rolesScalarWhereInput | r_users_rolesScalarWhereInput[]
  }

  export type r_users_rolesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<r_users_rolesCreateWithoutUsersInput, r_users_rolesUncheckedCreateWithoutUsersInput> | r_users_rolesCreateWithoutUsersInput[] | r_users_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: r_users_rolesCreateOrConnectWithoutUsersInput | r_users_rolesCreateOrConnectWithoutUsersInput[]
    upsert?: r_users_rolesUpsertWithWhereUniqueWithoutUsersInput | r_users_rolesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: r_users_rolesCreateManyUsersInputEnvelope
    set?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
    disconnect?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
    delete?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
    connect?: r_users_rolesWhereUniqueInput | r_users_rolesWhereUniqueInput[]
    update?: r_users_rolesUpdateWithWhereUniqueWithoutUsersInput | r_users_rolesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: r_users_rolesUpdateManyWithWhereWithoutUsersInput | r_users_rolesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: r_users_rolesScalarWhereInput | r_users_rolesScalarWhereInput[]
  }

  export type r_users_client_contractorsCreateNestedManyWithoutUsers_clientInput = {
    create?: XOR<r_users_client_contractorsCreateWithoutUsers_clientInput, r_users_client_contractorsUncheckedCreateWithoutUsers_clientInput> | r_users_client_contractorsCreateWithoutUsers_clientInput[] | r_users_client_contractorsUncheckedCreateWithoutUsers_clientInput[]
    connectOrCreate?: r_users_client_contractorsCreateOrConnectWithoutUsers_clientInput | r_users_client_contractorsCreateOrConnectWithoutUsers_clientInput[]
    createMany?: r_users_client_contractorsCreateManyUsers_clientInputEnvelope
    connect?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
  }

  export type roles_clientCreateNestedOneWithoutUsers_clientInput = {
    create?: XOR<roles_clientCreateWithoutUsers_clientInput, roles_clientUncheckedCreateWithoutUsers_clientInput>
    connectOrCreate?: roles_clientCreateOrConnectWithoutUsers_clientInput
    connect?: roles_clientWhereUniqueInput
  }

  export type r_users_client_contractorsUncheckedCreateNestedManyWithoutUsers_clientInput = {
    create?: XOR<r_users_client_contractorsCreateWithoutUsers_clientInput, r_users_client_contractorsUncheckedCreateWithoutUsers_clientInput> | r_users_client_contractorsCreateWithoutUsers_clientInput[] | r_users_client_contractorsUncheckedCreateWithoutUsers_clientInput[]
    connectOrCreate?: r_users_client_contractorsCreateOrConnectWithoutUsers_clientInput | r_users_client_contractorsCreateOrConnectWithoutUsers_clientInput[]
    createMany?: r_users_client_contractorsCreateManyUsers_clientInputEnvelope
    connect?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type r_users_client_contractorsUpdateManyWithoutUsers_clientNestedInput = {
    create?: XOR<r_users_client_contractorsCreateWithoutUsers_clientInput, r_users_client_contractorsUncheckedCreateWithoutUsers_clientInput> | r_users_client_contractorsCreateWithoutUsers_clientInput[] | r_users_client_contractorsUncheckedCreateWithoutUsers_clientInput[]
    connectOrCreate?: r_users_client_contractorsCreateOrConnectWithoutUsers_clientInput | r_users_client_contractorsCreateOrConnectWithoutUsers_clientInput[]
    upsert?: r_users_client_contractorsUpsertWithWhereUniqueWithoutUsers_clientInput | r_users_client_contractorsUpsertWithWhereUniqueWithoutUsers_clientInput[]
    createMany?: r_users_client_contractorsCreateManyUsers_clientInputEnvelope
    set?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
    disconnect?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
    delete?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
    connect?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
    update?: r_users_client_contractorsUpdateWithWhereUniqueWithoutUsers_clientInput | r_users_client_contractorsUpdateWithWhereUniqueWithoutUsers_clientInput[]
    updateMany?: r_users_client_contractorsUpdateManyWithWhereWithoutUsers_clientInput | r_users_client_contractorsUpdateManyWithWhereWithoutUsers_clientInput[]
    deleteMany?: r_users_client_contractorsScalarWhereInput | r_users_client_contractorsScalarWhereInput[]
  }

  export type roles_clientUpdateOneRequiredWithoutUsers_clientNestedInput = {
    create?: XOR<roles_clientCreateWithoutUsers_clientInput, roles_clientUncheckedCreateWithoutUsers_clientInput>
    connectOrCreate?: roles_clientCreateOrConnectWithoutUsers_clientInput
    upsert?: roles_clientUpsertWithoutUsers_clientInput
    connect?: roles_clientWhereUniqueInput
    update?: XOR<XOR<roles_clientUpdateToOneWithWhereWithoutUsers_clientInput, roles_clientUpdateWithoutUsers_clientInput>, roles_clientUncheckedUpdateWithoutUsers_clientInput>
  }

  export type r_users_client_contractorsUncheckedUpdateManyWithoutUsers_clientNestedInput = {
    create?: XOR<r_users_client_contractorsCreateWithoutUsers_clientInput, r_users_client_contractorsUncheckedCreateWithoutUsers_clientInput> | r_users_client_contractorsCreateWithoutUsers_clientInput[] | r_users_client_contractorsUncheckedCreateWithoutUsers_clientInput[]
    connectOrCreate?: r_users_client_contractorsCreateOrConnectWithoutUsers_clientInput | r_users_client_contractorsCreateOrConnectWithoutUsers_clientInput[]
    upsert?: r_users_client_contractorsUpsertWithWhereUniqueWithoutUsers_clientInput | r_users_client_contractorsUpsertWithWhereUniqueWithoutUsers_clientInput[]
    createMany?: r_users_client_contractorsCreateManyUsers_clientInputEnvelope
    set?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
    disconnect?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
    delete?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
    connect?: r_users_client_contractorsWhereUniqueInput | r_users_client_contractorsWhereUniqueInput[]
    update?: r_users_client_contractorsUpdateWithWhereUniqueWithoutUsers_clientInput | r_users_client_contractorsUpdateWithWhereUniqueWithoutUsers_clientInput[]
    updateMany?: r_users_client_contractorsUpdateManyWithWhereWithoutUsers_clientInput | r_users_client_contractorsUpdateManyWithWhereWithoutUsers_clientInput[]
    deleteMany?: r_users_client_contractorsScalarWhereInput | r_users_client_contractorsScalarWhereInput[]
  }

  export type banks_itemsCreateNestedManyWithoutBanks_items_versionsInput = {
    create?: XOR<banks_itemsCreateWithoutBanks_items_versionsInput, banks_itemsUncheckedCreateWithoutBanks_items_versionsInput> | banks_itemsCreateWithoutBanks_items_versionsInput[] | banks_itemsUncheckedCreateWithoutBanks_items_versionsInput[]
    connectOrCreate?: banks_itemsCreateOrConnectWithoutBanks_items_versionsInput | banks_itemsCreateOrConnectWithoutBanks_items_versionsInput[]
    createMany?: banks_itemsCreateManyBanks_items_versionsInputEnvelope
    connect?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
  }

  export type banksCreateNestedOneWithoutBanks_items_versionsInput = {
    create?: XOR<banksCreateWithoutBanks_items_versionsInput, banksUncheckedCreateWithoutBanks_items_versionsInput>
    connectOrCreate?: banksCreateOrConnectWithoutBanks_items_versionsInput
    connect?: banksWhereUniqueInput
  }

  export type banks_itemsUncheckedCreateNestedManyWithoutBanks_items_versionsInput = {
    create?: XOR<banks_itemsCreateWithoutBanks_items_versionsInput, banks_itemsUncheckedCreateWithoutBanks_items_versionsInput> | banks_itemsCreateWithoutBanks_items_versionsInput[] | banks_itemsUncheckedCreateWithoutBanks_items_versionsInput[]
    connectOrCreate?: banks_itemsCreateOrConnectWithoutBanks_items_versionsInput | banks_itemsCreateOrConnectWithoutBanks_items_versionsInput[]
    createMany?: banks_itemsCreateManyBanks_items_versionsInputEnvelope
    connect?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type banks_itemsUpdateManyWithoutBanks_items_versionsNestedInput = {
    create?: XOR<banks_itemsCreateWithoutBanks_items_versionsInput, banks_itemsUncheckedCreateWithoutBanks_items_versionsInput> | banks_itemsCreateWithoutBanks_items_versionsInput[] | banks_itemsUncheckedCreateWithoutBanks_items_versionsInput[]
    connectOrCreate?: banks_itemsCreateOrConnectWithoutBanks_items_versionsInput | banks_itemsCreateOrConnectWithoutBanks_items_versionsInput[]
    upsert?: banks_itemsUpsertWithWhereUniqueWithoutBanks_items_versionsInput | banks_itemsUpsertWithWhereUniqueWithoutBanks_items_versionsInput[]
    createMany?: banks_itemsCreateManyBanks_items_versionsInputEnvelope
    set?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
    disconnect?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
    delete?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
    connect?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
    update?: banks_itemsUpdateWithWhereUniqueWithoutBanks_items_versionsInput | banks_itemsUpdateWithWhereUniqueWithoutBanks_items_versionsInput[]
    updateMany?: banks_itemsUpdateManyWithWhereWithoutBanks_items_versionsInput | banks_itemsUpdateManyWithWhereWithoutBanks_items_versionsInput[]
    deleteMany?: banks_itemsScalarWhereInput | banks_itemsScalarWhereInput[]
  }

  export type banksUpdateOneRequiredWithoutBanks_items_versionsNestedInput = {
    create?: XOR<banksCreateWithoutBanks_items_versionsInput, banksUncheckedCreateWithoutBanks_items_versionsInput>
    connectOrCreate?: banksCreateOrConnectWithoutBanks_items_versionsInput
    upsert?: banksUpsertWithoutBanks_items_versionsInput
    connect?: banksWhereUniqueInput
    update?: XOR<XOR<banksUpdateToOneWithWhereWithoutBanks_items_versionsInput, banksUpdateWithoutBanks_items_versionsInput>, banksUncheckedUpdateWithoutBanks_items_versionsInput>
  }

  export type banks_itemsUncheckedUpdateManyWithoutBanks_items_versionsNestedInput = {
    create?: XOR<banks_itemsCreateWithoutBanks_items_versionsInput, banks_itemsUncheckedCreateWithoutBanks_items_versionsInput> | banks_itemsCreateWithoutBanks_items_versionsInput[] | banks_itemsUncheckedCreateWithoutBanks_items_versionsInput[]
    connectOrCreate?: banks_itemsCreateOrConnectWithoutBanks_items_versionsInput | banks_itemsCreateOrConnectWithoutBanks_items_versionsInput[]
    upsert?: banks_itemsUpsertWithWhereUniqueWithoutBanks_items_versionsInput | banks_itemsUpsertWithWhereUniqueWithoutBanks_items_versionsInput[]
    createMany?: banks_itemsCreateManyBanks_items_versionsInputEnvelope
    set?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
    disconnect?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
    delete?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
    connect?: banks_itemsWhereUniqueInput | banks_itemsWhereUniqueInput[]
    update?: banks_itemsUpdateWithWhereUniqueWithoutBanks_items_versionsInput | banks_itemsUpdateWithWhereUniqueWithoutBanks_items_versionsInput[]
    updateMany?: banks_itemsUpdateManyWithWhereWithoutBanks_items_versionsInput | banks_itemsUpdateManyWithWhereWithoutBanks_items_versionsInput[]
    deleteMany?: banks_itemsScalarWhereInput | banks_itemsScalarWhereInput[]
  }

  export type objectsCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<objectsCreateWithoutEntitiesInput, objectsUncheckedCreateWithoutEntitiesInput> | objectsCreateWithoutEntitiesInput[] | objectsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: objectsCreateOrConnectWithoutEntitiesInput | objectsCreateOrConnectWithoutEntitiesInput[]
    createMany?: objectsCreateManyEntitiesInputEnvelope
    connect?: objectsWhereUniqueInput | objectsWhereUniqueInput[]
  }

  export type objectsUncheckedCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<objectsCreateWithoutEntitiesInput, objectsUncheckedCreateWithoutEntitiesInput> | objectsCreateWithoutEntitiesInput[] | objectsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: objectsCreateOrConnectWithoutEntitiesInput | objectsCreateOrConnectWithoutEntitiesInput[]
    createMany?: objectsCreateManyEntitiesInputEnvelope
    connect?: objectsWhereUniqueInput | objectsWhereUniqueInput[]
  }

  export type objectsUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<objectsCreateWithoutEntitiesInput, objectsUncheckedCreateWithoutEntitiesInput> | objectsCreateWithoutEntitiesInput[] | objectsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: objectsCreateOrConnectWithoutEntitiesInput | objectsCreateOrConnectWithoutEntitiesInput[]
    upsert?: objectsUpsertWithWhereUniqueWithoutEntitiesInput | objectsUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: objectsCreateManyEntitiesInputEnvelope
    set?: objectsWhereUniqueInput | objectsWhereUniqueInput[]
    disconnect?: objectsWhereUniqueInput | objectsWhereUniqueInput[]
    delete?: objectsWhereUniqueInput | objectsWhereUniqueInput[]
    connect?: objectsWhereUniqueInput | objectsWhereUniqueInput[]
    update?: objectsUpdateWithWhereUniqueWithoutEntitiesInput | objectsUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: objectsUpdateManyWithWhereWithoutEntitiesInput | objectsUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: objectsScalarWhereInput | objectsScalarWhereInput[]
  }

  export type objectsUncheckedUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<objectsCreateWithoutEntitiesInput, objectsUncheckedCreateWithoutEntitiesInput> | objectsCreateWithoutEntitiesInput[] | objectsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: objectsCreateOrConnectWithoutEntitiesInput | objectsCreateOrConnectWithoutEntitiesInput[]
    upsert?: objectsUpsertWithWhereUniqueWithoutEntitiesInput | objectsUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: objectsCreateManyEntitiesInputEnvelope
    set?: objectsWhereUniqueInput | objectsWhereUniqueInput[]
    disconnect?: objectsWhereUniqueInput | objectsWhereUniqueInput[]
    delete?: objectsWhereUniqueInput | objectsWhereUniqueInput[]
    connect?: objectsWhereUniqueInput | objectsWhereUniqueInput[]
    update?: objectsUpdateWithWhereUniqueWithoutEntitiesInput | objectsUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: objectsUpdateManyWithWhereWithoutEntitiesInput | objectsUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: objectsScalarWhereInput | objectsScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumapplications_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.applications_type | Enumapplications_typeFieldRefInput<$PrismaModel>
    in?: $Enums.applications_type[]
    notIn?: $Enums.applications_type[]
    not?: NestedEnumapplications_typeFilter<$PrismaModel> | $Enums.applications_type
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumapplications_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.applications_type | Enumapplications_typeFieldRefInput<$PrismaModel>
    in?: $Enums.applications_type[]
    notIn?: $Enums.applications_type[]
    not?: NestedEnumapplications_typeWithAggregatesFilter<$PrismaModel> | $Enums.applications_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumapplications_typeFilter<$PrismaModel>
    _max?: NestedEnumapplications_typeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type banksCreateWithoutAccountsInput = {
    name: string
    city?: string | null
    bik: string
    correspondent_number?: string | null
    banks_items_versions?: banks_items_versionsCreateNestedManyWithoutBanksInput
  }

  export type banksUncheckedCreateWithoutAccountsInput = {
    id?: number
    name: string
    city?: string | null
    bik: string
    correspondent_number?: string | null
    banks_items_versions?: banks_items_versionsUncheckedCreateNestedManyWithoutBanksInput
  }

  export type banksCreateOrConnectWithoutAccountsInput = {
    where: banksWhereUniqueInput
    create: XOR<banksCreateWithoutAccountsInput, banksUncheckedCreateWithoutAccountsInput>
  }

  export type contractorsCreateWithoutAccountsInput = {
    name: string
    short_name?: string | null
    inn?: string | null
    kpp?: string | null
    ogrn?: string | null
    legal_address?: string | null
    actual_address?: string | null
    contacts?: string | null
    reconciliation_link?: string | null
    is_active?: boolean
    propogated_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    r_users_client_contractors?: r_users_client_contractorsCreateNestedManyWithoutContractorsInput
  }

  export type contractorsUncheckedCreateWithoutAccountsInput = {
    id?: number
    name: string
    short_name?: string | null
    inn?: string | null
    kpp?: string | null
    ogrn?: string | null
    legal_address?: string | null
    actual_address?: string | null
    contacts?: string | null
    reconciliation_link?: string | null
    is_active?: boolean
    propogated_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    r_users_client_contractors?: r_users_client_contractorsUncheckedCreateNestedManyWithoutContractorsInput
  }

  export type contractorsCreateOrConnectWithoutAccountsInput = {
    where: contractorsWhereUniqueInput
    create: XOR<contractorsCreateWithoutAccountsInput, contractorsUncheckedCreateWithoutAccountsInput>
  }

  export type banksUpsertWithoutAccountsInput = {
    update: XOR<banksUpdateWithoutAccountsInput, banksUncheckedUpdateWithoutAccountsInput>
    create: XOR<banksCreateWithoutAccountsInput, banksUncheckedCreateWithoutAccountsInput>
    where?: banksWhereInput
  }

  export type banksUpdateToOneWithWhereWithoutAccountsInput = {
    where?: banksWhereInput
    data: XOR<banksUpdateWithoutAccountsInput, banksUncheckedUpdateWithoutAccountsInput>
  }

  export type banksUpdateWithoutAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bik?: StringFieldUpdateOperationsInput | string
    correspondent_number?: NullableStringFieldUpdateOperationsInput | string | null
    banks_items_versions?: banks_items_versionsUpdateManyWithoutBanksNestedInput
  }

  export type banksUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bik?: StringFieldUpdateOperationsInput | string
    correspondent_number?: NullableStringFieldUpdateOperationsInput | string | null
    banks_items_versions?: banks_items_versionsUncheckedUpdateManyWithoutBanksNestedInput
  }

  export type contractorsUpsertWithoutAccountsInput = {
    update: XOR<contractorsUpdateWithoutAccountsInput, contractorsUncheckedUpdateWithoutAccountsInput>
    create: XOR<contractorsCreateWithoutAccountsInput, contractorsUncheckedCreateWithoutAccountsInput>
    where?: contractorsWhereInput
  }

  export type contractorsUpdateToOneWithWhereWithoutAccountsInput = {
    where?: contractorsWhereInput
    data: XOR<contractorsUpdateWithoutAccountsInput, contractorsUncheckedUpdateWithoutAccountsInput>
  }

  export type contractorsUpdateWithoutAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    ogrn?: NullableStringFieldUpdateOperationsInput | string | null
    legal_address?: NullableStringFieldUpdateOperationsInput | string | null
    actual_address?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: NullableStringFieldUpdateOperationsInput | string | null
    reconciliation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    r_users_client_contractors?: r_users_client_contractorsUpdateManyWithoutContractorsNestedInput
  }

  export type contractorsUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    ogrn?: NullableStringFieldUpdateOperationsInput | string | null
    legal_address?: NullableStringFieldUpdateOperationsInput | string | null
    actual_address?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: NullableStringFieldUpdateOperationsInput | string | null
    reconciliation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    r_users_client_contractors?: r_users_client_contractorsUncheckedUpdateManyWithoutContractorsNestedInput
  }

  export type applicationsCreateWithoutApp_groupsInput = {
    id: string
    name: string
    active?: boolean | null
    type?: $Enums.applications_type
    path?: string | null
    description?: string | null
    r_roles_apps?: r_roles_appsCreateNestedManyWithoutApplicationsInput
  }

  export type applicationsUncheckedCreateWithoutApp_groupsInput = {
    id: string
    name: string
    active?: boolean | null
    type?: $Enums.applications_type
    path?: string | null
    description?: string | null
    r_roles_apps?: r_roles_appsUncheckedCreateNestedManyWithoutApplicationsInput
  }

  export type applicationsCreateOrConnectWithoutApp_groupsInput = {
    where: applicationsWhereUniqueInput
    create: XOR<applicationsCreateWithoutApp_groupsInput, applicationsUncheckedCreateWithoutApp_groupsInput>
  }

  export type applicationsCreateManyApp_groupsInputEnvelope = {
    data: applicationsCreateManyApp_groupsInput | applicationsCreateManyApp_groupsInput[]
    skipDuplicates?: boolean
  }

  export type applicationsUpsertWithWhereUniqueWithoutApp_groupsInput = {
    where: applicationsWhereUniqueInput
    update: XOR<applicationsUpdateWithoutApp_groupsInput, applicationsUncheckedUpdateWithoutApp_groupsInput>
    create: XOR<applicationsCreateWithoutApp_groupsInput, applicationsUncheckedCreateWithoutApp_groupsInput>
  }

  export type applicationsUpdateWithWhereUniqueWithoutApp_groupsInput = {
    where: applicationsWhereUniqueInput
    data: XOR<applicationsUpdateWithoutApp_groupsInput, applicationsUncheckedUpdateWithoutApp_groupsInput>
  }

  export type applicationsUpdateManyWithWhereWithoutApp_groupsInput = {
    where: applicationsScalarWhereInput
    data: XOR<applicationsUpdateManyMutationInput, applicationsUncheckedUpdateManyWithoutApp_groupsInput>
  }

  export type applicationsScalarWhereInput = {
    AND?: applicationsScalarWhereInput | applicationsScalarWhereInput[]
    OR?: applicationsScalarWhereInput[]
    NOT?: applicationsScalarWhereInput | applicationsScalarWhereInput[]
    id?: StringFilter<"applications"> | string
    name?: StringFilter<"applications"> | string
    active?: BoolNullableFilter<"applications"> | boolean | null
    type?: Enumapplications_typeFilter<"applications"> | $Enums.applications_type
    path?: StringNullableFilter<"applications"> | string | null
    description?: StringNullableFilter<"applications"> | string | null
    app_group_id?: IntFilter<"applications"> | number
  }

  export type app_groupsCreateWithoutApplicationsInput = {
    name: string
  }

  export type app_groupsUncheckedCreateWithoutApplicationsInput = {
    id?: number
    name: string
  }

  export type app_groupsCreateOrConnectWithoutApplicationsInput = {
    where: app_groupsWhereUniqueInput
    create: XOR<app_groupsCreateWithoutApplicationsInput, app_groupsUncheckedCreateWithoutApplicationsInput>
  }

  export type r_roles_appsCreateWithoutApplicationsInput = {
    roles: rolesCreateNestedOneWithoutR_roles_appsInput
  }

  export type r_roles_appsUncheckedCreateWithoutApplicationsInput = {
    role_id: number
  }

  export type r_roles_appsCreateOrConnectWithoutApplicationsInput = {
    where: r_roles_appsWhereUniqueInput
    create: XOR<r_roles_appsCreateWithoutApplicationsInput, r_roles_appsUncheckedCreateWithoutApplicationsInput>
  }

  export type r_roles_appsCreateManyApplicationsInputEnvelope = {
    data: r_roles_appsCreateManyApplicationsInput | r_roles_appsCreateManyApplicationsInput[]
    skipDuplicates?: boolean
  }

  export type app_groupsUpsertWithoutApplicationsInput = {
    update: XOR<app_groupsUpdateWithoutApplicationsInput, app_groupsUncheckedUpdateWithoutApplicationsInput>
    create: XOR<app_groupsCreateWithoutApplicationsInput, app_groupsUncheckedCreateWithoutApplicationsInput>
    where?: app_groupsWhereInput
  }

  export type app_groupsUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: app_groupsWhereInput
    data: XOR<app_groupsUpdateWithoutApplicationsInput, app_groupsUncheckedUpdateWithoutApplicationsInput>
  }

  export type app_groupsUpdateWithoutApplicationsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type app_groupsUncheckedUpdateWithoutApplicationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type r_roles_appsUpsertWithWhereUniqueWithoutApplicationsInput = {
    where: r_roles_appsWhereUniqueInput
    update: XOR<r_roles_appsUpdateWithoutApplicationsInput, r_roles_appsUncheckedUpdateWithoutApplicationsInput>
    create: XOR<r_roles_appsCreateWithoutApplicationsInput, r_roles_appsUncheckedCreateWithoutApplicationsInput>
  }

  export type r_roles_appsUpdateWithWhereUniqueWithoutApplicationsInput = {
    where: r_roles_appsWhereUniqueInput
    data: XOR<r_roles_appsUpdateWithoutApplicationsInput, r_roles_appsUncheckedUpdateWithoutApplicationsInput>
  }

  export type r_roles_appsUpdateManyWithWhereWithoutApplicationsInput = {
    where: r_roles_appsScalarWhereInput
    data: XOR<r_roles_appsUpdateManyMutationInput, r_roles_appsUncheckedUpdateManyWithoutApplicationsInput>
  }

  export type r_roles_appsScalarWhereInput = {
    AND?: r_roles_appsScalarWhereInput | r_roles_appsScalarWhereInput[]
    OR?: r_roles_appsScalarWhereInput[]
    NOT?: r_roles_appsScalarWhereInput | r_roles_appsScalarWhereInput[]
    role_id?: IntFilter<"r_roles_apps"> | number
    app_id?: StringFilter<"r_roles_apps"> | string
  }

  export type accountsCreateWithoutBanksInput = {
    number: string
    contractors: contractorsCreateNestedOneWithoutAccountsInput
  }

  export type accountsUncheckedCreateWithoutBanksInput = {
    id?: number
    number: string
    contractors_id: number
  }

  export type accountsCreateOrConnectWithoutBanksInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutBanksInput, accountsUncheckedCreateWithoutBanksInput>
  }

  export type accountsCreateManyBanksInputEnvelope = {
    data: accountsCreateManyBanksInput | accountsCreateManyBanksInput[]
    skipDuplicates?: boolean
  }

  export type banks_items_versionsCreateWithoutBanksInput = {
    id?: bigint | number
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    banks_items?: banks_itemsCreateNestedManyWithoutBanks_items_versionsInput
  }

  export type banks_items_versionsUncheckedCreateWithoutBanksInput = {
    id?: bigint | number
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    banks_items?: banks_itemsUncheckedCreateNestedManyWithoutBanks_items_versionsInput
  }

  export type banks_items_versionsCreateOrConnectWithoutBanksInput = {
    where: banks_items_versionsWhereUniqueInput
    create: XOR<banks_items_versionsCreateWithoutBanksInput, banks_items_versionsUncheckedCreateWithoutBanksInput>
  }

  export type banks_items_versionsCreateManyBanksInputEnvelope = {
    data: banks_items_versionsCreateManyBanksInput | banks_items_versionsCreateManyBanksInput[]
    skipDuplicates?: boolean
  }

  export type accountsUpsertWithWhereUniqueWithoutBanksInput = {
    where: accountsWhereUniqueInput
    update: XOR<accountsUpdateWithoutBanksInput, accountsUncheckedUpdateWithoutBanksInput>
    create: XOR<accountsCreateWithoutBanksInput, accountsUncheckedCreateWithoutBanksInput>
  }

  export type accountsUpdateWithWhereUniqueWithoutBanksInput = {
    where: accountsWhereUniqueInput
    data: XOR<accountsUpdateWithoutBanksInput, accountsUncheckedUpdateWithoutBanksInput>
  }

  export type accountsUpdateManyWithWhereWithoutBanksInput = {
    where: accountsScalarWhereInput
    data: XOR<accountsUpdateManyMutationInput, accountsUncheckedUpdateManyWithoutBanksInput>
  }

  export type accountsScalarWhereInput = {
    AND?: accountsScalarWhereInput | accountsScalarWhereInput[]
    OR?: accountsScalarWhereInput[]
    NOT?: accountsScalarWhereInput | accountsScalarWhereInput[]
    id?: IntFilter<"accounts"> | number
    number?: StringFilter<"accounts"> | string
    bank_id?: IntFilter<"accounts"> | number
    contractors_id?: IntFilter<"accounts"> | number
  }

  export type banks_items_versionsUpsertWithWhereUniqueWithoutBanksInput = {
    where: banks_items_versionsWhereUniqueInput
    update: XOR<banks_items_versionsUpdateWithoutBanksInput, banks_items_versionsUncheckedUpdateWithoutBanksInput>
    create: XOR<banks_items_versionsCreateWithoutBanksInput, banks_items_versionsUncheckedCreateWithoutBanksInput>
  }

  export type banks_items_versionsUpdateWithWhereUniqueWithoutBanksInput = {
    where: banks_items_versionsWhereUniqueInput
    data: XOR<banks_items_versionsUpdateWithoutBanksInput, banks_items_versionsUncheckedUpdateWithoutBanksInput>
  }

  export type banks_items_versionsUpdateManyWithWhereWithoutBanksInput = {
    where: banks_items_versionsScalarWhereInput
    data: XOR<banks_items_versionsUpdateManyMutationInput, banks_items_versionsUncheckedUpdateManyWithoutBanksInput>
  }

  export type banks_items_versionsScalarWhereInput = {
    AND?: banks_items_versionsScalarWhereInput | banks_items_versionsScalarWhereInput[]
    OR?: banks_items_versionsScalarWhereInput[]
    NOT?: banks_items_versionsScalarWhereInput | banks_items_versionsScalarWhereInput[]
    id?: BigIntFilter<"banks_items_versions"> | bigint | number
    name?: StringFilter<"banks_items_versions"> | string
    is_active?: BoolFilter<"banks_items_versions"> | boolean
    bank_id?: IntFilter<"banks_items_versions"> | number
    created_at?: DateTimeFilter<"banks_items_versions"> | Date | string
    updated_at?: DateTimeFilter<"banks_items_versions"> | Date | string
  }

  export type banks_paketsCreateWithoutBanks_itemsInput = {
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
  }

  export type banks_paketsUncheckedCreateWithoutBanks_itemsInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
  }

  export type banks_paketsCreateOrConnectWithoutBanks_itemsInput = {
    where: banks_paketsWhereUniqueInput
    create: XOR<banks_paketsCreateWithoutBanks_itemsInput, banks_paketsUncheckedCreateWithoutBanks_itemsInput>
  }

  export type banks_items_versionsCreateWithoutBanks_itemsInput = {
    id?: bigint | number
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    banks: banksCreateNestedOneWithoutBanks_items_versionsInput
  }

  export type banks_items_versionsUncheckedCreateWithoutBanks_itemsInput = {
    id?: bigint | number
    name: string
    is_active?: boolean
    bank_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type banks_items_versionsCreateOrConnectWithoutBanks_itemsInput = {
    where: banks_items_versionsWhereUniqueInput
    create: XOR<banks_items_versionsCreateWithoutBanks_itemsInput, banks_items_versionsUncheckedCreateWithoutBanks_itemsInput>
  }

  export type itemsCreateWithoutBanks_itemsInput = {
    name: string
    code: string
    clc_code?: string | null
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    sub_pakets: sub_paketsCreateNestedOneWithoutItemsInput
  }

  export type itemsUncheckedCreateWithoutBanks_itemsInput = {
    id?: number
    name: string
    code: string
    clc_code?: string | null
    order_num?: number | null
    is_active?: boolean
    sub_pakets_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
  }

  export type itemsCreateOrConnectWithoutBanks_itemsInput = {
    where: itemsWhereUniqueInput
    create: XOR<itemsCreateWithoutBanks_itemsInput, itemsUncheckedCreateWithoutBanks_itemsInput>
  }

  export type itemsCreateManyBanks_itemsInputEnvelope = {
    data: itemsCreateManyBanks_itemsInput | itemsCreateManyBanks_itemsInput[]
    skipDuplicates?: boolean
  }

  export type banks_paketsUpsertWithoutBanks_itemsInput = {
    update: XOR<banks_paketsUpdateWithoutBanks_itemsInput, banks_paketsUncheckedUpdateWithoutBanks_itemsInput>
    create: XOR<banks_paketsCreateWithoutBanks_itemsInput, banks_paketsUncheckedCreateWithoutBanks_itemsInput>
    where?: banks_paketsWhereInput
  }

  export type banks_paketsUpdateToOneWithWhereWithoutBanks_itemsInput = {
    where?: banks_paketsWhereInput
    data: XOR<banks_paketsUpdateWithoutBanks_itemsInput, banks_paketsUncheckedUpdateWithoutBanks_itemsInput>
  }

  export type banks_paketsUpdateWithoutBanks_itemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type banks_paketsUncheckedUpdateWithoutBanks_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type banks_items_versionsUpsertWithoutBanks_itemsInput = {
    update: XOR<banks_items_versionsUpdateWithoutBanks_itemsInput, banks_items_versionsUncheckedUpdateWithoutBanks_itemsInput>
    create: XOR<banks_items_versionsCreateWithoutBanks_itemsInput, banks_items_versionsUncheckedCreateWithoutBanks_itemsInput>
    where?: banks_items_versionsWhereInput
  }

  export type banks_items_versionsUpdateToOneWithWhereWithoutBanks_itemsInput = {
    where?: banks_items_versionsWhereInput
    data: XOR<banks_items_versionsUpdateWithoutBanks_itemsInput, banks_items_versionsUncheckedUpdateWithoutBanks_itemsInput>
  }

  export type banks_items_versionsUpdateWithoutBanks_itemsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    banks?: banksUpdateOneRequiredWithoutBanks_items_versionsNestedInput
  }

  export type banks_items_versionsUncheckedUpdateWithoutBanks_itemsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    bank_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemsUpsertWithWhereUniqueWithoutBanks_itemsInput = {
    where: itemsWhereUniqueInput
    update: XOR<itemsUpdateWithoutBanks_itemsInput, itemsUncheckedUpdateWithoutBanks_itemsInput>
    create: XOR<itemsCreateWithoutBanks_itemsInput, itemsUncheckedCreateWithoutBanks_itemsInput>
  }

  export type itemsUpdateWithWhereUniqueWithoutBanks_itemsInput = {
    where: itemsWhereUniqueInput
    data: XOR<itemsUpdateWithoutBanks_itemsInput, itemsUncheckedUpdateWithoutBanks_itemsInput>
  }

  export type itemsUpdateManyWithWhereWithoutBanks_itemsInput = {
    where: itemsScalarWhereInput
    data: XOR<itemsUpdateManyMutationInput, itemsUncheckedUpdateManyWithoutBanks_itemsInput>
  }

  export type itemsScalarWhereInput = {
    AND?: itemsScalarWhereInput | itemsScalarWhereInput[]
    OR?: itemsScalarWhereInput[]
    NOT?: itemsScalarWhereInput | itemsScalarWhereInput[]
    id?: IntFilter<"items"> | number
    name?: StringFilter<"items"> | string
    code?: StringFilter<"items"> | string
    clc_code?: StringNullableFilter<"items"> | string | null
    order_num?: IntNullableFilter<"items"> | number | null
    is_active?: BoolFilter<"items"> | boolean
    sub_pakets_id?: IntFilter<"items"> | number
    banks_items_id?: IntNullableFilter<"items"> | number | null
    created_at?: DateTimeNullableFilter<"items"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"items"> | Date | string | null
    propogated_at?: DateTimeNullableFilter<"items"> | Date | string | null
  }

  export type banks_itemsCreateWithoutBanks_paketsInput = {
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    banks_items_versions?: banks_items_versionsCreateNestedOneWithoutBanks_itemsInput
    items?: itemsCreateNestedManyWithoutBanks_itemsInput
  }

  export type banks_itemsUncheckedCreateWithoutBanks_paketsInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    version_id?: bigint | number | null
    items?: itemsUncheckedCreateNestedManyWithoutBanks_itemsInput
  }

  export type banks_itemsCreateOrConnectWithoutBanks_paketsInput = {
    where: banks_itemsWhereUniqueInput
    create: XOR<banks_itemsCreateWithoutBanks_paketsInput, banks_itemsUncheckedCreateWithoutBanks_paketsInput>
  }

  export type banks_itemsCreateManyBanks_paketsInputEnvelope = {
    data: banks_itemsCreateManyBanks_paketsInput | banks_itemsCreateManyBanks_paketsInput[]
    skipDuplicates?: boolean
  }

  export type banks_itemsUpsertWithWhereUniqueWithoutBanks_paketsInput = {
    where: banks_itemsWhereUniqueInput
    update: XOR<banks_itemsUpdateWithoutBanks_paketsInput, banks_itemsUncheckedUpdateWithoutBanks_paketsInput>
    create: XOR<banks_itemsCreateWithoutBanks_paketsInput, banks_itemsUncheckedCreateWithoutBanks_paketsInput>
  }

  export type banks_itemsUpdateWithWhereUniqueWithoutBanks_paketsInput = {
    where: banks_itemsWhereUniqueInput
    data: XOR<banks_itemsUpdateWithoutBanks_paketsInput, banks_itemsUncheckedUpdateWithoutBanks_paketsInput>
  }

  export type banks_itemsUpdateManyWithWhereWithoutBanks_paketsInput = {
    where: banks_itemsScalarWhereInput
    data: XOR<banks_itemsUpdateManyMutationInput, banks_itemsUncheckedUpdateManyWithoutBanks_paketsInput>
  }

  export type banks_itemsScalarWhereInput = {
    AND?: banks_itemsScalarWhereInput | banks_itemsScalarWhereInput[]
    OR?: banks_itemsScalarWhereInput[]
    NOT?: banks_itemsScalarWhereInput | banks_itemsScalarWhereInput[]
    id?: IntFilter<"banks_items"> | number
    name?: StringFilter<"banks_items"> | string
    code?: StringFilter<"banks_items"> | string
    order_num?: IntNullableFilter<"banks_items"> | number | null
    is_active?: BoolFilter<"banks_items"> | boolean
    created_at?: DateTimeNullableFilter<"banks_items"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"banks_items"> | Date | string | null
    banks_pakets_id?: IntNullableFilter<"banks_items"> | number | null
    propogated_at?: DateTimeNullableFilter<"banks_items"> | Date | string | null
    version_id?: BigIntNullableFilter<"banks_items"> | bigint | number | null
  }

  export type paketsCreateWithoutBlocksInput = {
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    sub_pakets?: sub_paketsCreateNestedManyWithoutPaketsInput
  }

  export type paketsUncheckedCreateWithoutBlocksInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    sub_pakets?: sub_paketsUncheckedCreateNestedManyWithoutPaketsInput
  }

  export type paketsCreateOrConnectWithoutBlocksInput = {
    where: paketsWhereUniqueInput
    create: XOR<paketsCreateWithoutBlocksInput, paketsUncheckedCreateWithoutBlocksInput>
  }

  export type paketsCreateManyBlocksInputEnvelope = {
    data: paketsCreateManyBlocksInput | paketsCreateManyBlocksInput[]
    skipDuplicates?: boolean
  }

  export type paketsUpsertWithWhereUniqueWithoutBlocksInput = {
    where: paketsWhereUniqueInput
    update: XOR<paketsUpdateWithoutBlocksInput, paketsUncheckedUpdateWithoutBlocksInput>
    create: XOR<paketsCreateWithoutBlocksInput, paketsUncheckedCreateWithoutBlocksInput>
  }

  export type paketsUpdateWithWhereUniqueWithoutBlocksInput = {
    where: paketsWhereUniqueInput
    data: XOR<paketsUpdateWithoutBlocksInput, paketsUncheckedUpdateWithoutBlocksInput>
  }

  export type paketsUpdateManyWithWhereWithoutBlocksInput = {
    where: paketsScalarWhereInput
    data: XOR<paketsUpdateManyMutationInput, paketsUncheckedUpdateManyWithoutBlocksInput>
  }

  export type paketsScalarWhereInput = {
    AND?: paketsScalarWhereInput | paketsScalarWhereInput[]
    OR?: paketsScalarWhereInput[]
    NOT?: paketsScalarWhereInput | paketsScalarWhereInput[]
    id?: IntFilter<"pakets"> | number
    name?: StringFilter<"pakets"> | string
    code?: StringFilter<"pakets"> | string
    order_num?: IntNullableFilter<"pakets"> | number | null
    is_active?: BoolFilter<"pakets"> | boolean
    blocks_id?: IntFilter<"pakets"> | number
    created_at?: DateTimeNullableFilter<"pakets"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"pakets"> | Date | string | null
    propogated_at?: DateTimeNullableFilter<"pakets"> | Date | string | null
  }

  export type accountsCreateWithoutContractorsInput = {
    number: string
    banks: banksCreateNestedOneWithoutAccountsInput
  }

  export type accountsUncheckedCreateWithoutContractorsInput = {
    id?: number
    number: string
    bank_id: number
  }

  export type accountsCreateOrConnectWithoutContractorsInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutContractorsInput, accountsUncheckedCreateWithoutContractorsInput>
  }

  export type accountsCreateManyContractorsInputEnvelope = {
    data: accountsCreateManyContractorsInput | accountsCreateManyContractorsInput[]
    skipDuplicates?: boolean
  }

  export type r_users_client_contractorsCreateWithoutContractorsInput = {
    users_client: users_clientCreateNestedOneWithoutR_users_client_contractorsInput
  }

  export type r_users_client_contractorsUncheckedCreateWithoutContractorsInput = {
    id?: number
    users_client_id: number
  }

  export type r_users_client_contractorsCreateOrConnectWithoutContractorsInput = {
    where: r_users_client_contractorsWhereUniqueInput
    create: XOR<r_users_client_contractorsCreateWithoutContractorsInput, r_users_client_contractorsUncheckedCreateWithoutContractorsInput>
  }

  export type r_users_client_contractorsCreateManyContractorsInputEnvelope = {
    data: r_users_client_contractorsCreateManyContractorsInput | r_users_client_contractorsCreateManyContractorsInput[]
    skipDuplicates?: boolean
  }

  export type accountsUpsertWithWhereUniqueWithoutContractorsInput = {
    where: accountsWhereUniqueInput
    update: XOR<accountsUpdateWithoutContractorsInput, accountsUncheckedUpdateWithoutContractorsInput>
    create: XOR<accountsCreateWithoutContractorsInput, accountsUncheckedCreateWithoutContractorsInput>
  }

  export type accountsUpdateWithWhereUniqueWithoutContractorsInput = {
    where: accountsWhereUniqueInput
    data: XOR<accountsUpdateWithoutContractorsInput, accountsUncheckedUpdateWithoutContractorsInput>
  }

  export type accountsUpdateManyWithWhereWithoutContractorsInput = {
    where: accountsScalarWhereInput
    data: XOR<accountsUpdateManyMutationInput, accountsUncheckedUpdateManyWithoutContractorsInput>
  }

  export type r_users_client_contractorsUpsertWithWhereUniqueWithoutContractorsInput = {
    where: r_users_client_contractorsWhereUniqueInput
    update: XOR<r_users_client_contractorsUpdateWithoutContractorsInput, r_users_client_contractorsUncheckedUpdateWithoutContractorsInput>
    create: XOR<r_users_client_contractorsCreateWithoutContractorsInput, r_users_client_contractorsUncheckedCreateWithoutContractorsInput>
  }

  export type r_users_client_contractorsUpdateWithWhereUniqueWithoutContractorsInput = {
    where: r_users_client_contractorsWhereUniqueInput
    data: XOR<r_users_client_contractorsUpdateWithoutContractorsInput, r_users_client_contractorsUncheckedUpdateWithoutContractorsInput>
  }

  export type r_users_client_contractorsUpdateManyWithWhereWithoutContractorsInput = {
    where: r_users_client_contractorsScalarWhereInput
    data: XOR<r_users_client_contractorsUpdateManyMutationInput, r_users_client_contractorsUncheckedUpdateManyWithoutContractorsInput>
  }

  export type r_users_client_contractorsScalarWhereInput = {
    AND?: r_users_client_contractorsScalarWhereInput | r_users_client_contractorsScalarWhereInput[]
    OR?: r_users_client_contractorsScalarWhereInput[]
    NOT?: r_users_client_contractorsScalarWhereInput | r_users_client_contractorsScalarWhereInput[]
    id?: IntFilter<"r_users_client_contractors"> | number
    contractors_id?: IntFilter<"r_users_client_contractors"> | number
    users_client_id?: IntFilter<"r_users_client_contractors"> | number
  }

  export type sub_paketsCreateWithoutItemsInput = {
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    pakets: paketsCreateNestedOneWithoutSub_paketsInput
  }

  export type sub_paketsUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    pakets_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
  }

  export type sub_paketsCreateOrConnectWithoutItemsInput = {
    where: sub_paketsWhereUniqueInput
    create: XOR<sub_paketsCreateWithoutItemsInput, sub_paketsUncheckedCreateWithoutItemsInput>
  }

  export type banks_itemsCreateWithoutItemsInput = {
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    banks_pakets?: banks_paketsCreateNestedOneWithoutBanks_itemsInput
    banks_items_versions?: banks_items_versionsCreateNestedOneWithoutBanks_itemsInput
  }

  export type banks_itemsUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    banks_pakets_id?: number | null
    propogated_at?: Date | string | null
    version_id?: bigint | number | null
  }

  export type banks_itemsCreateOrConnectWithoutItemsInput = {
    where: banks_itemsWhereUniqueInput
    create: XOR<banks_itemsCreateWithoutItemsInput, banks_itemsUncheckedCreateWithoutItemsInput>
  }

  export type sub_paketsUpsertWithoutItemsInput = {
    update: XOR<sub_paketsUpdateWithoutItemsInput, sub_paketsUncheckedUpdateWithoutItemsInput>
    create: XOR<sub_paketsCreateWithoutItemsInput, sub_paketsUncheckedCreateWithoutItemsInput>
    where?: sub_paketsWhereInput
  }

  export type sub_paketsUpdateToOneWithWhereWithoutItemsInput = {
    where?: sub_paketsWhereInput
    data: XOR<sub_paketsUpdateWithoutItemsInput, sub_paketsUncheckedUpdateWithoutItemsInput>
  }

  export type sub_paketsUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pakets?: paketsUpdateOneRequiredWithoutSub_paketsNestedInput
  }

  export type sub_paketsUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    pakets_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type banks_itemsUpsertWithoutItemsInput = {
    update: XOR<banks_itemsUpdateWithoutItemsInput, banks_itemsUncheckedUpdateWithoutItemsInput>
    create: XOR<banks_itemsCreateWithoutItemsInput, banks_itemsUncheckedCreateWithoutItemsInput>
    where?: banks_itemsWhereInput
  }

  export type banks_itemsUpdateToOneWithWhereWithoutItemsInput = {
    where?: banks_itemsWhereInput
    data: XOR<banks_itemsUpdateWithoutItemsInput, banks_itemsUncheckedUpdateWithoutItemsInput>
  }

  export type banks_itemsUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banks_pakets?: banks_paketsUpdateOneWithoutBanks_itemsNestedInput
    banks_items_versions?: banks_items_versionsUpdateOneWithoutBanks_itemsNestedInput
  }

  export type banks_itemsUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banks_pakets_id?: NullableIntFieldUpdateOperationsInput | number | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type entitiesCreateWithoutObjectsInput = {
    str_id: string
    name: string
    short_name: string
    display_name: string
    inn: string
    kpp: string
    ogrn: string
    db_name: string
  }

  export type entitiesUncheckedCreateWithoutObjectsInput = {
    id?: number
    str_id: string
    name: string
    short_name: string
    display_name: string
    inn: string
    kpp: string
    ogrn: string
    db_name: string
  }

  export type entitiesCreateOrConnectWithoutObjectsInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutObjectsInput, entitiesUncheckedCreateWithoutObjectsInput>
  }

  export type sectionsCreateWithoutObjectsInput = {
    name: string
    created_at?: Date | string | null
    updated_ad?: Date | string | null
  }

  export type sectionsUncheckedCreateWithoutObjectsInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    updated_ad?: Date | string | null
  }

  export type sectionsCreateOrConnectWithoutObjectsInput = {
    where: sectionsWhereUniqueInput
    create: XOR<sectionsCreateWithoutObjectsInput, sectionsUncheckedCreateWithoutObjectsInput>
  }

  export type sectionsCreateManyObjectsInputEnvelope = {
    data: sectionsCreateManyObjectsInput | sectionsCreateManyObjectsInput[]
    skipDuplicates?: boolean
  }

  export type entitiesUpsertWithoutObjectsInput = {
    update: XOR<entitiesUpdateWithoutObjectsInput, entitiesUncheckedUpdateWithoutObjectsInput>
    create: XOR<entitiesCreateWithoutObjectsInput, entitiesUncheckedCreateWithoutObjectsInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutObjectsInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutObjectsInput, entitiesUncheckedUpdateWithoutObjectsInput>
  }

  export type entitiesUpdateWithoutObjectsInput = {
    str_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short_name?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    inn?: StringFieldUpdateOperationsInput | string
    kpp?: StringFieldUpdateOperationsInput | string
    ogrn?: StringFieldUpdateOperationsInput | string
    db_name?: StringFieldUpdateOperationsInput | string
  }

  export type entitiesUncheckedUpdateWithoutObjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    str_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short_name?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    inn?: StringFieldUpdateOperationsInput | string
    kpp?: StringFieldUpdateOperationsInput | string
    ogrn?: StringFieldUpdateOperationsInput | string
    db_name?: StringFieldUpdateOperationsInput | string
  }

  export type sectionsUpsertWithWhereUniqueWithoutObjectsInput = {
    where: sectionsWhereUniqueInput
    update: XOR<sectionsUpdateWithoutObjectsInput, sectionsUncheckedUpdateWithoutObjectsInput>
    create: XOR<sectionsCreateWithoutObjectsInput, sectionsUncheckedCreateWithoutObjectsInput>
  }

  export type sectionsUpdateWithWhereUniqueWithoutObjectsInput = {
    where: sectionsWhereUniqueInput
    data: XOR<sectionsUpdateWithoutObjectsInput, sectionsUncheckedUpdateWithoutObjectsInput>
  }

  export type sectionsUpdateManyWithWhereWithoutObjectsInput = {
    where: sectionsScalarWhereInput
    data: XOR<sectionsUpdateManyMutationInput, sectionsUncheckedUpdateManyWithoutObjectsInput>
  }

  export type sectionsScalarWhereInput = {
    AND?: sectionsScalarWhereInput | sectionsScalarWhereInput[]
    OR?: sectionsScalarWhereInput[]
    NOT?: sectionsScalarWhereInput | sectionsScalarWhereInput[]
    id?: IntFilter<"sections"> | number
    name?: StringFilter<"sections"> | string
    object_id?: IntFilter<"sections"> | number
    created_at?: DateTimeNullableFilter<"sections"> | Date | string | null
    updated_ad?: DateTimeNullableFilter<"sections"> | Date | string | null
  }

  export type blocksCreateWithoutPaketsInput = {
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
  }

  export type blocksUncheckedCreateWithoutPaketsInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
  }

  export type blocksCreateOrConnectWithoutPaketsInput = {
    where: blocksWhereUniqueInput
    create: XOR<blocksCreateWithoutPaketsInput, blocksUncheckedCreateWithoutPaketsInput>
  }

  export type sub_paketsCreateWithoutPaketsInput = {
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    items?: itemsCreateNestedManyWithoutSub_paketsInput
  }

  export type sub_paketsUncheckedCreateWithoutPaketsInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    items?: itemsUncheckedCreateNestedManyWithoutSub_paketsInput
  }

  export type sub_paketsCreateOrConnectWithoutPaketsInput = {
    where: sub_paketsWhereUniqueInput
    create: XOR<sub_paketsCreateWithoutPaketsInput, sub_paketsUncheckedCreateWithoutPaketsInput>
  }

  export type sub_paketsCreateManyPaketsInputEnvelope = {
    data: sub_paketsCreateManyPaketsInput | sub_paketsCreateManyPaketsInput[]
    skipDuplicates?: boolean
  }

  export type blocksUpsertWithoutPaketsInput = {
    update: XOR<blocksUpdateWithoutPaketsInput, blocksUncheckedUpdateWithoutPaketsInput>
    create: XOR<blocksCreateWithoutPaketsInput, blocksUncheckedCreateWithoutPaketsInput>
    where?: blocksWhereInput
  }

  export type blocksUpdateToOneWithWhereWithoutPaketsInput = {
    where?: blocksWhereInput
    data: XOR<blocksUpdateWithoutPaketsInput, blocksUncheckedUpdateWithoutPaketsInput>
  }

  export type blocksUpdateWithoutPaketsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blocksUncheckedUpdateWithoutPaketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sub_paketsUpsertWithWhereUniqueWithoutPaketsInput = {
    where: sub_paketsWhereUniqueInput
    update: XOR<sub_paketsUpdateWithoutPaketsInput, sub_paketsUncheckedUpdateWithoutPaketsInput>
    create: XOR<sub_paketsCreateWithoutPaketsInput, sub_paketsUncheckedCreateWithoutPaketsInput>
  }

  export type sub_paketsUpdateWithWhereUniqueWithoutPaketsInput = {
    where: sub_paketsWhereUniqueInput
    data: XOR<sub_paketsUpdateWithoutPaketsInput, sub_paketsUncheckedUpdateWithoutPaketsInput>
  }

  export type sub_paketsUpdateManyWithWhereWithoutPaketsInput = {
    where: sub_paketsScalarWhereInput
    data: XOR<sub_paketsUpdateManyMutationInput, sub_paketsUncheckedUpdateManyWithoutPaketsInput>
  }

  export type sub_paketsScalarWhereInput = {
    AND?: sub_paketsScalarWhereInput | sub_paketsScalarWhereInput[]
    OR?: sub_paketsScalarWhereInput[]
    NOT?: sub_paketsScalarWhereInput | sub_paketsScalarWhereInput[]
    id?: IntFilter<"sub_pakets"> | number
    name?: StringFilter<"sub_pakets"> | string
    code?: StringFilter<"sub_pakets"> | string
    order_num?: IntNullableFilter<"sub_pakets"> | number | null
    is_active?: BoolFilter<"sub_pakets"> | boolean
    pakets_id?: IntFilter<"sub_pakets"> | number
    created_at?: DateTimeNullableFilter<"sub_pakets"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"sub_pakets"> | Date | string | null
    propogated_at?: DateTimeNullableFilter<"sub_pakets"> | Date | string | null
  }

  export type rolesCreateWithoutR_roles_appsInput = {
    name: string
    r_users_roles?: r_users_rolesCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateWithoutR_roles_appsInput = {
    id?: number
    name: string
    r_users_roles?: r_users_rolesUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesCreateOrConnectWithoutR_roles_appsInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutR_roles_appsInput, rolesUncheckedCreateWithoutR_roles_appsInput>
  }

  export type applicationsCreateWithoutR_roles_appsInput = {
    id: string
    name: string
    active?: boolean | null
    type?: $Enums.applications_type
    path?: string | null
    description?: string | null
    app_groups?: app_groupsCreateNestedOneWithoutApplicationsInput
  }

  export type applicationsUncheckedCreateWithoutR_roles_appsInput = {
    id: string
    name: string
    active?: boolean | null
    type?: $Enums.applications_type
    path?: string | null
    description?: string | null
    app_group_id?: number
  }

  export type applicationsCreateOrConnectWithoutR_roles_appsInput = {
    where: applicationsWhereUniqueInput
    create: XOR<applicationsCreateWithoutR_roles_appsInput, applicationsUncheckedCreateWithoutR_roles_appsInput>
  }

  export type rolesUpsertWithoutR_roles_appsInput = {
    update: XOR<rolesUpdateWithoutR_roles_appsInput, rolesUncheckedUpdateWithoutR_roles_appsInput>
    create: XOR<rolesCreateWithoutR_roles_appsInput, rolesUncheckedCreateWithoutR_roles_appsInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutR_roles_appsInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutR_roles_appsInput, rolesUncheckedUpdateWithoutR_roles_appsInput>
  }

  export type rolesUpdateWithoutR_roles_appsInput = {
    name?: StringFieldUpdateOperationsInput | string
    r_users_roles?: r_users_rolesUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateWithoutR_roles_appsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    r_users_roles?: r_users_rolesUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type applicationsUpsertWithoutR_roles_appsInput = {
    update: XOR<applicationsUpdateWithoutR_roles_appsInput, applicationsUncheckedUpdateWithoutR_roles_appsInput>
    create: XOR<applicationsCreateWithoutR_roles_appsInput, applicationsUncheckedCreateWithoutR_roles_appsInput>
    where?: applicationsWhereInput
  }

  export type applicationsUpdateToOneWithWhereWithoutR_roles_appsInput = {
    where?: applicationsWhereInput
    data: XOR<applicationsUpdateWithoutR_roles_appsInput, applicationsUncheckedUpdateWithoutR_roles_appsInput>
  }

  export type applicationsUpdateWithoutR_roles_appsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: Enumapplications_typeFieldUpdateOperationsInput | $Enums.applications_type
    path?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    app_groups?: app_groupsUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type applicationsUncheckedUpdateWithoutR_roles_appsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: Enumapplications_typeFieldUpdateOperationsInput | $Enums.applications_type
    path?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    app_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type contractorsCreateWithoutR_users_client_contractorsInput = {
    name: string
    short_name?: string | null
    inn?: string | null
    kpp?: string | null
    ogrn?: string | null
    legal_address?: string | null
    actual_address?: string | null
    contacts?: string | null
    reconciliation_link?: string | null
    is_active?: boolean
    propogated_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    accounts?: accountsCreateNestedManyWithoutContractorsInput
  }

  export type contractorsUncheckedCreateWithoutR_users_client_contractorsInput = {
    id?: number
    name: string
    short_name?: string | null
    inn?: string | null
    kpp?: string | null
    ogrn?: string | null
    legal_address?: string | null
    actual_address?: string | null
    contacts?: string | null
    reconciliation_link?: string | null
    is_active?: boolean
    propogated_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    accounts?: accountsUncheckedCreateNestedManyWithoutContractorsInput
  }

  export type contractorsCreateOrConnectWithoutR_users_client_contractorsInput = {
    where: contractorsWhereUniqueInput
    create: XOR<contractorsCreateWithoutR_users_client_contractorsInput, contractorsUncheckedCreateWithoutR_users_client_contractorsInput>
  }

  export type users_clientCreateWithoutR_users_client_contractorsInput = {
    name: string
    email: string
    phone: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    roles_client?: roles_clientCreateNestedOneWithoutUsers_clientInput
  }

  export type users_clientUncheckedCreateWithoutR_users_client_contractorsInput = {
    id?: number
    name: string
    email: string
    phone: string
    role_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type users_clientCreateOrConnectWithoutR_users_client_contractorsInput = {
    where: users_clientWhereUniqueInput
    create: XOR<users_clientCreateWithoutR_users_client_contractorsInput, users_clientUncheckedCreateWithoutR_users_client_contractorsInput>
  }

  export type contractorsUpsertWithoutR_users_client_contractorsInput = {
    update: XOR<contractorsUpdateWithoutR_users_client_contractorsInput, contractorsUncheckedUpdateWithoutR_users_client_contractorsInput>
    create: XOR<contractorsCreateWithoutR_users_client_contractorsInput, contractorsUncheckedCreateWithoutR_users_client_contractorsInput>
    where?: contractorsWhereInput
  }

  export type contractorsUpdateToOneWithWhereWithoutR_users_client_contractorsInput = {
    where?: contractorsWhereInput
    data: XOR<contractorsUpdateWithoutR_users_client_contractorsInput, contractorsUncheckedUpdateWithoutR_users_client_contractorsInput>
  }

  export type contractorsUpdateWithoutR_users_client_contractorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    ogrn?: NullableStringFieldUpdateOperationsInput | string | null
    legal_address?: NullableStringFieldUpdateOperationsInput | string | null
    actual_address?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: NullableStringFieldUpdateOperationsInput | string | null
    reconciliation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUpdateManyWithoutContractorsNestedInput
  }

  export type contractorsUncheckedUpdateWithoutR_users_client_contractorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    ogrn?: NullableStringFieldUpdateOperationsInput | string | null
    legal_address?: NullableStringFieldUpdateOperationsInput | string | null
    actual_address?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: NullableStringFieldUpdateOperationsInput | string | null
    reconciliation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUncheckedUpdateManyWithoutContractorsNestedInput
  }

  export type users_clientUpsertWithoutR_users_client_contractorsInput = {
    update: XOR<users_clientUpdateWithoutR_users_client_contractorsInput, users_clientUncheckedUpdateWithoutR_users_client_contractorsInput>
    create: XOR<users_clientCreateWithoutR_users_client_contractorsInput, users_clientUncheckedCreateWithoutR_users_client_contractorsInput>
    where?: users_clientWhereInput
  }

  export type users_clientUpdateToOneWithWhereWithoutR_users_client_contractorsInput = {
    where?: users_clientWhereInput
    data: XOR<users_clientUpdateWithoutR_users_client_contractorsInput, users_clientUncheckedUpdateWithoutR_users_client_contractorsInput>
  }

  export type users_clientUpdateWithoutR_users_client_contractorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roles_client?: roles_clientUpdateOneRequiredWithoutUsers_clientNestedInput
  }

  export type users_clientUncheckedUpdateWithoutR_users_client_contractorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateWithoutR_users_rolesInput = {
    name: string
    password: string
    email: string
  }

  export type usersUncheckedCreateWithoutR_users_rolesInput = {
    id?: number
    name: string
    password: string
    email: string
  }

  export type usersCreateOrConnectWithoutR_users_rolesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutR_users_rolesInput, usersUncheckedCreateWithoutR_users_rolesInput>
  }

  export type rolesCreateWithoutR_users_rolesInput = {
    name: string
    r_roles_apps?: r_roles_appsCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateWithoutR_users_rolesInput = {
    id?: number
    name: string
    r_roles_apps?: r_roles_appsUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesCreateOrConnectWithoutR_users_rolesInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutR_users_rolesInput, rolesUncheckedCreateWithoutR_users_rolesInput>
  }

  export type usersUpsertWithoutR_users_rolesInput = {
    update: XOR<usersUpdateWithoutR_users_rolesInput, usersUncheckedUpdateWithoutR_users_rolesInput>
    create: XOR<usersCreateWithoutR_users_rolesInput, usersUncheckedCreateWithoutR_users_rolesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutR_users_rolesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutR_users_rolesInput, usersUncheckedUpdateWithoutR_users_rolesInput>
  }

  export type usersUpdateWithoutR_users_rolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type usersUncheckedUpdateWithoutR_users_rolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type rolesUpsertWithoutR_users_rolesInput = {
    update: XOR<rolesUpdateWithoutR_users_rolesInput, rolesUncheckedUpdateWithoutR_users_rolesInput>
    create: XOR<rolesCreateWithoutR_users_rolesInput, rolesUncheckedCreateWithoutR_users_rolesInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutR_users_rolesInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutR_users_rolesInput, rolesUncheckedUpdateWithoutR_users_rolesInput>
  }

  export type rolesUpdateWithoutR_users_rolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    r_roles_apps?: r_roles_appsUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateWithoutR_users_rolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    r_roles_apps?: r_roles_appsUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type r_roles_appsCreateWithoutRolesInput = {
    applications: applicationsCreateNestedOneWithoutR_roles_appsInput
  }

  export type r_roles_appsUncheckedCreateWithoutRolesInput = {
    app_id: string
  }

  export type r_roles_appsCreateOrConnectWithoutRolesInput = {
    where: r_roles_appsWhereUniqueInput
    create: XOR<r_roles_appsCreateWithoutRolesInput, r_roles_appsUncheckedCreateWithoutRolesInput>
  }

  export type r_roles_appsCreateManyRolesInputEnvelope = {
    data: r_roles_appsCreateManyRolesInput | r_roles_appsCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type r_users_rolesCreateWithoutRolesInput = {
    users: usersCreateNestedOneWithoutR_users_rolesInput
  }

  export type r_users_rolesUncheckedCreateWithoutRolesInput = {
    user_id: number
  }

  export type r_users_rolesCreateOrConnectWithoutRolesInput = {
    where: r_users_rolesWhereUniqueInput
    create: XOR<r_users_rolesCreateWithoutRolesInput, r_users_rolesUncheckedCreateWithoutRolesInput>
  }

  export type r_users_rolesCreateManyRolesInputEnvelope = {
    data: r_users_rolesCreateManyRolesInput | r_users_rolesCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type r_roles_appsUpsertWithWhereUniqueWithoutRolesInput = {
    where: r_roles_appsWhereUniqueInput
    update: XOR<r_roles_appsUpdateWithoutRolesInput, r_roles_appsUncheckedUpdateWithoutRolesInput>
    create: XOR<r_roles_appsCreateWithoutRolesInput, r_roles_appsUncheckedCreateWithoutRolesInput>
  }

  export type r_roles_appsUpdateWithWhereUniqueWithoutRolesInput = {
    where: r_roles_appsWhereUniqueInput
    data: XOR<r_roles_appsUpdateWithoutRolesInput, r_roles_appsUncheckedUpdateWithoutRolesInput>
  }

  export type r_roles_appsUpdateManyWithWhereWithoutRolesInput = {
    where: r_roles_appsScalarWhereInput
    data: XOR<r_roles_appsUpdateManyMutationInput, r_roles_appsUncheckedUpdateManyWithoutRolesInput>
  }

  export type r_users_rolesUpsertWithWhereUniqueWithoutRolesInput = {
    where: r_users_rolesWhereUniqueInput
    update: XOR<r_users_rolesUpdateWithoutRolesInput, r_users_rolesUncheckedUpdateWithoutRolesInput>
    create: XOR<r_users_rolesCreateWithoutRolesInput, r_users_rolesUncheckedCreateWithoutRolesInput>
  }

  export type r_users_rolesUpdateWithWhereUniqueWithoutRolesInput = {
    where: r_users_rolesWhereUniqueInput
    data: XOR<r_users_rolesUpdateWithoutRolesInput, r_users_rolesUncheckedUpdateWithoutRolesInput>
  }

  export type r_users_rolesUpdateManyWithWhereWithoutRolesInput = {
    where: r_users_rolesScalarWhereInput
    data: XOR<r_users_rolesUpdateManyMutationInput, r_users_rolesUncheckedUpdateManyWithoutRolesInput>
  }

  export type r_users_rolesScalarWhereInput = {
    AND?: r_users_rolesScalarWhereInput | r_users_rolesScalarWhereInput[]
    OR?: r_users_rolesScalarWhereInput[]
    NOT?: r_users_rolesScalarWhereInput | r_users_rolesScalarWhereInput[]
    user_id?: IntFilter<"r_users_roles"> | number
    role_id?: IntFilter<"r_users_roles"> | number
  }

  export type users_clientCreateWithoutRoles_clientInput = {
    name: string
    email: string
    phone: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    r_users_client_contractors?: r_users_client_contractorsCreateNestedManyWithoutUsers_clientInput
  }

  export type users_clientUncheckedCreateWithoutRoles_clientInput = {
    id?: number
    name: string
    email: string
    phone: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    r_users_client_contractors?: r_users_client_contractorsUncheckedCreateNestedManyWithoutUsers_clientInput
  }

  export type users_clientCreateOrConnectWithoutRoles_clientInput = {
    where: users_clientWhereUniqueInput
    create: XOR<users_clientCreateWithoutRoles_clientInput, users_clientUncheckedCreateWithoutRoles_clientInput>
  }

  export type users_clientCreateManyRoles_clientInputEnvelope = {
    data: users_clientCreateManyRoles_clientInput | users_clientCreateManyRoles_clientInput[]
    skipDuplicates?: boolean
  }

  export type users_clientUpsertWithWhereUniqueWithoutRoles_clientInput = {
    where: users_clientWhereUniqueInput
    update: XOR<users_clientUpdateWithoutRoles_clientInput, users_clientUncheckedUpdateWithoutRoles_clientInput>
    create: XOR<users_clientCreateWithoutRoles_clientInput, users_clientUncheckedCreateWithoutRoles_clientInput>
  }

  export type users_clientUpdateWithWhereUniqueWithoutRoles_clientInput = {
    where: users_clientWhereUniqueInput
    data: XOR<users_clientUpdateWithoutRoles_clientInput, users_clientUncheckedUpdateWithoutRoles_clientInput>
  }

  export type users_clientUpdateManyWithWhereWithoutRoles_clientInput = {
    where: users_clientScalarWhereInput
    data: XOR<users_clientUpdateManyMutationInput, users_clientUncheckedUpdateManyWithoutRoles_clientInput>
  }

  export type users_clientScalarWhereInput = {
    AND?: users_clientScalarWhereInput | users_clientScalarWhereInput[]
    OR?: users_clientScalarWhereInput[]
    NOT?: users_clientScalarWhereInput | users_clientScalarWhereInput[]
    id?: IntFilter<"users_client"> | number
    name?: StringFilter<"users_client"> | string
    email?: StringFilter<"users_client"> | string
    phone?: StringFilter<"users_client"> | string
    role_id?: IntFilter<"users_client"> | number
    created_at?: DateTimeFilter<"users_client"> | Date | string
    updated_at?: DateTimeFilter<"users_client"> | Date | string
    deleted_at?: DateTimeNullableFilter<"users_client"> | Date | string | null
  }

  export type objectsCreateWithoutSectionsInput = {
    short_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    entities: entitiesCreateNestedOneWithoutObjectsInput
  }

  export type objectsUncheckedCreateWithoutSectionsInput = {
    id?: number
    short_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    entity_id: number
  }

  export type objectsCreateOrConnectWithoutSectionsInput = {
    where: objectsWhereUniqueInput
    create: XOR<objectsCreateWithoutSectionsInput, objectsUncheckedCreateWithoutSectionsInput>
  }

  export type objectsUpsertWithoutSectionsInput = {
    update: XOR<objectsUpdateWithoutSectionsInput, objectsUncheckedUpdateWithoutSectionsInput>
    create: XOR<objectsCreateWithoutSectionsInput, objectsUncheckedCreateWithoutSectionsInput>
    where?: objectsWhereInput
  }

  export type objectsUpdateToOneWithWhereWithoutSectionsInput = {
    where?: objectsWhereInput
    data: XOR<objectsUpdateWithoutSectionsInput, objectsUncheckedUpdateWithoutSectionsInput>
  }

  export type objectsUpdateWithoutSectionsInput = {
    short_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entities?: entitiesUpdateOneRequiredWithoutObjectsNestedInput
  }

  export type objectsUncheckedUpdateWithoutSectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    short_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entity_id?: IntFieldUpdateOperationsInput | number
  }

  export type itemsCreateWithoutSub_paketsInput = {
    name: string
    code: string
    clc_code?: string | null
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    banks_items?: banks_itemsCreateNestedOneWithoutItemsInput
  }

  export type itemsUncheckedCreateWithoutSub_paketsInput = {
    id?: number
    name: string
    code: string
    clc_code?: string | null
    order_num?: number | null
    is_active?: boolean
    banks_items_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
  }

  export type itemsCreateOrConnectWithoutSub_paketsInput = {
    where: itemsWhereUniqueInput
    create: XOR<itemsCreateWithoutSub_paketsInput, itemsUncheckedCreateWithoutSub_paketsInput>
  }

  export type itemsCreateManySub_paketsInputEnvelope = {
    data: itemsCreateManySub_paketsInput | itemsCreateManySub_paketsInput[]
    skipDuplicates?: boolean
  }

  export type paketsCreateWithoutSub_paketsInput = {
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    blocks: blocksCreateNestedOneWithoutPaketsInput
  }

  export type paketsUncheckedCreateWithoutSub_paketsInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    blocks_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
  }

  export type paketsCreateOrConnectWithoutSub_paketsInput = {
    where: paketsWhereUniqueInput
    create: XOR<paketsCreateWithoutSub_paketsInput, paketsUncheckedCreateWithoutSub_paketsInput>
  }

  export type itemsUpsertWithWhereUniqueWithoutSub_paketsInput = {
    where: itemsWhereUniqueInput
    update: XOR<itemsUpdateWithoutSub_paketsInput, itemsUncheckedUpdateWithoutSub_paketsInput>
    create: XOR<itemsCreateWithoutSub_paketsInput, itemsUncheckedCreateWithoutSub_paketsInput>
  }

  export type itemsUpdateWithWhereUniqueWithoutSub_paketsInput = {
    where: itemsWhereUniqueInput
    data: XOR<itemsUpdateWithoutSub_paketsInput, itemsUncheckedUpdateWithoutSub_paketsInput>
  }

  export type itemsUpdateManyWithWhereWithoutSub_paketsInput = {
    where: itemsScalarWhereInput
    data: XOR<itemsUpdateManyMutationInput, itemsUncheckedUpdateManyWithoutSub_paketsInput>
  }

  export type paketsUpsertWithoutSub_paketsInput = {
    update: XOR<paketsUpdateWithoutSub_paketsInput, paketsUncheckedUpdateWithoutSub_paketsInput>
    create: XOR<paketsCreateWithoutSub_paketsInput, paketsUncheckedCreateWithoutSub_paketsInput>
    where?: paketsWhereInput
  }

  export type paketsUpdateToOneWithWhereWithoutSub_paketsInput = {
    where?: paketsWhereInput
    data: XOR<paketsUpdateWithoutSub_paketsInput, paketsUncheckedUpdateWithoutSub_paketsInput>
  }

  export type paketsUpdateWithoutSub_paketsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blocks?: blocksUpdateOneRequiredWithoutPaketsNestedInput
  }

  export type paketsUncheckedUpdateWithoutSub_paketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    blocks_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type r_users_rolesCreateWithoutUsersInput = {
    roles: rolesCreateNestedOneWithoutR_users_rolesInput
  }

  export type r_users_rolesUncheckedCreateWithoutUsersInput = {
    role_id: number
  }

  export type r_users_rolesCreateOrConnectWithoutUsersInput = {
    where: r_users_rolesWhereUniqueInput
    create: XOR<r_users_rolesCreateWithoutUsersInput, r_users_rolesUncheckedCreateWithoutUsersInput>
  }

  export type r_users_rolesCreateManyUsersInputEnvelope = {
    data: r_users_rolesCreateManyUsersInput | r_users_rolesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type r_users_rolesUpsertWithWhereUniqueWithoutUsersInput = {
    where: r_users_rolesWhereUniqueInput
    update: XOR<r_users_rolesUpdateWithoutUsersInput, r_users_rolesUncheckedUpdateWithoutUsersInput>
    create: XOR<r_users_rolesCreateWithoutUsersInput, r_users_rolesUncheckedCreateWithoutUsersInput>
  }

  export type r_users_rolesUpdateWithWhereUniqueWithoutUsersInput = {
    where: r_users_rolesWhereUniqueInput
    data: XOR<r_users_rolesUpdateWithoutUsersInput, r_users_rolesUncheckedUpdateWithoutUsersInput>
  }

  export type r_users_rolesUpdateManyWithWhereWithoutUsersInput = {
    where: r_users_rolesScalarWhereInput
    data: XOR<r_users_rolesUpdateManyMutationInput, r_users_rolesUncheckedUpdateManyWithoutUsersInput>
  }

  export type r_users_client_contractorsCreateWithoutUsers_clientInput = {
    contractors: contractorsCreateNestedOneWithoutR_users_client_contractorsInput
  }

  export type r_users_client_contractorsUncheckedCreateWithoutUsers_clientInput = {
    id?: number
    contractors_id: number
  }

  export type r_users_client_contractorsCreateOrConnectWithoutUsers_clientInput = {
    where: r_users_client_contractorsWhereUniqueInput
    create: XOR<r_users_client_contractorsCreateWithoutUsers_clientInput, r_users_client_contractorsUncheckedCreateWithoutUsers_clientInput>
  }

  export type r_users_client_contractorsCreateManyUsers_clientInputEnvelope = {
    data: r_users_client_contractorsCreateManyUsers_clientInput | r_users_client_contractorsCreateManyUsers_clientInput[]
    skipDuplicates?: boolean
  }

  export type roles_clientCreateWithoutUsers_clientInput = {
    name: string
  }

  export type roles_clientUncheckedCreateWithoutUsers_clientInput = {
    id?: number
    name: string
  }

  export type roles_clientCreateOrConnectWithoutUsers_clientInput = {
    where: roles_clientWhereUniqueInput
    create: XOR<roles_clientCreateWithoutUsers_clientInput, roles_clientUncheckedCreateWithoutUsers_clientInput>
  }

  export type r_users_client_contractorsUpsertWithWhereUniqueWithoutUsers_clientInput = {
    where: r_users_client_contractorsWhereUniqueInput
    update: XOR<r_users_client_contractorsUpdateWithoutUsers_clientInput, r_users_client_contractorsUncheckedUpdateWithoutUsers_clientInput>
    create: XOR<r_users_client_contractorsCreateWithoutUsers_clientInput, r_users_client_contractorsUncheckedCreateWithoutUsers_clientInput>
  }

  export type r_users_client_contractorsUpdateWithWhereUniqueWithoutUsers_clientInput = {
    where: r_users_client_contractorsWhereUniqueInput
    data: XOR<r_users_client_contractorsUpdateWithoutUsers_clientInput, r_users_client_contractorsUncheckedUpdateWithoutUsers_clientInput>
  }

  export type r_users_client_contractorsUpdateManyWithWhereWithoutUsers_clientInput = {
    where: r_users_client_contractorsScalarWhereInput
    data: XOR<r_users_client_contractorsUpdateManyMutationInput, r_users_client_contractorsUncheckedUpdateManyWithoutUsers_clientInput>
  }

  export type roles_clientUpsertWithoutUsers_clientInput = {
    update: XOR<roles_clientUpdateWithoutUsers_clientInput, roles_clientUncheckedUpdateWithoutUsers_clientInput>
    create: XOR<roles_clientCreateWithoutUsers_clientInput, roles_clientUncheckedCreateWithoutUsers_clientInput>
    where?: roles_clientWhereInput
  }

  export type roles_clientUpdateToOneWithWhereWithoutUsers_clientInput = {
    where?: roles_clientWhereInput
    data: XOR<roles_clientUpdateWithoutUsers_clientInput, roles_clientUncheckedUpdateWithoutUsers_clientInput>
  }

  export type roles_clientUpdateWithoutUsers_clientInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type roles_clientUncheckedUpdateWithoutUsers_clientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type banks_itemsCreateWithoutBanks_items_versionsInput = {
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    banks_pakets?: banks_paketsCreateNestedOneWithoutBanks_itemsInput
    items?: itemsCreateNestedManyWithoutBanks_itemsInput
  }

  export type banks_itemsUncheckedCreateWithoutBanks_items_versionsInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    banks_pakets_id?: number | null
    propogated_at?: Date | string | null
    items?: itemsUncheckedCreateNestedManyWithoutBanks_itemsInput
  }

  export type banks_itemsCreateOrConnectWithoutBanks_items_versionsInput = {
    where: banks_itemsWhereUniqueInput
    create: XOR<banks_itemsCreateWithoutBanks_items_versionsInput, banks_itemsUncheckedCreateWithoutBanks_items_versionsInput>
  }

  export type banks_itemsCreateManyBanks_items_versionsInputEnvelope = {
    data: banks_itemsCreateManyBanks_items_versionsInput | banks_itemsCreateManyBanks_items_versionsInput[]
    skipDuplicates?: boolean
  }

  export type banksCreateWithoutBanks_items_versionsInput = {
    name: string
    city?: string | null
    bik: string
    correspondent_number?: string | null
    accounts?: accountsCreateNestedManyWithoutBanksInput
  }

  export type banksUncheckedCreateWithoutBanks_items_versionsInput = {
    id?: number
    name: string
    city?: string | null
    bik: string
    correspondent_number?: string | null
    accounts?: accountsUncheckedCreateNestedManyWithoutBanksInput
  }

  export type banksCreateOrConnectWithoutBanks_items_versionsInput = {
    where: banksWhereUniqueInput
    create: XOR<banksCreateWithoutBanks_items_versionsInput, banksUncheckedCreateWithoutBanks_items_versionsInput>
  }

  export type banks_itemsUpsertWithWhereUniqueWithoutBanks_items_versionsInput = {
    where: banks_itemsWhereUniqueInput
    update: XOR<banks_itemsUpdateWithoutBanks_items_versionsInput, banks_itemsUncheckedUpdateWithoutBanks_items_versionsInput>
    create: XOR<banks_itemsCreateWithoutBanks_items_versionsInput, banks_itemsUncheckedCreateWithoutBanks_items_versionsInput>
  }

  export type banks_itemsUpdateWithWhereUniqueWithoutBanks_items_versionsInput = {
    where: banks_itemsWhereUniqueInput
    data: XOR<banks_itemsUpdateWithoutBanks_items_versionsInput, banks_itemsUncheckedUpdateWithoutBanks_items_versionsInput>
  }

  export type banks_itemsUpdateManyWithWhereWithoutBanks_items_versionsInput = {
    where: banks_itemsScalarWhereInput
    data: XOR<banks_itemsUpdateManyMutationInput, banks_itemsUncheckedUpdateManyWithoutBanks_items_versionsInput>
  }

  export type banksUpsertWithoutBanks_items_versionsInput = {
    update: XOR<banksUpdateWithoutBanks_items_versionsInput, banksUncheckedUpdateWithoutBanks_items_versionsInput>
    create: XOR<banksCreateWithoutBanks_items_versionsInput, banksUncheckedCreateWithoutBanks_items_versionsInput>
    where?: banksWhereInput
  }

  export type banksUpdateToOneWithWhereWithoutBanks_items_versionsInput = {
    where?: banksWhereInput
    data: XOR<banksUpdateWithoutBanks_items_versionsInput, banksUncheckedUpdateWithoutBanks_items_versionsInput>
  }

  export type banksUpdateWithoutBanks_items_versionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bik?: StringFieldUpdateOperationsInput | string
    correspondent_number?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUpdateManyWithoutBanksNestedInput
  }

  export type banksUncheckedUpdateWithoutBanks_items_versionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bik?: StringFieldUpdateOperationsInput | string
    correspondent_number?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUncheckedUpdateManyWithoutBanksNestedInput
  }

  export type objectsCreateWithoutEntitiesInput = {
    short_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    sections?: sectionsCreateNestedManyWithoutObjectsInput
  }

  export type objectsUncheckedCreateWithoutEntitiesInput = {
    id?: number
    short_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    sections?: sectionsUncheckedCreateNestedManyWithoutObjectsInput
  }

  export type objectsCreateOrConnectWithoutEntitiesInput = {
    where: objectsWhereUniqueInput
    create: XOR<objectsCreateWithoutEntitiesInput, objectsUncheckedCreateWithoutEntitiesInput>
  }

  export type objectsCreateManyEntitiesInputEnvelope = {
    data: objectsCreateManyEntitiesInput | objectsCreateManyEntitiesInput[]
    skipDuplicates?: boolean
  }

  export type objectsUpsertWithWhereUniqueWithoutEntitiesInput = {
    where: objectsWhereUniqueInput
    update: XOR<objectsUpdateWithoutEntitiesInput, objectsUncheckedUpdateWithoutEntitiesInput>
    create: XOR<objectsCreateWithoutEntitiesInput, objectsUncheckedCreateWithoutEntitiesInput>
  }

  export type objectsUpdateWithWhereUniqueWithoutEntitiesInput = {
    where: objectsWhereUniqueInput
    data: XOR<objectsUpdateWithoutEntitiesInput, objectsUncheckedUpdateWithoutEntitiesInput>
  }

  export type objectsUpdateManyWithWhereWithoutEntitiesInput = {
    where: objectsScalarWhereInput
    data: XOR<objectsUpdateManyMutationInput, objectsUncheckedUpdateManyWithoutEntitiesInput>
  }

  export type objectsScalarWhereInput = {
    AND?: objectsScalarWhereInput | objectsScalarWhereInput[]
    OR?: objectsScalarWhereInput[]
    NOT?: objectsScalarWhereInput | objectsScalarWhereInput[]
    id?: IntFilter<"objects"> | number
    short_name?: StringFilter<"objects"> | string
    created_at?: DateTimeNullableFilter<"objects"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"objects"> | Date | string | null
    entity_id?: IntFilter<"objects"> | number
  }

  export type applicationsCreateManyApp_groupsInput = {
    id: string
    name: string
    active?: boolean | null
    type?: $Enums.applications_type
    path?: string | null
    description?: string | null
  }

  export type applicationsUpdateWithoutApp_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: Enumapplications_typeFieldUpdateOperationsInput | $Enums.applications_type
    path?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    r_roles_apps?: r_roles_appsUpdateManyWithoutApplicationsNestedInput
  }

  export type applicationsUncheckedUpdateWithoutApp_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: Enumapplications_typeFieldUpdateOperationsInput | $Enums.applications_type
    path?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    r_roles_apps?: r_roles_appsUncheckedUpdateManyWithoutApplicationsNestedInput
  }

  export type applicationsUncheckedUpdateManyWithoutApp_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: Enumapplications_typeFieldUpdateOperationsInput | $Enums.applications_type
    path?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type r_roles_appsCreateManyApplicationsInput = {
    role_id: number
  }

  export type r_roles_appsUpdateWithoutApplicationsInput = {
    roles?: rolesUpdateOneRequiredWithoutR_roles_appsNestedInput
  }

  export type r_roles_appsUncheckedUpdateWithoutApplicationsInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type r_roles_appsUncheckedUpdateManyWithoutApplicationsInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type accountsCreateManyBanksInput = {
    id?: number
    number: string
    contractors_id: number
  }

  export type banks_items_versionsCreateManyBanksInput = {
    id?: bigint | number
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type accountsUpdateWithoutBanksInput = {
    number?: StringFieldUpdateOperationsInput | string
    contractors?: contractorsUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type accountsUncheckedUpdateWithoutBanksInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    contractors_id?: IntFieldUpdateOperationsInput | number
  }

  export type accountsUncheckedUpdateManyWithoutBanksInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    contractors_id?: IntFieldUpdateOperationsInput | number
  }

  export type banks_items_versionsUpdateWithoutBanksInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    banks_items?: banks_itemsUpdateManyWithoutBanks_items_versionsNestedInput
  }

  export type banks_items_versionsUncheckedUpdateWithoutBanksInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    banks_items?: banks_itemsUncheckedUpdateManyWithoutBanks_items_versionsNestedInput
  }

  export type banks_items_versionsUncheckedUpdateManyWithoutBanksInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemsCreateManyBanks_itemsInput = {
    id?: number
    name: string
    code: string
    clc_code?: string | null
    order_num?: number | null
    is_active?: boolean
    sub_pakets_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
  }

  export type itemsUpdateWithoutBanks_itemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clc_code?: NullableStringFieldUpdateOperationsInput | string | null
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_pakets?: sub_paketsUpdateOneRequiredWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateWithoutBanks_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clc_code?: NullableStringFieldUpdateOperationsInput | string | null
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sub_pakets_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itemsUncheckedUpdateManyWithoutBanks_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clc_code?: NullableStringFieldUpdateOperationsInput | string | null
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sub_pakets_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type banks_itemsCreateManyBanks_paketsInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
    version_id?: bigint | number | null
  }

  export type banks_itemsUpdateWithoutBanks_paketsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banks_items_versions?: banks_items_versionsUpdateOneWithoutBanks_itemsNestedInput
    items?: itemsUpdateManyWithoutBanks_itemsNestedInput
  }

  export type banks_itemsUncheckedUpdateWithoutBanks_paketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    items?: itemsUncheckedUpdateManyWithoutBanks_itemsNestedInput
  }

  export type banks_itemsUncheckedUpdateManyWithoutBanks_paketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type paketsCreateManyBlocksInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
  }

  export type paketsUpdateWithoutBlocksInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_pakets?: sub_paketsUpdateManyWithoutPaketsNestedInput
  }

  export type paketsUncheckedUpdateWithoutBlocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_pakets?: sub_paketsUncheckedUpdateManyWithoutPaketsNestedInput
  }

  export type paketsUncheckedUpdateManyWithoutBlocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type accountsCreateManyContractorsInput = {
    id?: number
    number: string
    bank_id: number
  }

  export type r_users_client_contractorsCreateManyContractorsInput = {
    id?: number
    users_client_id: number
  }

  export type accountsUpdateWithoutContractorsInput = {
    number?: StringFieldUpdateOperationsInput | string
    banks?: banksUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type accountsUncheckedUpdateWithoutContractorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    bank_id?: IntFieldUpdateOperationsInput | number
  }

  export type accountsUncheckedUpdateManyWithoutContractorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    bank_id?: IntFieldUpdateOperationsInput | number
  }

  export type r_users_client_contractorsUpdateWithoutContractorsInput = {
    users_client?: users_clientUpdateOneRequiredWithoutR_users_client_contractorsNestedInput
  }

  export type r_users_client_contractorsUncheckedUpdateWithoutContractorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_client_id?: IntFieldUpdateOperationsInput | number
  }

  export type r_users_client_contractorsUncheckedUpdateManyWithoutContractorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_client_id?: IntFieldUpdateOperationsInput | number
  }

  export type sectionsCreateManyObjectsInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    updated_ad?: Date | string | null
  }

  export type sectionsUpdateWithoutObjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_ad?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sectionsUncheckedUpdateWithoutObjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_ad?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sectionsUncheckedUpdateManyWithoutObjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_ad?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sub_paketsCreateManyPaketsInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
  }

  export type sub_paketsUpdateWithoutPaketsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: itemsUpdateManyWithoutSub_paketsNestedInput
  }

  export type sub_paketsUncheckedUpdateWithoutPaketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: itemsUncheckedUpdateManyWithoutSub_paketsNestedInput
  }

  export type sub_paketsUncheckedUpdateManyWithoutPaketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type r_roles_appsCreateManyRolesInput = {
    app_id: string
  }

  export type r_users_rolesCreateManyRolesInput = {
    user_id: number
  }

  export type r_roles_appsUpdateWithoutRolesInput = {
    applications?: applicationsUpdateOneRequiredWithoutR_roles_appsNestedInput
  }

  export type r_roles_appsUncheckedUpdateWithoutRolesInput = {
    app_id?: StringFieldUpdateOperationsInput | string
  }

  export type r_roles_appsUncheckedUpdateManyWithoutRolesInput = {
    app_id?: StringFieldUpdateOperationsInput | string
  }

  export type r_users_rolesUpdateWithoutRolesInput = {
    users?: usersUpdateOneRequiredWithoutR_users_rolesNestedInput
  }

  export type r_users_rolesUncheckedUpdateWithoutRolesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type r_users_rolesUncheckedUpdateManyWithoutRolesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type users_clientCreateManyRoles_clientInput = {
    id?: number
    name: string
    email: string
    phone: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type users_clientUpdateWithoutRoles_clientInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    r_users_client_contractors?: r_users_client_contractorsUpdateManyWithoutUsers_clientNestedInput
  }

  export type users_clientUncheckedUpdateWithoutRoles_clientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    r_users_client_contractors?: r_users_client_contractorsUncheckedUpdateManyWithoutUsers_clientNestedInput
  }

  export type users_clientUncheckedUpdateManyWithoutRoles_clientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itemsCreateManySub_paketsInput = {
    id?: number
    name: string
    code: string
    clc_code?: string | null
    order_num?: number | null
    is_active?: boolean
    banks_items_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    propogated_at?: Date | string | null
  }

  export type itemsUpdateWithoutSub_paketsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clc_code?: NullableStringFieldUpdateOperationsInput | string | null
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banks_items?: banks_itemsUpdateOneWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateWithoutSub_paketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clc_code?: NullableStringFieldUpdateOperationsInput | string | null
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    banks_items_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itemsUncheckedUpdateManyWithoutSub_paketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clc_code?: NullableStringFieldUpdateOperationsInput | string | null
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    banks_items_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type r_users_rolesCreateManyUsersInput = {
    role_id: number
  }

  export type r_users_rolesUpdateWithoutUsersInput = {
    roles?: rolesUpdateOneRequiredWithoutR_users_rolesNestedInput
  }

  export type r_users_rolesUncheckedUpdateWithoutUsersInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type r_users_rolesUncheckedUpdateManyWithoutUsersInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type r_users_client_contractorsCreateManyUsers_clientInput = {
    id?: number
    contractors_id: number
  }

  export type r_users_client_contractorsUpdateWithoutUsers_clientInput = {
    contractors?: contractorsUpdateOneRequiredWithoutR_users_client_contractorsNestedInput
  }

  export type r_users_client_contractorsUncheckedUpdateWithoutUsers_clientInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractors_id?: IntFieldUpdateOperationsInput | number
  }

  export type r_users_client_contractorsUncheckedUpdateManyWithoutUsers_clientInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractors_id?: IntFieldUpdateOperationsInput | number
  }

  export type banks_itemsCreateManyBanks_items_versionsInput = {
    id?: number
    name: string
    code: string
    order_num?: number | null
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    banks_pakets_id?: number | null
    propogated_at?: Date | string | null
  }

  export type banks_itemsUpdateWithoutBanks_items_versionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banks_pakets?: banks_paketsUpdateOneWithoutBanks_itemsNestedInput
    items?: itemsUpdateManyWithoutBanks_itemsNestedInput
  }

  export type banks_itemsUncheckedUpdateWithoutBanks_items_versionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banks_pakets_id?: NullableIntFieldUpdateOperationsInput | number | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: itemsUncheckedUpdateManyWithoutBanks_itemsNestedInput
  }

  export type banks_itemsUncheckedUpdateManyWithoutBanks_items_versionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    order_num?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banks_pakets_id?: NullableIntFieldUpdateOperationsInput | number | null
    propogated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type objectsCreateManyEntitiesInput = {
    id?: number
    short_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type objectsUpdateWithoutEntitiesInput = {
    short_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sections?: sectionsUpdateManyWithoutObjectsNestedInput
  }

  export type objectsUncheckedUpdateWithoutEntitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    short_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sections?: sectionsUncheckedUpdateManyWithoutObjectsNestedInput
  }

  export type objectsUncheckedUpdateManyWithoutEntitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    short_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use App_groupsCountOutputTypeDefaultArgs instead
     */
    export type App_groupsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = App_groupsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApplicationsCountOutputTypeDefaultArgs instead
     */
    export type ApplicationsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApplicationsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BanksCountOutputTypeDefaultArgs instead
     */
    export type BanksCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BanksCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Banks_itemsCountOutputTypeDefaultArgs instead
     */
    export type Banks_itemsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Banks_itemsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Banks_paketsCountOutputTypeDefaultArgs instead
     */
    export type Banks_paketsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Banks_paketsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlocksCountOutputTypeDefaultArgs instead
     */
    export type BlocksCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlocksCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractorsCountOutputTypeDefaultArgs instead
     */
    export type ContractorsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractorsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectsCountOutputTypeDefaultArgs instead
     */
    export type ObjectsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaketsCountOutputTypeDefaultArgs instead
     */
    export type PaketsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaketsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolesCountOutputTypeDefaultArgs instead
     */
    export type RolesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Roles_clientCountOutputTypeDefaultArgs instead
     */
    export type Roles_clientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Roles_clientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Sub_paketsCountOutputTypeDefaultArgs instead
     */
    export type Sub_paketsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Sub_paketsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Users_clientCountOutputTypeDefaultArgs instead
     */
    export type Users_clientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Users_clientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Banks_items_versionsCountOutputTypeDefaultArgs instead
     */
    export type Banks_items_versionsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Banks_items_versionsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntitiesCountOutputTypeDefaultArgs instead
     */
    export type EntitiesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntitiesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use accountsDefaultArgs instead
     */
    export type accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = accountsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use app_groupsDefaultArgs instead
     */
    export type app_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = app_groupsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use applicationsDefaultArgs instead
     */
    export type applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = applicationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use banksDefaultArgs instead
     */
    export type banksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = banksDefaultArgs<ExtArgs>
    /**
     * @deprecated Use banks_itemsDefaultArgs instead
     */
    export type banks_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = banks_itemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use banks_paketsDefaultArgs instead
     */
    export type banks_paketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = banks_paketsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use blocksDefaultArgs instead
     */
    export type blocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = blocksDefaultArgs<ExtArgs>
    /**
     * @deprecated Use contractorsDefaultArgs instead
     */
    export type contractorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = contractorsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use floorsDefaultArgs instead
     */
    export type floorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = floorsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use itemsDefaultArgs instead
     */
    export type itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = itemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use objectsDefaultArgs instead
     */
    export type objectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = objectsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use paketsDefaultArgs instead
     */
    export type paketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = paketsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use r_roles_appsDefaultArgs instead
     */
    export type r_roles_appsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = r_roles_appsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use r_users_client_contractorsDefaultArgs instead
     */
    export type r_users_client_contractorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = r_users_client_contractorsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use r_users_rolesDefaultArgs instead
     */
    export type r_users_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = r_users_rolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rolesDefaultArgs instead
     */
    export type rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use roles_clientDefaultArgs instead
     */
    export type roles_clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = roles_clientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use sectionsDefaultArgs instead
     */
    export type sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = sectionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use sub_paketsDefaultArgs instead
     */
    export type sub_paketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = sub_paketsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use users_clientDefaultArgs instead
     */
    export type users_clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = users_clientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use banks_items_versionsDefaultArgs instead
     */
    export type banks_items_versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = banks_items_versionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use entitiesDefaultArgs instead
     */
    export type entitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = entitiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use r_items_banks_itemsDefaultArgs instead
     */
    export type r_items_banks_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = r_items_banks_itemsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}