
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model ClientIndividualProperties
 * 
 */
export type ClientIndividualProperties = $Result.DefaultSelection<Prisma.$ClientIndividualPropertiesPayload>
/**
 * Model ClientIndividualMinorProperties
 * 
 */
export type ClientIndividualMinorProperties = $Result.DefaultSelection<Prisma.$ClientIndividualMinorPropertiesPayload>
/**
 * Model ClientEntityProperties
 * 
 */
export type ClientEntityProperties = $Result.DefaultSelection<Prisma.$ClientEntityPropertiesPayload>
/**
 * Model ClientToClientIndividualMinorProperties
 * 
 */
export type ClientToClientIndividualMinorProperties = $Result.DefaultSelection<Prisma.$ClientToClientIndividualMinorPropertiesPayload>
/**
 * Model ClientPassport
 * 
 */
export type ClientPassport = $Result.DefaultSelection<Prisma.$ClientPassportPayload>
/**
 * Model ClientContract
 * 
 */
export type ClientContract = $Result.DefaultSelection<Prisma.$ClientContractPayload>
/**
 * Model DDUClientContractProperties
 * 
 */
export type DDUClientContractProperties = $Result.DefaultSelection<Prisma.$DDUClientContractPropertiesPayload>
/**
 * Model ClientContractToAgencyContract
 * 
 */
export type ClientContractToAgencyContract = $Result.DefaultSelection<Prisma.$ClientContractToAgencyContractPayload>
/**
 * Model ClientContractToClient
 * 
 */
export type ClientContractToClient = $Result.DefaultSelection<Prisma.$ClientContractToClientPayload>
/**
 * Model ScheduledPayment
 * 
 */
export type ScheduledPayment = $Result.DefaultSelection<Prisma.$ScheduledPaymentPayload>
/**
 * Model ActualPayment
 * 
 */
export type ActualPayment = $Result.DefaultSelection<Prisma.$ActualPaymentPayload>
/**
 * Model Object
 * 
 */
export type Object = $Result.DefaultSelection<Prisma.$ObjectPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Agency
 * 
 */
export type Agency = $Result.DefaultSelection<Prisma.$AgencyPayload>
/**
 * Model AgencyContract
 * 
 */
export type AgencyContract = $Result.DefaultSelection<Prisma.$AgencyContractPayload>
/**
 * Model AgencyContractSignatory
 * 
 */
export type AgencyContractSignatory = $Result.DefaultSelection<Prisma.$AgencyContractSignatoryPayload>
/**
 * Model RealEstateAgencyContractProperties
 * 
 */
export type RealEstateAgencyContractProperties = $Result.DefaultSelection<Prisma.$RealEstateAgencyContractPropertiesPayload>
/**
 * Model MIPAgencyContractProperties
 * 
 */
export type MIPAgencyContractProperties = $Result.DefaultSelection<Prisma.$MIPAgencyContractPropertiesPayload>
/**
 * Model AgencyContractCommission
 * 
 */
export type AgencyContractCommission = $Result.DefaultSelection<Prisma.$AgencyContractCommissionPayload>
/**
 * Model RealEstateAgent
 * 
 */
export type RealEstateAgent = $Result.DefaultSelection<Prisma.$RealEstateAgentPayload>
/**
 * Model AgencyToRealEstateAgent
 * 
 */
export type AgencyToRealEstateAgent = $Result.DefaultSelection<Prisma.$AgencyToRealEstateAgentPayload>
/**
 * Model Entity
 * 
 */
export type Entity = $Result.DefaultSelection<Prisma.$EntityPayload>
/**
 * Model EntityForbiddenWebsite
 * 
 */
export type EntityForbiddenWebsite = $Result.DefaultSelection<Prisma.$EntityForbiddenWebsitePayload>
/**
 * Model EntityForbiddenBrand
 * 
 */
export type EntityForbiddenBrand = $Result.DefaultSelection<Prisma.$EntityForbiddenBrandPayload>
/**
 * Model Bank
 * 
 */
export type Bank = $Result.DefaultSelection<Prisma.$BankPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMINISTRATOR: 'ADMINISTRATOR',
  DIRECTOR: 'DIRECTOR',
  SALES_EMPLOYEE: 'SALES_EMPLOYEE'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ClientCategory: {
  INDIVIDUAL: 'INDIVIDUAL',
  INDIVIDUAL_MINOR: 'INDIVIDUAL_MINOR',
  ENTITY: 'ENTITY'
};

export type ClientCategory = (typeof ClientCategory)[keyof typeof ClientCategory]


export const ClientContractType: {
  DDU: 'DDU',
  DKP: 'DKP'
};

export type ClientContractType = (typeof ClientContractType)[keyof typeof ClientContractType]


export const ScheduledPaymentType: {
  OWN: 'OWN',
  MORTGAGE: 'MORTGAGE',
  EXCHANGE: 'EXCHANGE',
  MATERNITY_CAPITAL: 'MATERNITY_CAPITAL'
};

export type ScheduledPaymentType = (typeof ScheduledPaymentType)[keyof typeof ScheduledPaymentType]


export const ProductCategory: {
  FLAT: 'FLAT',
  OFFICE: 'OFFICE',
  APARTMENT: 'APARTMENT',
  STORAGE_ROOM: 'STORAGE_ROOM',
  PARKING_SPACE: 'PARKING_SPACE'
};

export type ProductCategory = (typeof ProductCategory)[keyof typeof ProductCategory]


export const AgencyContractType: {
  REAL_ESTATE_AGENCY_CONTRACT: 'REAL_ESTATE_AGENCY_CONTRACT',
  MIP_AGENCY_CONTRACT: 'MIP_AGENCY_CONTRACT'
};

export type AgencyContractType = (typeof AgencyContractType)[keyof typeof AgencyContractType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ClientCategory = $Enums.ClientCategory

export const ClientCategory: typeof $Enums.ClientCategory

export type ClientContractType = $Enums.ClientContractType

export const ClientContractType: typeof $Enums.ClientContractType

export type ScheduledPaymentType = $Enums.ScheduledPaymentType

export const ScheduledPaymentType: typeof $Enums.ScheduledPaymentType

export type ProductCategory = $Enums.ProductCategory

export const ProductCategory: typeof $Enums.ProductCategory

export type AgencyContractType = $Enums.AgencyContractType

export const AgencyContractType: typeof $Enums.AgencyContractType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs>;

  /**
   * `prisma.clientIndividualProperties`: Exposes CRUD operations for the **ClientIndividualProperties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientIndividualProperties
    * const clientIndividualProperties = await prisma.clientIndividualProperties.findMany()
    * ```
    */
  get clientIndividualProperties(): Prisma.ClientIndividualPropertiesDelegate<ExtArgs>;

  /**
   * `prisma.clientIndividualMinorProperties`: Exposes CRUD operations for the **ClientIndividualMinorProperties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientIndividualMinorProperties
    * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.findMany()
    * ```
    */
  get clientIndividualMinorProperties(): Prisma.ClientIndividualMinorPropertiesDelegate<ExtArgs>;

  /**
   * `prisma.clientEntityProperties`: Exposes CRUD operations for the **ClientEntityProperties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientEntityProperties
    * const clientEntityProperties = await prisma.clientEntityProperties.findMany()
    * ```
    */
  get clientEntityProperties(): Prisma.ClientEntityPropertiesDelegate<ExtArgs>;

  /**
   * `prisma.clientToClientIndividualMinorProperties`: Exposes CRUD operations for the **ClientToClientIndividualMinorProperties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientToClientIndividualMinorProperties
    * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.findMany()
    * ```
    */
  get clientToClientIndividualMinorProperties(): Prisma.ClientToClientIndividualMinorPropertiesDelegate<ExtArgs>;

  /**
   * `prisma.clientPassport`: Exposes CRUD operations for the **ClientPassport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientPassports
    * const clientPassports = await prisma.clientPassport.findMany()
    * ```
    */
  get clientPassport(): Prisma.ClientPassportDelegate<ExtArgs>;

  /**
   * `prisma.clientContract`: Exposes CRUD operations for the **ClientContract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientContracts
    * const clientContracts = await prisma.clientContract.findMany()
    * ```
    */
  get clientContract(): Prisma.ClientContractDelegate<ExtArgs>;

  /**
   * `prisma.dDUClientContractProperties`: Exposes CRUD operations for the **DDUClientContractProperties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DDUClientContractProperties
    * const dDUClientContractProperties = await prisma.dDUClientContractProperties.findMany()
    * ```
    */
  get dDUClientContractProperties(): Prisma.DDUClientContractPropertiesDelegate<ExtArgs>;

  /**
   * `prisma.clientContractToAgencyContract`: Exposes CRUD operations for the **ClientContractToAgencyContract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientContractToAgencyContracts
    * const clientContractToAgencyContracts = await prisma.clientContractToAgencyContract.findMany()
    * ```
    */
  get clientContractToAgencyContract(): Prisma.ClientContractToAgencyContractDelegate<ExtArgs>;

  /**
   * `prisma.clientContractToClient`: Exposes CRUD operations for the **ClientContractToClient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientContractToClients
    * const clientContractToClients = await prisma.clientContractToClient.findMany()
    * ```
    */
  get clientContractToClient(): Prisma.ClientContractToClientDelegate<ExtArgs>;

  /**
   * `prisma.scheduledPayment`: Exposes CRUD operations for the **ScheduledPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduledPayments
    * const scheduledPayments = await prisma.scheduledPayment.findMany()
    * ```
    */
  get scheduledPayment(): Prisma.ScheduledPaymentDelegate<ExtArgs>;

  /**
   * `prisma.actualPayment`: Exposes CRUD operations for the **ActualPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActualPayments
    * const actualPayments = await prisma.actualPayment.findMany()
    * ```
    */
  get actualPayment(): Prisma.ActualPaymentDelegate<ExtArgs>;

  /**
   * `prisma.object`: Exposes CRUD operations for the **Object** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Objects
    * const objects = await prisma.object.findMany()
    * ```
    */
  get object(): Prisma.ObjectDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.agency`: Exposes CRUD operations for the **Agency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agencies
    * const agencies = await prisma.agency.findMany()
    * ```
    */
  get agency(): Prisma.AgencyDelegate<ExtArgs>;

  /**
   * `prisma.agencyContract`: Exposes CRUD operations for the **AgencyContract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyContracts
    * const agencyContracts = await prisma.agencyContract.findMany()
    * ```
    */
  get agencyContract(): Prisma.AgencyContractDelegate<ExtArgs>;

  /**
   * `prisma.agencyContractSignatory`: Exposes CRUD operations for the **AgencyContractSignatory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyContractSignatories
    * const agencyContractSignatories = await prisma.agencyContractSignatory.findMany()
    * ```
    */
  get agencyContractSignatory(): Prisma.AgencyContractSignatoryDelegate<ExtArgs>;

  /**
   * `prisma.realEstateAgencyContractProperties`: Exposes CRUD operations for the **RealEstateAgencyContractProperties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RealEstateAgencyContractProperties
    * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.findMany()
    * ```
    */
  get realEstateAgencyContractProperties(): Prisma.RealEstateAgencyContractPropertiesDelegate<ExtArgs>;

  /**
   * `prisma.mIPAgencyContractProperties`: Exposes CRUD operations for the **MIPAgencyContractProperties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MIPAgencyContractProperties
    * const mIPAgencyContractProperties = await prisma.mIPAgencyContractProperties.findMany()
    * ```
    */
  get mIPAgencyContractProperties(): Prisma.MIPAgencyContractPropertiesDelegate<ExtArgs>;

  /**
   * `prisma.agencyContractCommission`: Exposes CRUD operations for the **AgencyContractCommission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyContractCommissions
    * const agencyContractCommissions = await prisma.agencyContractCommission.findMany()
    * ```
    */
  get agencyContractCommission(): Prisma.AgencyContractCommissionDelegate<ExtArgs>;

  /**
   * `prisma.realEstateAgent`: Exposes CRUD operations for the **RealEstateAgent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RealEstateAgents
    * const realEstateAgents = await prisma.realEstateAgent.findMany()
    * ```
    */
  get realEstateAgent(): Prisma.RealEstateAgentDelegate<ExtArgs>;

  /**
   * `prisma.agencyToRealEstateAgent`: Exposes CRUD operations for the **AgencyToRealEstateAgent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyToRealEstateAgents
    * const agencyToRealEstateAgents = await prisma.agencyToRealEstateAgent.findMany()
    * ```
    */
  get agencyToRealEstateAgent(): Prisma.AgencyToRealEstateAgentDelegate<ExtArgs>;

  /**
   * `prisma.entity`: Exposes CRUD operations for the **Entity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entities
    * const entities = await prisma.entity.findMany()
    * ```
    */
  get entity(): Prisma.EntityDelegate<ExtArgs>;

  /**
   * `prisma.entityForbiddenWebsite`: Exposes CRUD operations for the **EntityForbiddenWebsite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EntityForbiddenWebsites
    * const entityForbiddenWebsites = await prisma.entityForbiddenWebsite.findMany()
    * ```
    */
  get entityForbiddenWebsite(): Prisma.EntityForbiddenWebsiteDelegate<ExtArgs>;

  /**
   * `prisma.entityForbiddenBrand`: Exposes CRUD operations for the **EntityForbiddenBrand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EntityForbiddenBrands
    * const entityForbiddenBrands = await prisma.entityForbiddenBrand.findMany()
    * ```
    */
  get entityForbiddenBrand(): Prisma.EntityForbiddenBrandDelegate<ExtArgs>;

  /**
   * `prisma.bank`: Exposes CRUD operations for the **Bank** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banks
    * const banks = await prisma.bank.findMany()
    * ```
    */
  get bank(): Prisma.BankDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.15.0
   * Query Engine version: 12e25d8d06f6ea5a0252864dd9a03b1bb51f3022
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Client: 'Client',
    ClientIndividualProperties: 'ClientIndividualProperties',
    ClientIndividualMinorProperties: 'ClientIndividualMinorProperties',
    ClientEntityProperties: 'ClientEntityProperties',
    ClientToClientIndividualMinorProperties: 'ClientToClientIndividualMinorProperties',
    ClientPassport: 'ClientPassport',
    ClientContract: 'ClientContract',
    DDUClientContractProperties: 'DDUClientContractProperties',
    ClientContractToAgencyContract: 'ClientContractToAgencyContract',
    ClientContractToClient: 'ClientContractToClient',
    ScheduledPayment: 'ScheduledPayment',
    ActualPayment: 'ActualPayment',
    Object: 'Object',
    Product: 'Product',
    Agency: 'Agency',
    AgencyContract: 'AgencyContract',
    AgencyContractSignatory: 'AgencyContractSignatory',
    RealEstateAgencyContractProperties: 'RealEstateAgencyContractProperties',
    MIPAgencyContractProperties: 'MIPAgencyContractProperties',
    AgencyContractCommission: 'AgencyContractCommission',
    RealEstateAgent: 'RealEstateAgent',
    AgencyToRealEstateAgent: 'AgencyToRealEstateAgent',
    Entity: 'Entity',
    EntityForbiddenWebsite: 'EntityForbiddenWebsite',
    EntityForbiddenBrand: 'EntityForbiddenBrand',
    Bank: 'Bank'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'client' | 'clientIndividualProperties' | 'clientIndividualMinorProperties' | 'clientEntityProperties' | 'clientToClientIndividualMinorProperties' | 'clientPassport' | 'clientContract' | 'dDUClientContractProperties' | 'clientContractToAgencyContract' | 'clientContractToClient' | 'scheduledPayment' | 'actualPayment' | 'object' | 'product' | 'agency' | 'agencyContract' | 'agencyContractSignatory' | 'realEstateAgencyContractProperties' | 'mIPAgencyContractProperties' | 'agencyContractCommission' | 'realEstateAgent' | 'agencyToRealEstateAgent' | 'entity' | 'entityForbiddenWebsite' | 'entityForbiddenBrand' | 'bank'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      ClientIndividualProperties: {
        payload: Prisma.$ClientIndividualPropertiesPayload<ExtArgs>
        fields: Prisma.ClientIndividualPropertiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientIndividualPropertiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualPropertiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientIndividualPropertiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualPropertiesPayload>
          }
          findFirst: {
            args: Prisma.ClientIndividualPropertiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualPropertiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientIndividualPropertiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualPropertiesPayload>
          }
          findMany: {
            args: Prisma.ClientIndividualPropertiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualPropertiesPayload>[]
          }
          create: {
            args: Prisma.ClientIndividualPropertiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualPropertiesPayload>
          }
          createMany: {
            args: Prisma.ClientIndividualPropertiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientIndividualPropertiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualPropertiesPayload>
          }
          update: {
            args: Prisma.ClientIndividualPropertiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualPropertiesPayload>
          }
          deleteMany: {
            args: Prisma.ClientIndividualPropertiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientIndividualPropertiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientIndividualPropertiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualPropertiesPayload>
          }
          aggregate: {
            args: Prisma.ClientIndividualPropertiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClientIndividualProperties>
          }
          groupBy: {
            args: Prisma.ClientIndividualPropertiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientIndividualPropertiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientIndividualPropertiesCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientIndividualPropertiesCountAggregateOutputType> | number
          }
        }
      }
      ClientIndividualMinorProperties: {
        payload: Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>
        fields: Prisma.ClientIndividualMinorPropertiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientIndividualMinorPropertiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualMinorPropertiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientIndividualMinorPropertiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualMinorPropertiesPayload>
          }
          findFirst: {
            args: Prisma.ClientIndividualMinorPropertiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualMinorPropertiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientIndividualMinorPropertiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualMinorPropertiesPayload>
          }
          findMany: {
            args: Prisma.ClientIndividualMinorPropertiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualMinorPropertiesPayload>[]
          }
          create: {
            args: Prisma.ClientIndividualMinorPropertiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualMinorPropertiesPayload>
          }
          createMany: {
            args: Prisma.ClientIndividualMinorPropertiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientIndividualMinorPropertiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualMinorPropertiesPayload>
          }
          update: {
            args: Prisma.ClientIndividualMinorPropertiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualMinorPropertiesPayload>
          }
          deleteMany: {
            args: Prisma.ClientIndividualMinorPropertiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientIndividualMinorPropertiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientIndividualMinorPropertiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualMinorPropertiesPayload>
          }
          aggregate: {
            args: Prisma.ClientIndividualMinorPropertiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClientIndividualMinorProperties>
          }
          groupBy: {
            args: Prisma.ClientIndividualMinorPropertiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientIndividualMinorPropertiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientIndividualMinorPropertiesCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientIndividualMinorPropertiesCountAggregateOutputType> | number
          }
        }
      }
      ClientEntityProperties: {
        payload: Prisma.$ClientEntityPropertiesPayload<ExtArgs>
        fields: Prisma.ClientEntityPropertiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientEntityPropertiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPropertiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientEntityPropertiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPropertiesPayload>
          }
          findFirst: {
            args: Prisma.ClientEntityPropertiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPropertiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientEntityPropertiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPropertiesPayload>
          }
          findMany: {
            args: Prisma.ClientEntityPropertiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPropertiesPayload>[]
          }
          create: {
            args: Prisma.ClientEntityPropertiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPropertiesPayload>
          }
          createMany: {
            args: Prisma.ClientEntityPropertiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientEntityPropertiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPropertiesPayload>
          }
          update: {
            args: Prisma.ClientEntityPropertiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPropertiesPayload>
          }
          deleteMany: {
            args: Prisma.ClientEntityPropertiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientEntityPropertiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientEntityPropertiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPropertiesPayload>
          }
          aggregate: {
            args: Prisma.ClientEntityPropertiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClientEntityProperties>
          }
          groupBy: {
            args: Prisma.ClientEntityPropertiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientEntityPropertiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientEntityPropertiesCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientEntityPropertiesCountAggregateOutputType> | number
          }
        }
      }
      ClientToClientIndividualMinorProperties: {
        payload: Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>
        fields: Prisma.ClientToClientIndividualMinorPropertiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientToClientIndividualMinorPropertiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientToClientIndividualMinorPropertiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload>
          }
          findFirst: {
            args: Prisma.ClientToClientIndividualMinorPropertiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientToClientIndividualMinorPropertiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload>
          }
          findMany: {
            args: Prisma.ClientToClientIndividualMinorPropertiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload>[]
          }
          create: {
            args: Prisma.ClientToClientIndividualMinorPropertiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload>
          }
          createMany: {
            args: Prisma.ClientToClientIndividualMinorPropertiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientToClientIndividualMinorPropertiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload>
          }
          update: {
            args: Prisma.ClientToClientIndividualMinorPropertiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload>
          }
          deleteMany: {
            args: Prisma.ClientToClientIndividualMinorPropertiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientToClientIndividualMinorPropertiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientToClientIndividualMinorPropertiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload>
          }
          aggregate: {
            args: Prisma.ClientToClientIndividualMinorPropertiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClientToClientIndividualMinorProperties>
          }
          groupBy: {
            args: Prisma.ClientToClientIndividualMinorPropertiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientToClientIndividualMinorPropertiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientToClientIndividualMinorPropertiesCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientToClientIndividualMinorPropertiesCountAggregateOutputType> | number
          }
        }
      }
      ClientPassport: {
        payload: Prisma.$ClientPassportPayload<ExtArgs>
        fields: Prisma.ClientPassportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientPassportFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPassportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientPassportFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPassportPayload>
          }
          findFirst: {
            args: Prisma.ClientPassportFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPassportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientPassportFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPassportPayload>
          }
          findMany: {
            args: Prisma.ClientPassportFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPassportPayload>[]
          }
          create: {
            args: Prisma.ClientPassportCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPassportPayload>
          }
          createMany: {
            args: Prisma.ClientPassportCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientPassportDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPassportPayload>
          }
          update: {
            args: Prisma.ClientPassportUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPassportPayload>
          }
          deleteMany: {
            args: Prisma.ClientPassportDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientPassportUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientPassportUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPassportPayload>
          }
          aggregate: {
            args: Prisma.ClientPassportAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClientPassport>
          }
          groupBy: {
            args: Prisma.ClientPassportGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientPassportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientPassportCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientPassportCountAggregateOutputType> | number
          }
        }
      }
      ClientContract: {
        payload: Prisma.$ClientContractPayload<ExtArgs>
        fields: Prisma.ClientContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientContractFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientContractFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractPayload>
          }
          findFirst: {
            args: Prisma.ClientContractFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientContractFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractPayload>
          }
          findMany: {
            args: Prisma.ClientContractFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractPayload>[]
          }
          create: {
            args: Prisma.ClientContractCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractPayload>
          }
          createMany: {
            args: Prisma.ClientContractCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientContractDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractPayload>
          }
          update: {
            args: Prisma.ClientContractUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractPayload>
          }
          deleteMany: {
            args: Prisma.ClientContractDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientContractUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientContractUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractPayload>
          }
          aggregate: {
            args: Prisma.ClientContractAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClientContract>
          }
          groupBy: {
            args: Prisma.ClientContractGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientContractCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientContractCountAggregateOutputType> | number
          }
        }
      }
      DDUClientContractProperties: {
        payload: Prisma.$DDUClientContractPropertiesPayload<ExtArgs>
        fields: Prisma.DDUClientContractPropertiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DDUClientContractPropertiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DDUClientContractPropertiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DDUClientContractPropertiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DDUClientContractPropertiesPayload>
          }
          findFirst: {
            args: Prisma.DDUClientContractPropertiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DDUClientContractPropertiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DDUClientContractPropertiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DDUClientContractPropertiesPayload>
          }
          findMany: {
            args: Prisma.DDUClientContractPropertiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DDUClientContractPropertiesPayload>[]
          }
          create: {
            args: Prisma.DDUClientContractPropertiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DDUClientContractPropertiesPayload>
          }
          createMany: {
            args: Prisma.DDUClientContractPropertiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DDUClientContractPropertiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DDUClientContractPropertiesPayload>
          }
          update: {
            args: Prisma.DDUClientContractPropertiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DDUClientContractPropertiesPayload>
          }
          deleteMany: {
            args: Prisma.DDUClientContractPropertiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DDUClientContractPropertiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DDUClientContractPropertiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DDUClientContractPropertiesPayload>
          }
          aggregate: {
            args: Prisma.DDUClientContractPropertiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDDUClientContractProperties>
          }
          groupBy: {
            args: Prisma.DDUClientContractPropertiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DDUClientContractPropertiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.DDUClientContractPropertiesCountArgs<ExtArgs>,
            result: $Utils.Optional<DDUClientContractPropertiesCountAggregateOutputType> | number
          }
        }
      }
      ClientContractToAgencyContract: {
        payload: Prisma.$ClientContractToAgencyContractPayload<ExtArgs>
        fields: Prisma.ClientContractToAgencyContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientContractToAgencyContractFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToAgencyContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientContractToAgencyContractFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToAgencyContractPayload>
          }
          findFirst: {
            args: Prisma.ClientContractToAgencyContractFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToAgencyContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientContractToAgencyContractFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToAgencyContractPayload>
          }
          findMany: {
            args: Prisma.ClientContractToAgencyContractFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToAgencyContractPayload>[]
          }
          create: {
            args: Prisma.ClientContractToAgencyContractCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToAgencyContractPayload>
          }
          createMany: {
            args: Prisma.ClientContractToAgencyContractCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientContractToAgencyContractDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToAgencyContractPayload>
          }
          update: {
            args: Prisma.ClientContractToAgencyContractUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToAgencyContractPayload>
          }
          deleteMany: {
            args: Prisma.ClientContractToAgencyContractDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientContractToAgencyContractUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientContractToAgencyContractUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToAgencyContractPayload>
          }
          aggregate: {
            args: Prisma.ClientContractToAgencyContractAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClientContractToAgencyContract>
          }
          groupBy: {
            args: Prisma.ClientContractToAgencyContractGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientContractToAgencyContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientContractToAgencyContractCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientContractToAgencyContractCountAggregateOutputType> | number
          }
        }
      }
      ClientContractToClient: {
        payload: Prisma.$ClientContractToClientPayload<ExtArgs>
        fields: Prisma.ClientContractToClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientContractToClientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientContractToClientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToClientPayload>
          }
          findFirst: {
            args: Prisma.ClientContractToClientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientContractToClientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToClientPayload>
          }
          findMany: {
            args: Prisma.ClientContractToClientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToClientPayload>[]
          }
          create: {
            args: Prisma.ClientContractToClientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToClientPayload>
          }
          createMany: {
            args: Prisma.ClientContractToClientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientContractToClientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToClientPayload>
          }
          update: {
            args: Prisma.ClientContractToClientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientContractToClientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientContractToClientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientContractToClientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToClientPayload>
          }
          aggregate: {
            args: Prisma.ClientContractToClientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClientContractToClient>
          }
          groupBy: {
            args: Prisma.ClientContractToClientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientContractToClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientContractToClientCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientContractToClientCountAggregateOutputType> | number
          }
        }
      }
      ScheduledPayment: {
        payload: Prisma.$ScheduledPaymentPayload<ExtArgs>
        fields: Prisma.ScheduledPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduledPaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ScheduledPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduledPaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ScheduledPaymentPayload>
          }
          findFirst: {
            args: Prisma.ScheduledPaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ScheduledPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduledPaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ScheduledPaymentPayload>
          }
          findMany: {
            args: Prisma.ScheduledPaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ScheduledPaymentPayload>[]
          }
          create: {
            args: Prisma.ScheduledPaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ScheduledPaymentPayload>
          }
          createMany: {
            args: Prisma.ScheduledPaymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ScheduledPaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ScheduledPaymentPayload>
          }
          update: {
            args: Prisma.ScheduledPaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ScheduledPaymentPayload>
          }
          deleteMany: {
            args: Prisma.ScheduledPaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduledPaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ScheduledPaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ScheduledPaymentPayload>
          }
          aggregate: {
            args: Prisma.ScheduledPaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateScheduledPayment>
          }
          groupBy: {
            args: Prisma.ScheduledPaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ScheduledPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduledPaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<ScheduledPaymentCountAggregateOutputType> | number
          }
        }
      }
      ActualPayment: {
        payload: Prisma.$ActualPaymentPayload<ExtArgs>
        fields: Prisma.ActualPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActualPaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActualPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActualPaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActualPaymentPayload>
          }
          findFirst: {
            args: Prisma.ActualPaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActualPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActualPaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActualPaymentPayload>
          }
          findMany: {
            args: Prisma.ActualPaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActualPaymentPayload>[]
          }
          create: {
            args: Prisma.ActualPaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActualPaymentPayload>
          }
          createMany: {
            args: Prisma.ActualPaymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ActualPaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActualPaymentPayload>
          }
          update: {
            args: Prisma.ActualPaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActualPaymentPayload>
          }
          deleteMany: {
            args: Prisma.ActualPaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ActualPaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ActualPaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActualPaymentPayload>
          }
          aggregate: {
            args: Prisma.ActualPaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateActualPayment>
          }
          groupBy: {
            args: Prisma.ActualPaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ActualPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActualPaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<ActualPaymentCountAggregateOutputType> | number
          }
        }
      }
      Object: {
        payload: Prisma.$ObjectPayload<ExtArgs>
        fields: Prisma.ObjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObjectFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObjectFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          findFirst: {
            args: Prisma.ObjectFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObjectFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          findMany: {
            args: Prisma.ObjectFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>[]
          }
          create: {
            args: Prisma.ObjectCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          createMany: {
            args: Prisma.ObjectCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ObjectDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          update: {
            args: Prisma.ObjectUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          deleteMany: {
            args: Prisma.ObjectDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ObjectUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ObjectUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          aggregate: {
            args: Prisma.ObjectAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateObject>
          }
          groupBy: {
            args: Prisma.ObjectGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ObjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObjectCountArgs<ExtArgs>,
            result: $Utils.Optional<ObjectCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Agency: {
        payload: Prisma.$AgencyPayload<ExtArgs>
        fields: Prisma.AgencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findFirst: {
            args: Prisma.AgencyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findMany: {
            args: Prisma.AgencyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          create: {
            args: Prisma.AgencyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          createMany: {
            args: Prisma.AgencyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AgencyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          update: {
            args: Prisma.AgencyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          deleteMany: {
            args: Prisma.AgencyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AgencyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          aggregate: {
            args: Prisma.AgencyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgency>
          }
          groupBy: {
            args: Prisma.AgencyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyCountArgs<ExtArgs>,
            result: $Utils.Optional<AgencyCountAggregateOutputType> | number
          }
        }
      }
      AgencyContract: {
        payload: Prisma.$AgencyContractPayload<ExtArgs>
        fields: Prisma.AgencyContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyContractFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyContractFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractPayload>
          }
          findFirst: {
            args: Prisma.AgencyContractFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyContractFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractPayload>
          }
          findMany: {
            args: Prisma.AgencyContractFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractPayload>[]
          }
          create: {
            args: Prisma.AgencyContractCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractPayload>
          }
          createMany: {
            args: Prisma.AgencyContractCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AgencyContractDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractPayload>
          }
          update: {
            args: Prisma.AgencyContractUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractPayload>
          }
          deleteMany: {
            args: Prisma.AgencyContractDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyContractUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AgencyContractUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractPayload>
          }
          aggregate: {
            args: Prisma.AgencyContractAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgencyContract>
          }
          groupBy: {
            args: Prisma.AgencyContractGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgencyContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyContractCountArgs<ExtArgs>,
            result: $Utils.Optional<AgencyContractCountAggregateOutputType> | number
          }
        }
      }
      AgencyContractSignatory: {
        payload: Prisma.$AgencyContractSignatoryPayload<ExtArgs>
        fields: Prisma.AgencyContractSignatoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyContractSignatoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractSignatoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyContractSignatoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractSignatoryPayload>
          }
          findFirst: {
            args: Prisma.AgencyContractSignatoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractSignatoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyContractSignatoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractSignatoryPayload>
          }
          findMany: {
            args: Prisma.AgencyContractSignatoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractSignatoryPayload>[]
          }
          create: {
            args: Prisma.AgencyContractSignatoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractSignatoryPayload>
          }
          createMany: {
            args: Prisma.AgencyContractSignatoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AgencyContractSignatoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractSignatoryPayload>
          }
          update: {
            args: Prisma.AgencyContractSignatoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractSignatoryPayload>
          }
          deleteMany: {
            args: Prisma.AgencyContractSignatoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyContractSignatoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AgencyContractSignatoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractSignatoryPayload>
          }
          aggregate: {
            args: Prisma.AgencyContractSignatoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgencyContractSignatory>
          }
          groupBy: {
            args: Prisma.AgencyContractSignatoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgencyContractSignatoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyContractSignatoryCountArgs<ExtArgs>,
            result: $Utils.Optional<AgencyContractSignatoryCountAggregateOutputType> | number
          }
        }
      }
      RealEstateAgencyContractProperties: {
        payload: Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>
        fields: Prisma.RealEstateAgencyContractPropertiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RealEstateAgencyContractPropertiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyContractPropertiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RealEstateAgencyContractPropertiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyContractPropertiesPayload>
          }
          findFirst: {
            args: Prisma.RealEstateAgencyContractPropertiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyContractPropertiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RealEstateAgencyContractPropertiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyContractPropertiesPayload>
          }
          findMany: {
            args: Prisma.RealEstateAgencyContractPropertiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyContractPropertiesPayload>[]
          }
          create: {
            args: Prisma.RealEstateAgencyContractPropertiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyContractPropertiesPayload>
          }
          createMany: {
            args: Prisma.RealEstateAgencyContractPropertiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RealEstateAgencyContractPropertiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyContractPropertiesPayload>
          }
          update: {
            args: Prisma.RealEstateAgencyContractPropertiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyContractPropertiesPayload>
          }
          deleteMany: {
            args: Prisma.RealEstateAgencyContractPropertiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RealEstateAgencyContractPropertiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RealEstateAgencyContractPropertiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyContractPropertiesPayload>
          }
          aggregate: {
            args: Prisma.RealEstateAgencyContractPropertiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRealEstateAgencyContractProperties>
          }
          groupBy: {
            args: Prisma.RealEstateAgencyContractPropertiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RealEstateAgencyContractPropertiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RealEstateAgencyContractPropertiesCountArgs<ExtArgs>,
            result: $Utils.Optional<RealEstateAgencyContractPropertiesCountAggregateOutputType> | number
          }
        }
      }
      MIPAgencyContractProperties: {
        payload: Prisma.$MIPAgencyContractPropertiesPayload<ExtArgs>
        fields: Prisma.MIPAgencyContractPropertiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MIPAgencyContractPropertiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MIPAgencyContractPropertiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MIPAgencyContractPropertiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MIPAgencyContractPropertiesPayload>
          }
          findFirst: {
            args: Prisma.MIPAgencyContractPropertiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MIPAgencyContractPropertiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MIPAgencyContractPropertiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MIPAgencyContractPropertiesPayload>
          }
          findMany: {
            args: Prisma.MIPAgencyContractPropertiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MIPAgencyContractPropertiesPayload>[]
          }
          create: {
            args: Prisma.MIPAgencyContractPropertiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MIPAgencyContractPropertiesPayload>
          }
          createMany: {
            args: Prisma.MIPAgencyContractPropertiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MIPAgencyContractPropertiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MIPAgencyContractPropertiesPayload>
          }
          update: {
            args: Prisma.MIPAgencyContractPropertiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MIPAgencyContractPropertiesPayload>
          }
          deleteMany: {
            args: Prisma.MIPAgencyContractPropertiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MIPAgencyContractPropertiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MIPAgencyContractPropertiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MIPAgencyContractPropertiesPayload>
          }
          aggregate: {
            args: Prisma.MIPAgencyContractPropertiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMIPAgencyContractProperties>
          }
          groupBy: {
            args: Prisma.MIPAgencyContractPropertiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MIPAgencyContractPropertiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.MIPAgencyContractPropertiesCountArgs<ExtArgs>,
            result: $Utils.Optional<MIPAgencyContractPropertiesCountAggregateOutputType> | number
          }
        }
      }
      AgencyContractCommission: {
        payload: Prisma.$AgencyContractCommissionPayload<ExtArgs>
        fields: Prisma.AgencyContractCommissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyContractCommissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractCommissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyContractCommissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractCommissionPayload>
          }
          findFirst: {
            args: Prisma.AgencyContractCommissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractCommissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyContractCommissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractCommissionPayload>
          }
          findMany: {
            args: Prisma.AgencyContractCommissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractCommissionPayload>[]
          }
          create: {
            args: Prisma.AgencyContractCommissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractCommissionPayload>
          }
          createMany: {
            args: Prisma.AgencyContractCommissionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AgencyContractCommissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractCommissionPayload>
          }
          update: {
            args: Prisma.AgencyContractCommissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractCommissionPayload>
          }
          deleteMany: {
            args: Prisma.AgencyContractCommissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyContractCommissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AgencyContractCommissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractCommissionPayload>
          }
          aggregate: {
            args: Prisma.AgencyContractCommissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgencyContractCommission>
          }
          groupBy: {
            args: Prisma.AgencyContractCommissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgencyContractCommissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyContractCommissionCountArgs<ExtArgs>,
            result: $Utils.Optional<AgencyContractCommissionCountAggregateOutputType> | number
          }
        }
      }
      RealEstateAgent: {
        payload: Prisma.$RealEstateAgentPayload<ExtArgs>
        fields: Prisma.RealEstateAgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RealEstateAgentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RealEstateAgentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgentPayload>
          }
          findFirst: {
            args: Prisma.RealEstateAgentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RealEstateAgentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgentPayload>
          }
          findMany: {
            args: Prisma.RealEstateAgentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgentPayload>[]
          }
          create: {
            args: Prisma.RealEstateAgentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgentPayload>
          }
          createMany: {
            args: Prisma.RealEstateAgentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RealEstateAgentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgentPayload>
          }
          update: {
            args: Prisma.RealEstateAgentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgentPayload>
          }
          deleteMany: {
            args: Prisma.RealEstateAgentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RealEstateAgentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RealEstateAgentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgentPayload>
          }
          aggregate: {
            args: Prisma.RealEstateAgentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRealEstateAgent>
          }
          groupBy: {
            args: Prisma.RealEstateAgentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RealEstateAgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RealEstateAgentCountArgs<ExtArgs>,
            result: $Utils.Optional<RealEstateAgentCountAggregateOutputType> | number
          }
        }
      }
      AgencyToRealEstateAgent: {
        payload: Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>
        fields: Prisma.AgencyToRealEstateAgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyToRealEstateAgentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyToRealEstateAgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyToRealEstateAgentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyToRealEstateAgentPayload>
          }
          findFirst: {
            args: Prisma.AgencyToRealEstateAgentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyToRealEstateAgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyToRealEstateAgentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyToRealEstateAgentPayload>
          }
          findMany: {
            args: Prisma.AgencyToRealEstateAgentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyToRealEstateAgentPayload>[]
          }
          create: {
            args: Prisma.AgencyToRealEstateAgentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyToRealEstateAgentPayload>
          }
          createMany: {
            args: Prisma.AgencyToRealEstateAgentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AgencyToRealEstateAgentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyToRealEstateAgentPayload>
          }
          update: {
            args: Prisma.AgencyToRealEstateAgentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyToRealEstateAgentPayload>
          }
          deleteMany: {
            args: Prisma.AgencyToRealEstateAgentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyToRealEstateAgentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AgencyToRealEstateAgentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyToRealEstateAgentPayload>
          }
          aggregate: {
            args: Prisma.AgencyToRealEstateAgentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgencyToRealEstateAgent>
          }
          groupBy: {
            args: Prisma.AgencyToRealEstateAgentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgencyToRealEstateAgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyToRealEstateAgentCountArgs<ExtArgs>,
            result: $Utils.Optional<AgencyToRealEstateAgentCountAggregateOutputType> | number
          }
        }
      }
      Entity: {
        payload: Prisma.$EntityPayload<ExtArgs>
        fields: Prisma.EntityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>
          }
          findFirst: {
            args: Prisma.EntityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>
          }
          findMany: {
            args: Prisma.EntityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>[]
          }
          create: {
            args: Prisma.EntityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>
          }
          createMany: {
            args: Prisma.EntityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EntityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>
          }
          update: {
            args: Prisma.EntityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>
          }
          deleteMany: {
            args: Prisma.EntityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EntityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EntityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>
          }
          aggregate: {
            args: Prisma.EntityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEntity>
          }
          groupBy: {
            args: Prisma.EntityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EntityGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntityCountArgs<ExtArgs>,
            result: $Utils.Optional<EntityCountAggregateOutputType> | number
          }
        }
      }
      EntityForbiddenWebsite: {
        payload: Prisma.$EntityForbiddenWebsitePayload<ExtArgs>
        fields: Prisma.EntityForbiddenWebsiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntityForbiddenWebsiteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenWebsitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntityForbiddenWebsiteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenWebsitePayload>
          }
          findFirst: {
            args: Prisma.EntityForbiddenWebsiteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenWebsitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntityForbiddenWebsiteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenWebsitePayload>
          }
          findMany: {
            args: Prisma.EntityForbiddenWebsiteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenWebsitePayload>[]
          }
          create: {
            args: Prisma.EntityForbiddenWebsiteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenWebsitePayload>
          }
          createMany: {
            args: Prisma.EntityForbiddenWebsiteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EntityForbiddenWebsiteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenWebsitePayload>
          }
          update: {
            args: Prisma.EntityForbiddenWebsiteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenWebsitePayload>
          }
          deleteMany: {
            args: Prisma.EntityForbiddenWebsiteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EntityForbiddenWebsiteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EntityForbiddenWebsiteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenWebsitePayload>
          }
          aggregate: {
            args: Prisma.EntityForbiddenWebsiteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEntityForbiddenWebsite>
          }
          groupBy: {
            args: Prisma.EntityForbiddenWebsiteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EntityForbiddenWebsiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntityForbiddenWebsiteCountArgs<ExtArgs>,
            result: $Utils.Optional<EntityForbiddenWebsiteCountAggregateOutputType> | number
          }
        }
      }
      EntityForbiddenBrand: {
        payload: Prisma.$EntityForbiddenBrandPayload<ExtArgs>
        fields: Prisma.EntityForbiddenBrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntityForbiddenBrandFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenBrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntityForbiddenBrandFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenBrandPayload>
          }
          findFirst: {
            args: Prisma.EntityForbiddenBrandFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenBrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntityForbiddenBrandFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenBrandPayload>
          }
          findMany: {
            args: Prisma.EntityForbiddenBrandFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenBrandPayload>[]
          }
          create: {
            args: Prisma.EntityForbiddenBrandCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenBrandPayload>
          }
          createMany: {
            args: Prisma.EntityForbiddenBrandCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EntityForbiddenBrandDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenBrandPayload>
          }
          update: {
            args: Prisma.EntityForbiddenBrandUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenBrandPayload>
          }
          deleteMany: {
            args: Prisma.EntityForbiddenBrandDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EntityForbiddenBrandUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EntityForbiddenBrandUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenBrandPayload>
          }
          aggregate: {
            args: Prisma.EntityForbiddenBrandAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEntityForbiddenBrand>
          }
          groupBy: {
            args: Prisma.EntityForbiddenBrandGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EntityForbiddenBrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntityForbiddenBrandCountArgs<ExtArgs>,
            result: $Utils.Optional<EntityForbiddenBrandCountAggregateOutputType> | number
          }
        }
      }
      Bank: {
        payload: Prisma.$BankPayload<ExtArgs>
        fields: Prisma.BankFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankPayload>
          }
          findFirst: {
            args: Prisma.BankFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankPayload>
          }
          findMany: {
            args: Prisma.BankFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankPayload>[]
          }
          create: {
            args: Prisma.BankCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankPayload>
          }
          createMany: {
            args: Prisma.BankCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BankDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankPayload>
          }
          update: {
            args: Prisma.BankUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankPayload>
          }
          deleteMany: {
            args: Prisma.BankDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BankUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BankUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankPayload>
          }
          aggregate: {
            args: Prisma.BankAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBank>
          }
          groupBy: {
            args: Prisma.BankGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BankGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankCountArgs<ExtArgs>,
            result: $Utils.Optional<BankCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    client_contracts: number
    agency_contracts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_contracts?: boolean | UserCountOutputTypeCountClient_contractsArgs
    agency_contracts?: boolean | UserCountOutputTypeCountAgency_contractsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClient_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAgency_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyContractWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    client_contracts: number
    clients_to_client_individual_minor_properties: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_contracts?: boolean | ClientCountOutputTypeCountClient_contractsArgs
    clients_to_client_individual_minor_properties?: boolean | ClientCountOutputTypeCountClients_to_client_individual_minor_propertiesArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountClient_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractToClientWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountClients_to_client_individual_minor_propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientToClientIndividualMinorPropertiesWhereInput
  }


  /**
   * Count Type ClientIndividualMinorPropertiesCountOutputType
   */

  export type ClientIndividualMinorPropertiesCountOutputType = {
    representatives: number
  }

  export type ClientIndividualMinorPropertiesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    representatives?: boolean | ClientIndividualMinorPropertiesCountOutputTypeCountRepresentativesArgs
  }

  // Custom InputTypes
  /**
   * ClientIndividualMinorPropertiesCountOutputType without action
   */
  export type ClientIndividualMinorPropertiesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorPropertiesCountOutputType
     */
    select?: ClientIndividualMinorPropertiesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientIndividualMinorPropertiesCountOutputType without action
   */
  export type ClientIndividualMinorPropertiesCountOutputTypeCountRepresentativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientToClientIndividualMinorPropertiesWhereInput
  }


  /**
   * Count Type ClientContractCountOutputType
   */

  export type ClientContractCountOutputType = {
    clients: number
    agency_contracts: number
    scheduled_payments: number
    actual_payment: number
  }

  export type ClientContractCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | ClientContractCountOutputTypeCountClientsArgs
    agency_contracts?: boolean | ClientContractCountOutputTypeCountAgency_contractsArgs
    scheduled_payments?: boolean | ClientContractCountOutputTypeCountScheduled_paymentsArgs
    actual_payment?: boolean | ClientContractCountOutputTypeCountActual_paymentArgs
  }

  // Custom InputTypes
  /**
   * ClientContractCountOutputType without action
   */
  export type ClientContractCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractCountOutputType
     */
    select?: ClientContractCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientContractCountOutputType without action
   */
  export type ClientContractCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractToClientWhereInput
  }

  /**
   * ClientContractCountOutputType without action
   */
  export type ClientContractCountOutputTypeCountAgency_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractToAgencyContractWhereInput
  }

  /**
   * ClientContractCountOutputType without action
   */
  export type ClientContractCountOutputTypeCountScheduled_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledPaymentWhereInput
  }

  /**
   * ClientContractCountOutputType without action
   */
  export type ClientContractCountOutputTypeCountActual_paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActualPaymentWhereInput
  }


  /**
   * Count Type ObjectCountOutputType
   */

  export type ObjectCountOutputType = {
    products: number
    client_contracts: number
    agency_contracts: number
  }

  export type ObjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ObjectCountOutputTypeCountProductsArgs
    client_contracts?: boolean | ObjectCountOutputTypeCountClient_contractsArgs
    agency_contracts?: boolean | ObjectCountOutputTypeCountAgency_contractsArgs
  }

  // Custom InputTypes
  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectCountOutputType
     */
    select?: ObjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeCountClient_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractWhereInput
  }

  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeCountAgency_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyContractWhereInput
  }


  /**
   * Count Type AgencyCountOutputType
   */

  export type AgencyCountOutputType = {
    agency_contracts: number
    real_estate_agents: number
    agency_contract_signatory: number
  }

  export type AgencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency_contracts?: boolean | AgencyCountOutputTypeCountAgency_contractsArgs
    real_estate_agents?: boolean | AgencyCountOutputTypeCountReal_estate_agentsArgs
    agency_contract_signatory?: boolean | AgencyCountOutputTypeCountAgency_contract_signatoryArgs
  }

  // Custom InputTypes
  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyCountOutputType
     */
    select?: AgencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountAgency_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyContractWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountReal_estate_agentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyToRealEstateAgentWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountAgency_contract_signatoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyContractSignatoryWhereInput
  }


  /**
   * Count Type AgencyContractCountOutputType
   */

  export type AgencyContractCountOutputType = {
    client_contracts: number
  }

  export type AgencyContractCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_contracts?: boolean | AgencyContractCountOutputTypeCountClient_contractsArgs
  }

  // Custom InputTypes
  /**
   * AgencyContractCountOutputType without action
   */
  export type AgencyContractCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCountOutputType
     */
    select?: AgencyContractCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgencyContractCountOutputType without action
   */
  export type AgencyContractCountOutputTypeCountClient_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractToAgencyContractWhereInput
  }


  /**
   * Count Type AgencyContractSignatoryCountOutputType
   */

  export type AgencyContractSignatoryCountOutputType = {
    agency_contract: number
  }

  export type AgencyContractSignatoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency_contract?: boolean | AgencyContractSignatoryCountOutputTypeCountAgency_contractArgs
  }

  // Custom InputTypes
  /**
   * AgencyContractSignatoryCountOutputType without action
   */
  export type AgencyContractSignatoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatoryCountOutputType
     */
    select?: AgencyContractSignatoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgencyContractSignatoryCountOutputType without action
   */
  export type AgencyContractSignatoryCountOutputTypeCountAgency_contractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyContractWhereInput
  }


  /**
   * Count Type RealEstateAgentCountOutputType
   */

  export type RealEstateAgentCountOutputType = {
    client_contracts: number
    agencies: number
  }

  export type RealEstateAgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_contracts?: boolean | RealEstateAgentCountOutputTypeCountClient_contractsArgs
    agencies?: boolean | RealEstateAgentCountOutputTypeCountAgenciesArgs
  }

  // Custom InputTypes
  /**
   * RealEstateAgentCountOutputType without action
   */
  export type RealEstateAgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgentCountOutputType
     */
    select?: RealEstateAgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RealEstateAgentCountOutputType without action
   */
  export type RealEstateAgentCountOutputTypeCountClient_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractWhereInput
  }

  /**
   * RealEstateAgentCountOutputType without action
   */
  export type RealEstateAgentCountOutputTypeCountAgenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyToRealEstateAgentWhereInput
  }


  /**
   * Count Type EntityCountOutputType
   */

  export type EntityCountOutputType = {
    agency_contracts: number
    objects: number
    entity_forbidden_websites: number
    entity_forbidden_brands: number
  }

  export type EntityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency_contracts?: boolean | EntityCountOutputTypeCountAgency_contractsArgs
    objects?: boolean | EntityCountOutputTypeCountObjectsArgs
    entity_forbidden_websites?: boolean | EntityCountOutputTypeCountEntity_forbidden_websitesArgs
    entity_forbidden_brands?: boolean | EntityCountOutputTypeCountEntity_forbidden_brandsArgs
  }

  // Custom InputTypes
  /**
   * EntityCountOutputType without action
   */
  export type EntityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityCountOutputType
     */
    select?: EntityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EntityCountOutputType without action
   */
  export type EntityCountOutputTypeCountAgency_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyContractWhereInput
  }

  /**
   * EntityCountOutputType without action
   */
  export type EntityCountOutputTypeCountObjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectWhereInput
  }

  /**
   * EntityCountOutputType without action
   */
  export type EntityCountOutputTypeCountEntity_forbidden_websitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityForbiddenWebsiteWhereInput
  }

  /**
   * EntityCountOutputType without action
   */
  export type EntityCountOutputTypeCountEntity_forbidden_brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityForbiddenBrandWhereInput
  }


  /**
   * Count Type BankCountOutputType
   */

  export type BankCountOutputType = {
    client_contracts: number
  }

  export type BankCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_contracts?: boolean | BankCountOutputTypeCountClient_contractsArgs
  }

  // Custom InputTypes
  /**
   * BankCountOutputType without action
   */
  export type BankCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankCountOutputType
     */
    select?: BankCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BankCountOutputType without action
   */
  export type BankCountOutputTypeCountClient_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    full_name: string | null
    email: string | null
    phone: string | null
    is_manager: boolean | null
    user_role: $Enums.UserRole | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    full_name: string | null
    email: string | null
    phone: string | null
    is_manager: boolean | null
    user_role: $Enums.UserRole | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    full_name: number
    email: number
    phone: number
    is_manager: number
    user_role: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    phone?: true
    is_manager?: true
    user_role?: true
    created_at?: true
    updated_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    phone?: true
    is_manager?: true
    user_role?: true
    created_at?: true
    updated_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    phone?: true
    is_manager?: true
    user_role?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    full_name: string
    email: string
    phone: string | null
    is_manager: boolean
    user_role: $Enums.UserRole
    created_at: Date
    updated_at: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    phone?: boolean
    is_manager?: boolean
    user_role?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_contracts?: boolean | User$client_contractsArgs<ExtArgs>
    agency_contracts?: boolean | User$agency_contractsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    full_name?: boolean
    email?: boolean
    phone?: boolean
    is_manager?: boolean
    user_role?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_contracts?: boolean | User$client_contractsArgs<ExtArgs>
    agency_contracts?: boolean | User$agency_contractsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      client_contracts: Prisma.$ClientContractPayload<ExtArgs>[]
      agency_contracts: Prisma.$AgencyContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      full_name: string
      email: string
      phone: string | null
      is_manager: boolean
      user_role: $Enums.UserRole
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client_contracts<T extends User$client_contractsArgs<ExtArgs> = {}>(args?: Subset<T, User$client_contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    agency_contracts<T extends User$agency_contractsArgs<ExtArgs> = {}>(args?: Subset<T, User$agency_contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly full_name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly is_manager: FieldRef<"User", 'Boolean'>
    readonly user_role: FieldRef<"User", 'UserRole'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.client_contracts
   */
  export type User$client_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    where?: ClientContractWhereInput
    orderBy?: ClientContractOrderByWithRelationInput | ClientContractOrderByWithRelationInput[]
    cursor?: ClientContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientContractScalarFieldEnum | ClientContractScalarFieldEnum[]
  }

  /**
   * User.agency_contracts
   */
  export type User$agency_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    where?: AgencyContractWhereInput
    orderBy?: AgencyContractOrderByWithRelationInput | AgencyContractOrderByWithRelationInput[]
    cursor?: AgencyContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyContractScalarFieldEnum | AgencyContractScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    id: number | null
    client_individual_properties_id: number | null
    client_individual_minor_properties_id: number | null
    client_entity_properties_id: number | null
  }

  export type ClientSumAggregateOutputType = {
    id: number | null
    client_individual_properties_id: number | null
    client_individual_minor_properties_id: number | null
    client_entity_properties_id: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: number | null
    full_name: string | null
    inn: string | null
    phone: string | null
    email: string | null
    address: string | null
    client_category: $Enums.ClientCategory | null
    created_at: Date | null
    updated_at: Date | null
    client_individual_properties_id: number | null
    client_individual_minor_properties_id: number | null
    client_entity_properties_id: number | null
  }

  export type ClientMaxAggregateOutputType = {
    id: number | null
    full_name: string | null
    inn: string | null
    phone: string | null
    email: string | null
    address: string | null
    client_category: $Enums.ClientCategory | null
    created_at: Date | null
    updated_at: Date | null
    client_individual_properties_id: number | null
    client_individual_minor_properties_id: number | null
    client_entity_properties_id: number | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    full_name: number
    inn: number
    phone: number
    email: number
    address: number
    client_category: number
    created_at: number
    updated_at: number
    client_individual_properties_id: number
    client_individual_minor_properties_id: number
    client_entity_properties_id: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    id?: true
    client_individual_properties_id?: true
    client_individual_minor_properties_id?: true
    client_entity_properties_id?: true
  }

  export type ClientSumAggregateInputType = {
    id?: true
    client_individual_properties_id?: true
    client_individual_minor_properties_id?: true
    client_entity_properties_id?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    full_name?: true
    inn?: true
    phone?: true
    email?: true
    address?: true
    client_category?: true
    created_at?: true
    updated_at?: true
    client_individual_properties_id?: true
    client_individual_minor_properties_id?: true
    client_entity_properties_id?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    full_name?: true
    inn?: true
    phone?: true
    email?: true
    address?: true
    client_category?: true
    created_at?: true
    updated_at?: true
    client_individual_properties_id?: true
    client_individual_minor_properties_id?: true
    client_entity_properties_id?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    full_name?: true
    inn?: true
    phone?: true
    email?: true
    address?: true
    client_category?: true
    created_at?: true
    updated_at?: true
    client_individual_properties_id?: true
    client_individual_minor_properties_id?: true
    client_entity_properties_id?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: number
    full_name: string
    inn: string | null
    phone: string | null
    email: string | null
    address: string | null
    client_category: $Enums.ClientCategory
    created_at: Date
    updated_at: Date
    client_individual_properties_id: number | null
    client_individual_minor_properties_id: number | null
    client_entity_properties_id: number | null
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    inn?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    client_category?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_individual_properties_id?: boolean
    client_individual_minor_properties_id?: boolean
    client_entity_properties_id?: boolean
    client_individual_properties?: boolean | Client$client_individual_propertiesArgs<ExtArgs>
    client_individual_minor_properties?: boolean | Client$client_individual_minor_propertiesArgs<ExtArgs>
    client_entity_properties?: boolean | Client$client_entity_propertiesArgs<ExtArgs>
    client_contracts?: boolean | Client$client_contractsArgs<ExtArgs>
    clients_to_client_individual_minor_properties?: boolean | Client$clients_to_client_individual_minor_propertiesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>


  export type ClientSelectScalar = {
    id?: boolean
    full_name?: boolean
    inn?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    client_category?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_individual_properties_id?: boolean
    client_individual_minor_properties_id?: boolean
    client_entity_properties_id?: boolean
  }

  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_individual_properties?: boolean | Client$client_individual_propertiesArgs<ExtArgs>
    client_individual_minor_properties?: boolean | Client$client_individual_minor_propertiesArgs<ExtArgs>
    client_entity_properties?: boolean | Client$client_entity_propertiesArgs<ExtArgs>
    client_contracts?: boolean | Client$client_contractsArgs<ExtArgs>
    clients_to_client_individual_minor_properties?: boolean | Client$clients_to_client_individual_minor_propertiesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      client_individual_properties: Prisma.$ClientIndividualPropertiesPayload<ExtArgs> | null
      client_individual_minor_properties: Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs> | null
      client_entity_properties: Prisma.$ClientEntityPropertiesPayload<ExtArgs> | null
      client_contracts: Prisma.$ClientContractToClientPayload<ExtArgs>[]
      clients_to_client_individual_minor_properties: Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      full_name: string
      inn: string | null
      phone: string | null
      email: string | null
      address: string | null
      client_category: $Enums.ClientCategory
      created_at: Date
      updated_at: Date
      client_individual_properties_id: number | null
      client_individual_minor_properties_id: number | null
      client_entity_properties_id: number | null
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
    **/
    create<T extends ClientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientCreateArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
    **/
    delete<T extends ClientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
    **/
    upsert<T extends ClientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client_individual_properties<T extends Client$client_individual_propertiesArgs<ExtArgs> = {}>(args?: Subset<T, Client$client_individual_propertiesArgs<ExtArgs>>): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    client_individual_minor_properties<T extends Client$client_individual_minor_propertiesArgs<ExtArgs> = {}>(args?: Subset<T, Client$client_individual_minor_propertiesArgs<ExtArgs>>): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    client_entity_properties<T extends Client$client_entity_propertiesArgs<ExtArgs> = {}>(args?: Subset<T, Client$client_entity_propertiesArgs<ExtArgs>>): Prisma__ClientEntityPropertiesClient<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    client_contracts<T extends Client$client_contractsArgs<ExtArgs> = {}>(args?: Subset<T, Client$client_contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'findMany'> | Null>;

    clients_to_client_individual_minor_properties<T extends Client$clients_to_client_individual_minor_propertiesArgs<ExtArgs> = {}>(args?: Subset<T, Client$clients_to_client_individual_minor_propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Client model
   */ 
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'Int'>
    readonly full_name: FieldRef<"Client", 'String'>
    readonly inn: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly address: FieldRef<"Client", 'String'>
    readonly client_category: FieldRef<"Client", 'ClientCategory'>
    readonly created_at: FieldRef<"Client", 'DateTime'>
    readonly updated_at: FieldRef<"Client", 'DateTime'>
    readonly client_individual_properties_id: FieldRef<"Client", 'Int'>
    readonly client_individual_minor_properties_id: FieldRef<"Client", 'Int'>
    readonly client_entity_properties_id: FieldRef<"Client", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
  }

  /**
   * Client.client_individual_properties
   */
  export type Client$client_individual_propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    where?: ClientIndividualPropertiesWhereInput
  }

  /**
   * Client.client_individual_minor_properties
   */
  export type Client$client_individual_minor_propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    where?: ClientIndividualMinorPropertiesWhereInput
  }

  /**
   * Client.client_entity_properties
   */
  export type Client$client_entity_propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    where?: ClientEntityPropertiesWhereInput
  }

  /**
   * Client.client_contracts
   */
  export type Client$client_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    where?: ClientContractToClientWhereInput
    orderBy?: ClientContractToClientOrderByWithRelationInput | ClientContractToClientOrderByWithRelationInput[]
    cursor?: ClientContractToClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientContractToClientScalarFieldEnum | ClientContractToClientScalarFieldEnum[]
  }

  /**
   * Client.clients_to_client_individual_minor_properties
   */
  export type Client$clients_to_client_individual_minor_propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    where?: ClientToClientIndividualMinorPropertiesWhereInput
    orderBy?: ClientToClientIndividualMinorPropertiesOrderByWithRelationInput | ClientToClientIndividualMinorPropertiesOrderByWithRelationInput[]
    cursor?: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientToClientIndividualMinorPropertiesScalarFieldEnum | ClientToClientIndividualMinorPropertiesScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model ClientIndividualProperties
   */

  export type AggregateClientIndividualProperties = {
    _count: ClientIndividualPropertiesCountAggregateOutputType | null
    _avg: ClientIndividualPropertiesAvgAggregateOutputType | null
    _sum: ClientIndividualPropertiesSumAggregateOutputType | null
    _min: ClientIndividualPropertiesMinAggregateOutputType | null
    _max: ClientIndividualPropertiesMaxAggregateOutputType | null
  }

  export type ClientIndividualPropertiesAvgAggregateOutputType = {
    id: number | null
    client_passport_id: number | null
  }

  export type ClientIndividualPropertiesSumAggregateOutputType = {
    id: number | null
    client_passport_id: number | null
  }

  export type ClientIndividualPropertiesMinAggregateOutputType = {
    id: number | null
    dob: Date | null
    snils: string | null
    created_at: Date | null
    updated_at: Date | null
    client_passport_id: number | null
  }

  export type ClientIndividualPropertiesMaxAggregateOutputType = {
    id: number | null
    dob: Date | null
    snils: string | null
    created_at: Date | null
    updated_at: Date | null
    client_passport_id: number | null
  }

  export type ClientIndividualPropertiesCountAggregateOutputType = {
    id: number
    dob: number
    snils: number
    created_at: number
    updated_at: number
    client_passport_id: number
    _all: number
  }


  export type ClientIndividualPropertiesAvgAggregateInputType = {
    id?: true
    client_passport_id?: true
  }

  export type ClientIndividualPropertiesSumAggregateInputType = {
    id?: true
    client_passport_id?: true
  }

  export type ClientIndividualPropertiesMinAggregateInputType = {
    id?: true
    dob?: true
    snils?: true
    created_at?: true
    updated_at?: true
    client_passport_id?: true
  }

  export type ClientIndividualPropertiesMaxAggregateInputType = {
    id?: true
    dob?: true
    snils?: true
    created_at?: true
    updated_at?: true
    client_passport_id?: true
  }

  export type ClientIndividualPropertiesCountAggregateInputType = {
    id?: true
    dob?: true
    snils?: true
    created_at?: true
    updated_at?: true
    client_passport_id?: true
    _all?: true
  }

  export type ClientIndividualPropertiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientIndividualProperties to aggregate.
     */
    where?: ClientIndividualPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientIndividualProperties to fetch.
     */
    orderBy?: ClientIndividualPropertiesOrderByWithRelationInput | ClientIndividualPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientIndividualPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientIndividualProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientIndividualProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientIndividualProperties
    **/
    _count?: true | ClientIndividualPropertiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientIndividualPropertiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientIndividualPropertiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientIndividualPropertiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientIndividualPropertiesMaxAggregateInputType
  }

  export type GetClientIndividualPropertiesAggregateType<T extends ClientIndividualPropertiesAggregateArgs> = {
        [P in keyof T & keyof AggregateClientIndividualProperties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientIndividualProperties[P]>
      : GetScalarType<T[P], AggregateClientIndividualProperties[P]>
  }




  export type ClientIndividualPropertiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientIndividualPropertiesWhereInput
    orderBy?: ClientIndividualPropertiesOrderByWithAggregationInput | ClientIndividualPropertiesOrderByWithAggregationInput[]
    by: ClientIndividualPropertiesScalarFieldEnum[] | ClientIndividualPropertiesScalarFieldEnum
    having?: ClientIndividualPropertiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientIndividualPropertiesCountAggregateInputType | true
    _avg?: ClientIndividualPropertiesAvgAggregateInputType
    _sum?: ClientIndividualPropertiesSumAggregateInputType
    _min?: ClientIndividualPropertiesMinAggregateInputType
    _max?: ClientIndividualPropertiesMaxAggregateInputType
  }

  export type ClientIndividualPropertiesGroupByOutputType = {
    id: number
    dob: Date | null
    snils: string | null
    created_at: Date
    updated_at: Date
    client_passport_id: number | null
    _count: ClientIndividualPropertiesCountAggregateOutputType | null
    _avg: ClientIndividualPropertiesAvgAggregateOutputType | null
    _sum: ClientIndividualPropertiesSumAggregateOutputType | null
    _min: ClientIndividualPropertiesMinAggregateOutputType | null
    _max: ClientIndividualPropertiesMaxAggregateOutputType | null
  }

  type GetClientIndividualPropertiesGroupByPayload<T extends ClientIndividualPropertiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientIndividualPropertiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientIndividualPropertiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientIndividualPropertiesGroupByOutputType[P]>
            : GetScalarType<T[P], ClientIndividualPropertiesGroupByOutputType[P]>
        }
      >
    >


  export type ClientIndividualPropertiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dob?: boolean
    snils?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_passport_id?: boolean
    client?: boolean | ClientIndividualProperties$clientArgs<ExtArgs>
    client_passport?: boolean | ClientIndividualProperties$client_passportArgs<ExtArgs>
  }, ExtArgs["result"]["clientIndividualProperties"]>


  export type ClientIndividualPropertiesSelectScalar = {
    id?: boolean
    dob?: boolean
    snils?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_passport_id?: boolean
  }

  export type ClientIndividualPropertiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientIndividualProperties$clientArgs<ExtArgs>
    client_passport?: boolean | ClientIndividualProperties$client_passportArgs<ExtArgs>
  }

  export type $ClientIndividualPropertiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientIndividualProperties"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      client_passport: Prisma.$ClientPassportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dob: Date | null
      snils: string | null
      created_at: Date
      updated_at: Date
      client_passport_id: number | null
    }, ExtArgs["result"]["clientIndividualProperties"]>
    composites: {}
  }

  type ClientIndividualPropertiesGetPayload<S extends boolean | null | undefined | ClientIndividualPropertiesDefaultArgs> = $Result.GetResult<Prisma.$ClientIndividualPropertiesPayload, S>

  type ClientIndividualPropertiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientIndividualPropertiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientIndividualPropertiesCountAggregateInputType | true
    }

  export interface ClientIndividualPropertiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientIndividualProperties'], meta: { name: 'ClientIndividualProperties' } }
    /**
     * Find zero or one ClientIndividualProperties that matches the filter.
     * @param {ClientIndividualPropertiesFindUniqueArgs} args - Arguments to find a ClientIndividualProperties
     * @example
     * // Get one ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientIndividualPropertiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualPropertiesFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClientIndividualProperties that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientIndividualPropertiesFindUniqueOrThrowArgs} args - Arguments to find a ClientIndividualProperties
     * @example
     * // Get one ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientIndividualPropertiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualPropertiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClientIndividualProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualPropertiesFindFirstArgs} args - Arguments to find a ClientIndividualProperties
     * @example
     * // Get one ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientIndividualPropertiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualPropertiesFindFirstArgs<ExtArgs>>
    ): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClientIndividualProperties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualPropertiesFindFirstOrThrowArgs} args - Arguments to find a ClientIndividualProperties
     * @example
     * // Get one ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientIndividualPropertiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualPropertiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClientIndividualProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualPropertiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.findMany()
     * 
     * // Get first 10 ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientIndividualPropertiesWithIdOnly = await prisma.clientIndividualProperties.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientIndividualPropertiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualPropertiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClientIndividualProperties.
     * @param {ClientIndividualPropertiesCreateArgs} args - Arguments to create a ClientIndividualProperties.
     * @example
     * // Create one ClientIndividualProperties
     * const ClientIndividualProperties = await prisma.clientIndividualProperties.create({
     *   data: {
     *     // ... data to create a ClientIndividualProperties
     *   }
     * })
     * 
    **/
    create<T extends ClientIndividualPropertiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualPropertiesCreateArgs<ExtArgs>>
    ): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClientIndividualProperties.
     * @param {ClientIndividualPropertiesCreateManyArgs} args - Arguments to create many ClientIndividualProperties.
     * @example
     * // Create many ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientIndividualPropertiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualPropertiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientIndividualProperties.
     * @param {ClientIndividualPropertiesDeleteArgs} args - Arguments to delete one ClientIndividualProperties.
     * @example
     * // Delete one ClientIndividualProperties
     * const ClientIndividualProperties = await prisma.clientIndividualProperties.delete({
     *   where: {
     *     // ... filter to delete one ClientIndividualProperties
     *   }
     * })
     * 
    **/
    delete<T extends ClientIndividualPropertiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualPropertiesDeleteArgs<ExtArgs>>
    ): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClientIndividualProperties.
     * @param {ClientIndividualPropertiesUpdateArgs} args - Arguments to update one ClientIndividualProperties.
     * @example
     * // Update one ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientIndividualPropertiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualPropertiesUpdateArgs<ExtArgs>>
    ): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClientIndividualProperties.
     * @param {ClientIndividualPropertiesDeleteManyArgs} args - Arguments to filter ClientIndividualProperties to delete.
     * @example
     * // Delete a few ClientIndividualProperties
     * const { count } = await prisma.clientIndividualProperties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientIndividualPropertiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualPropertiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientIndividualProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualPropertiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientIndividualPropertiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualPropertiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientIndividualProperties.
     * @param {ClientIndividualPropertiesUpsertArgs} args - Arguments to update or create a ClientIndividualProperties.
     * @example
     * // Update or create a ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.upsert({
     *   create: {
     *     // ... data to create a ClientIndividualProperties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientIndividualProperties we want to update
     *   }
     * })
    **/
    upsert<T extends ClientIndividualPropertiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualPropertiesUpsertArgs<ExtArgs>>
    ): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClientIndividualProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualPropertiesCountArgs} args - Arguments to filter ClientIndividualProperties to count.
     * @example
     * // Count the number of ClientIndividualProperties
     * const count = await prisma.clientIndividualProperties.count({
     *   where: {
     *     // ... the filter for the ClientIndividualProperties we want to count
     *   }
     * })
    **/
    count<T extends ClientIndividualPropertiesCountArgs>(
      args?: Subset<T, ClientIndividualPropertiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientIndividualPropertiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientIndividualProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualPropertiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientIndividualPropertiesAggregateArgs>(args: Subset<T, ClientIndividualPropertiesAggregateArgs>): Prisma.PrismaPromise<GetClientIndividualPropertiesAggregateType<T>>

    /**
     * Group by ClientIndividualProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualPropertiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientIndividualPropertiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientIndividualPropertiesGroupByArgs['orderBy'] }
        : { orderBy?: ClientIndividualPropertiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientIndividualPropertiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientIndividualPropertiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientIndividualProperties model
   */
  readonly fields: ClientIndividualPropertiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientIndividualProperties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientIndividualPropertiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client<T extends ClientIndividualProperties$clientArgs<ExtArgs> = {}>(args?: Subset<T, ClientIndividualProperties$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    client_passport<T extends ClientIndividualProperties$client_passportArgs<ExtArgs> = {}>(args?: Subset<T, ClientIndividualProperties$client_passportArgs<ExtArgs>>): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClientIndividualProperties model
   */ 
  interface ClientIndividualPropertiesFieldRefs {
    readonly id: FieldRef<"ClientIndividualProperties", 'Int'>
    readonly dob: FieldRef<"ClientIndividualProperties", 'DateTime'>
    readonly snils: FieldRef<"ClientIndividualProperties", 'String'>
    readonly created_at: FieldRef<"ClientIndividualProperties", 'DateTime'>
    readonly updated_at: FieldRef<"ClientIndividualProperties", 'DateTime'>
    readonly client_passport_id: FieldRef<"ClientIndividualProperties", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClientIndividualProperties findUnique
   */
  export type ClientIndividualPropertiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualProperties to fetch.
     */
    where: ClientIndividualPropertiesWhereUniqueInput
  }

  /**
   * ClientIndividualProperties findUniqueOrThrow
   */
  export type ClientIndividualPropertiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualProperties to fetch.
     */
    where: ClientIndividualPropertiesWhereUniqueInput
  }

  /**
   * ClientIndividualProperties findFirst
   */
  export type ClientIndividualPropertiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualProperties to fetch.
     */
    where?: ClientIndividualPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientIndividualProperties to fetch.
     */
    orderBy?: ClientIndividualPropertiesOrderByWithRelationInput | ClientIndividualPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientIndividualProperties.
     */
    cursor?: ClientIndividualPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientIndividualProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientIndividualProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientIndividualProperties.
     */
    distinct?: ClientIndividualPropertiesScalarFieldEnum | ClientIndividualPropertiesScalarFieldEnum[]
  }

  /**
   * ClientIndividualProperties findFirstOrThrow
   */
  export type ClientIndividualPropertiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualProperties to fetch.
     */
    where?: ClientIndividualPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientIndividualProperties to fetch.
     */
    orderBy?: ClientIndividualPropertiesOrderByWithRelationInput | ClientIndividualPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientIndividualProperties.
     */
    cursor?: ClientIndividualPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientIndividualProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientIndividualProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientIndividualProperties.
     */
    distinct?: ClientIndividualPropertiesScalarFieldEnum | ClientIndividualPropertiesScalarFieldEnum[]
  }

  /**
   * ClientIndividualProperties findMany
   */
  export type ClientIndividualPropertiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualProperties to fetch.
     */
    where?: ClientIndividualPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientIndividualProperties to fetch.
     */
    orderBy?: ClientIndividualPropertiesOrderByWithRelationInput | ClientIndividualPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientIndividualProperties.
     */
    cursor?: ClientIndividualPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientIndividualProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientIndividualProperties.
     */
    skip?: number
    distinct?: ClientIndividualPropertiesScalarFieldEnum | ClientIndividualPropertiesScalarFieldEnum[]
  }

  /**
   * ClientIndividualProperties create
   */
  export type ClientIndividualPropertiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientIndividualProperties.
     */
    data: XOR<ClientIndividualPropertiesCreateInput, ClientIndividualPropertiesUncheckedCreateInput>
  }

  /**
   * ClientIndividualProperties createMany
   */
  export type ClientIndividualPropertiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientIndividualProperties.
     */
    data: ClientIndividualPropertiesCreateManyInput | ClientIndividualPropertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientIndividualProperties update
   */
  export type ClientIndividualPropertiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientIndividualProperties.
     */
    data: XOR<ClientIndividualPropertiesUpdateInput, ClientIndividualPropertiesUncheckedUpdateInput>
    /**
     * Choose, which ClientIndividualProperties to update.
     */
    where: ClientIndividualPropertiesWhereUniqueInput
  }

  /**
   * ClientIndividualProperties updateMany
   */
  export type ClientIndividualPropertiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientIndividualProperties.
     */
    data: XOR<ClientIndividualPropertiesUpdateManyMutationInput, ClientIndividualPropertiesUncheckedUpdateManyInput>
    /**
     * Filter which ClientIndividualProperties to update
     */
    where?: ClientIndividualPropertiesWhereInput
  }

  /**
   * ClientIndividualProperties upsert
   */
  export type ClientIndividualPropertiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientIndividualProperties to update in case it exists.
     */
    where: ClientIndividualPropertiesWhereUniqueInput
    /**
     * In case the ClientIndividualProperties found by the `where` argument doesn't exist, create a new ClientIndividualProperties with this data.
     */
    create: XOR<ClientIndividualPropertiesCreateInput, ClientIndividualPropertiesUncheckedCreateInput>
    /**
     * In case the ClientIndividualProperties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientIndividualPropertiesUpdateInput, ClientIndividualPropertiesUncheckedUpdateInput>
  }

  /**
   * ClientIndividualProperties delete
   */
  export type ClientIndividualPropertiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    /**
     * Filter which ClientIndividualProperties to delete.
     */
    where: ClientIndividualPropertiesWhereUniqueInput
  }

  /**
   * ClientIndividualProperties deleteMany
   */
  export type ClientIndividualPropertiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientIndividualProperties to delete
     */
    where?: ClientIndividualPropertiesWhereInput
  }

  /**
   * ClientIndividualProperties.client
   */
  export type ClientIndividualProperties$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * ClientIndividualProperties.client_passport
   */
  export type ClientIndividualProperties$client_passportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    where?: ClientPassportWhereInput
  }

  /**
   * ClientIndividualProperties without action
   */
  export type ClientIndividualPropertiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
  }


  /**
   * Model ClientIndividualMinorProperties
   */

  export type AggregateClientIndividualMinorProperties = {
    _count: ClientIndividualMinorPropertiesCountAggregateOutputType | null
    _avg: ClientIndividualMinorPropertiesAvgAggregateOutputType | null
    _sum: ClientIndividualMinorPropertiesSumAggregateOutputType | null
    _min: ClientIndividualMinorPropertiesMinAggregateOutputType | null
    _max: ClientIndividualMinorPropertiesMaxAggregateOutputType | null
  }

  export type ClientIndividualMinorPropertiesAvgAggregateOutputType = {
    id: number | null
    client_passport_id: number | null
  }

  export type ClientIndividualMinorPropertiesSumAggregateOutputType = {
    id: number | null
    client_passport_id: number | null
  }

  export type ClientIndividualMinorPropertiesMinAggregateOutputType = {
    id: number | null
    dob: Date | null
    snils: string | null
    birth_certificate: string | null
    created_at: Date | null
    updated_at: Date | null
    client_passport_id: number | null
  }

  export type ClientIndividualMinorPropertiesMaxAggregateOutputType = {
    id: number | null
    dob: Date | null
    snils: string | null
    birth_certificate: string | null
    created_at: Date | null
    updated_at: Date | null
    client_passport_id: number | null
  }

  export type ClientIndividualMinorPropertiesCountAggregateOutputType = {
    id: number
    dob: number
    snils: number
    birth_certificate: number
    created_at: number
    updated_at: number
    client_passport_id: number
    _all: number
  }


  export type ClientIndividualMinorPropertiesAvgAggregateInputType = {
    id?: true
    client_passport_id?: true
  }

  export type ClientIndividualMinorPropertiesSumAggregateInputType = {
    id?: true
    client_passport_id?: true
  }

  export type ClientIndividualMinorPropertiesMinAggregateInputType = {
    id?: true
    dob?: true
    snils?: true
    birth_certificate?: true
    created_at?: true
    updated_at?: true
    client_passport_id?: true
  }

  export type ClientIndividualMinorPropertiesMaxAggregateInputType = {
    id?: true
    dob?: true
    snils?: true
    birth_certificate?: true
    created_at?: true
    updated_at?: true
    client_passport_id?: true
  }

  export type ClientIndividualMinorPropertiesCountAggregateInputType = {
    id?: true
    dob?: true
    snils?: true
    birth_certificate?: true
    created_at?: true
    updated_at?: true
    client_passport_id?: true
    _all?: true
  }

  export type ClientIndividualMinorPropertiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientIndividualMinorProperties to aggregate.
     */
    where?: ClientIndividualMinorPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientIndividualMinorProperties to fetch.
     */
    orderBy?: ClientIndividualMinorPropertiesOrderByWithRelationInput | ClientIndividualMinorPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientIndividualMinorProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientIndividualMinorProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientIndividualMinorProperties
    **/
    _count?: true | ClientIndividualMinorPropertiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientIndividualMinorPropertiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientIndividualMinorPropertiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientIndividualMinorPropertiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientIndividualMinorPropertiesMaxAggregateInputType
  }

  export type GetClientIndividualMinorPropertiesAggregateType<T extends ClientIndividualMinorPropertiesAggregateArgs> = {
        [P in keyof T & keyof AggregateClientIndividualMinorProperties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientIndividualMinorProperties[P]>
      : GetScalarType<T[P], AggregateClientIndividualMinorProperties[P]>
  }




  export type ClientIndividualMinorPropertiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientIndividualMinorPropertiesWhereInput
    orderBy?: ClientIndividualMinorPropertiesOrderByWithAggregationInput | ClientIndividualMinorPropertiesOrderByWithAggregationInput[]
    by: ClientIndividualMinorPropertiesScalarFieldEnum[] | ClientIndividualMinorPropertiesScalarFieldEnum
    having?: ClientIndividualMinorPropertiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientIndividualMinorPropertiesCountAggregateInputType | true
    _avg?: ClientIndividualMinorPropertiesAvgAggregateInputType
    _sum?: ClientIndividualMinorPropertiesSumAggregateInputType
    _min?: ClientIndividualMinorPropertiesMinAggregateInputType
    _max?: ClientIndividualMinorPropertiesMaxAggregateInputType
  }

  export type ClientIndividualMinorPropertiesGroupByOutputType = {
    id: number
    dob: Date | null
    snils: string | null
    birth_certificate: string | null
    created_at: Date
    updated_at: Date
    client_passport_id: number | null
    _count: ClientIndividualMinorPropertiesCountAggregateOutputType | null
    _avg: ClientIndividualMinorPropertiesAvgAggregateOutputType | null
    _sum: ClientIndividualMinorPropertiesSumAggregateOutputType | null
    _min: ClientIndividualMinorPropertiesMinAggregateOutputType | null
    _max: ClientIndividualMinorPropertiesMaxAggregateOutputType | null
  }

  type GetClientIndividualMinorPropertiesGroupByPayload<T extends ClientIndividualMinorPropertiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientIndividualMinorPropertiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientIndividualMinorPropertiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientIndividualMinorPropertiesGroupByOutputType[P]>
            : GetScalarType<T[P], ClientIndividualMinorPropertiesGroupByOutputType[P]>
        }
      >
    >


  export type ClientIndividualMinorPropertiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dob?: boolean
    snils?: boolean
    birth_certificate?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_passport_id?: boolean
    client?: boolean | ClientIndividualMinorProperties$clientArgs<ExtArgs>
    client_passport?: boolean | ClientIndividualMinorProperties$client_passportArgs<ExtArgs>
    representatives?: boolean | ClientIndividualMinorProperties$representativesArgs<ExtArgs>
    _count?: boolean | ClientIndividualMinorPropertiesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientIndividualMinorProperties"]>


  export type ClientIndividualMinorPropertiesSelectScalar = {
    id?: boolean
    dob?: boolean
    snils?: boolean
    birth_certificate?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_passport_id?: boolean
  }

  export type ClientIndividualMinorPropertiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientIndividualMinorProperties$clientArgs<ExtArgs>
    client_passport?: boolean | ClientIndividualMinorProperties$client_passportArgs<ExtArgs>
    representatives?: boolean | ClientIndividualMinorProperties$representativesArgs<ExtArgs>
    _count?: boolean | ClientIndividualMinorPropertiesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClientIndividualMinorPropertiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientIndividualMinorProperties"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      client_passport: Prisma.$ClientPassportPayload<ExtArgs> | null
      representatives: Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dob: Date | null
      snils: string | null
      birth_certificate: string | null
      created_at: Date
      updated_at: Date
      client_passport_id: number | null
    }, ExtArgs["result"]["clientIndividualMinorProperties"]>
    composites: {}
  }

  type ClientIndividualMinorPropertiesGetPayload<S extends boolean | null | undefined | ClientIndividualMinorPropertiesDefaultArgs> = $Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload, S>

  type ClientIndividualMinorPropertiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientIndividualMinorPropertiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientIndividualMinorPropertiesCountAggregateInputType | true
    }

  export interface ClientIndividualMinorPropertiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientIndividualMinorProperties'], meta: { name: 'ClientIndividualMinorProperties' } }
    /**
     * Find zero or one ClientIndividualMinorProperties that matches the filter.
     * @param {ClientIndividualMinorPropertiesFindUniqueArgs} args - Arguments to find a ClientIndividualMinorProperties
     * @example
     * // Get one ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientIndividualMinorPropertiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualMinorPropertiesFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClientIndividualMinorProperties that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientIndividualMinorPropertiesFindUniqueOrThrowArgs} args - Arguments to find a ClientIndividualMinorProperties
     * @example
     * // Get one ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientIndividualMinorPropertiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualMinorPropertiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClientIndividualMinorProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualMinorPropertiesFindFirstArgs} args - Arguments to find a ClientIndividualMinorProperties
     * @example
     * // Get one ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientIndividualMinorPropertiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualMinorPropertiesFindFirstArgs<ExtArgs>>
    ): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClientIndividualMinorProperties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualMinorPropertiesFindFirstOrThrowArgs} args - Arguments to find a ClientIndividualMinorProperties
     * @example
     * // Get one ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientIndividualMinorPropertiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualMinorPropertiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClientIndividualMinorProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualMinorPropertiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.findMany()
     * 
     * // Get first 10 ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientIndividualMinorPropertiesWithIdOnly = await prisma.clientIndividualMinorProperties.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientIndividualMinorPropertiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualMinorPropertiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClientIndividualMinorProperties.
     * @param {ClientIndividualMinorPropertiesCreateArgs} args - Arguments to create a ClientIndividualMinorProperties.
     * @example
     * // Create one ClientIndividualMinorProperties
     * const ClientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.create({
     *   data: {
     *     // ... data to create a ClientIndividualMinorProperties
     *   }
     * })
     * 
    **/
    create<T extends ClientIndividualMinorPropertiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualMinorPropertiesCreateArgs<ExtArgs>>
    ): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClientIndividualMinorProperties.
     * @param {ClientIndividualMinorPropertiesCreateManyArgs} args - Arguments to create many ClientIndividualMinorProperties.
     * @example
     * // Create many ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientIndividualMinorPropertiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualMinorPropertiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientIndividualMinorProperties.
     * @param {ClientIndividualMinorPropertiesDeleteArgs} args - Arguments to delete one ClientIndividualMinorProperties.
     * @example
     * // Delete one ClientIndividualMinorProperties
     * const ClientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.delete({
     *   where: {
     *     // ... filter to delete one ClientIndividualMinorProperties
     *   }
     * })
     * 
    **/
    delete<T extends ClientIndividualMinorPropertiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualMinorPropertiesDeleteArgs<ExtArgs>>
    ): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClientIndividualMinorProperties.
     * @param {ClientIndividualMinorPropertiesUpdateArgs} args - Arguments to update one ClientIndividualMinorProperties.
     * @example
     * // Update one ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientIndividualMinorPropertiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualMinorPropertiesUpdateArgs<ExtArgs>>
    ): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClientIndividualMinorProperties.
     * @param {ClientIndividualMinorPropertiesDeleteManyArgs} args - Arguments to filter ClientIndividualMinorProperties to delete.
     * @example
     * // Delete a few ClientIndividualMinorProperties
     * const { count } = await prisma.clientIndividualMinorProperties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientIndividualMinorPropertiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualMinorPropertiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientIndividualMinorProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualMinorPropertiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientIndividualMinorPropertiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualMinorPropertiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientIndividualMinorProperties.
     * @param {ClientIndividualMinorPropertiesUpsertArgs} args - Arguments to update or create a ClientIndividualMinorProperties.
     * @example
     * // Update or create a ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.upsert({
     *   create: {
     *     // ... data to create a ClientIndividualMinorProperties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientIndividualMinorProperties we want to update
     *   }
     * })
    **/
    upsert<T extends ClientIndividualMinorPropertiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualMinorPropertiesUpsertArgs<ExtArgs>>
    ): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClientIndividualMinorProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualMinorPropertiesCountArgs} args - Arguments to filter ClientIndividualMinorProperties to count.
     * @example
     * // Count the number of ClientIndividualMinorProperties
     * const count = await prisma.clientIndividualMinorProperties.count({
     *   where: {
     *     // ... the filter for the ClientIndividualMinorProperties we want to count
     *   }
     * })
    **/
    count<T extends ClientIndividualMinorPropertiesCountArgs>(
      args?: Subset<T, ClientIndividualMinorPropertiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientIndividualMinorPropertiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientIndividualMinorProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualMinorPropertiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientIndividualMinorPropertiesAggregateArgs>(args: Subset<T, ClientIndividualMinorPropertiesAggregateArgs>): Prisma.PrismaPromise<GetClientIndividualMinorPropertiesAggregateType<T>>

    /**
     * Group by ClientIndividualMinorProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualMinorPropertiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientIndividualMinorPropertiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientIndividualMinorPropertiesGroupByArgs['orderBy'] }
        : { orderBy?: ClientIndividualMinorPropertiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientIndividualMinorPropertiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientIndividualMinorPropertiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientIndividualMinorProperties model
   */
  readonly fields: ClientIndividualMinorPropertiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientIndividualMinorProperties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientIndividualMinorPropertiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client<T extends ClientIndividualMinorProperties$clientArgs<ExtArgs> = {}>(args?: Subset<T, ClientIndividualMinorProperties$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    client_passport<T extends ClientIndividualMinorProperties$client_passportArgs<ExtArgs> = {}>(args?: Subset<T, ClientIndividualMinorProperties$client_passportArgs<ExtArgs>>): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    representatives<T extends ClientIndividualMinorProperties$representativesArgs<ExtArgs> = {}>(args?: Subset<T, ClientIndividualMinorProperties$representativesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClientIndividualMinorProperties model
   */ 
  interface ClientIndividualMinorPropertiesFieldRefs {
    readonly id: FieldRef<"ClientIndividualMinorProperties", 'Int'>
    readonly dob: FieldRef<"ClientIndividualMinorProperties", 'DateTime'>
    readonly snils: FieldRef<"ClientIndividualMinorProperties", 'String'>
    readonly birth_certificate: FieldRef<"ClientIndividualMinorProperties", 'String'>
    readonly created_at: FieldRef<"ClientIndividualMinorProperties", 'DateTime'>
    readonly updated_at: FieldRef<"ClientIndividualMinorProperties", 'DateTime'>
    readonly client_passport_id: FieldRef<"ClientIndividualMinorProperties", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClientIndividualMinorProperties findUnique
   */
  export type ClientIndividualMinorPropertiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualMinorProperties to fetch.
     */
    where: ClientIndividualMinorPropertiesWhereUniqueInput
  }

  /**
   * ClientIndividualMinorProperties findUniqueOrThrow
   */
  export type ClientIndividualMinorPropertiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualMinorProperties to fetch.
     */
    where: ClientIndividualMinorPropertiesWhereUniqueInput
  }

  /**
   * ClientIndividualMinorProperties findFirst
   */
  export type ClientIndividualMinorPropertiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualMinorProperties to fetch.
     */
    where?: ClientIndividualMinorPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientIndividualMinorProperties to fetch.
     */
    orderBy?: ClientIndividualMinorPropertiesOrderByWithRelationInput | ClientIndividualMinorPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientIndividualMinorProperties.
     */
    cursor?: ClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientIndividualMinorProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientIndividualMinorProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientIndividualMinorProperties.
     */
    distinct?: ClientIndividualMinorPropertiesScalarFieldEnum | ClientIndividualMinorPropertiesScalarFieldEnum[]
  }

  /**
   * ClientIndividualMinorProperties findFirstOrThrow
   */
  export type ClientIndividualMinorPropertiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualMinorProperties to fetch.
     */
    where?: ClientIndividualMinorPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientIndividualMinorProperties to fetch.
     */
    orderBy?: ClientIndividualMinorPropertiesOrderByWithRelationInput | ClientIndividualMinorPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientIndividualMinorProperties.
     */
    cursor?: ClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientIndividualMinorProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientIndividualMinorProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientIndividualMinorProperties.
     */
    distinct?: ClientIndividualMinorPropertiesScalarFieldEnum | ClientIndividualMinorPropertiesScalarFieldEnum[]
  }

  /**
   * ClientIndividualMinorProperties findMany
   */
  export type ClientIndividualMinorPropertiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualMinorProperties to fetch.
     */
    where?: ClientIndividualMinorPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientIndividualMinorProperties to fetch.
     */
    orderBy?: ClientIndividualMinorPropertiesOrderByWithRelationInput | ClientIndividualMinorPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientIndividualMinorProperties.
     */
    cursor?: ClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientIndividualMinorProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientIndividualMinorProperties.
     */
    skip?: number
    distinct?: ClientIndividualMinorPropertiesScalarFieldEnum | ClientIndividualMinorPropertiesScalarFieldEnum[]
  }

  /**
   * ClientIndividualMinorProperties create
   */
  export type ClientIndividualMinorPropertiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientIndividualMinorProperties.
     */
    data: XOR<ClientIndividualMinorPropertiesCreateInput, ClientIndividualMinorPropertiesUncheckedCreateInput>
  }

  /**
   * ClientIndividualMinorProperties createMany
   */
  export type ClientIndividualMinorPropertiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientIndividualMinorProperties.
     */
    data: ClientIndividualMinorPropertiesCreateManyInput | ClientIndividualMinorPropertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientIndividualMinorProperties update
   */
  export type ClientIndividualMinorPropertiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientIndividualMinorProperties.
     */
    data: XOR<ClientIndividualMinorPropertiesUpdateInput, ClientIndividualMinorPropertiesUncheckedUpdateInput>
    /**
     * Choose, which ClientIndividualMinorProperties to update.
     */
    where: ClientIndividualMinorPropertiesWhereUniqueInput
  }

  /**
   * ClientIndividualMinorProperties updateMany
   */
  export type ClientIndividualMinorPropertiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientIndividualMinorProperties.
     */
    data: XOR<ClientIndividualMinorPropertiesUpdateManyMutationInput, ClientIndividualMinorPropertiesUncheckedUpdateManyInput>
    /**
     * Filter which ClientIndividualMinorProperties to update
     */
    where?: ClientIndividualMinorPropertiesWhereInput
  }

  /**
   * ClientIndividualMinorProperties upsert
   */
  export type ClientIndividualMinorPropertiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientIndividualMinorProperties to update in case it exists.
     */
    where: ClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * In case the ClientIndividualMinorProperties found by the `where` argument doesn't exist, create a new ClientIndividualMinorProperties with this data.
     */
    create: XOR<ClientIndividualMinorPropertiesCreateInput, ClientIndividualMinorPropertiesUncheckedCreateInput>
    /**
     * In case the ClientIndividualMinorProperties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientIndividualMinorPropertiesUpdateInput, ClientIndividualMinorPropertiesUncheckedUpdateInput>
  }

  /**
   * ClientIndividualMinorProperties delete
   */
  export type ClientIndividualMinorPropertiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter which ClientIndividualMinorProperties to delete.
     */
    where: ClientIndividualMinorPropertiesWhereUniqueInput
  }

  /**
   * ClientIndividualMinorProperties deleteMany
   */
  export type ClientIndividualMinorPropertiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientIndividualMinorProperties to delete
     */
    where?: ClientIndividualMinorPropertiesWhereInput
  }

  /**
   * ClientIndividualMinorProperties.client
   */
  export type ClientIndividualMinorProperties$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * ClientIndividualMinorProperties.client_passport
   */
  export type ClientIndividualMinorProperties$client_passportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    where?: ClientPassportWhereInput
  }

  /**
   * ClientIndividualMinorProperties.representatives
   */
  export type ClientIndividualMinorProperties$representativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    where?: ClientToClientIndividualMinorPropertiesWhereInput
    orderBy?: ClientToClientIndividualMinorPropertiesOrderByWithRelationInput | ClientToClientIndividualMinorPropertiesOrderByWithRelationInput[]
    cursor?: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientToClientIndividualMinorPropertiesScalarFieldEnum | ClientToClientIndividualMinorPropertiesScalarFieldEnum[]
  }

  /**
   * ClientIndividualMinorProperties without action
   */
  export type ClientIndividualMinorPropertiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
  }


  /**
   * Model ClientEntityProperties
   */

  export type AggregateClientEntityProperties = {
    _count: ClientEntityPropertiesCountAggregateOutputType | null
    _avg: ClientEntityPropertiesAvgAggregateOutputType | null
    _sum: ClientEntityPropertiesSumAggregateOutputType | null
    _min: ClientEntityPropertiesMinAggregateOutputType | null
    _max: ClientEntityPropertiesMaxAggregateOutputType | null
  }

  export type ClientEntityPropertiesAvgAggregateOutputType = {
    id: number | null
  }

  export type ClientEntityPropertiesSumAggregateOutputType = {
    id: number | null
  }

  export type ClientEntityPropertiesMinAggregateOutputType = {
    id: number | null
    kpp: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientEntityPropertiesMaxAggregateOutputType = {
    id: number | null
    kpp: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientEntityPropertiesCountAggregateOutputType = {
    id: number
    kpp: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ClientEntityPropertiesAvgAggregateInputType = {
    id?: true
  }

  export type ClientEntityPropertiesSumAggregateInputType = {
    id?: true
  }

  export type ClientEntityPropertiesMinAggregateInputType = {
    id?: true
    kpp?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientEntityPropertiesMaxAggregateInputType = {
    id?: true
    kpp?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientEntityPropertiesCountAggregateInputType = {
    id?: true
    kpp?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ClientEntityPropertiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientEntityProperties to aggregate.
     */
    where?: ClientEntityPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEntityProperties to fetch.
     */
    orderBy?: ClientEntityPropertiesOrderByWithRelationInput | ClientEntityPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientEntityPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEntityProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEntityProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientEntityProperties
    **/
    _count?: true | ClientEntityPropertiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientEntityPropertiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientEntityPropertiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientEntityPropertiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientEntityPropertiesMaxAggregateInputType
  }

  export type GetClientEntityPropertiesAggregateType<T extends ClientEntityPropertiesAggregateArgs> = {
        [P in keyof T & keyof AggregateClientEntityProperties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientEntityProperties[P]>
      : GetScalarType<T[P], AggregateClientEntityProperties[P]>
  }




  export type ClientEntityPropertiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientEntityPropertiesWhereInput
    orderBy?: ClientEntityPropertiesOrderByWithAggregationInput | ClientEntityPropertiesOrderByWithAggregationInput[]
    by: ClientEntityPropertiesScalarFieldEnum[] | ClientEntityPropertiesScalarFieldEnum
    having?: ClientEntityPropertiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientEntityPropertiesCountAggregateInputType | true
    _avg?: ClientEntityPropertiesAvgAggregateInputType
    _sum?: ClientEntityPropertiesSumAggregateInputType
    _min?: ClientEntityPropertiesMinAggregateInputType
    _max?: ClientEntityPropertiesMaxAggregateInputType
  }

  export type ClientEntityPropertiesGroupByOutputType = {
    id: number
    kpp: string | null
    created_at: Date
    updated_at: Date
    _count: ClientEntityPropertiesCountAggregateOutputType | null
    _avg: ClientEntityPropertiesAvgAggregateOutputType | null
    _sum: ClientEntityPropertiesSumAggregateOutputType | null
    _min: ClientEntityPropertiesMinAggregateOutputType | null
    _max: ClientEntityPropertiesMaxAggregateOutputType | null
  }

  type GetClientEntityPropertiesGroupByPayload<T extends ClientEntityPropertiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientEntityPropertiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientEntityPropertiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientEntityPropertiesGroupByOutputType[P]>
            : GetScalarType<T[P], ClientEntityPropertiesGroupByOutputType[P]>
        }
      >
    >


  export type ClientEntityPropertiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kpp?: boolean
    created_at?: boolean
    updated_at?: boolean
    client?: boolean | ClientEntityProperties$clientArgs<ExtArgs>
  }, ExtArgs["result"]["clientEntityProperties"]>


  export type ClientEntityPropertiesSelectScalar = {
    id?: boolean
    kpp?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ClientEntityPropertiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientEntityProperties$clientArgs<ExtArgs>
  }

  export type $ClientEntityPropertiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientEntityProperties"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kpp: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["clientEntityProperties"]>
    composites: {}
  }

  type ClientEntityPropertiesGetPayload<S extends boolean | null | undefined | ClientEntityPropertiesDefaultArgs> = $Result.GetResult<Prisma.$ClientEntityPropertiesPayload, S>

  type ClientEntityPropertiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientEntityPropertiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientEntityPropertiesCountAggregateInputType | true
    }

  export interface ClientEntityPropertiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientEntityProperties'], meta: { name: 'ClientEntityProperties' } }
    /**
     * Find zero or one ClientEntityProperties that matches the filter.
     * @param {ClientEntityPropertiesFindUniqueArgs} args - Arguments to find a ClientEntityProperties
     * @example
     * // Get one ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientEntityPropertiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientEntityPropertiesFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientEntityPropertiesClient<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClientEntityProperties that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientEntityPropertiesFindUniqueOrThrowArgs} args - Arguments to find a ClientEntityProperties
     * @example
     * // Get one ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientEntityPropertiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientEntityPropertiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientEntityPropertiesClient<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClientEntityProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityPropertiesFindFirstArgs} args - Arguments to find a ClientEntityProperties
     * @example
     * // Get one ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientEntityPropertiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientEntityPropertiesFindFirstArgs<ExtArgs>>
    ): Prisma__ClientEntityPropertiesClient<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClientEntityProperties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityPropertiesFindFirstOrThrowArgs} args - Arguments to find a ClientEntityProperties
     * @example
     * // Get one ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientEntityPropertiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientEntityPropertiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientEntityPropertiesClient<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClientEntityProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityPropertiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.findMany()
     * 
     * // Get first 10 ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientEntityPropertiesWithIdOnly = await prisma.clientEntityProperties.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientEntityPropertiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientEntityPropertiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClientEntityProperties.
     * @param {ClientEntityPropertiesCreateArgs} args - Arguments to create a ClientEntityProperties.
     * @example
     * // Create one ClientEntityProperties
     * const ClientEntityProperties = await prisma.clientEntityProperties.create({
     *   data: {
     *     // ... data to create a ClientEntityProperties
     *   }
     * })
     * 
    **/
    create<T extends ClientEntityPropertiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientEntityPropertiesCreateArgs<ExtArgs>>
    ): Prisma__ClientEntityPropertiesClient<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClientEntityProperties.
     * @param {ClientEntityPropertiesCreateManyArgs} args - Arguments to create many ClientEntityProperties.
     * @example
     * // Create many ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientEntityPropertiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientEntityPropertiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientEntityProperties.
     * @param {ClientEntityPropertiesDeleteArgs} args - Arguments to delete one ClientEntityProperties.
     * @example
     * // Delete one ClientEntityProperties
     * const ClientEntityProperties = await prisma.clientEntityProperties.delete({
     *   where: {
     *     // ... filter to delete one ClientEntityProperties
     *   }
     * })
     * 
    **/
    delete<T extends ClientEntityPropertiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientEntityPropertiesDeleteArgs<ExtArgs>>
    ): Prisma__ClientEntityPropertiesClient<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClientEntityProperties.
     * @param {ClientEntityPropertiesUpdateArgs} args - Arguments to update one ClientEntityProperties.
     * @example
     * // Update one ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientEntityPropertiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientEntityPropertiesUpdateArgs<ExtArgs>>
    ): Prisma__ClientEntityPropertiesClient<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClientEntityProperties.
     * @param {ClientEntityPropertiesDeleteManyArgs} args - Arguments to filter ClientEntityProperties to delete.
     * @example
     * // Delete a few ClientEntityProperties
     * const { count } = await prisma.clientEntityProperties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientEntityPropertiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientEntityPropertiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientEntityProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityPropertiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientEntityPropertiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientEntityPropertiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientEntityProperties.
     * @param {ClientEntityPropertiesUpsertArgs} args - Arguments to update or create a ClientEntityProperties.
     * @example
     * // Update or create a ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.upsert({
     *   create: {
     *     // ... data to create a ClientEntityProperties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientEntityProperties we want to update
     *   }
     * })
    **/
    upsert<T extends ClientEntityPropertiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientEntityPropertiesUpsertArgs<ExtArgs>>
    ): Prisma__ClientEntityPropertiesClient<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClientEntityProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityPropertiesCountArgs} args - Arguments to filter ClientEntityProperties to count.
     * @example
     * // Count the number of ClientEntityProperties
     * const count = await prisma.clientEntityProperties.count({
     *   where: {
     *     // ... the filter for the ClientEntityProperties we want to count
     *   }
     * })
    **/
    count<T extends ClientEntityPropertiesCountArgs>(
      args?: Subset<T, ClientEntityPropertiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientEntityPropertiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientEntityProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityPropertiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientEntityPropertiesAggregateArgs>(args: Subset<T, ClientEntityPropertiesAggregateArgs>): Prisma.PrismaPromise<GetClientEntityPropertiesAggregateType<T>>

    /**
     * Group by ClientEntityProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityPropertiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientEntityPropertiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientEntityPropertiesGroupByArgs['orderBy'] }
        : { orderBy?: ClientEntityPropertiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientEntityPropertiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientEntityPropertiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientEntityProperties model
   */
  readonly fields: ClientEntityPropertiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientEntityProperties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientEntityPropertiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client<T extends ClientEntityProperties$clientArgs<ExtArgs> = {}>(args?: Subset<T, ClientEntityProperties$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClientEntityProperties model
   */ 
  interface ClientEntityPropertiesFieldRefs {
    readonly id: FieldRef<"ClientEntityProperties", 'Int'>
    readonly kpp: FieldRef<"ClientEntityProperties", 'String'>
    readonly created_at: FieldRef<"ClientEntityProperties", 'DateTime'>
    readonly updated_at: FieldRef<"ClientEntityProperties", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientEntityProperties findUnique
   */
  export type ClientEntityPropertiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientEntityProperties to fetch.
     */
    where: ClientEntityPropertiesWhereUniqueInput
  }

  /**
   * ClientEntityProperties findUniqueOrThrow
   */
  export type ClientEntityPropertiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientEntityProperties to fetch.
     */
    where: ClientEntityPropertiesWhereUniqueInput
  }

  /**
   * ClientEntityProperties findFirst
   */
  export type ClientEntityPropertiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientEntityProperties to fetch.
     */
    where?: ClientEntityPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEntityProperties to fetch.
     */
    orderBy?: ClientEntityPropertiesOrderByWithRelationInput | ClientEntityPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientEntityProperties.
     */
    cursor?: ClientEntityPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEntityProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEntityProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientEntityProperties.
     */
    distinct?: ClientEntityPropertiesScalarFieldEnum | ClientEntityPropertiesScalarFieldEnum[]
  }

  /**
   * ClientEntityProperties findFirstOrThrow
   */
  export type ClientEntityPropertiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientEntityProperties to fetch.
     */
    where?: ClientEntityPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEntityProperties to fetch.
     */
    orderBy?: ClientEntityPropertiesOrderByWithRelationInput | ClientEntityPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientEntityProperties.
     */
    cursor?: ClientEntityPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEntityProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEntityProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientEntityProperties.
     */
    distinct?: ClientEntityPropertiesScalarFieldEnum | ClientEntityPropertiesScalarFieldEnum[]
  }

  /**
   * ClientEntityProperties findMany
   */
  export type ClientEntityPropertiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientEntityProperties to fetch.
     */
    where?: ClientEntityPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEntityProperties to fetch.
     */
    orderBy?: ClientEntityPropertiesOrderByWithRelationInput | ClientEntityPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientEntityProperties.
     */
    cursor?: ClientEntityPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEntityProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEntityProperties.
     */
    skip?: number
    distinct?: ClientEntityPropertiesScalarFieldEnum | ClientEntityPropertiesScalarFieldEnum[]
  }

  /**
   * ClientEntityProperties create
   */
  export type ClientEntityPropertiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientEntityProperties.
     */
    data: XOR<ClientEntityPropertiesCreateInput, ClientEntityPropertiesUncheckedCreateInput>
  }

  /**
   * ClientEntityProperties createMany
   */
  export type ClientEntityPropertiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientEntityProperties.
     */
    data: ClientEntityPropertiesCreateManyInput | ClientEntityPropertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientEntityProperties update
   */
  export type ClientEntityPropertiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientEntityProperties.
     */
    data: XOR<ClientEntityPropertiesUpdateInput, ClientEntityPropertiesUncheckedUpdateInput>
    /**
     * Choose, which ClientEntityProperties to update.
     */
    where: ClientEntityPropertiesWhereUniqueInput
  }

  /**
   * ClientEntityProperties updateMany
   */
  export type ClientEntityPropertiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientEntityProperties.
     */
    data: XOR<ClientEntityPropertiesUpdateManyMutationInput, ClientEntityPropertiesUncheckedUpdateManyInput>
    /**
     * Filter which ClientEntityProperties to update
     */
    where?: ClientEntityPropertiesWhereInput
  }

  /**
   * ClientEntityProperties upsert
   */
  export type ClientEntityPropertiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientEntityProperties to update in case it exists.
     */
    where: ClientEntityPropertiesWhereUniqueInput
    /**
     * In case the ClientEntityProperties found by the `where` argument doesn't exist, create a new ClientEntityProperties with this data.
     */
    create: XOR<ClientEntityPropertiesCreateInput, ClientEntityPropertiesUncheckedCreateInput>
    /**
     * In case the ClientEntityProperties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientEntityPropertiesUpdateInput, ClientEntityPropertiesUncheckedUpdateInput>
  }

  /**
   * ClientEntityProperties delete
   */
  export type ClientEntityPropertiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    /**
     * Filter which ClientEntityProperties to delete.
     */
    where: ClientEntityPropertiesWhereUniqueInput
  }

  /**
   * ClientEntityProperties deleteMany
   */
  export type ClientEntityPropertiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientEntityProperties to delete
     */
    where?: ClientEntityPropertiesWhereInput
  }

  /**
   * ClientEntityProperties.client
   */
  export type ClientEntityProperties$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * ClientEntityProperties without action
   */
  export type ClientEntityPropertiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
  }


  /**
   * Model ClientToClientIndividualMinorProperties
   */

  export type AggregateClientToClientIndividualMinorProperties = {
    _count: ClientToClientIndividualMinorPropertiesCountAggregateOutputType | null
    _avg: ClientToClientIndividualMinorPropertiesAvgAggregateOutputType | null
    _sum: ClientToClientIndividualMinorPropertiesSumAggregateOutputType | null
    _min: ClientToClientIndividualMinorPropertiesMinAggregateOutputType | null
    _max: ClientToClientIndividualMinorPropertiesMaxAggregateOutputType | null
  }

  export type ClientToClientIndividualMinorPropertiesAvgAggregateOutputType = {
    client_id: number | null
    client_individual_minor_properties_id: number | null
  }

  export type ClientToClientIndividualMinorPropertiesSumAggregateOutputType = {
    client_id: number | null
    client_individual_minor_properties_id: number | null
  }

  export type ClientToClientIndividualMinorPropertiesMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    client_id: number | null
    client_individual_minor_properties_id: number | null
  }

  export type ClientToClientIndividualMinorPropertiesMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    client_id: number | null
    client_individual_minor_properties_id: number | null
  }

  export type ClientToClientIndividualMinorPropertiesCountAggregateOutputType = {
    created_at: number
    updated_at: number
    client_id: number
    client_individual_minor_properties_id: number
    _all: number
  }


  export type ClientToClientIndividualMinorPropertiesAvgAggregateInputType = {
    client_id?: true
    client_individual_minor_properties_id?: true
  }

  export type ClientToClientIndividualMinorPropertiesSumAggregateInputType = {
    client_id?: true
    client_individual_minor_properties_id?: true
  }

  export type ClientToClientIndividualMinorPropertiesMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    client_id?: true
    client_individual_minor_properties_id?: true
  }

  export type ClientToClientIndividualMinorPropertiesMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    client_id?: true
    client_individual_minor_properties_id?: true
  }

  export type ClientToClientIndividualMinorPropertiesCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    client_id?: true
    client_individual_minor_properties_id?: true
    _all?: true
  }

  export type ClientToClientIndividualMinorPropertiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientToClientIndividualMinorProperties to aggregate.
     */
    where?: ClientToClientIndividualMinorPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientToClientIndividualMinorProperties to fetch.
     */
    orderBy?: ClientToClientIndividualMinorPropertiesOrderByWithRelationInput | ClientToClientIndividualMinorPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientToClientIndividualMinorProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientToClientIndividualMinorProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientToClientIndividualMinorProperties
    **/
    _count?: true | ClientToClientIndividualMinorPropertiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientToClientIndividualMinorPropertiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientToClientIndividualMinorPropertiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientToClientIndividualMinorPropertiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientToClientIndividualMinorPropertiesMaxAggregateInputType
  }

  export type GetClientToClientIndividualMinorPropertiesAggregateType<T extends ClientToClientIndividualMinorPropertiesAggregateArgs> = {
        [P in keyof T & keyof AggregateClientToClientIndividualMinorProperties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientToClientIndividualMinorProperties[P]>
      : GetScalarType<T[P], AggregateClientToClientIndividualMinorProperties[P]>
  }




  export type ClientToClientIndividualMinorPropertiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientToClientIndividualMinorPropertiesWhereInput
    orderBy?: ClientToClientIndividualMinorPropertiesOrderByWithAggregationInput | ClientToClientIndividualMinorPropertiesOrderByWithAggregationInput[]
    by: ClientToClientIndividualMinorPropertiesScalarFieldEnum[] | ClientToClientIndividualMinorPropertiesScalarFieldEnum
    having?: ClientToClientIndividualMinorPropertiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientToClientIndividualMinorPropertiesCountAggregateInputType | true
    _avg?: ClientToClientIndividualMinorPropertiesAvgAggregateInputType
    _sum?: ClientToClientIndividualMinorPropertiesSumAggregateInputType
    _min?: ClientToClientIndividualMinorPropertiesMinAggregateInputType
    _max?: ClientToClientIndividualMinorPropertiesMaxAggregateInputType
  }

  export type ClientToClientIndividualMinorPropertiesGroupByOutputType = {
    created_at: Date
    updated_at: Date
    client_id: number
    client_individual_minor_properties_id: number
    _count: ClientToClientIndividualMinorPropertiesCountAggregateOutputType | null
    _avg: ClientToClientIndividualMinorPropertiesAvgAggregateOutputType | null
    _sum: ClientToClientIndividualMinorPropertiesSumAggregateOutputType | null
    _min: ClientToClientIndividualMinorPropertiesMinAggregateOutputType | null
    _max: ClientToClientIndividualMinorPropertiesMaxAggregateOutputType | null
  }

  type GetClientToClientIndividualMinorPropertiesGroupByPayload<T extends ClientToClientIndividualMinorPropertiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientToClientIndividualMinorPropertiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientToClientIndividualMinorPropertiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientToClientIndividualMinorPropertiesGroupByOutputType[P]>
            : GetScalarType<T[P], ClientToClientIndividualMinorPropertiesGroupByOutputType[P]>
        }
      >
    >


  export type ClientToClientIndividualMinorPropertiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    client_id?: boolean
    client_individual_minor_properties_id?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    client_individual_minor_properties?: boolean | ClientIndividualMinorPropertiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientToClientIndividualMinorProperties"]>


  export type ClientToClientIndividualMinorPropertiesSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    client_id?: boolean
    client_individual_minor_properties_id?: boolean
  }

  export type ClientToClientIndividualMinorPropertiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    client_individual_minor_properties?: boolean | ClientIndividualMinorPropertiesDefaultArgs<ExtArgs>
  }

  export type $ClientToClientIndividualMinorPropertiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientToClientIndividualMinorProperties"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      client_individual_minor_properties: Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      created_at: Date
      updated_at: Date
      client_id: number
      client_individual_minor_properties_id: number
    }, ExtArgs["result"]["clientToClientIndividualMinorProperties"]>
    composites: {}
  }

  type ClientToClientIndividualMinorPropertiesGetPayload<S extends boolean | null | undefined | ClientToClientIndividualMinorPropertiesDefaultArgs> = $Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload, S>

  type ClientToClientIndividualMinorPropertiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientToClientIndividualMinorPropertiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientToClientIndividualMinorPropertiesCountAggregateInputType | true
    }

  export interface ClientToClientIndividualMinorPropertiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientToClientIndividualMinorProperties'], meta: { name: 'ClientToClientIndividualMinorProperties' } }
    /**
     * Find zero or one ClientToClientIndividualMinorProperties that matches the filter.
     * @param {ClientToClientIndividualMinorPropertiesFindUniqueArgs} args - Arguments to find a ClientToClientIndividualMinorProperties
     * @example
     * // Get one ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientToClientIndividualMinorPropertiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientToClientIndividualMinorPropertiesFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientToClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClientToClientIndividualMinorProperties that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientToClientIndividualMinorPropertiesFindUniqueOrThrowArgs} args - Arguments to find a ClientToClientIndividualMinorProperties
     * @example
     * // Get one ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientToClientIndividualMinorPropertiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientToClientIndividualMinorPropertiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientToClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClientToClientIndividualMinorProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientToClientIndividualMinorPropertiesFindFirstArgs} args - Arguments to find a ClientToClientIndividualMinorProperties
     * @example
     * // Get one ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientToClientIndividualMinorPropertiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientToClientIndividualMinorPropertiesFindFirstArgs<ExtArgs>>
    ): Prisma__ClientToClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClientToClientIndividualMinorProperties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientToClientIndividualMinorPropertiesFindFirstOrThrowArgs} args - Arguments to find a ClientToClientIndividualMinorProperties
     * @example
     * // Get one ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientToClientIndividualMinorPropertiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientToClientIndividualMinorPropertiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientToClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClientToClientIndividualMinorProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientToClientIndividualMinorPropertiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.findMany()
     * 
     * // Get first 10 ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const clientToClientIndividualMinorPropertiesWithCreated_atOnly = await prisma.clientToClientIndividualMinorProperties.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends ClientToClientIndividualMinorPropertiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientToClientIndividualMinorPropertiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClientToClientIndividualMinorProperties.
     * @param {ClientToClientIndividualMinorPropertiesCreateArgs} args - Arguments to create a ClientToClientIndividualMinorProperties.
     * @example
     * // Create one ClientToClientIndividualMinorProperties
     * const ClientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.create({
     *   data: {
     *     // ... data to create a ClientToClientIndividualMinorProperties
     *   }
     * })
     * 
    **/
    create<T extends ClientToClientIndividualMinorPropertiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientToClientIndividualMinorPropertiesCreateArgs<ExtArgs>>
    ): Prisma__ClientToClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClientToClientIndividualMinorProperties.
     * @param {ClientToClientIndividualMinorPropertiesCreateManyArgs} args - Arguments to create many ClientToClientIndividualMinorProperties.
     * @example
     * // Create many ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientToClientIndividualMinorPropertiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientToClientIndividualMinorPropertiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientToClientIndividualMinorProperties.
     * @param {ClientToClientIndividualMinorPropertiesDeleteArgs} args - Arguments to delete one ClientToClientIndividualMinorProperties.
     * @example
     * // Delete one ClientToClientIndividualMinorProperties
     * const ClientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.delete({
     *   where: {
     *     // ... filter to delete one ClientToClientIndividualMinorProperties
     *   }
     * })
     * 
    **/
    delete<T extends ClientToClientIndividualMinorPropertiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientToClientIndividualMinorPropertiesDeleteArgs<ExtArgs>>
    ): Prisma__ClientToClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClientToClientIndividualMinorProperties.
     * @param {ClientToClientIndividualMinorPropertiesUpdateArgs} args - Arguments to update one ClientToClientIndividualMinorProperties.
     * @example
     * // Update one ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientToClientIndividualMinorPropertiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientToClientIndividualMinorPropertiesUpdateArgs<ExtArgs>>
    ): Prisma__ClientToClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClientToClientIndividualMinorProperties.
     * @param {ClientToClientIndividualMinorPropertiesDeleteManyArgs} args - Arguments to filter ClientToClientIndividualMinorProperties to delete.
     * @example
     * // Delete a few ClientToClientIndividualMinorProperties
     * const { count } = await prisma.clientToClientIndividualMinorProperties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientToClientIndividualMinorPropertiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientToClientIndividualMinorPropertiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientToClientIndividualMinorProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientToClientIndividualMinorPropertiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientToClientIndividualMinorPropertiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientToClientIndividualMinorPropertiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientToClientIndividualMinorProperties.
     * @param {ClientToClientIndividualMinorPropertiesUpsertArgs} args - Arguments to update or create a ClientToClientIndividualMinorProperties.
     * @example
     * // Update or create a ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.upsert({
     *   create: {
     *     // ... data to create a ClientToClientIndividualMinorProperties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientToClientIndividualMinorProperties we want to update
     *   }
     * })
    **/
    upsert<T extends ClientToClientIndividualMinorPropertiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientToClientIndividualMinorPropertiesUpsertArgs<ExtArgs>>
    ): Prisma__ClientToClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClientToClientIndividualMinorProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientToClientIndividualMinorPropertiesCountArgs} args - Arguments to filter ClientToClientIndividualMinorProperties to count.
     * @example
     * // Count the number of ClientToClientIndividualMinorProperties
     * const count = await prisma.clientToClientIndividualMinorProperties.count({
     *   where: {
     *     // ... the filter for the ClientToClientIndividualMinorProperties we want to count
     *   }
     * })
    **/
    count<T extends ClientToClientIndividualMinorPropertiesCountArgs>(
      args?: Subset<T, ClientToClientIndividualMinorPropertiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientToClientIndividualMinorPropertiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientToClientIndividualMinorProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientToClientIndividualMinorPropertiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientToClientIndividualMinorPropertiesAggregateArgs>(args: Subset<T, ClientToClientIndividualMinorPropertiesAggregateArgs>): Prisma.PrismaPromise<GetClientToClientIndividualMinorPropertiesAggregateType<T>>

    /**
     * Group by ClientToClientIndividualMinorProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientToClientIndividualMinorPropertiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientToClientIndividualMinorPropertiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientToClientIndividualMinorPropertiesGroupByArgs['orderBy'] }
        : { orderBy?: ClientToClientIndividualMinorPropertiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientToClientIndividualMinorPropertiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientToClientIndividualMinorPropertiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientToClientIndividualMinorProperties model
   */
  readonly fields: ClientToClientIndividualMinorPropertiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientToClientIndividualMinorProperties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientToClientIndividualMinorPropertiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    client_individual_minor_properties<T extends ClientIndividualMinorPropertiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientIndividualMinorPropertiesDefaultArgs<ExtArgs>>): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClientToClientIndividualMinorProperties model
   */ 
  interface ClientToClientIndividualMinorPropertiesFieldRefs {
    readonly created_at: FieldRef<"ClientToClientIndividualMinorProperties", 'DateTime'>
    readonly updated_at: FieldRef<"ClientToClientIndividualMinorProperties", 'DateTime'>
    readonly client_id: FieldRef<"ClientToClientIndividualMinorProperties", 'Int'>
    readonly client_individual_minor_properties_id: FieldRef<"ClientToClientIndividualMinorProperties", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClientToClientIndividualMinorProperties findUnique
   */
  export type ClientToClientIndividualMinorPropertiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientToClientIndividualMinorProperties to fetch.
     */
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
  }

  /**
   * ClientToClientIndividualMinorProperties findUniqueOrThrow
   */
  export type ClientToClientIndividualMinorPropertiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientToClientIndividualMinorProperties to fetch.
     */
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
  }

  /**
   * ClientToClientIndividualMinorProperties findFirst
   */
  export type ClientToClientIndividualMinorPropertiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientToClientIndividualMinorProperties to fetch.
     */
    where?: ClientToClientIndividualMinorPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientToClientIndividualMinorProperties to fetch.
     */
    orderBy?: ClientToClientIndividualMinorPropertiesOrderByWithRelationInput | ClientToClientIndividualMinorPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientToClientIndividualMinorProperties.
     */
    cursor?: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientToClientIndividualMinorProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientToClientIndividualMinorProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientToClientIndividualMinorProperties.
     */
    distinct?: ClientToClientIndividualMinorPropertiesScalarFieldEnum | ClientToClientIndividualMinorPropertiesScalarFieldEnum[]
  }

  /**
   * ClientToClientIndividualMinorProperties findFirstOrThrow
   */
  export type ClientToClientIndividualMinorPropertiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientToClientIndividualMinorProperties to fetch.
     */
    where?: ClientToClientIndividualMinorPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientToClientIndividualMinorProperties to fetch.
     */
    orderBy?: ClientToClientIndividualMinorPropertiesOrderByWithRelationInput | ClientToClientIndividualMinorPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientToClientIndividualMinorProperties.
     */
    cursor?: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientToClientIndividualMinorProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientToClientIndividualMinorProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientToClientIndividualMinorProperties.
     */
    distinct?: ClientToClientIndividualMinorPropertiesScalarFieldEnum | ClientToClientIndividualMinorPropertiesScalarFieldEnum[]
  }

  /**
   * ClientToClientIndividualMinorProperties findMany
   */
  export type ClientToClientIndividualMinorPropertiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientToClientIndividualMinorProperties to fetch.
     */
    where?: ClientToClientIndividualMinorPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientToClientIndividualMinorProperties to fetch.
     */
    orderBy?: ClientToClientIndividualMinorPropertiesOrderByWithRelationInput | ClientToClientIndividualMinorPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientToClientIndividualMinorProperties.
     */
    cursor?: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientToClientIndividualMinorProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientToClientIndividualMinorProperties.
     */
    skip?: number
    distinct?: ClientToClientIndividualMinorPropertiesScalarFieldEnum | ClientToClientIndividualMinorPropertiesScalarFieldEnum[]
  }

  /**
   * ClientToClientIndividualMinorProperties create
   */
  export type ClientToClientIndividualMinorPropertiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientToClientIndividualMinorProperties.
     */
    data: XOR<ClientToClientIndividualMinorPropertiesCreateInput, ClientToClientIndividualMinorPropertiesUncheckedCreateInput>
  }

  /**
   * ClientToClientIndividualMinorProperties createMany
   */
  export type ClientToClientIndividualMinorPropertiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientToClientIndividualMinorProperties.
     */
    data: ClientToClientIndividualMinorPropertiesCreateManyInput | ClientToClientIndividualMinorPropertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientToClientIndividualMinorProperties update
   */
  export type ClientToClientIndividualMinorPropertiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientToClientIndividualMinorProperties.
     */
    data: XOR<ClientToClientIndividualMinorPropertiesUpdateInput, ClientToClientIndividualMinorPropertiesUncheckedUpdateInput>
    /**
     * Choose, which ClientToClientIndividualMinorProperties to update.
     */
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
  }

  /**
   * ClientToClientIndividualMinorProperties updateMany
   */
  export type ClientToClientIndividualMinorPropertiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientToClientIndividualMinorProperties.
     */
    data: XOR<ClientToClientIndividualMinorPropertiesUpdateManyMutationInput, ClientToClientIndividualMinorPropertiesUncheckedUpdateManyInput>
    /**
     * Filter which ClientToClientIndividualMinorProperties to update
     */
    where?: ClientToClientIndividualMinorPropertiesWhereInput
  }

  /**
   * ClientToClientIndividualMinorProperties upsert
   */
  export type ClientToClientIndividualMinorPropertiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientToClientIndividualMinorProperties to update in case it exists.
     */
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * In case the ClientToClientIndividualMinorProperties found by the `where` argument doesn't exist, create a new ClientToClientIndividualMinorProperties with this data.
     */
    create: XOR<ClientToClientIndividualMinorPropertiesCreateInput, ClientToClientIndividualMinorPropertiesUncheckedCreateInput>
    /**
     * In case the ClientToClientIndividualMinorProperties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientToClientIndividualMinorPropertiesUpdateInput, ClientToClientIndividualMinorPropertiesUncheckedUpdateInput>
  }

  /**
   * ClientToClientIndividualMinorProperties delete
   */
  export type ClientToClientIndividualMinorPropertiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter which ClientToClientIndividualMinorProperties to delete.
     */
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
  }

  /**
   * ClientToClientIndividualMinorProperties deleteMany
   */
  export type ClientToClientIndividualMinorPropertiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientToClientIndividualMinorProperties to delete
     */
    where?: ClientToClientIndividualMinorPropertiesWhereInput
  }

  /**
   * ClientToClientIndividualMinorProperties without action
   */
  export type ClientToClientIndividualMinorPropertiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
  }


  /**
   * Model ClientPassport
   */

  export type AggregateClientPassport = {
    _count: ClientPassportCountAggregateOutputType | null
    _avg: ClientPassportAvgAggregateOutputType | null
    _sum: ClientPassportSumAggregateOutputType | null
    _min: ClientPassportMinAggregateOutputType | null
    _max: ClientPassportMaxAggregateOutputType | null
  }

  export type ClientPassportAvgAggregateOutputType = {
    id: number | null
  }

  export type ClientPassportSumAggregateOutputType = {
    id: number | null
  }

  export type ClientPassportMinAggregateOutputType = {
    id: number | null
    number: string | null
    issued: string | null
    code: string | null
    place_of_birth: string | null
    registration_address: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientPassportMaxAggregateOutputType = {
    id: number | null
    number: string | null
    issued: string | null
    code: string | null
    place_of_birth: string | null
    registration_address: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientPassportCountAggregateOutputType = {
    id: number
    number: number
    issued: number
    code: number
    place_of_birth: number
    registration_address: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ClientPassportAvgAggregateInputType = {
    id?: true
  }

  export type ClientPassportSumAggregateInputType = {
    id?: true
  }

  export type ClientPassportMinAggregateInputType = {
    id?: true
    number?: true
    issued?: true
    code?: true
    place_of_birth?: true
    registration_address?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientPassportMaxAggregateInputType = {
    id?: true
    number?: true
    issued?: true
    code?: true
    place_of_birth?: true
    registration_address?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientPassportCountAggregateInputType = {
    id?: true
    number?: true
    issued?: true
    code?: true
    place_of_birth?: true
    registration_address?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ClientPassportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientPassport to aggregate.
     */
    where?: ClientPassportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPassports to fetch.
     */
    orderBy?: ClientPassportOrderByWithRelationInput | ClientPassportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientPassportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPassports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPassports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientPassports
    **/
    _count?: true | ClientPassportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientPassportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientPassportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientPassportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientPassportMaxAggregateInputType
  }

  export type GetClientPassportAggregateType<T extends ClientPassportAggregateArgs> = {
        [P in keyof T & keyof AggregateClientPassport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientPassport[P]>
      : GetScalarType<T[P], AggregateClientPassport[P]>
  }




  export type ClientPassportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientPassportWhereInput
    orderBy?: ClientPassportOrderByWithAggregationInput | ClientPassportOrderByWithAggregationInput[]
    by: ClientPassportScalarFieldEnum[] | ClientPassportScalarFieldEnum
    having?: ClientPassportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientPassportCountAggregateInputType | true
    _avg?: ClientPassportAvgAggregateInputType
    _sum?: ClientPassportSumAggregateInputType
    _min?: ClientPassportMinAggregateInputType
    _max?: ClientPassportMaxAggregateInputType
  }

  export type ClientPassportGroupByOutputType = {
    id: number
    number: string | null
    issued: string | null
    code: string | null
    place_of_birth: string | null
    registration_address: string | null
    created_at: Date
    updated_at: Date
    _count: ClientPassportCountAggregateOutputType | null
    _avg: ClientPassportAvgAggregateOutputType | null
    _sum: ClientPassportSumAggregateOutputType | null
    _min: ClientPassportMinAggregateOutputType | null
    _max: ClientPassportMaxAggregateOutputType | null
  }

  type GetClientPassportGroupByPayload<T extends ClientPassportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientPassportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientPassportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientPassportGroupByOutputType[P]>
            : GetScalarType<T[P], ClientPassportGroupByOutputType[P]>
        }
      >
    >


  export type ClientPassportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    issued?: boolean
    code?: boolean
    place_of_birth?: boolean
    registration_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_individual_properties?: boolean | ClientPassport$client_individual_propertiesArgs<ExtArgs>
    client_individual_minor_properties?: boolean | ClientPassport$client_individual_minor_propertiesArgs<ExtArgs>
  }, ExtArgs["result"]["clientPassport"]>


  export type ClientPassportSelectScalar = {
    id?: boolean
    number?: boolean
    issued?: boolean
    code?: boolean
    place_of_birth?: boolean
    registration_address?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ClientPassportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_individual_properties?: boolean | ClientPassport$client_individual_propertiesArgs<ExtArgs>
    client_individual_minor_properties?: boolean | ClientPassport$client_individual_minor_propertiesArgs<ExtArgs>
  }

  export type $ClientPassportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientPassport"
    objects: {
      client_individual_properties: Prisma.$ClientIndividualPropertiesPayload<ExtArgs> | null
      client_individual_minor_properties: Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      number: string | null
      issued: string | null
      code: string | null
      place_of_birth: string | null
      registration_address: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["clientPassport"]>
    composites: {}
  }

  type ClientPassportGetPayload<S extends boolean | null | undefined | ClientPassportDefaultArgs> = $Result.GetResult<Prisma.$ClientPassportPayload, S>

  type ClientPassportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientPassportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientPassportCountAggregateInputType | true
    }

  export interface ClientPassportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientPassport'], meta: { name: 'ClientPassport' } }
    /**
     * Find zero or one ClientPassport that matches the filter.
     * @param {ClientPassportFindUniqueArgs} args - Arguments to find a ClientPassport
     * @example
     * // Get one ClientPassport
     * const clientPassport = await prisma.clientPassport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientPassportFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientPassportFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClientPassport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientPassportFindUniqueOrThrowArgs} args - Arguments to find a ClientPassport
     * @example
     * // Get one ClientPassport
     * const clientPassport = await prisma.clientPassport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientPassportFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientPassportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClientPassport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPassportFindFirstArgs} args - Arguments to find a ClientPassport
     * @example
     * // Get one ClientPassport
     * const clientPassport = await prisma.clientPassport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientPassportFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientPassportFindFirstArgs<ExtArgs>>
    ): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClientPassport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPassportFindFirstOrThrowArgs} args - Arguments to find a ClientPassport
     * @example
     * // Get one ClientPassport
     * const clientPassport = await prisma.clientPassport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientPassportFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientPassportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClientPassports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPassportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientPassports
     * const clientPassports = await prisma.clientPassport.findMany()
     * 
     * // Get first 10 ClientPassports
     * const clientPassports = await prisma.clientPassport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientPassportWithIdOnly = await prisma.clientPassport.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientPassportFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientPassportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClientPassport.
     * @param {ClientPassportCreateArgs} args - Arguments to create a ClientPassport.
     * @example
     * // Create one ClientPassport
     * const ClientPassport = await prisma.clientPassport.create({
     *   data: {
     *     // ... data to create a ClientPassport
     *   }
     * })
     * 
    **/
    create<T extends ClientPassportCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientPassportCreateArgs<ExtArgs>>
    ): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClientPassports.
     * @param {ClientPassportCreateManyArgs} args - Arguments to create many ClientPassports.
     * @example
     * // Create many ClientPassports
     * const clientPassport = await prisma.clientPassport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientPassportCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientPassportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientPassport.
     * @param {ClientPassportDeleteArgs} args - Arguments to delete one ClientPassport.
     * @example
     * // Delete one ClientPassport
     * const ClientPassport = await prisma.clientPassport.delete({
     *   where: {
     *     // ... filter to delete one ClientPassport
     *   }
     * })
     * 
    **/
    delete<T extends ClientPassportDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientPassportDeleteArgs<ExtArgs>>
    ): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClientPassport.
     * @param {ClientPassportUpdateArgs} args - Arguments to update one ClientPassport.
     * @example
     * // Update one ClientPassport
     * const clientPassport = await prisma.clientPassport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientPassportUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientPassportUpdateArgs<ExtArgs>>
    ): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClientPassports.
     * @param {ClientPassportDeleteManyArgs} args - Arguments to filter ClientPassports to delete.
     * @example
     * // Delete a few ClientPassports
     * const { count } = await prisma.clientPassport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientPassportDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientPassportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientPassports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPassportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientPassports
     * const clientPassport = await prisma.clientPassport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientPassportUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientPassportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientPassport.
     * @param {ClientPassportUpsertArgs} args - Arguments to update or create a ClientPassport.
     * @example
     * // Update or create a ClientPassport
     * const clientPassport = await prisma.clientPassport.upsert({
     *   create: {
     *     // ... data to create a ClientPassport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientPassport we want to update
     *   }
     * })
    **/
    upsert<T extends ClientPassportUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientPassportUpsertArgs<ExtArgs>>
    ): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClientPassports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPassportCountArgs} args - Arguments to filter ClientPassports to count.
     * @example
     * // Count the number of ClientPassports
     * const count = await prisma.clientPassport.count({
     *   where: {
     *     // ... the filter for the ClientPassports we want to count
     *   }
     * })
    **/
    count<T extends ClientPassportCountArgs>(
      args?: Subset<T, ClientPassportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientPassportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientPassport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPassportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientPassportAggregateArgs>(args: Subset<T, ClientPassportAggregateArgs>): Prisma.PrismaPromise<GetClientPassportAggregateType<T>>

    /**
     * Group by ClientPassport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPassportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientPassportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientPassportGroupByArgs['orderBy'] }
        : { orderBy?: ClientPassportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientPassportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientPassportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientPassport model
   */
  readonly fields: ClientPassportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientPassport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientPassportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client_individual_properties<T extends ClientPassport$client_individual_propertiesArgs<ExtArgs> = {}>(args?: Subset<T, ClientPassport$client_individual_propertiesArgs<ExtArgs>>): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    client_individual_minor_properties<T extends ClientPassport$client_individual_minor_propertiesArgs<ExtArgs> = {}>(args?: Subset<T, ClientPassport$client_individual_minor_propertiesArgs<ExtArgs>>): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClientPassport model
   */ 
  interface ClientPassportFieldRefs {
    readonly id: FieldRef<"ClientPassport", 'Int'>
    readonly number: FieldRef<"ClientPassport", 'String'>
    readonly issued: FieldRef<"ClientPassport", 'String'>
    readonly code: FieldRef<"ClientPassport", 'String'>
    readonly place_of_birth: FieldRef<"ClientPassport", 'String'>
    readonly registration_address: FieldRef<"ClientPassport", 'String'>
    readonly created_at: FieldRef<"ClientPassport", 'DateTime'>
    readonly updated_at: FieldRef<"ClientPassport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientPassport findUnique
   */
  export type ClientPassportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    /**
     * Filter, which ClientPassport to fetch.
     */
    where: ClientPassportWhereUniqueInput
  }

  /**
   * ClientPassport findUniqueOrThrow
   */
  export type ClientPassportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    /**
     * Filter, which ClientPassport to fetch.
     */
    where: ClientPassportWhereUniqueInput
  }

  /**
   * ClientPassport findFirst
   */
  export type ClientPassportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    /**
     * Filter, which ClientPassport to fetch.
     */
    where?: ClientPassportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPassports to fetch.
     */
    orderBy?: ClientPassportOrderByWithRelationInput | ClientPassportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientPassports.
     */
    cursor?: ClientPassportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPassports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPassports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientPassports.
     */
    distinct?: ClientPassportScalarFieldEnum | ClientPassportScalarFieldEnum[]
  }

  /**
   * ClientPassport findFirstOrThrow
   */
  export type ClientPassportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    /**
     * Filter, which ClientPassport to fetch.
     */
    where?: ClientPassportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPassports to fetch.
     */
    orderBy?: ClientPassportOrderByWithRelationInput | ClientPassportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientPassports.
     */
    cursor?: ClientPassportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPassports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPassports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientPassports.
     */
    distinct?: ClientPassportScalarFieldEnum | ClientPassportScalarFieldEnum[]
  }

  /**
   * ClientPassport findMany
   */
  export type ClientPassportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    /**
     * Filter, which ClientPassports to fetch.
     */
    where?: ClientPassportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPassports to fetch.
     */
    orderBy?: ClientPassportOrderByWithRelationInput | ClientPassportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientPassports.
     */
    cursor?: ClientPassportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPassports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPassports.
     */
    skip?: number
    distinct?: ClientPassportScalarFieldEnum | ClientPassportScalarFieldEnum[]
  }

  /**
   * ClientPassport create
   */
  export type ClientPassportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientPassport.
     */
    data: XOR<ClientPassportCreateInput, ClientPassportUncheckedCreateInput>
  }

  /**
   * ClientPassport createMany
   */
  export type ClientPassportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientPassports.
     */
    data: ClientPassportCreateManyInput | ClientPassportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientPassport update
   */
  export type ClientPassportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientPassport.
     */
    data: XOR<ClientPassportUpdateInput, ClientPassportUncheckedUpdateInput>
    /**
     * Choose, which ClientPassport to update.
     */
    where: ClientPassportWhereUniqueInput
  }

  /**
   * ClientPassport updateMany
   */
  export type ClientPassportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientPassports.
     */
    data: XOR<ClientPassportUpdateManyMutationInput, ClientPassportUncheckedUpdateManyInput>
    /**
     * Filter which ClientPassports to update
     */
    where?: ClientPassportWhereInput
  }

  /**
   * ClientPassport upsert
   */
  export type ClientPassportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientPassport to update in case it exists.
     */
    where: ClientPassportWhereUniqueInput
    /**
     * In case the ClientPassport found by the `where` argument doesn't exist, create a new ClientPassport with this data.
     */
    create: XOR<ClientPassportCreateInput, ClientPassportUncheckedCreateInput>
    /**
     * In case the ClientPassport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientPassportUpdateInput, ClientPassportUncheckedUpdateInput>
  }

  /**
   * ClientPassport delete
   */
  export type ClientPassportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    /**
     * Filter which ClientPassport to delete.
     */
    where: ClientPassportWhereUniqueInput
  }

  /**
   * ClientPassport deleteMany
   */
  export type ClientPassportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientPassports to delete
     */
    where?: ClientPassportWhereInput
  }

  /**
   * ClientPassport.client_individual_properties
   */
  export type ClientPassport$client_individual_propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    where?: ClientIndividualPropertiesWhereInput
  }

  /**
   * ClientPassport.client_individual_minor_properties
   */
  export type ClientPassport$client_individual_minor_propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    where?: ClientIndividualMinorPropertiesWhereInput
  }

  /**
   * ClientPassport without action
   */
  export type ClientPassportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
  }


  /**
   * Model ClientContract
   */

  export type AggregateClientContract = {
    _count: ClientContractCountAggregateOutputType | null
    _avg: ClientContractAvgAggregateOutputType | null
    _sum: ClientContractSumAggregateOutputType | null
    _min: ClientContractMinAggregateOutputType | null
    _max: ClientContractMaxAggregateOutputType | null
  }

  export type ClientContractAvgAggregateOutputType = {
    id: number | null
    price: Decimal | null
    object_id: number | null
    product_id: number | null
    real_estate_agent_id: number | null
    manager_id: number | null
    bank_id: number | null
    ddu_client_contract_properties_id: number | null
  }

  export type ClientContractSumAggregateOutputType = {
    id: number | null
    price: Decimal | null
    object_id: number | null
    product_id: number | null
    real_estate_agent_id: number | null
    manager_id: number | null
    bank_id: number | null
    ddu_client_contract_properties_id: number | null
  }

  export type ClientContractMinAggregateOutputType = {
    id: number | null
    number: string | null
    date: Date | null
    registration_date: Date | null
    price: Decimal | null
    client_contract_type: $Enums.ClientContractType | null
    created_at: Date | null
    updated_at: Date | null
    object_id: number | null
    product_id: number | null
    real_estate_agent_id: number | null
    manager_id: number | null
    bank_id: number | null
    ddu_client_contract_properties_id: number | null
  }

  export type ClientContractMaxAggregateOutputType = {
    id: number | null
    number: string | null
    date: Date | null
    registration_date: Date | null
    price: Decimal | null
    client_contract_type: $Enums.ClientContractType | null
    created_at: Date | null
    updated_at: Date | null
    object_id: number | null
    product_id: number | null
    real_estate_agent_id: number | null
    manager_id: number | null
    bank_id: number | null
    ddu_client_contract_properties_id: number | null
  }

  export type ClientContractCountAggregateOutputType = {
    id: number
    number: number
    date: number
    registration_date: number
    price: number
    client_contract_type: number
    created_at: number
    updated_at: number
    object_id: number
    product_id: number
    real_estate_agent_id: number
    manager_id: number
    bank_id: number
    ddu_client_contract_properties_id: number
    _all: number
  }


  export type ClientContractAvgAggregateInputType = {
    id?: true
    price?: true
    object_id?: true
    product_id?: true
    real_estate_agent_id?: true
    manager_id?: true
    bank_id?: true
    ddu_client_contract_properties_id?: true
  }

  export type ClientContractSumAggregateInputType = {
    id?: true
    price?: true
    object_id?: true
    product_id?: true
    real_estate_agent_id?: true
    manager_id?: true
    bank_id?: true
    ddu_client_contract_properties_id?: true
  }

  export type ClientContractMinAggregateInputType = {
    id?: true
    number?: true
    date?: true
    registration_date?: true
    price?: true
    client_contract_type?: true
    created_at?: true
    updated_at?: true
    object_id?: true
    product_id?: true
    real_estate_agent_id?: true
    manager_id?: true
    bank_id?: true
    ddu_client_contract_properties_id?: true
  }

  export type ClientContractMaxAggregateInputType = {
    id?: true
    number?: true
    date?: true
    registration_date?: true
    price?: true
    client_contract_type?: true
    created_at?: true
    updated_at?: true
    object_id?: true
    product_id?: true
    real_estate_agent_id?: true
    manager_id?: true
    bank_id?: true
    ddu_client_contract_properties_id?: true
  }

  export type ClientContractCountAggregateInputType = {
    id?: true
    number?: true
    date?: true
    registration_date?: true
    price?: true
    client_contract_type?: true
    created_at?: true
    updated_at?: true
    object_id?: true
    product_id?: true
    real_estate_agent_id?: true
    manager_id?: true
    bank_id?: true
    ddu_client_contract_properties_id?: true
    _all?: true
  }

  export type ClientContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientContract to aggregate.
     */
    where?: ClientContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContracts to fetch.
     */
    orderBy?: ClientContractOrderByWithRelationInput | ClientContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientContracts
    **/
    _count?: true | ClientContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientContractMaxAggregateInputType
  }

  export type GetClientContractAggregateType<T extends ClientContractAggregateArgs> = {
        [P in keyof T & keyof AggregateClientContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientContract[P]>
      : GetScalarType<T[P], AggregateClientContract[P]>
  }




  export type ClientContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractWhereInput
    orderBy?: ClientContractOrderByWithAggregationInput | ClientContractOrderByWithAggregationInput[]
    by: ClientContractScalarFieldEnum[] | ClientContractScalarFieldEnum
    having?: ClientContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientContractCountAggregateInputType | true
    _avg?: ClientContractAvgAggregateInputType
    _sum?: ClientContractSumAggregateInputType
    _min?: ClientContractMinAggregateInputType
    _max?: ClientContractMaxAggregateInputType
  }

  export type ClientContractGroupByOutputType = {
    id: number
    number: string
    date: Date
    registration_date: Date | null
    price: Decimal
    client_contract_type: $Enums.ClientContractType
    created_at: Date
    updated_at: Date
    object_id: number
    product_id: number
    real_estate_agent_id: number | null
    manager_id: number | null
    bank_id: number | null
    ddu_client_contract_properties_id: number | null
    _count: ClientContractCountAggregateOutputType | null
    _avg: ClientContractAvgAggregateOutputType | null
    _sum: ClientContractSumAggregateOutputType | null
    _min: ClientContractMinAggregateOutputType | null
    _max: ClientContractMaxAggregateOutputType | null
  }

  type GetClientContractGroupByPayload<T extends ClientContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientContractGroupByOutputType[P]>
            : GetScalarType<T[P], ClientContractGroupByOutputType[P]>
        }
      >
    >


  export type ClientContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    registration_date?: boolean
    price?: boolean
    client_contract_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    object_id?: boolean
    product_id?: boolean
    real_estate_agent_id?: boolean
    manager_id?: boolean
    bank_id?: boolean
    ddu_client_contract_properties_id?: boolean
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    real_estate_agent?: boolean | ClientContract$real_estate_agentArgs<ExtArgs>
    manager?: boolean | ClientContract$managerArgs<ExtArgs>
    bank?: boolean | ClientContract$bankArgs<ExtArgs>
    ddu_client_contract_properties?: boolean | ClientContract$ddu_client_contract_propertiesArgs<ExtArgs>
    clients?: boolean | ClientContract$clientsArgs<ExtArgs>
    agency_contracts?: boolean | ClientContract$agency_contractsArgs<ExtArgs>
    scheduled_payments?: boolean | ClientContract$scheduled_paymentsArgs<ExtArgs>
    actual_payment?: boolean | ClientContract$actual_paymentArgs<ExtArgs>
    _count?: boolean | ClientContractCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientContract"]>


  export type ClientContractSelectScalar = {
    id?: boolean
    number?: boolean
    date?: boolean
    registration_date?: boolean
    price?: boolean
    client_contract_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    object_id?: boolean
    product_id?: boolean
    real_estate_agent_id?: boolean
    manager_id?: boolean
    bank_id?: boolean
    ddu_client_contract_properties_id?: boolean
  }

  export type ClientContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    real_estate_agent?: boolean | ClientContract$real_estate_agentArgs<ExtArgs>
    manager?: boolean | ClientContract$managerArgs<ExtArgs>
    bank?: boolean | ClientContract$bankArgs<ExtArgs>
    ddu_client_contract_properties?: boolean | ClientContract$ddu_client_contract_propertiesArgs<ExtArgs>
    clients?: boolean | ClientContract$clientsArgs<ExtArgs>
    agency_contracts?: boolean | ClientContract$agency_contractsArgs<ExtArgs>
    scheduled_payments?: boolean | ClientContract$scheduled_paymentsArgs<ExtArgs>
    actual_payment?: boolean | ClientContract$actual_paymentArgs<ExtArgs>
    _count?: boolean | ClientContractCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClientContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientContract"
    objects: {
      object: Prisma.$ObjectPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      real_estate_agent: Prisma.$RealEstateAgentPayload<ExtArgs> | null
      manager: Prisma.$UserPayload<ExtArgs> | null
      bank: Prisma.$BankPayload<ExtArgs> | null
      ddu_client_contract_properties: Prisma.$DDUClientContractPropertiesPayload<ExtArgs> | null
      clients: Prisma.$ClientContractToClientPayload<ExtArgs>[]
      agency_contracts: Prisma.$ClientContractToAgencyContractPayload<ExtArgs>[]
      scheduled_payments: Prisma.$ScheduledPaymentPayload<ExtArgs>[]
      actual_payment: Prisma.$ActualPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      number: string
      date: Date
      registration_date: Date | null
      price: Prisma.Decimal
      client_contract_type: $Enums.ClientContractType
      created_at: Date
      updated_at: Date
      object_id: number
      product_id: number
      real_estate_agent_id: number | null
      manager_id: number | null
      bank_id: number | null
      ddu_client_contract_properties_id: number | null
    }, ExtArgs["result"]["clientContract"]>
    composites: {}
  }

  type ClientContractGetPayload<S extends boolean | null | undefined | ClientContractDefaultArgs> = $Result.GetResult<Prisma.$ClientContractPayload, S>

  type ClientContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientContractFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientContractCountAggregateInputType | true
    }

  export interface ClientContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientContract'], meta: { name: 'ClientContract' } }
    /**
     * Find zero or one ClientContract that matches the filter.
     * @param {ClientContractFindUniqueArgs} args - Arguments to find a ClientContract
     * @example
     * // Get one ClientContract
     * const clientContract = await prisma.clientContract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientContractFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClientContract that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientContractFindUniqueOrThrowArgs} args - Arguments to find a ClientContract
     * @example
     * // Get one ClientContract
     * const clientContract = await prisma.clientContract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientContractFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClientContract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractFindFirstArgs} args - Arguments to find a ClientContract
     * @example
     * // Get one ClientContract
     * const clientContract = await prisma.clientContract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientContractFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractFindFirstArgs<ExtArgs>>
    ): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClientContract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractFindFirstOrThrowArgs} args - Arguments to find a ClientContract
     * @example
     * // Get one ClientContract
     * const clientContract = await prisma.clientContract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientContractFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClientContracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientContracts
     * const clientContracts = await prisma.clientContract.findMany()
     * 
     * // Get first 10 ClientContracts
     * const clientContracts = await prisma.clientContract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientContractWithIdOnly = await prisma.clientContract.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientContractFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClientContract.
     * @param {ClientContractCreateArgs} args - Arguments to create a ClientContract.
     * @example
     * // Create one ClientContract
     * const ClientContract = await prisma.clientContract.create({
     *   data: {
     *     // ... data to create a ClientContract
     *   }
     * })
     * 
    **/
    create<T extends ClientContractCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractCreateArgs<ExtArgs>>
    ): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClientContracts.
     * @param {ClientContractCreateManyArgs} args - Arguments to create many ClientContracts.
     * @example
     * // Create many ClientContracts
     * const clientContract = await prisma.clientContract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientContractCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientContract.
     * @param {ClientContractDeleteArgs} args - Arguments to delete one ClientContract.
     * @example
     * // Delete one ClientContract
     * const ClientContract = await prisma.clientContract.delete({
     *   where: {
     *     // ... filter to delete one ClientContract
     *   }
     * })
     * 
    **/
    delete<T extends ClientContractDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractDeleteArgs<ExtArgs>>
    ): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClientContract.
     * @param {ClientContractUpdateArgs} args - Arguments to update one ClientContract.
     * @example
     * // Update one ClientContract
     * const clientContract = await prisma.clientContract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientContractUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractUpdateArgs<ExtArgs>>
    ): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClientContracts.
     * @param {ClientContractDeleteManyArgs} args - Arguments to filter ClientContracts to delete.
     * @example
     * // Delete a few ClientContracts
     * const { count } = await prisma.clientContract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientContractDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientContracts
     * const clientContract = await prisma.clientContract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientContractUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientContract.
     * @param {ClientContractUpsertArgs} args - Arguments to update or create a ClientContract.
     * @example
     * // Update or create a ClientContract
     * const clientContract = await prisma.clientContract.upsert({
     *   create: {
     *     // ... data to create a ClientContract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientContract we want to update
     *   }
     * })
    **/
    upsert<T extends ClientContractUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractUpsertArgs<ExtArgs>>
    ): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClientContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractCountArgs} args - Arguments to filter ClientContracts to count.
     * @example
     * // Count the number of ClientContracts
     * const count = await prisma.clientContract.count({
     *   where: {
     *     // ... the filter for the ClientContracts we want to count
     *   }
     * })
    **/
    count<T extends ClientContractCountArgs>(
      args?: Subset<T, ClientContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientContractAggregateArgs>(args: Subset<T, ClientContractAggregateArgs>): Prisma.PrismaPromise<GetClientContractAggregateType<T>>

    /**
     * Group by ClientContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientContractGroupByArgs['orderBy'] }
        : { orderBy?: ClientContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientContract model
   */
  readonly fields: ClientContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientContract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    object<T extends ObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectDefaultArgs<ExtArgs>>): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    real_estate_agent<T extends ClientContract$real_estate_agentArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$real_estate_agentArgs<ExtArgs>>): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    manager<T extends ClientContract$managerArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    bank<T extends ClientContract$bankArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$bankArgs<ExtArgs>>): Prisma__BankClient<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    ddu_client_contract_properties<T extends ClientContract$ddu_client_contract_propertiesArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$ddu_client_contract_propertiesArgs<ExtArgs>>): Prisma__DDUClientContractPropertiesClient<$Result.GetResult<Prisma.$DDUClientContractPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    clients<T extends ClientContract$clientsArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'findMany'> | Null>;

    agency_contracts<T extends ClientContract$agency_contractsArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$agency_contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    scheduled_payments<T extends ClientContract$scheduled_paymentsArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$scheduled_paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    actual_payment<T extends ClientContract$actual_paymentArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$actual_paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClientContract model
   */ 
  interface ClientContractFieldRefs {
    readonly id: FieldRef<"ClientContract", 'Int'>
    readonly number: FieldRef<"ClientContract", 'String'>
    readonly date: FieldRef<"ClientContract", 'DateTime'>
    readonly registration_date: FieldRef<"ClientContract", 'DateTime'>
    readonly price: FieldRef<"ClientContract", 'Decimal'>
    readonly client_contract_type: FieldRef<"ClientContract", 'ClientContractType'>
    readonly created_at: FieldRef<"ClientContract", 'DateTime'>
    readonly updated_at: FieldRef<"ClientContract", 'DateTime'>
    readonly object_id: FieldRef<"ClientContract", 'Int'>
    readonly product_id: FieldRef<"ClientContract", 'Int'>
    readonly real_estate_agent_id: FieldRef<"ClientContract", 'Int'>
    readonly manager_id: FieldRef<"ClientContract", 'Int'>
    readonly bank_id: FieldRef<"ClientContract", 'Int'>
    readonly ddu_client_contract_properties_id: FieldRef<"ClientContract", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClientContract findUnique
   */
  export type ClientContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContract to fetch.
     */
    where: ClientContractWhereUniqueInput
  }

  /**
   * ClientContract findUniqueOrThrow
   */
  export type ClientContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContract to fetch.
     */
    where: ClientContractWhereUniqueInput
  }

  /**
   * ClientContract findFirst
   */
  export type ClientContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContract to fetch.
     */
    where?: ClientContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContracts to fetch.
     */
    orderBy?: ClientContractOrderByWithRelationInput | ClientContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientContracts.
     */
    cursor?: ClientContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientContracts.
     */
    distinct?: ClientContractScalarFieldEnum | ClientContractScalarFieldEnum[]
  }

  /**
   * ClientContract findFirstOrThrow
   */
  export type ClientContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContract to fetch.
     */
    where?: ClientContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContracts to fetch.
     */
    orderBy?: ClientContractOrderByWithRelationInput | ClientContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientContracts.
     */
    cursor?: ClientContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientContracts.
     */
    distinct?: ClientContractScalarFieldEnum | ClientContractScalarFieldEnum[]
  }

  /**
   * ClientContract findMany
   */
  export type ClientContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContracts to fetch.
     */
    where?: ClientContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContracts to fetch.
     */
    orderBy?: ClientContractOrderByWithRelationInput | ClientContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientContracts.
     */
    cursor?: ClientContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContracts.
     */
    skip?: number
    distinct?: ClientContractScalarFieldEnum | ClientContractScalarFieldEnum[]
  }

  /**
   * ClientContract create
   */
  export type ClientContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientContract.
     */
    data: XOR<ClientContractCreateInput, ClientContractUncheckedCreateInput>
  }

  /**
   * ClientContract createMany
   */
  export type ClientContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientContracts.
     */
    data: ClientContractCreateManyInput | ClientContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientContract update
   */
  export type ClientContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientContract.
     */
    data: XOR<ClientContractUpdateInput, ClientContractUncheckedUpdateInput>
    /**
     * Choose, which ClientContract to update.
     */
    where: ClientContractWhereUniqueInput
  }

  /**
   * ClientContract updateMany
   */
  export type ClientContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientContracts.
     */
    data: XOR<ClientContractUpdateManyMutationInput, ClientContractUncheckedUpdateManyInput>
    /**
     * Filter which ClientContracts to update
     */
    where?: ClientContractWhereInput
  }

  /**
   * ClientContract upsert
   */
  export type ClientContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientContract to update in case it exists.
     */
    where: ClientContractWhereUniqueInput
    /**
     * In case the ClientContract found by the `where` argument doesn't exist, create a new ClientContract with this data.
     */
    create: XOR<ClientContractCreateInput, ClientContractUncheckedCreateInput>
    /**
     * In case the ClientContract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientContractUpdateInput, ClientContractUncheckedUpdateInput>
  }

  /**
   * ClientContract delete
   */
  export type ClientContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    /**
     * Filter which ClientContract to delete.
     */
    where: ClientContractWhereUniqueInput
  }

  /**
   * ClientContract deleteMany
   */
  export type ClientContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientContracts to delete
     */
    where?: ClientContractWhereInput
  }

  /**
   * ClientContract.real_estate_agent
   */
  export type ClientContract$real_estate_agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    where?: RealEstateAgentWhereInput
  }

  /**
   * ClientContract.manager
   */
  export type ClientContract$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ClientContract.bank
   */
  export type ClientContract$bankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    where?: BankWhereInput
  }

  /**
   * ClientContract.ddu_client_contract_properties
   */
  export type ClientContract$ddu_client_contract_propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DDUClientContractProperties
     */
    select?: DDUClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DDUClientContractPropertiesInclude<ExtArgs> | null
    where?: DDUClientContractPropertiesWhereInput
  }

  /**
   * ClientContract.clients
   */
  export type ClientContract$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    where?: ClientContractToClientWhereInput
    orderBy?: ClientContractToClientOrderByWithRelationInput | ClientContractToClientOrderByWithRelationInput[]
    cursor?: ClientContractToClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientContractToClientScalarFieldEnum | ClientContractToClientScalarFieldEnum[]
  }

  /**
   * ClientContract.agency_contracts
   */
  export type ClientContract$agency_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    where?: ClientContractToAgencyContractWhereInput
    orderBy?: ClientContractToAgencyContractOrderByWithRelationInput | ClientContractToAgencyContractOrderByWithRelationInput[]
    cursor?: ClientContractToAgencyContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientContractToAgencyContractScalarFieldEnum | ClientContractToAgencyContractScalarFieldEnum[]
  }

  /**
   * ClientContract.scheduled_payments
   */
  export type ClientContract$scheduled_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    where?: ScheduledPaymentWhereInput
    orderBy?: ScheduledPaymentOrderByWithRelationInput | ScheduledPaymentOrderByWithRelationInput[]
    cursor?: ScheduledPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledPaymentScalarFieldEnum | ScheduledPaymentScalarFieldEnum[]
  }

  /**
   * ClientContract.actual_payment
   */
  export type ClientContract$actual_paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    where?: ActualPaymentWhereInput
    orderBy?: ActualPaymentOrderByWithRelationInput | ActualPaymentOrderByWithRelationInput[]
    cursor?: ActualPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActualPaymentScalarFieldEnum | ActualPaymentScalarFieldEnum[]
  }

  /**
   * ClientContract without action
   */
  export type ClientContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
  }


  /**
   * Model DDUClientContractProperties
   */

  export type AggregateDDUClientContractProperties = {
    _count: DDUClientContractPropertiesCountAggregateOutputType | null
    _avg: DDUClientContractPropertiesAvgAggregateOutputType | null
    _sum: DDUClientContractPropertiesSumAggregateOutputType | null
    _min: DDUClientContractPropertiesMinAggregateOutputType | null
    _max: DDUClientContractPropertiesMaxAggregateOutputType | null
  }

  export type DDUClientContractPropertiesAvgAggregateOutputType = {
    id: number | null
  }

  export type DDUClientContractPropertiesSumAggregateOutputType = {
    id: number | null
  }

  export type DDUClientContractPropertiesMinAggregateOutputType = {
    id: number | null
    ddu_link: string | null
    return_account: string | null
    escrow_account_opening_date: Date | null
    escrow_period: Date | null
    escrow_account_number: string | null
    is_escrow_discount: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DDUClientContractPropertiesMaxAggregateOutputType = {
    id: number | null
    ddu_link: string | null
    return_account: string | null
    escrow_account_opening_date: Date | null
    escrow_period: Date | null
    escrow_account_number: string | null
    is_escrow_discount: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DDUClientContractPropertiesCountAggregateOutputType = {
    id: number
    ddu_link: number
    return_account: number
    escrow_account_opening_date: number
    escrow_period: number
    escrow_account_number: number
    is_escrow_discount: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DDUClientContractPropertiesAvgAggregateInputType = {
    id?: true
  }

  export type DDUClientContractPropertiesSumAggregateInputType = {
    id?: true
  }

  export type DDUClientContractPropertiesMinAggregateInputType = {
    id?: true
    ddu_link?: true
    return_account?: true
    escrow_account_opening_date?: true
    escrow_period?: true
    escrow_account_number?: true
    is_escrow_discount?: true
    created_at?: true
    updated_at?: true
  }

  export type DDUClientContractPropertiesMaxAggregateInputType = {
    id?: true
    ddu_link?: true
    return_account?: true
    escrow_account_opening_date?: true
    escrow_period?: true
    escrow_account_number?: true
    is_escrow_discount?: true
    created_at?: true
    updated_at?: true
  }

  export type DDUClientContractPropertiesCountAggregateInputType = {
    id?: true
    ddu_link?: true
    return_account?: true
    escrow_account_opening_date?: true
    escrow_period?: true
    escrow_account_number?: true
    is_escrow_discount?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DDUClientContractPropertiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DDUClientContractProperties to aggregate.
     */
    where?: DDUClientContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DDUClientContractProperties to fetch.
     */
    orderBy?: DDUClientContractPropertiesOrderByWithRelationInput | DDUClientContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DDUClientContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DDUClientContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DDUClientContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DDUClientContractProperties
    **/
    _count?: true | DDUClientContractPropertiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DDUClientContractPropertiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DDUClientContractPropertiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DDUClientContractPropertiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DDUClientContractPropertiesMaxAggregateInputType
  }

  export type GetDDUClientContractPropertiesAggregateType<T extends DDUClientContractPropertiesAggregateArgs> = {
        [P in keyof T & keyof AggregateDDUClientContractProperties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDDUClientContractProperties[P]>
      : GetScalarType<T[P], AggregateDDUClientContractProperties[P]>
  }




  export type DDUClientContractPropertiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DDUClientContractPropertiesWhereInput
    orderBy?: DDUClientContractPropertiesOrderByWithAggregationInput | DDUClientContractPropertiesOrderByWithAggregationInput[]
    by: DDUClientContractPropertiesScalarFieldEnum[] | DDUClientContractPropertiesScalarFieldEnum
    having?: DDUClientContractPropertiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DDUClientContractPropertiesCountAggregateInputType | true
    _avg?: DDUClientContractPropertiesAvgAggregateInputType
    _sum?: DDUClientContractPropertiesSumAggregateInputType
    _min?: DDUClientContractPropertiesMinAggregateInputType
    _max?: DDUClientContractPropertiesMaxAggregateInputType
  }

  export type DDUClientContractPropertiesGroupByOutputType = {
    id: number
    ddu_link: string | null
    return_account: string | null
    escrow_account_opening_date: Date | null
    escrow_period: Date | null
    escrow_account_number: string | null
    is_escrow_discount: boolean | null
    created_at: Date
    updated_at: Date
    _count: DDUClientContractPropertiesCountAggregateOutputType | null
    _avg: DDUClientContractPropertiesAvgAggregateOutputType | null
    _sum: DDUClientContractPropertiesSumAggregateOutputType | null
    _min: DDUClientContractPropertiesMinAggregateOutputType | null
    _max: DDUClientContractPropertiesMaxAggregateOutputType | null
  }

  type GetDDUClientContractPropertiesGroupByPayload<T extends DDUClientContractPropertiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DDUClientContractPropertiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DDUClientContractPropertiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DDUClientContractPropertiesGroupByOutputType[P]>
            : GetScalarType<T[P], DDUClientContractPropertiesGroupByOutputType[P]>
        }
      >
    >


  export type DDUClientContractPropertiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ddu_link?: boolean
    return_account?: boolean
    escrow_account_opening_date?: boolean
    escrow_period?: boolean
    escrow_account_number?: boolean
    is_escrow_discount?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_contract?: boolean | DDUClientContractProperties$client_contractArgs<ExtArgs>
  }, ExtArgs["result"]["dDUClientContractProperties"]>


  export type DDUClientContractPropertiesSelectScalar = {
    id?: boolean
    ddu_link?: boolean
    return_account?: boolean
    escrow_account_opening_date?: boolean
    escrow_period?: boolean
    escrow_account_number?: boolean
    is_escrow_discount?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type DDUClientContractPropertiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_contract?: boolean | DDUClientContractProperties$client_contractArgs<ExtArgs>
  }

  export type $DDUClientContractPropertiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DDUClientContractProperties"
    objects: {
      client_contract: Prisma.$ClientContractPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ddu_link: string | null
      return_account: string | null
      escrow_account_opening_date: Date | null
      escrow_period: Date | null
      escrow_account_number: string | null
      is_escrow_discount: boolean | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["dDUClientContractProperties"]>
    composites: {}
  }

  type DDUClientContractPropertiesGetPayload<S extends boolean | null | undefined | DDUClientContractPropertiesDefaultArgs> = $Result.GetResult<Prisma.$DDUClientContractPropertiesPayload, S>

  type DDUClientContractPropertiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DDUClientContractPropertiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DDUClientContractPropertiesCountAggregateInputType | true
    }

  export interface DDUClientContractPropertiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DDUClientContractProperties'], meta: { name: 'DDUClientContractProperties' } }
    /**
     * Find zero or one DDUClientContractProperties that matches the filter.
     * @param {DDUClientContractPropertiesFindUniqueArgs} args - Arguments to find a DDUClientContractProperties
     * @example
     * // Get one DDUClientContractProperties
     * const dDUClientContractProperties = await prisma.dDUClientContractProperties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DDUClientContractPropertiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DDUClientContractPropertiesFindUniqueArgs<ExtArgs>>
    ): Prisma__DDUClientContractPropertiesClient<$Result.GetResult<Prisma.$DDUClientContractPropertiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DDUClientContractProperties that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DDUClientContractPropertiesFindUniqueOrThrowArgs} args - Arguments to find a DDUClientContractProperties
     * @example
     * // Get one DDUClientContractProperties
     * const dDUClientContractProperties = await prisma.dDUClientContractProperties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DDUClientContractPropertiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DDUClientContractPropertiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DDUClientContractPropertiesClient<$Result.GetResult<Prisma.$DDUClientContractPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DDUClientContractProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DDUClientContractPropertiesFindFirstArgs} args - Arguments to find a DDUClientContractProperties
     * @example
     * // Get one DDUClientContractProperties
     * const dDUClientContractProperties = await prisma.dDUClientContractProperties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DDUClientContractPropertiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DDUClientContractPropertiesFindFirstArgs<ExtArgs>>
    ): Prisma__DDUClientContractPropertiesClient<$Result.GetResult<Prisma.$DDUClientContractPropertiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DDUClientContractProperties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DDUClientContractPropertiesFindFirstOrThrowArgs} args - Arguments to find a DDUClientContractProperties
     * @example
     * // Get one DDUClientContractProperties
     * const dDUClientContractProperties = await prisma.dDUClientContractProperties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DDUClientContractPropertiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DDUClientContractPropertiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DDUClientContractPropertiesClient<$Result.GetResult<Prisma.$DDUClientContractPropertiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DDUClientContractProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DDUClientContractPropertiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DDUClientContractProperties
     * const dDUClientContractProperties = await prisma.dDUClientContractProperties.findMany()
     * 
     * // Get first 10 DDUClientContractProperties
     * const dDUClientContractProperties = await prisma.dDUClientContractProperties.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dDUClientContractPropertiesWithIdOnly = await prisma.dDUClientContractProperties.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DDUClientContractPropertiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DDUClientContractPropertiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DDUClientContractPropertiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DDUClientContractProperties.
     * @param {DDUClientContractPropertiesCreateArgs} args - Arguments to create a DDUClientContractProperties.
     * @example
     * // Create one DDUClientContractProperties
     * const DDUClientContractProperties = await prisma.dDUClientContractProperties.create({
     *   data: {
     *     // ... data to create a DDUClientContractProperties
     *   }
     * })
     * 
    **/
    create<T extends DDUClientContractPropertiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DDUClientContractPropertiesCreateArgs<ExtArgs>>
    ): Prisma__DDUClientContractPropertiesClient<$Result.GetResult<Prisma.$DDUClientContractPropertiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DDUClientContractProperties.
     * @param {DDUClientContractPropertiesCreateManyArgs} args - Arguments to create many DDUClientContractProperties.
     * @example
     * // Create many DDUClientContractProperties
     * const dDUClientContractProperties = await prisma.dDUClientContractProperties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends DDUClientContractPropertiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DDUClientContractPropertiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DDUClientContractProperties.
     * @param {DDUClientContractPropertiesDeleteArgs} args - Arguments to delete one DDUClientContractProperties.
     * @example
     * // Delete one DDUClientContractProperties
     * const DDUClientContractProperties = await prisma.dDUClientContractProperties.delete({
     *   where: {
     *     // ... filter to delete one DDUClientContractProperties
     *   }
     * })
     * 
    **/
    delete<T extends DDUClientContractPropertiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DDUClientContractPropertiesDeleteArgs<ExtArgs>>
    ): Prisma__DDUClientContractPropertiesClient<$Result.GetResult<Prisma.$DDUClientContractPropertiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DDUClientContractProperties.
     * @param {DDUClientContractPropertiesUpdateArgs} args - Arguments to update one DDUClientContractProperties.
     * @example
     * // Update one DDUClientContractProperties
     * const dDUClientContractProperties = await prisma.dDUClientContractProperties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DDUClientContractPropertiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DDUClientContractPropertiesUpdateArgs<ExtArgs>>
    ): Prisma__DDUClientContractPropertiesClient<$Result.GetResult<Prisma.$DDUClientContractPropertiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DDUClientContractProperties.
     * @param {DDUClientContractPropertiesDeleteManyArgs} args - Arguments to filter DDUClientContractProperties to delete.
     * @example
     * // Delete a few DDUClientContractProperties
     * const { count } = await prisma.dDUClientContractProperties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DDUClientContractPropertiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DDUClientContractPropertiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DDUClientContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DDUClientContractPropertiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DDUClientContractProperties
     * const dDUClientContractProperties = await prisma.dDUClientContractProperties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DDUClientContractPropertiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DDUClientContractPropertiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DDUClientContractProperties.
     * @param {DDUClientContractPropertiesUpsertArgs} args - Arguments to update or create a DDUClientContractProperties.
     * @example
     * // Update or create a DDUClientContractProperties
     * const dDUClientContractProperties = await prisma.dDUClientContractProperties.upsert({
     *   create: {
     *     // ... data to create a DDUClientContractProperties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DDUClientContractProperties we want to update
     *   }
     * })
    **/
    upsert<T extends DDUClientContractPropertiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DDUClientContractPropertiesUpsertArgs<ExtArgs>>
    ): Prisma__DDUClientContractPropertiesClient<$Result.GetResult<Prisma.$DDUClientContractPropertiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DDUClientContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DDUClientContractPropertiesCountArgs} args - Arguments to filter DDUClientContractProperties to count.
     * @example
     * // Count the number of DDUClientContractProperties
     * const count = await prisma.dDUClientContractProperties.count({
     *   where: {
     *     // ... the filter for the DDUClientContractProperties we want to count
     *   }
     * })
    **/
    count<T extends DDUClientContractPropertiesCountArgs>(
      args?: Subset<T, DDUClientContractPropertiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DDUClientContractPropertiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DDUClientContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DDUClientContractPropertiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DDUClientContractPropertiesAggregateArgs>(args: Subset<T, DDUClientContractPropertiesAggregateArgs>): Prisma.PrismaPromise<GetDDUClientContractPropertiesAggregateType<T>>

    /**
     * Group by DDUClientContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DDUClientContractPropertiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DDUClientContractPropertiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DDUClientContractPropertiesGroupByArgs['orderBy'] }
        : { orderBy?: DDUClientContractPropertiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DDUClientContractPropertiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDDUClientContractPropertiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DDUClientContractProperties model
   */
  readonly fields: DDUClientContractPropertiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DDUClientContractProperties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DDUClientContractPropertiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client_contract<T extends DDUClientContractProperties$client_contractArgs<ExtArgs> = {}>(args?: Subset<T, DDUClientContractProperties$client_contractArgs<ExtArgs>>): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DDUClientContractProperties model
   */ 
  interface DDUClientContractPropertiesFieldRefs {
    readonly id: FieldRef<"DDUClientContractProperties", 'Int'>
    readonly ddu_link: FieldRef<"DDUClientContractProperties", 'String'>
    readonly return_account: FieldRef<"DDUClientContractProperties", 'String'>
    readonly escrow_account_opening_date: FieldRef<"DDUClientContractProperties", 'DateTime'>
    readonly escrow_period: FieldRef<"DDUClientContractProperties", 'DateTime'>
    readonly escrow_account_number: FieldRef<"DDUClientContractProperties", 'String'>
    readonly is_escrow_discount: FieldRef<"DDUClientContractProperties", 'Boolean'>
    readonly created_at: FieldRef<"DDUClientContractProperties", 'DateTime'>
    readonly updated_at: FieldRef<"DDUClientContractProperties", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DDUClientContractProperties findUnique
   */
  export type DDUClientContractPropertiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DDUClientContractProperties
     */
    select?: DDUClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DDUClientContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which DDUClientContractProperties to fetch.
     */
    where: DDUClientContractPropertiesWhereUniqueInput
  }

  /**
   * DDUClientContractProperties findUniqueOrThrow
   */
  export type DDUClientContractPropertiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DDUClientContractProperties
     */
    select?: DDUClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DDUClientContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which DDUClientContractProperties to fetch.
     */
    where: DDUClientContractPropertiesWhereUniqueInput
  }

  /**
   * DDUClientContractProperties findFirst
   */
  export type DDUClientContractPropertiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DDUClientContractProperties
     */
    select?: DDUClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DDUClientContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which DDUClientContractProperties to fetch.
     */
    where?: DDUClientContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DDUClientContractProperties to fetch.
     */
    orderBy?: DDUClientContractPropertiesOrderByWithRelationInput | DDUClientContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DDUClientContractProperties.
     */
    cursor?: DDUClientContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DDUClientContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DDUClientContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DDUClientContractProperties.
     */
    distinct?: DDUClientContractPropertiesScalarFieldEnum | DDUClientContractPropertiesScalarFieldEnum[]
  }

  /**
   * DDUClientContractProperties findFirstOrThrow
   */
  export type DDUClientContractPropertiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DDUClientContractProperties
     */
    select?: DDUClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DDUClientContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which DDUClientContractProperties to fetch.
     */
    where?: DDUClientContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DDUClientContractProperties to fetch.
     */
    orderBy?: DDUClientContractPropertiesOrderByWithRelationInput | DDUClientContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DDUClientContractProperties.
     */
    cursor?: DDUClientContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DDUClientContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DDUClientContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DDUClientContractProperties.
     */
    distinct?: DDUClientContractPropertiesScalarFieldEnum | DDUClientContractPropertiesScalarFieldEnum[]
  }

  /**
   * DDUClientContractProperties findMany
   */
  export type DDUClientContractPropertiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DDUClientContractProperties
     */
    select?: DDUClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DDUClientContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which DDUClientContractProperties to fetch.
     */
    where?: DDUClientContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DDUClientContractProperties to fetch.
     */
    orderBy?: DDUClientContractPropertiesOrderByWithRelationInput | DDUClientContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DDUClientContractProperties.
     */
    cursor?: DDUClientContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DDUClientContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DDUClientContractProperties.
     */
    skip?: number
    distinct?: DDUClientContractPropertiesScalarFieldEnum | DDUClientContractPropertiesScalarFieldEnum[]
  }

  /**
   * DDUClientContractProperties create
   */
  export type DDUClientContractPropertiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DDUClientContractProperties
     */
    select?: DDUClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DDUClientContractPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to create a DDUClientContractProperties.
     */
    data: XOR<DDUClientContractPropertiesCreateInput, DDUClientContractPropertiesUncheckedCreateInput>
  }

  /**
   * DDUClientContractProperties createMany
   */
  export type DDUClientContractPropertiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DDUClientContractProperties.
     */
    data: DDUClientContractPropertiesCreateManyInput | DDUClientContractPropertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DDUClientContractProperties update
   */
  export type DDUClientContractPropertiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DDUClientContractProperties
     */
    select?: DDUClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DDUClientContractPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to update a DDUClientContractProperties.
     */
    data: XOR<DDUClientContractPropertiesUpdateInput, DDUClientContractPropertiesUncheckedUpdateInput>
    /**
     * Choose, which DDUClientContractProperties to update.
     */
    where: DDUClientContractPropertiesWhereUniqueInput
  }

  /**
   * DDUClientContractProperties updateMany
   */
  export type DDUClientContractPropertiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DDUClientContractProperties.
     */
    data: XOR<DDUClientContractPropertiesUpdateManyMutationInput, DDUClientContractPropertiesUncheckedUpdateManyInput>
    /**
     * Filter which DDUClientContractProperties to update
     */
    where?: DDUClientContractPropertiesWhereInput
  }

  /**
   * DDUClientContractProperties upsert
   */
  export type DDUClientContractPropertiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DDUClientContractProperties
     */
    select?: DDUClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DDUClientContractPropertiesInclude<ExtArgs> | null
    /**
     * The filter to search for the DDUClientContractProperties to update in case it exists.
     */
    where: DDUClientContractPropertiesWhereUniqueInput
    /**
     * In case the DDUClientContractProperties found by the `where` argument doesn't exist, create a new DDUClientContractProperties with this data.
     */
    create: XOR<DDUClientContractPropertiesCreateInput, DDUClientContractPropertiesUncheckedCreateInput>
    /**
     * In case the DDUClientContractProperties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DDUClientContractPropertiesUpdateInput, DDUClientContractPropertiesUncheckedUpdateInput>
  }

  /**
   * DDUClientContractProperties delete
   */
  export type DDUClientContractPropertiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DDUClientContractProperties
     */
    select?: DDUClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DDUClientContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter which DDUClientContractProperties to delete.
     */
    where: DDUClientContractPropertiesWhereUniqueInput
  }

  /**
   * DDUClientContractProperties deleteMany
   */
  export type DDUClientContractPropertiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DDUClientContractProperties to delete
     */
    where?: DDUClientContractPropertiesWhereInput
  }

  /**
   * DDUClientContractProperties.client_contract
   */
  export type DDUClientContractProperties$client_contractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    where?: ClientContractWhereInput
  }

  /**
   * DDUClientContractProperties without action
   */
  export type DDUClientContractPropertiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DDUClientContractProperties
     */
    select?: DDUClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DDUClientContractPropertiesInclude<ExtArgs> | null
  }


  /**
   * Model ClientContractToAgencyContract
   */

  export type AggregateClientContractToAgencyContract = {
    _count: ClientContractToAgencyContractCountAggregateOutputType | null
    _avg: ClientContractToAgencyContractAvgAggregateOutputType | null
    _sum: ClientContractToAgencyContractSumAggregateOutputType | null
    _min: ClientContractToAgencyContractMinAggregateOutputType | null
    _max: ClientContractToAgencyContractMaxAggregateOutputType | null
  }

  export type ClientContractToAgencyContractAvgAggregateOutputType = {
    client_contract_id: number | null
    agency_contract_id: number | null
  }

  export type ClientContractToAgencyContractSumAggregateOutputType = {
    client_contract_id: number | null
    agency_contract_id: number | null
  }

  export type ClientContractToAgencyContractMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    client_contract_id: number | null
    agency_contract_id: number | null
  }

  export type ClientContractToAgencyContractMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    client_contract_id: number | null
    agency_contract_id: number | null
  }

  export type ClientContractToAgencyContractCountAggregateOutputType = {
    created_at: number
    updated_at: number
    client_contract_id: number
    agency_contract_id: number
    _all: number
  }


  export type ClientContractToAgencyContractAvgAggregateInputType = {
    client_contract_id?: true
    agency_contract_id?: true
  }

  export type ClientContractToAgencyContractSumAggregateInputType = {
    client_contract_id?: true
    agency_contract_id?: true
  }

  export type ClientContractToAgencyContractMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    client_contract_id?: true
    agency_contract_id?: true
  }

  export type ClientContractToAgencyContractMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    client_contract_id?: true
    agency_contract_id?: true
  }

  export type ClientContractToAgencyContractCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    client_contract_id?: true
    agency_contract_id?: true
    _all?: true
  }

  export type ClientContractToAgencyContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientContractToAgencyContract to aggregate.
     */
    where?: ClientContractToAgencyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContractToAgencyContracts to fetch.
     */
    orderBy?: ClientContractToAgencyContractOrderByWithRelationInput | ClientContractToAgencyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientContractToAgencyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContractToAgencyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContractToAgencyContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientContractToAgencyContracts
    **/
    _count?: true | ClientContractToAgencyContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientContractToAgencyContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientContractToAgencyContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientContractToAgencyContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientContractToAgencyContractMaxAggregateInputType
  }

  export type GetClientContractToAgencyContractAggregateType<T extends ClientContractToAgencyContractAggregateArgs> = {
        [P in keyof T & keyof AggregateClientContractToAgencyContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientContractToAgencyContract[P]>
      : GetScalarType<T[P], AggregateClientContractToAgencyContract[P]>
  }




  export type ClientContractToAgencyContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractToAgencyContractWhereInput
    orderBy?: ClientContractToAgencyContractOrderByWithAggregationInput | ClientContractToAgencyContractOrderByWithAggregationInput[]
    by: ClientContractToAgencyContractScalarFieldEnum[] | ClientContractToAgencyContractScalarFieldEnum
    having?: ClientContractToAgencyContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientContractToAgencyContractCountAggregateInputType | true
    _avg?: ClientContractToAgencyContractAvgAggregateInputType
    _sum?: ClientContractToAgencyContractSumAggregateInputType
    _min?: ClientContractToAgencyContractMinAggregateInputType
    _max?: ClientContractToAgencyContractMaxAggregateInputType
  }

  export type ClientContractToAgencyContractGroupByOutputType = {
    created_at: Date
    updated_at: Date
    client_contract_id: number
    agency_contract_id: number
    _count: ClientContractToAgencyContractCountAggregateOutputType | null
    _avg: ClientContractToAgencyContractAvgAggregateOutputType | null
    _sum: ClientContractToAgencyContractSumAggregateOutputType | null
    _min: ClientContractToAgencyContractMinAggregateOutputType | null
    _max: ClientContractToAgencyContractMaxAggregateOutputType | null
  }

  type GetClientContractToAgencyContractGroupByPayload<T extends ClientContractToAgencyContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientContractToAgencyContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientContractToAgencyContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientContractToAgencyContractGroupByOutputType[P]>
            : GetScalarType<T[P], ClientContractToAgencyContractGroupByOutputType[P]>
        }
      >
    >


  export type ClientContractToAgencyContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    client_contract_id?: boolean
    agency_contract_id?: boolean
    client_contract?: boolean | ClientContractDefaultArgs<ExtArgs>
    agency_contract?: boolean | AgencyContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientContractToAgencyContract"]>


  export type ClientContractToAgencyContractSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    client_contract_id?: boolean
    agency_contract_id?: boolean
  }

  export type ClientContractToAgencyContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_contract?: boolean | ClientContractDefaultArgs<ExtArgs>
    agency_contract?: boolean | AgencyContractDefaultArgs<ExtArgs>
  }

  export type $ClientContractToAgencyContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientContractToAgencyContract"
    objects: {
      client_contract: Prisma.$ClientContractPayload<ExtArgs>
      agency_contract: Prisma.$AgencyContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      created_at: Date
      updated_at: Date
      client_contract_id: number
      agency_contract_id: number
    }, ExtArgs["result"]["clientContractToAgencyContract"]>
    composites: {}
  }

  type ClientContractToAgencyContractGetPayload<S extends boolean | null | undefined | ClientContractToAgencyContractDefaultArgs> = $Result.GetResult<Prisma.$ClientContractToAgencyContractPayload, S>

  type ClientContractToAgencyContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientContractToAgencyContractFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientContractToAgencyContractCountAggregateInputType | true
    }

  export interface ClientContractToAgencyContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientContractToAgencyContract'], meta: { name: 'ClientContractToAgencyContract' } }
    /**
     * Find zero or one ClientContractToAgencyContract that matches the filter.
     * @param {ClientContractToAgencyContractFindUniqueArgs} args - Arguments to find a ClientContractToAgencyContract
     * @example
     * // Get one ClientContractToAgencyContract
     * const clientContractToAgencyContract = await prisma.clientContractToAgencyContract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientContractToAgencyContractFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToAgencyContractFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientContractToAgencyContractClient<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClientContractToAgencyContract that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientContractToAgencyContractFindUniqueOrThrowArgs} args - Arguments to find a ClientContractToAgencyContract
     * @example
     * // Get one ClientContractToAgencyContract
     * const clientContractToAgencyContract = await prisma.clientContractToAgencyContract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientContractToAgencyContractFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToAgencyContractFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientContractToAgencyContractClient<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClientContractToAgencyContract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToAgencyContractFindFirstArgs} args - Arguments to find a ClientContractToAgencyContract
     * @example
     * // Get one ClientContractToAgencyContract
     * const clientContractToAgencyContract = await prisma.clientContractToAgencyContract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientContractToAgencyContractFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToAgencyContractFindFirstArgs<ExtArgs>>
    ): Prisma__ClientContractToAgencyContractClient<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClientContractToAgencyContract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToAgencyContractFindFirstOrThrowArgs} args - Arguments to find a ClientContractToAgencyContract
     * @example
     * // Get one ClientContractToAgencyContract
     * const clientContractToAgencyContract = await prisma.clientContractToAgencyContract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientContractToAgencyContractFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToAgencyContractFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientContractToAgencyContractClient<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClientContractToAgencyContracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToAgencyContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientContractToAgencyContracts
     * const clientContractToAgencyContracts = await prisma.clientContractToAgencyContract.findMany()
     * 
     * // Get first 10 ClientContractToAgencyContracts
     * const clientContractToAgencyContracts = await prisma.clientContractToAgencyContract.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const clientContractToAgencyContractWithCreated_atOnly = await prisma.clientContractToAgencyContract.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends ClientContractToAgencyContractFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToAgencyContractFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClientContractToAgencyContract.
     * @param {ClientContractToAgencyContractCreateArgs} args - Arguments to create a ClientContractToAgencyContract.
     * @example
     * // Create one ClientContractToAgencyContract
     * const ClientContractToAgencyContract = await prisma.clientContractToAgencyContract.create({
     *   data: {
     *     // ... data to create a ClientContractToAgencyContract
     *   }
     * })
     * 
    **/
    create<T extends ClientContractToAgencyContractCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToAgencyContractCreateArgs<ExtArgs>>
    ): Prisma__ClientContractToAgencyContractClient<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClientContractToAgencyContracts.
     * @param {ClientContractToAgencyContractCreateManyArgs} args - Arguments to create many ClientContractToAgencyContracts.
     * @example
     * // Create many ClientContractToAgencyContracts
     * const clientContractToAgencyContract = await prisma.clientContractToAgencyContract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientContractToAgencyContractCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToAgencyContractCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientContractToAgencyContract.
     * @param {ClientContractToAgencyContractDeleteArgs} args - Arguments to delete one ClientContractToAgencyContract.
     * @example
     * // Delete one ClientContractToAgencyContract
     * const ClientContractToAgencyContract = await prisma.clientContractToAgencyContract.delete({
     *   where: {
     *     // ... filter to delete one ClientContractToAgencyContract
     *   }
     * })
     * 
    **/
    delete<T extends ClientContractToAgencyContractDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToAgencyContractDeleteArgs<ExtArgs>>
    ): Prisma__ClientContractToAgencyContractClient<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClientContractToAgencyContract.
     * @param {ClientContractToAgencyContractUpdateArgs} args - Arguments to update one ClientContractToAgencyContract.
     * @example
     * // Update one ClientContractToAgencyContract
     * const clientContractToAgencyContract = await prisma.clientContractToAgencyContract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientContractToAgencyContractUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToAgencyContractUpdateArgs<ExtArgs>>
    ): Prisma__ClientContractToAgencyContractClient<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClientContractToAgencyContracts.
     * @param {ClientContractToAgencyContractDeleteManyArgs} args - Arguments to filter ClientContractToAgencyContracts to delete.
     * @example
     * // Delete a few ClientContractToAgencyContracts
     * const { count } = await prisma.clientContractToAgencyContract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientContractToAgencyContractDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToAgencyContractDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientContractToAgencyContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToAgencyContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientContractToAgencyContracts
     * const clientContractToAgencyContract = await prisma.clientContractToAgencyContract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientContractToAgencyContractUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToAgencyContractUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientContractToAgencyContract.
     * @param {ClientContractToAgencyContractUpsertArgs} args - Arguments to update or create a ClientContractToAgencyContract.
     * @example
     * // Update or create a ClientContractToAgencyContract
     * const clientContractToAgencyContract = await prisma.clientContractToAgencyContract.upsert({
     *   create: {
     *     // ... data to create a ClientContractToAgencyContract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientContractToAgencyContract we want to update
     *   }
     * })
    **/
    upsert<T extends ClientContractToAgencyContractUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToAgencyContractUpsertArgs<ExtArgs>>
    ): Prisma__ClientContractToAgencyContractClient<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClientContractToAgencyContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToAgencyContractCountArgs} args - Arguments to filter ClientContractToAgencyContracts to count.
     * @example
     * // Count the number of ClientContractToAgencyContracts
     * const count = await prisma.clientContractToAgencyContract.count({
     *   where: {
     *     // ... the filter for the ClientContractToAgencyContracts we want to count
     *   }
     * })
    **/
    count<T extends ClientContractToAgencyContractCountArgs>(
      args?: Subset<T, ClientContractToAgencyContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientContractToAgencyContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientContractToAgencyContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToAgencyContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientContractToAgencyContractAggregateArgs>(args: Subset<T, ClientContractToAgencyContractAggregateArgs>): Prisma.PrismaPromise<GetClientContractToAgencyContractAggregateType<T>>

    /**
     * Group by ClientContractToAgencyContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToAgencyContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientContractToAgencyContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientContractToAgencyContractGroupByArgs['orderBy'] }
        : { orderBy?: ClientContractToAgencyContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientContractToAgencyContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientContractToAgencyContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientContractToAgencyContract model
   */
  readonly fields: ClientContractToAgencyContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientContractToAgencyContract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientContractToAgencyContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client_contract<T extends ClientContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientContractDefaultArgs<ExtArgs>>): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    agency_contract<T extends AgencyContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContractDefaultArgs<ExtArgs>>): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClientContractToAgencyContract model
   */ 
  interface ClientContractToAgencyContractFieldRefs {
    readonly created_at: FieldRef<"ClientContractToAgencyContract", 'DateTime'>
    readonly updated_at: FieldRef<"ClientContractToAgencyContract", 'DateTime'>
    readonly client_contract_id: FieldRef<"ClientContractToAgencyContract", 'Int'>
    readonly agency_contract_id: FieldRef<"ClientContractToAgencyContract", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClientContractToAgencyContract findUnique
   */
  export type ClientContractToAgencyContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToAgencyContract to fetch.
     */
    where: ClientContractToAgencyContractWhereUniqueInput
  }

  /**
   * ClientContractToAgencyContract findUniqueOrThrow
   */
  export type ClientContractToAgencyContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToAgencyContract to fetch.
     */
    where: ClientContractToAgencyContractWhereUniqueInput
  }

  /**
   * ClientContractToAgencyContract findFirst
   */
  export type ClientContractToAgencyContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToAgencyContract to fetch.
     */
    where?: ClientContractToAgencyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContractToAgencyContracts to fetch.
     */
    orderBy?: ClientContractToAgencyContractOrderByWithRelationInput | ClientContractToAgencyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientContractToAgencyContracts.
     */
    cursor?: ClientContractToAgencyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContractToAgencyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContractToAgencyContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientContractToAgencyContracts.
     */
    distinct?: ClientContractToAgencyContractScalarFieldEnum | ClientContractToAgencyContractScalarFieldEnum[]
  }

  /**
   * ClientContractToAgencyContract findFirstOrThrow
   */
  export type ClientContractToAgencyContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToAgencyContract to fetch.
     */
    where?: ClientContractToAgencyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContractToAgencyContracts to fetch.
     */
    orderBy?: ClientContractToAgencyContractOrderByWithRelationInput | ClientContractToAgencyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientContractToAgencyContracts.
     */
    cursor?: ClientContractToAgencyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContractToAgencyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContractToAgencyContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientContractToAgencyContracts.
     */
    distinct?: ClientContractToAgencyContractScalarFieldEnum | ClientContractToAgencyContractScalarFieldEnum[]
  }

  /**
   * ClientContractToAgencyContract findMany
   */
  export type ClientContractToAgencyContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToAgencyContracts to fetch.
     */
    where?: ClientContractToAgencyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContractToAgencyContracts to fetch.
     */
    orderBy?: ClientContractToAgencyContractOrderByWithRelationInput | ClientContractToAgencyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientContractToAgencyContracts.
     */
    cursor?: ClientContractToAgencyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContractToAgencyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContractToAgencyContracts.
     */
    skip?: number
    distinct?: ClientContractToAgencyContractScalarFieldEnum | ClientContractToAgencyContractScalarFieldEnum[]
  }

  /**
   * ClientContractToAgencyContract create
   */
  export type ClientContractToAgencyContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientContractToAgencyContract.
     */
    data: XOR<ClientContractToAgencyContractCreateInput, ClientContractToAgencyContractUncheckedCreateInput>
  }

  /**
   * ClientContractToAgencyContract createMany
   */
  export type ClientContractToAgencyContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientContractToAgencyContracts.
     */
    data: ClientContractToAgencyContractCreateManyInput | ClientContractToAgencyContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientContractToAgencyContract update
   */
  export type ClientContractToAgencyContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientContractToAgencyContract.
     */
    data: XOR<ClientContractToAgencyContractUpdateInput, ClientContractToAgencyContractUncheckedUpdateInput>
    /**
     * Choose, which ClientContractToAgencyContract to update.
     */
    where: ClientContractToAgencyContractWhereUniqueInput
  }

  /**
   * ClientContractToAgencyContract updateMany
   */
  export type ClientContractToAgencyContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientContractToAgencyContracts.
     */
    data: XOR<ClientContractToAgencyContractUpdateManyMutationInput, ClientContractToAgencyContractUncheckedUpdateManyInput>
    /**
     * Filter which ClientContractToAgencyContracts to update
     */
    where?: ClientContractToAgencyContractWhereInput
  }

  /**
   * ClientContractToAgencyContract upsert
   */
  export type ClientContractToAgencyContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientContractToAgencyContract to update in case it exists.
     */
    where: ClientContractToAgencyContractWhereUniqueInput
    /**
     * In case the ClientContractToAgencyContract found by the `where` argument doesn't exist, create a new ClientContractToAgencyContract with this data.
     */
    create: XOR<ClientContractToAgencyContractCreateInput, ClientContractToAgencyContractUncheckedCreateInput>
    /**
     * In case the ClientContractToAgencyContract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientContractToAgencyContractUpdateInput, ClientContractToAgencyContractUncheckedUpdateInput>
  }

  /**
   * ClientContractToAgencyContract delete
   */
  export type ClientContractToAgencyContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    /**
     * Filter which ClientContractToAgencyContract to delete.
     */
    where: ClientContractToAgencyContractWhereUniqueInput
  }

  /**
   * ClientContractToAgencyContract deleteMany
   */
  export type ClientContractToAgencyContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientContractToAgencyContracts to delete
     */
    where?: ClientContractToAgencyContractWhereInput
  }

  /**
   * ClientContractToAgencyContract without action
   */
  export type ClientContractToAgencyContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
  }


  /**
   * Model ClientContractToClient
   */

  export type AggregateClientContractToClient = {
    _count: ClientContractToClientCountAggregateOutputType | null
    _avg: ClientContractToClientAvgAggregateOutputType | null
    _sum: ClientContractToClientSumAggregateOutputType | null
    _min: ClientContractToClientMinAggregateOutputType | null
    _max: ClientContractToClientMaxAggregateOutputType | null
  }

  export type ClientContractToClientAvgAggregateOutputType = {
    share: number | null
    client_contract_id: number | null
    client_id: number | null
  }

  export type ClientContractToClientSumAggregateOutputType = {
    share: number | null
    client_contract_id: number | null
    client_id: number | null
  }

  export type ClientContractToClientMinAggregateOutputType = {
    is_main: boolean | null
    share: number | null
    created_at: Date | null
    updated_at: Date | null
    client_contract_id: number | null
    client_id: number | null
  }

  export type ClientContractToClientMaxAggregateOutputType = {
    is_main: boolean | null
    share: number | null
    created_at: Date | null
    updated_at: Date | null
    client_contract_id: number | null
    client_id: number | null
  }

  export type ClientContractToClientCountAggregateOutputType = {
    is_main: number
    share: number
    created_at: number
    updated_at: number
    client_contract_id: number
    client_id: number
    _all: number
  }


  export type ClientContractToClientAvgAggregateInputType = {
    share?: true
    client_contract_id?: true
    client_id?: true
  }

  export type ClientContractToClientSumAggregateInputType = {
    share?: true
    client_contract_id?: true
    client_id?: true
  }

  export type ClientContractToClientMinAggregateInputType = {
    is_main?: true
    share?: true
    created_at?: true
    updated_at?: true
    client_contract_id?: true
    client_id?: true
  }

  export type ClientContractToClientMaxAggregateInputType = {
    is_main?: true
    share?: true
    created_at?: true
    updated_at?: true
    client_contract_id?: true
    client_id?: true
  }

  export type ClientContractToClientCountAggregateInputType = {
    is_main?: true
    share?: true
    created_at?: true
    updated_at?: true
    client_contract_id?: true
    client_id?: true
    _all?: true
  }

  export type ClientContractToClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientContractToClient to aggregate.
     */
    where?: ClientContractToClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContractToClients to fetch.
     */
    orderBy?: ClientContractToClientOrderByWithRelationInput | ClientContractToClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientContractToClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContractToClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContractToClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientContractToClients
    **/
    _count?: true | ClientContractToClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientContractToClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientContractToClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientContractToClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientContractToClientMaxAggregateInputType
  }

  export type GetClientContractToClientAggregateType<T extends ClientContractToClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClientContractToClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientContractToClient[P]>
      : GetScalarType<T[P], AggregateClientContractToClient[P]>
  }




  export type ClientContractToClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractToClientWhereInput
    orderBy?: ClientContractToClientOrderByWithAggregationInput | ClientContractToClientOrderByWithAggregationInput[]
    by: ClientContractToClientScalarFieldEnum[] | ClientContractToClientScalarFieldEnum
    having?: ClientContractToClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientContractToClientCountAggregateInputType | true
    _avg?: ClientContractToClientAvgAggregateInputType
    _sum?: ClientContractToClientSumAggregateInputType
    _min?: ClientContractToClientMinAggregateInputType
    _max?: ClientContractToClientMaxAggregateInputType
  }

  export type ClientContractToClientGroupByOutputType = {
    is_main: boolean
    share: number
    created_at: Date
    updated_at: Date
    client_contract_id: number
    client_id: number
    _count: ClientContractToClientCountAggregateOutputType | null
    _avg: ClientContractToClientAvgAggregateOutputType | null
    _sum: ClientContractToClientSumAggregateOutputType | null
    _min: ClientContractToClientMinAggregateOutputType | null
    _max: ClientContractToClientMaxAggregateOutputType | null
  }

  type GetClientContractToClientGroupByPayload<T extends ClientContractToClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientContractToClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientContractToClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientContractToClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientContractToClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientContractToClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    is_main?: boolean
    share?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_contract_id?: boolean
    client_id?: boolean
    client_contract?: boolean | ClientContractDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientContractToClient"]>


  export type ClientContractToClientSelectScalar = {
    is_main?: boolean
    share?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_contract_id?: boolean
    client_id?: boolean
  }

  export type ClientContractToClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_contract?: boolean | ClientContractDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ClientContractToClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientContractToClient"
    objects: {
      client_contract: Prisma.$ClientContractPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      is_main: boolean
      share: number
      created_at: Date
      updated_at: Date
      client_contract_id: number
      client_id: number
    }, ExtArgs["result"]["clientContractToClient"]>
    composites: {}
  }

  type ClientContractToClientGetPayload<S extends boolean | null | undefined | ClientContractToClientDefaultArgs> = $Result.GetResult<Prisma.$ClientContractToClientPayload, S>

  type ClientContractToClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientContractToClientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientContractToClientCountAggregateInputType | true
    }

  export interface ClientContractToClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientContractToClient'], meta: { name: 'ClientContractToClient' } }
    /**
     * Find zero or one ClientContractToClient that matches the filter.
     * @param {ClientContractToClientFindUniqueArgs} args - Arguments to find a ClientContractToClient
     * @example
     * // Get one ClientContractToClient
     * const clientContractToClient = await prisma.clientContractToClient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientContractToClientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToClientFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientContractToClientClient<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClientContractToClient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientContractToClientFindUniqueOrThrowArgs} args - Arguments to find a ClientContractToClient
     * @example
     * // Get one ClientContractToClient
     * const clientContractToClient = await prisma.clientContractToClient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientContractToClientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToClientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientContractToClientClient<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClientContractToClient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToClientFindFirstArgs} args - Arguments to find a ClientContractToClient
     * @example
     * // Get one ClientContractToClient
     * const clientContractToClient = await prisma.clientContractToClient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientContractToClientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToClientFindFirstArgs<ExtArgs>>
    ): Prisma__ClientContractToClientClient<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClientContractToClient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToClientFindFirstOrThrowArgs} args - Arguments to find a ClientContractToClient
     * @example
     * // Get one ClientContractToClient
     * const clientContractToClient = await prisma.clientContractToClient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientContractToClientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToClientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientContractToClientClient<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClientContractToClients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientContractToClients
     * const clientContractToClients = await prisma.clientContractToClient.findMany()
     * 
     * // Get first 10 ClientContractToClients
     * const clientContractToClients = await prisma.clientContractToClient.findMany({ take: 10 })
     * 
     * // Only select the `is_main`
     * const clientContractToClientWithIs_mainOnly = await prisma.clientContractToClient.findMany({ select: { is_main: true } })
     * 
    **/
    findMany<T extends ClientContractToClientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToClientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClientContractToClient.
     * @param {ClientContractToClientCreateArgs} args - Arguments to create a ClientContractToClient.
     * @example
     * // Create one ClientContractToClient
     * const ClientContractToClient = await prisma.clientContractToClient.create({
     *   data: {
     *     // ... data to create a ClientContractToClient
     *   }
     * })
     * 
    **/
    create<T extends ClientContractToClientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToClientCreateArgs<ExtArgs>>
    ): Prisma__ClientContractToClientClient<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClientContractToClients.
     * @param {ClientContractToClientCreateManyArgs} args - Arguments to create many ClientContractToClients.
     * @example
     * // Create many ClientContractToClients
     * const clientContractToClient = await prisma.clientContractToClient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientContractToClientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToClientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientContractToClient.
     * @param {ClientContractToClientDeleteArgs} args - Arguments to delete one ClientContractToClient.
     * @example
     * // Delete one ClientContractToClient
     * const ClientContractToClient = await prisma.clientContractToClient.delete({
     *   where: {
     *     // ... filter to delete one ClientContractToClient
     *   }
     * })
     * 
    **/
    delete<T extends ClientContractToClientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToClientDeleteArgs<ExtArgs>>
    ): Prisma__ClientContractToClientClient<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClientContractToClient.
     * @param {ClientContractToClientUpdateArgs} args - Arguments to update one ClientContractToClient.
     * @example
     * // Update one ClientContractToClient
     * const clientContractToClient = await prisma.clientContractToClient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientContractToClientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToClientUpdateArgs<ExtArgs>>
    ): Prisma__ClientContractToClientClient<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClientContractToClients.
     * @param {ClientContractToClientDeleteManyArgs} args - Arguments to filter ClientContractToClients to delete.
     * @example
     * // Delete a few ClientContractToClients
     * const { count } = await prisma.clientContractToClient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientContractToClientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToClientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientContractToClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientContractToClients
     * const clientContractToClient = await prisma.clientContractToClient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientContractToClientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToClientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientContractToClient.
     * @param {ClientContractToClientUpsertArgs} args - Arguments to update or create a ClientContractToClient.
     * @example
     * // Update or create a ClientContractToClient
     * const clientContractToClient = await prisma.clientContractToClient.upsert({
     *   create: {
     *     // ... data to create a ClientContractToClient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientContractToClient we want to update
     *   }
     * })
    **/
    upsert<T extends ClientContractToClientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToClientUpsertArgs<ExtArgs>>
    ): Prisma__ClientContractToClientClient<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClientContractToClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToClientCountArgs} args - Arguments to filter ClientContractToClients to count.
     * @example
     * // Count the number of ClientContractToClients
     * const count = await prisma.clientContractToClient.count({
     *   where: {
     *     // ... the filter for the ClientContractToClients we want to count
     *   }
     * })
    **/
    count<T extends ClientContractToClientCountArgs>(
      args?: Subset<T, ClientContractToClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientContractToClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientContractToClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientContractToClientAggregateArgs>(args: Subset<T, ClientContractToClientAggregateArgs>): Prisma.PrismaPromise<GetClientContractToClientAggregateType<T>>

    /**
     * Group by ClientContractToClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientContractToClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientContractToClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientContractToClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientContractToClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientContractToClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientContractToClient model
   */
  readonly fields: ClientContractToClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientContractToClient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientContractToClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client_contract<T extends ClientContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientContractDefaultArgs<ExtArgs>>): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClientContractToClient model
   */ 
  interface ClientContractToClientFieldRefs {
    readonly is_main: FieldRef<"ClientContractToClient", 'Boolean'>
    readonly share: FieldRef<"ClientContractToClient", 'Int'>
    readonly created_at: FieldRef<"ClientContractToClient", 'DateTime'>
    readonly updated_at: FieldRef<"ClientContractToClient", 'DateTime'>
    readonly client_contract_id: FieldRef<"ClientContractToClient", 'Int'>
    readonly client_id: FieldRef<"ClientContractToClient", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClientContractToClient findUnique
   */
  export type ClientContractToClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToClient to fetch.
     */
    where: ClientContractToClientWhereUniqueInput
  }

  /**
   * ClientContractToClient findUniqueOrThrow
   */
  export type ClientContractToClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToClient to fetch.
     */
    where: ClientContractToClientWhereUniqueInput
  }

  /**
   * ClientContractToClient findFirst
   */
  export type ClientContractToClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToClient to fetch.
     */
    where?: ClientContractToClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContractToClients to fetch.
     */
    orderBy?: ClientContractToClientOrderByWithRelationInput | ClientContractToClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientContractToClients.
     */
    cursor?: ClientContractToClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContractToClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContractToClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientContractToClients.
     */
    distinct?: ClientContractToClientScalarFieldEnum | ClientContractToClientScalarFieldEnum[]
  }

  /**
   * ClientContractToClient findFirstOrThrow
   */
  export type ClientContractToClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToClient to fetch.
     */
    where?: ClientContractToClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContractToClients to fetch.
     */
    orderBy?: ClientContractToClientOrderByWithRelationInput | ClientContractToClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientContractToClients.
     */
    cursor?: ClientContractToClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContractToClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContractToClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientContractToClients.
     */
    distinct?: ClientContractToClientScalarFieldEnum | ClientContractToClientScalarFieldEnum[]
  }

  /**
   * ClientContractToClient findMany
   */
  export type ClientContractToClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToClients to fetch.
     */
    where?: ClientContractToClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContractToClients to fetch.
     */
    orderBy?: ClientContractToClientOrderByWithRelationInput | ClientContractToClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientContractToClients.
     */
    cursor?: ClientContractToClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContractToClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContractToClients.
     */
    skip?: number
    distinct?: ClientContractToClientScalarFieldEnum | ClientContractToClientScalarFieldEnum[]
  }

  /**
   * ClientContractToClient create
   */
  export type ClientContractToClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientContractToClient.
     */
    data: XOR<ClientContractToClientCreateInput, ClientContractToClientUncheckedCreateInput>
  }

  /**
   * ClientContractToClient createMany
   */
  export type ClientContractToClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientContractToClients.
     */
    data: ClientContractToClientCreateManyInput | ClientContractToClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientContractToClient update
   */
  export type ClientContractToClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientContractToClient.
     */
    data: XOR<ClientContractToClientUpdateInput, ClientContractToClientUncheckedUpdateInput>
    /**
     * Choose, which ClientContractToClient to update.
     */
    where: ClientContractToClientWhereUniqueInput
  }

  /**
   * ClientContractToClient updateMany
   */
  export type ClientContractToClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientContractToClients.
     */
    data: XOR<ClientContractToClientUpdateManyMutationInput, ClientContractToClientUncheckedUpdateManyInput>
    /**
     * Filter which ClientContractToClients to update
     */
    where?: ClientContractToClientWhereInput
  }

  /**
   * ClientContractToClient upsert
   */
  export type ClientContractToClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientContractToClient to update in case it exists.
     */
    where: ClientContractToClientWhereUniqueInput
    /**
     * In case the ClientContractToClient found by the `where` argument doesn't exist, create a new ClientContractToClient with this data.
     */
    create: XOR<ClientContractToClientCreateInput, ClientContractToClientUncheckedCreateInput>
    /**
     * In case the ClientContractToClient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientContractToClientUpdateInput, ClientContractToClientUncheckedUpdateInput>
  }

  /**
   * ClientContractToClient delete
   */
  export type ClientContractToClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    /**
     * Filter which ClientContractToClient to delete.
     */
    where: ClientContractToClientWhereUniqueInput
  }

  /**
   * ClientContractToClient deleteMany
   */
  export type ClientContractToClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientContractToClients to delete
     */
    where?: ClientContractToClientWhereInput
  }

  /**
   * ClientContractToClient without action
   */
  export type ClientContractToClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
  }


  /**
   * Model ScheduledPayment
   */

  export type AggregateScheduledPayment = {
    _count: ScheduledPaymentCountAggregateOutputType | null
    _avg: ScheduledPaymentAvgAggregateOutputType | null
    _sum: ScheduledPaymentSumAggregateOutputType | null
    _min: ScheduledPaymentMinAggregateOutputType | null
    _max: ScheduledPaymentMaxAggregateOutputType | null
  }

  export type ScheduledPaymentAvgAggregateOutputType = {
    id: number | null
    payment: Decimal | null
    client_contract_id: number | null
  }

  export type ScheduledPaymentSumAggregateOutputType = {
    id: number | null
    payment: Decimal | null
    client_contract_id: number | null
  }

  export type ScheduledPaymentMinAggregateOutputType = {
    id: number | null
    payment: Decimal | null
    date: Date | null
    scheduled_payment_type: $Enums.ScheduledPaymentType | null
    created_at: Date | null
    updated_at: Date | null
    client_contract_id: number | null
  }

  export type ScheduledPaymentMaxAggregateOutputType = {
    id: number | null
    payment: Decimal | null
    date: Date | null
    scheduled_payment_type: $Enums.ScheduledPaymentType | null
    created_at: Date | null
    updated_at: Date | null
    client_contract_id: number | null
  }

  export type ScheduledPaymentCountAggregateOutputType = {
    id: number
    payment: number
    date: number
    scheduled_payment_type: number
    created_at: number
    updated_at: number
    client_contract_id: number
    _all: number
  }


  export type ScheduledPaymentAvgAggregateInputType = {
    id?: true
    payment?: true
    client_contract_id?: true
  }

  export type ScheduledPaymentSumAggregateInputType = {
    id?: true
    payment?: true
    client_contract_id?: true
  }

  export type ScheduledPaymentMinAggregateInputType = {
    id?: true
    payment?: true
    date?: true
    scheduled_payment_type?: true
    created_at?: true
    updated_at?: true
    client_contract_id?: true
  }

  export type ScheduledPaymentMaxAggregateInputType = {
    id?: true
    payment?: true
    date?: true
    scheduled_payment_type?: true
    created_at?: true
    updated_at?: true
    client_contract_id?: true
  }

  export type ScheduledPaymentCountAggregateInputType = {
    id?: true
    payment?: true
    date?: true
    scheduled_payment_type?: true
    created_at?: true
    updated_at?: true
    client_contract_id?: true
    _all?: true
  }

  export type ScheduledPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledPayment to aggregate.
     */
    where?: ScheduledPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPayments to fetch.
     */
    orderBy?: ScheduledPaymentOrderByWithRelationInput | ScheduledPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduledPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduledPayments
    **/
    _count?: true | ScheduledPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduledPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduledPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduledPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduledPaymentMaxAggregateInputType
  }

  export type GetScheduledPaymentAggregateType<T extends ScheduledPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduledPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduledPayment[P]>
      : GetScalarType<T[P], AggregateScheduledPayment[P]>
  }




  export type ScheduledPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledPaymentWhereInput
    orderBy?: ScheduledPaymentOrderByWithAggregationInput | ScheduledPaymentOrderByWithAggregationInput[]
    by: ScheduledPaymentScalarFieldEnum[] | ScheduledPaymentScalarFieldEnum
    having?: ScheduledPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduledPaymentCountAggregateInputType | true
    _avg?: ScheduledPaymentAvgAggregateInputType
    _sum?: ScheduledPaymentSumAggregateInputType
    _min?: ScheduledPaymentMinAggregateInputType
    _max?: ScheduledPaymentMaxAggregateInputType
  }

  export type ScheduledPaymentGroupByOutputType = {
    id: number
    payment: Decimal
    date: Date
    scheduled_payment_type: $Enums.ScheduledPaymentType
    created_at: Date
    updated_at: Date
    client_contract_id: number
    _count: ScheduledPaymentCountAggregateOutputType | null
    _avg: ScheduledPaymentAvgAggregateOutputType | null
    _sum: ScheduledPaymentSumAggregateOutputType | null
    _min: ScheduledPaymentMinAggregateOutputType | null
    _max: ScheduledPaymentMaxAggregateOutputType | null
  }

  type GetScheduledPaymentGroupByPayload<T extends ScheduledPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduledPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduledPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduledPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduledPaymentGroupByOutputType[P]>
        }
      >
    >


  export type ScheduledPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payment?: boolean
    date?: boolean
    scheduled_payment_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_contract_id?: boolean
    client_contract?: boolean | ClientContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledPayment"]>


  export type ScheduledPaymentSelectScalar = {
    id?: boolean
    payment?: boolean
    date?: boolean
    scheduled_payment_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_contract_id?: boolean
  }

  export type ScheduledPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_contract?: boolean | ClientContractDefaultArgs<ExtArgs>
  }

  export type $ScheduledPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduledPayment"
    objects: {
      client_contract: Prisma.$ClientContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      payment: Prisma.Decimal
      date: Date
      scheduled_payment_type: $Enums.ScheduledPaymentType
      created_at: Date
      updated_at: Date
      client_contract_id: number
    }, ExtArgs["result"]["scheduledPayment"]>
    composites: {}
  }

  type ScheduledPaymentGetPayload<S extends boolean | null | undefined | ScheduledPaymentDefaultArgs> = $Result.GetResult<Prisma.$ScheduledPaymentPayload, S>

  type ScheduledPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScheduledPaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScheduledPaymentCountAggregateInputType | true
    }

  export interface ScheduledPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduledPayment'], meta: { name: 'ScheduledPayment' } }
    /**
     * Find zero or one ScheduledPayment that matches the filter.
     * @param {ScheduledPaymentFindUniqueArgs} args - Arguments to find a ScheduledPayment
     * @example
     * // Get one ScheduledPayment
     * const scheduledPayment = await prisma.scheduledPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ScheduledPaymentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ScheduledPaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__ScheduledPaymentClient<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ScheduledPayment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScheduledPaymentFindUniqueOrThrowArgs} args - Arguments to find a ScheduledPayment
     * @example
     * // Get one ScheduledPayment
     * const scheduledPayment = await prisma.scheduledPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ScheduledPaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ScheduledPaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ScheduledPaymentClient<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ScheduledPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPaymentFindFirstArgs} args - Arguments to find a ScheduledPayment
     * @example
     * // Get one ScheduledPayment
     * const scheduledPayment = await prisma.scheduledPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ScheduledPaymentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ScheduledPaymentFindFirstArgs<ExtArgs>>
    ): Prisma__ScheduledPaymentClient<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ScheduledPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPaymentFindFirstOrThrowArgs} args - Arguments to find a ScheduledPayment
     * @example
     * // Get one ScheduledPayment
     * const scheduledPayment = await prisma.scheduledPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ScheduledPaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ScheduledPaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ScheduledPaymentClient<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ScheduledPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduledPayments
     * const scheduledPayments = await prisma.scheduledPayment.findMany()
     * 
     * // Get first 10 ScheduledPayments
     * const scheduledPayments = await prisma.scheduledPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduledPaymentWithIdOnly = await prisma.scheduledPayment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ScheduledPaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ScheduledPaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ScheduledPayment.
     * @param {ScheduledPaymentCreateArgs} args - Arguments to create a ScheduledPayment.
     * @example
     * // Create one ScheduledPayment
     * const ScheduledPayment = await prisma.scheduledPayment.create({
     *   data: {
     *     // ... data to create a ScheduledPayment
     *   }
     * })
     * 
    **/
    create<T extends ScheduledPaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ScheduledPaymentCreateArgs<ExtArgs>>
    ): Prisma__ScheduledPaymentClient<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ScheduledPayments.
     * @param {ScheduledPaymentCreateManyArgs} args - Arguments to create many ScheduledPayments.
     * @example
     * // Create many ScheduledPayments
     * const scheduledPayment = await prisma.scheduledPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ScheduledPaymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ScheduledPaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ScheduledPayment.
     * @param {ScheduledPaymentDeleteArgs} args - Arguments to delete one ScheduledPayment.
     * @example
     * // Delete one ScheduledPayment
     * const ScheduledPayment = await prisma.scheduledPayment.delete({
     *   where: {
     *     // ... filter to delete one ScheduledPayment
     *   }
     * })
     * 
    **/
    delete<T extends ScheduledPaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ScheduledPaymentDeleteArgs<ExtArgs>>
    ): Prisma__ScheduledPaymentClient<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ScheduledPayment.
     * @param {ScheduledPaymentUpdateArgs} args - Arguments to update one ScheduledPayment.
     * @example
     * // Update one ScheduledPayment
     * const scheduledPayment = await prisma.scheduledPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ScheduledPaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ScheduledPaymentUpdateArgs<ExtArgs>>
    ): Prisma__ScheduledPaymentClient<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ScheduledPayments.
     * @param {ScheduledPaymentDeleteManyArgs} args - Arguments to filter ScheduledPayments to delete.
     * @example
     * // Delete a few ScheduledPayments
     * const { count } = await prisma.scheduledPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ScheduledPaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ScheduledPaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduledPayments
     * const scheduledPayment = await prisma.scheduledPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ScheduledPaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ScheduledPaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScheduledPayment.
     * @param {ScheduledPaymentUpsertArgs} args - Arguments to update or create a ScheduledPayment.
     * @example
     * // Update or create a ScheduledPayment
     * const scheduledPayment = await prisma.scheduledPayment.upsert({
     *   create: {
     *     // ... data to create a ScheduledPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduledPayment we want to update
     *   }
     * })
    **/
    upsert<T extends ScheduledPaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ScheduledPaymentUpsertArgs<ExtArgs>>
    ): Prisma__ScheduledPaymentClient<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ScheduledPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPaymentCountArgs} args - Arguments to filter ScheduledPayments to count.
     * @example
     * // Count the number of ScheduledPayments
     * const count = await prisma.scheduledPayment.count({
     *   where: {
     *     // ... the filter for the ScheduledPayments we want to count
     *   }
     * })
    **/
    count<T extends ScheduledPaymentCountArgs>(
      args?: Subset<T, ScheduledPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduledPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduledPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduledPaymentAggregateArgs>(args: Subset<T, ScheduledPaymentAggregateArgs>): Prisma.PrismaPromise<GetScheduledPaymentAggregateType<T>>

    /**
     * Group by ScheduledPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduledPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduledPaymentGroupByArgs['orderBy'] }
        : { orderBy?: ScheduledPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduledPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduledPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduledPayment model
   */
  readonly fields: ScheduledPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduledPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduledPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client_contract<T extends ClientContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientContractDefaultArgs<ExtArgs>>): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ScheduledPayment model
   */ 
  interface ScheduledPaymentFieldRefs {
    readonly id: FieldRef<"ScheduledPayment", 'Int'>
    readonly payment: FieldRef<"ScheduledPayment", 'Decimal'>
    readonly date: FieldRef<"ScheduledPayment", 'DateTime'>
    readonly scheduled_payment_type: FieldRef<"ScheduledPayment", 'ScheduledPaymentType'>
    readonly created_at: FieldRef<"ScheduledPayment", 'DateTime'>
    readonly updated_at: FieldRef<"ScheduledPayment", 'DateTime'>
    readonly client_contract_id: FieldRef<"ScheduledPayment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ScheduledPayment findUnique
   */
  export type ScheduledPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPayment to fetch.
     */
    where: ScheduledPaymentWhereUniqueInput
  }

  /**
   * ScheduledPayment findUniqueOrThrow
   */
  export type ScheduledPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPayment to fetch.
     */
    where: ScheduledPaymentWhereUniqueInput
  }

  /**
   * ScheduledPayment findFirst
   */
  export type ScheduledPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPayment to fetch.
     */
    where?: ScheduledPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPayments to fetch.
     */
    orderBy?: ScheduledPaymentOrderByWithRelationInput | ScheduledPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledPayments.
     */
    cursor?: ScheduledPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledPayments.
     */
    distinct?: ScheduledPaymentScalarFieldEnum | ScheduledPaymentScalarFieldEnum[]
  }

  /**
   * ScheduledPayment findFirstOrThrow
   */
  export type ScheduledPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPayment to fetch.
     */
    where?: ScheduledPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPayments to fetch.
     */
    orderBy?: ScheduledPaymentOrderByWithRelationInput | ScheduledPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledPayments.
     */
    cursor?: ScheduledPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledPayments.
     */
    distinct?: ScheduledPaymentScalarFieldEnum | ScheduledPaymentScalarFieldEnum[]
  }

  /**
   * ScheduledPayment findMany
   */
  export type ScheduledPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPayments to fetch.
     */
    where?: ScheduledPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPayments to fetch.
     */
    orderBy?: ScheduledPaymentOrderByWithRelationInput | ScheduledPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduledPayments.
     */
    cursor?: ScheduledPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPayments.
     */
    skip?: number
    distinct?: ScheduledPaymentScalarFieldEnum | ScheduledPaymentScalarFieldEnum[]
  }

  /**
   * ScheduledPayment create
   */
  export type ScheduledPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduledPayment.
     */
    data: XOR<ScheduledPaymentCreateInput, ScheduledPaymentUncheckedCreateInput>
  }

  /**
   * ScheduledPayment createMany
   */
  export type ScheduledPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduledPayments.
     */
    data: ScheduledPaymentCreateManyInput | ScheduledPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledPayment update
   */
  export type ScheduledPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduledPayment.
     */
    data: XOR<ScheduledPaymentUpdateInput, ScheduledPaymentUncheckedUpdateInput>
    /**
     * Choose, which ScheduledPayment to update.
     */
    where: ScheduledPaymentWhereUniqueInput
  }

  /**
   * ScheduledPayment updateMany
   */
  export type ScheduledPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduledPayments.
     */
    data: XOR<ScheduledPaymentUpdateManyMutationInput, ScheduledPaymentUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledPayments to update
     */
    where?: ScheduledPaymentWhereInput
  }

  /**
   * ScheduledPayment upsert
   */
  export type ScheduledPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduledPayment to update in case it exists.
     */
    where: ScheduledPaymentWhereUniqueInput
    /**
     * In case the ScheduledPayment found by the `where` argument doesn't exist, create a new ScheduledPayment with this data.
     */
    create: XOR<ScheduledPaymentCreateInput, ScheduledPaymentUncheckedCreateInput>
    /**
     * In case the ScheduledPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduledPaymentUpdateInput, ScheduledPaymentUncheckedUpdateInput>
  }

  /**
   * ScheduledPayment delete
   */
  export type ScheduledPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    /**
     * Filter which ScheduledPayment to delete.
     */
    where: ScheduledPaymentWhereUniqueInput
  }

  /**
   * ScheduledPayment deleteMany
   */
  export type ScheduledPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledPayments to delete
     */
    where?: ScheduledPaymentWhereInput
  }

  /**
   * ScheduledPayment without action
   */
  export type ScheduledPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
  }


  /**
   * Model ActualPayment
   */

  export type AggregateActualPayment = {
    _count: ActualPaymentCountAggregateOutputType | null
    _avg: ActualPaymentAvgAggregateOutputType | null
    _sum: ActualPaymentSumAggregateOutputType | null
    _min: ActualPaymentMinAggregateOutputType | null
    _max: ActualPaymentMaxAggregateOutputType | null
  }

  export type ActualPaymentAvgAggregateOutputType = {
    id: number | null
    payment: Decimal | null
    client_contract_id: number | null
  }

  export type ActualPaymentSumAggregateOutputType = {
    id: number | null
    payment: Decimal | null
    client_contract_id: number | null
  }

  export type ActualPaymentMinAggregateOutputType = {
    id: number | null
    payment: Decimal | null
    date: Date | null
    created_at: Date | null
    updated_at: Date | null
    client_contract_id: number | null
  }

  export type ActualPaymentMaxAggregateOutputType = {
    id: number | null
    payment: Decimal | null
    date: Date | null
    created_at: Date | null
    updated_at: Date | null
    client_contract_id: number | null
  }

  export type ActualPaymentCountAggregateOutputType = {
    id: number
    payment: number
    date: number
    created_at: number
    updated_at: number
    client_contract_id: number
    _all: number
  }


  export type ActualPaymentAvgAggregateInputType = {
    id?: true
    payment?: true
    client_contract_id?: true
  }

  export type ActualPaymentSumAggregateInputType = {
    id?: true
    payment?: true
    client_contract_id?: true
  }

  export type ActualPaymentMinAggregateInputType = {
    id?: true
    payment?: true
    date?: true
    created_at?: true
    updated_at?: true
    client_contract_id?: true
  }

  export type ActualPaymentMaxAggregateInputType = {
    id?: true
    payment?: true
    date?: true
    created_at?: true
    updated_at?: true
    client_contract_id?: true
  }

  export type ActualPaymentCountAggregateInputType = {
    id?: true
    payment?: true
    date?: true
    created_at?: true
    updated_at?: true
    client_contract_id?: true
    _all?: true
  }

  export type ActualPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActualPayment to aggregate.
     */
    where?: ActualPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActualPayments to fetch.
     */
    orderBy?: ActualPaymentOrderByWithRelationInput | ActualPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActualPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActualPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActualPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActualPayments
    **/
    _count?: true | ActualPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActualPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActualPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActualPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActualPaymentMaxAggregateInputType
  }

  export type GetActualPaymentAggregateType<T extends ActualPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateActualPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActualPayment[P]>
      : GetScalarType<T[P], AggregateActualPayment[P]>
  }




  export type ActualPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActualPaymentWhereInput
    orderBy?: ActualPaymentOrderByWithAggregationInput | ActualPaymentOrderByWithAggregationInput[]
    by: ActualPaymentScalarFieldEnum[] | ActualPaymentScalarFieldEnum
    having?: ActualPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActualPaymentCountAggregateInputType | true
    _avg?: ActualPaymentAvgAggregateInputType
    _sum?: ActualPaymentSumAggregateInputType
    _min?: ActualPaymentMinAggregateInputType
    _max?: ActualPaymentMaxAggregateInputType
  }

  export type ActualPaymentGroupByOutputType = {
    id: number
    payment: Decimal
    date: Date
    created_at: Date
    updated_at: Date
    client_contract_id: number
    _count: ActualPaymentCountAggregateOutputType | null
    _avg: ActualPaymentAvgAggregateOutputType | null
    _sum: ActualPaymentSumAggregateOutputType | null
    _min: ActualPaymentMinAggregateOutputType | null
    _max: ActualPaymentMaxAggregateOutputType | null
  }

  type GetActualPaymentGroupByPayload<T extends ActualPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActualPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActualPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActualPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], ActualPaymentGroupByOutputType[P]>
        }
      >
    >


  export type ActualPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payment?: boolean
    date?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_contract_id?: boolean
    client_contract?: boolean | ClientContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actualPayment"]>


  export type ActualPaymentSelectScalar = {
    id?: boolean
    payment?: boolean
    date?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_contract_id?: boolean
  }

  export type ActualPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_contract?: boolean | ClientContractDefaultArgs<ExtArgs>
  }

  export type $ActualPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActualPayment"
    objects: {
      client_contract: Prisma.$ClientContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      payment: Prisma.Decimal
      date: Date
      created_at: Date
      updated_at: Date
      client_contract_id: number
    }, ExtArgs["result"]["actualPayment"]>
    composites: {}
  }

  type ActualPaymentGetPayload<S extends boolean | null | undefined | ActualPaymentDefaultArgs> = $Result.GetResult<Prisma.$ActualPaymentPayload, S>

  type ActualPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActualPaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActualPaymentCountAggregateInputType | true
    }

  export interface ActualPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActualPayment'], meta: { name: 'ActualPayment' } }
    /**
     * Find zero or one ActualPayment that matches the filter.
     * @param {ActualPaymentFindUniqueArgs} args - Arguments to find a ActualPayment
     * @example
     * // Get one ActualPayment
     * const actualPayment = await prisma.actualPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActualPaymentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ActualPaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__ActualPaymentClient<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ActualPayment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActualPaymentFindUniqueOrThrowArgs} args - Arguments to find a ActualPayment
     * @example
     * // Get one ActualPayment
     * const actualPayment = await prisma.actualPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ActualPaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ActualPaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ActualPaymentClient<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ActualPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualPaymentFindFirstArgs} args - Arguments to find a ActualPayment
     * @example
     * // Get one ActualPayment
     * const actualPayment = await prisma.actualPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActualPaymentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ActualPaymentFindFirstArgs<ExtArgs>>
    ): Prisma__ActualPaymentClient<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ActualPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualPaymentFindFirstOrThrowArgs} args - Arguments to find a ActualPayment
     * @example
     * // Get one ActualPayment
     * const actualPayment = await prisma.actualPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ActualPaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ActualPaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ActualPaymentClient<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ActualPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActualPayments
     * const actualPayments = await prisma.actualPayment.findMany()
     * 
     * // Get first 10 ActualPayments
     * const actualPayments = await prisma.actualPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actualPaymentWithIdOnly = await prisma.actualPayment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ActualPaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActualPaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ActualPayment.
     * @param {ActualPaymentCreateArgs} args - Arguments to create a ActualPayment.
     * @example
     * // Create one ActualPayment
     * const ActualPayment = await prisma.actualPayment.create({
     *   data: {
     *     // ... data to create a ActualPayment
     *   }
     * })
     * 
    **/
    create<T extends ActualPaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ActualPaymentCreateArgs<ExtArgs>>
    ): Prisma__ActualPaymentClient<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ActualPayments.
     * @param {ActualPaymentCreateManyArgs} args - Arguments to create many ActualPayments.
     * @example
     * // Create many ActualPayments
     * const actualPayment = await prisma.actualPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ActualPaymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActualPaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ActualPayment.
     * @param {ActualPaymentDeleteArgs} args - Arguments to delete one ActualPayment.
     * @example
     * // Delete one ActualPayment
     * const ActualPayment = await prisma.actualPayment.delete({
     *   where: {
     *     // ... filter to delete one ActualPayment
     *   }
     * })
     * 
    **/
    delete<T extends ActualPaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ActualPaymentDeleteArgs<ExtArgs>>
    ): Prisma__ActualPaymentClient<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ActualPayment.
     * @param {ActualPaymentUpdateArgs} args - Arguments to update one ActualPayment.
     * @example
     * // Update one ActualPayment
     * const actualPayment = await prisma.actualPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActualPaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ActualPaymentUpdateArgs<ExtArgs>>
    ): Prisma__ActualPaymentClient<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ActualPayments.
     * @param {ActualPaymentDeleteManyArgs} args - Arguments to filter ActualPayments to delete.
     * @example
     * // Delete a few ActualPayments
     * const { count } = await prisma.actualPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActualPaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActualPaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActualPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActualPayments
     * const actualPayment = await prisma.actualPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActualPaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ActualPaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActualPayment.
     * @param {ActualPaymentUpsertArgs} args - Arguments to update or create a ActualPayment.
     * @example
     * // Update or create a ActualPayment
     * const actualPayment = await prisma.actualPayment.upsert({
     *   create: {
     *     // ... data to create a ActualPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActualPayment we want to update
     *   }
     * })
    **/
    upsert<T extends ActualPaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ActualPaymentUpsertArgs<ExtArgs>>
    ): Prisma__ActualPaymentClient<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ActualPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualPaymentCountArgs} args - Arguments to filter ActualPayments to count.
     * @example
     * // Count the number of ActualPayments
     * const count = await prisma.actualPayment.count({
     *   where: {
     *     // ... the filter for the ActualPayments we want to count
     *   }
     * })
    **/
    count<T extends ActualPaymentCountArgs>(
      args?: Subset<T, ActualPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActualPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActualPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActualPaymentAggregateArgs>(args: Subset<T, ActualPaymentAggregateArgs>): Prisma.PrismaPromise<GetActualPaymentAggregateType<T>>

    /**
     * Group by ActualPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActualPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActualPaymentGroupByArgs['orderBy'] }
        : { orderBy?: ActualPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActualPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActualPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActualPayment model
   */
  readonly fields: ActualPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActualPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActualPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client_contract<T extends ClientContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientContractDefaultArgs<ExtArgs>>): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ActualPayment model
   */ 
  interface ActualPaymentFieldRefs {
    readonly id: FieldRef<"ActualPayment", 'Int'>
    readonly payment: FieldRef<"ActualPayment", 'Decimal'>
    readonly date: FieldRef<"ActualPayment", 'DateTime'>
    readonly created_at: FieldRef<"ActualPayment", 'DateTime'>
    readonly updated_at: FieldRef<"ActualPayment", 'DateTime'>
    readonly client_contract_id: FieldRef<"ActualPayment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ActualPayment findUnique
   */
  export type ActualPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ActualPayment to fetch.
     */
    where: ActualPaymentWhereUniqueInput
  }

  /**
   * ActualPayment findUniqueOrThrow
   */
  export type ActualPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ActualPayment to fetch.
     */
    where: ActualPaymentWhereUniqueInput
  }

  /**
   * ActualPayment findFirst
   */
  export type ActualPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ActualPayment to fetch.
     */
    where?: ActualPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActualPayments to fetch.
     */
    orderBy?: ActualPaymentOrderByWithRelationInput | ActualPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActualPayments.
     */
    cursor?: ActualPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActualPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActualPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActualPayments.
     */
    distinct?: ActualPaymentScalarFieldEnum | ActualPaymentScalarFieldEnum[]
  }

  /**
   * ActualPayment findFirstOrThrow
   */
  export type ActualPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ActualPayment to fetch.
     */
    where?: ActualPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActualPayments to fetch.
     */
    orderBy?: ActualPaymentOrderByWithRelationInput | ActualPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActualPayments.
     */
    cursor?: ActualPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActualPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActualPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActualPayments.
     */
    distinct?: ActualPaymentScalarFieldEnum | ActualPaymentScalarFieldEnum[]
  }

  /**
   * ActualPayment findMany
   */
  export type ActualPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ActualPayments to fetch.
     */
    where?: ActualPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActualPayments to fetch.
     */
    orderBy?: ActualPaymentOrderByWithRelationInput | ActualPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActualPayments.
     */
    cursor?: ActualPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActualPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActualPayments.
     */
    skip?: number
    distinct?: ActualPaymentScalarFieldEnum | ActualPaymentScalarFieldEnum[]
  }

  /**
   * ActualPayment create
   */
  export type ActualPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a ActualPayment.
     */
    data: XOR<ActualPaymentCreateInput, ActualPaymentUncheckedCreateInput>
  }

  /**
   * ActualPayment createMany
   */
  export type ActualPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActualPayments.
     */
    data: ActualPaymentCreateManyInput | ActualPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActualPayment update
   */
  export type ActualPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a ActualPayment.
     */
    data: XOR<ActualPaymentUpdateInput, ActualPaymentUncheckedUpdateInput>
    /**
     * Choose, which ActualPayment to update.
     */
    where: ActualPaymentWhereUniqueInput
  }

  /**
   * ActualPayment updateMany
   */
  export type ActualPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActualPayments.
     */
    data: XOR<ActualPaymentUpdateManyMutationInput, ActualPaymentUncheckedUpdateManyInput>
    /**
     * Filter which ActualPayments to update
     */
    where?: ActualPaymentWhereInput
  }

  /**
   * ActualPayment upsert
   */
  export type ActualPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the ActualPayment to update in case it exists.
     */
    where: ActualPaymentWhereUniqueInput
    /**
     * In case the ActualPayment found by the `where` argument doesn't exist, create a new ActualPayment with this data.
     */
    create: XOR<ActualPaymentCreateInput, ActualPaymentUncheckedCreateInput>
    /**
     * In case the ActualPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActualPaymentUpdateInput, ActualPaymentUncheckedUpdateInput>
  }

  /**
   * ActualPayment delete
   */
  export type ActualPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    /**
     * Filter which ActualPayment to delete.
     */
    where: ActualPaymentWhereUniqueInput
  }

  /**
   * ActualPayment deleteMany
   */
  export type ActualPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActualPayments to delete
     */
    where?: ActualPaymentWhereInput
  }

  /**
   * ActualPayment without action
   */
  export type ActualPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
  }


  /**
   * Model Object
   */

  export type AggregateObject = {
    _count: ObjectCountAggregateOutputType | null
    _avg: ObjectAvgAggregateOutputType | null
    _sum: ObjectSumAggregateOutputType | null
    _min: ObjectMinAggregateOutputType | null
    _max: ObjectMaxAggregateOutputType | null
  }

  export type ObjectAvgAggregateOutputType = {
    id: number | null
    common_db_objects_id: number | null
    entity_id: number | null
  }

  export type ObjectSumAggregateOutputType = {
    id: number | null
    common_db_objects_id: number | null
    entity_id: number | null
  }

  export type ObjectMinAggregateOutputType = {
    id: number | null
    common_db_objects_id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    entity_id: number | null
  }

  export type ObjectMaxAggregateOutputType = {
    id: number | null
    common_db_objects_id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    entity_id: number | null
  }

  export type ObjectCountAggregateOutputType = {
    id: number
    common_db_objects_id: number
    name: number
    created_at: number
    updated_at: number
    entity_id: number
    _all: number
  }


  export type ObjectAvgAggregateInputType = {
    id?: true
    common_db_objects_id?: true
    entity_id?: true
  }

  export type ObjectSumAggregateInputType = {
    id?: true
    common_db_objects_id?: true
    entity_id?: true
  }

  export type ObjectMinAggregateInputType = {
    id?: true
    common_db_objects_id?: true
    name?: true
    created_at?: true
    updated_at?: true
    entity_id?: true
  }

  export type ObjectMaxAggregateInputType = {
    id?: true
    common_db_objects_id?: true
    name?: true
    created_at?: true
    updated_at?: true
    entity_id?: true
  }

  export type ObjectCountAggregateInputType = {
    id?: true
    common_db_objects_id?: true
    name?: true
    created_at?: true
    updated_at?: true
    entity_id?: true
    _all?: true
  }

  export type ObjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Object to aggregate.
     */
    where?: ObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objects to fetch.
     */
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Objects
    **/
    _count?: true | ObjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjectMaxAggregateInputType
  }

  export type GetObjectAggregateType<T extends ObjectAggregateArgs> = {
        [P in keyof T & keyof AggregateObject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObject[P]>
      : GetScalarType<T[P], AggregateObject[P]>
  }




  export type ObjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectWhereInput
    orderBy?: ObjectOrderByWithAggregationInput | ObjectOrderByWithAggregationInput[]
    by: ObjectScalarFieldEnum[] | ObjectScalarFieldEnum
    having?: ObjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjectCountAggregateInputType | true
    _avg?: ObjectAvgAggregateInputType
    _sum?: ObjectSumAggregateInputType
    _min?: ObjectMinAggregateInputType
    _max?: ObjectMaxAggregateInputType
  }

  export type ObjectGroupByOutputType = {
    id: number
    common_db_objects_id: number
    name: string
    created_at: Date
    updated_at: Date
    entity_id: number
    _count: ObjectCountAggregateOutputType | null
    _avg: ObjectAvgAggregateOutputType | null
    _sum: ObjectSumAggregateOutputType | null
    _min: ObjectMinAggregateOutputType | null
    _max: ObjectMaxAggregateOutputType | null
  }

  type GetObjectGroupByPayload<T extends ObjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjectGroupByOutputType[P]>
            : GetScalarType<T[P], ObjectGroupByOutputType[P]>
        }
      >
    >


  export type ObjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    common_db_objects_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    entity_id?: boolean
    entity?: boolean | EntityDefaultArgs<ExtArgs>
    products?: boolean | Object$productsArgs<ExtArgs>
    client_contracts?: boolean | Object$client_contractsArgs<ExtArgs>
    agency_contracts?: boolean | Object$agency_contractsArgs<ExtArgs>
    _count?: boolean | ObjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["object"]>


  export type ObjectSelectScalar = {
    id?: boolean
    common_db_objects_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    entity_id?: boolean
  }

  export type ObjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entity?: boolean | EntityDefaultArgs<ExtArgs>
    products?: boolean | Object$productsArgs<ExtArgs>
    client_contracts?: boolean | Object$client_contractsArgs<ExtArgs>
    agency_contracts?: boolean | Object$agency_contractsArgs<ExtArgs>
    _count?: boolean | ObjectCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ObjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Object"
    objects: {
      entity: Prisma.$EntityPayload<ExtArgs>
      products: Prisma.$ProductPayload<ExtArgs>[]
      client_contracts: Prisma.$ClientContractPayload<ExtArgs>[]
      agency_contracts: Prisma.$AgencyContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      common_db_objects_id: number
      name: string
      created_at: Date
      updated_at: Date
      entity_id: number
    }, ExtArgs["result"]["object"]>
    composites: {}
  }

  type ObjectGetPayload<S extends boolean | null | undefined | ObjectDefaultArgs> = $Result.GetResult<Prisma.$ObjectPayload, S>

  type ObjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ObjectCountAggregateInputType | true
    }

  export interface ObjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Object'], meta: { name: 'Object' } }
    /**
     * Find zero or one Object that matches the filter.
     * @param {ObjectFindUniqueArgs} args - Arguments to find a Object
     * @example
     * // Get one Object
     * const object = await prisma.object.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ObjectFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectFindUniqueArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Object that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ObjectFindUniqueOrThrowArgs} args - Arguments to find a Object
     * @example
     * // Get one Object
     * const object = await prisma.object.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ObjectFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Object that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectFindFirstArgs} args - Arguments to find a Object
     * @example
     * // Get one Object
     * const object = await prisma.object.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ObjectFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectFindFirstArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Object that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectFindFirstOrThrowArgs} args - Arguments to find a Object
     * @example
     * // Get one Object
     * const object = await prisma.object.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ObjectFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Objects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Objects
     * const objects = await prisma.object.findMany()
     * 
     * // Get first 10 Objects
     * const objects = await prisma.object.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objectWithIdOnly = await prisma.object.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ObjectFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Object.
     * @param {ObjectCreateArgs} args - Arguments to create a Object.
     * @example
     * // Create one Object
     * const Object = await prisma.object.create({
     *   data: {
     *     // ... data to create a Object
     *   }
     * })
     * 
    **/
    create<T extends ObjectCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectCreateArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Objects.
     * @param {ObjectCreateManyArgs} args - Arguments to create many Objects.
     * @example
     * // Create many Objects
     * const object = await prisma.object.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ObjectCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Object.
     * @param {ObjectDeleteArgs} args - Arguments to delete one Object.
     * @example
     * // Delete one Object
     * const Object = await prisma.object.delete({
     *   where: {
     *     // ... filter to delete one Object
     *   }
     * })
     * 
    **/
    delete<T extends ObjectDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectDeleteArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Object.
     * @param {ObjectUpdateArgs} args - Arguments to update one Object.
     * @example
     * // Update one Object
     * const object = await prisma.object.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ObjectUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectUpdateArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Objects.
     * @param {ObjectDeleteManyArgs} args - Arguments to filter Objects to delete.
     * @example
     * // Delete a few Objects
     * const { count } = await prisma.object.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ObjectDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Objects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Objects
     * const object = await prisma.object.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ObjectUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Object.
     * @param {ObjectUpsertArgs} args - Arguments to update or create a Object.
     * @example
     * // Update or create a Object
     * const object = await prisma.object.upsert({
     *   create: {
     *     // ... data to create a Object
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Object we want to update
     *   }
     * })
    **/
    upsert<T extends ObjectUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectUpsertArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Objects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectCountArgs} args - Arguments to filter Objects to count.
     * @example
     * // Count the number of Objects
     * const count = await prisma.object.count({
     *   where: {
     *     // ... the filter for the Objects we want to count
     *   }
     * })
    **/
    count<T extends ObjectCountArgs>(
      args?: Subset<T, ObjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Object.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjectAggregateArgs>(args: Subset<T, ObjectAggregateArgs>): Prisma.PrismaPromise<GetObjectAggregateType<T>>

    /**
     * Group by Object.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObjectGroupByArgs['orderBy'] }
        : { orderBy?: ObjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Object model
   */
  readonly fields: ObjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Object.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entity<T extends EntityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntityDefaultArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    products<T extends Object$productsArgs<ExtArgs> = {}>(args?: Subset<T, Object$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    client_contracts<T extends Object$client_contractsArgs<ExtArgs> = {}>(args?: Subset<T, Object$client_contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    agency_contracts<T extends Object$agency_contractsArgs<ExtArgs> = {}>(args?: Subset<T, Object$agency_contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Object model
   */ 
  interface ObjectFieldRefs {
    readonly id: FieldRef<"Object", 'Int'>
    readonly common_db_objects_id: FieldRef<"Object", 'Int'>
    readonly name: FieldRef<"Object", 'String'>
    readonly created_at: FieldRef<"Object", 'DateTime'>
    readonly updated_at: FieldRef<"Object", 'DateTime'>
    readonly entity_id: FieldRef<"Object", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Object findUnique
   */
  export type ObjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Object to fetch.
     */
    where: ObjectWhereUniqueInput
  }

  /**
   * Object findUniqueOrThrow
   */
  export type ObjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Object to fetch.
     */
    where: ObjectWhereUniqueInput
  }

  /**
   * Object findFirst
   */
  export type ObjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Object to fetch.
     */
    where?: ObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objects to fetch.
     */
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Objects.
     */
    cursor?: ObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Objects.
     */
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * Object findFirstOrThrow
   */
  export type ObjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Object to fetch.
     */
    where?: ObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objects to fetch.
     */
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Objects.
     */
    cursor?: ObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Objects.
     */
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * Object findMany
   */
  export type ObjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Objects to fetch.
     */
    where?: ObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objects to fetch.
     */
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Objects.
     */
    cursor?: ObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objects.
     */
    skip?: number
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * Object create
   */
  export type ObjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Object.
     */
    data: XOR<ObjectCreateInput, ObjectUncheckedCreateInput>
  }

  /**
   * Object createMany
   */
  export type ObjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Objects.
     */
    data: ObjectCreateManyInput | ObjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Object update
   */
  export type ObjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Object.
     */
    data: XOR<ObjectUpdateInput, ObjectUncheckedUpdateInput>
    /**
     * Choose, which Object to update.
     */
    where: ObjectWhereUniqueInput
  }

  /**
   * Object updateMany
   */
  export type ObjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Objects.
     */
    data: XOR<ObjectUpdateManyMutationInput, ObjectUncheckedUpdateManyInput>
    /**
     * Filter which Objects to update
     */
    where?: ObjectWhereInput
  }

  /**
   * Object upsert
   */
  export type ObjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Object to update in case it exists.
     */
    where: ObjectWhereUniqueInput
    /**
     * In case the Object found by the `where` argument doesn't exist, create a new Object with this data.
     */
    create: XOR<ObjectCreateInput, ObjectUncheckedCreateInput>
    /**
     * In case the Object was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObjectUpdateInput, ObjectUncheckedUpdateInput>
  }

  /**
   * Object delete
   */
  export type ObjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter which Object to delete.
     */
    where: ObjectWhereUniqueInput
  }

  /**
   * Object deleteMany
   */
  export type ObjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Objects to delete
     */
    where?: ObjectWhereInput
  }

  /**
   * Object.products
   */
  export type Object$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Object.client_contracts
   */
  export type Object$client_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    where?: ClientContractWhereInput
    orderBy?: ClientContractOrderByWithRelationInput | ClientContractOrderByWithRelationInput[]
    cursor?: ClientContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientContractScalarFieldEnum | ClientContractScalarFieldEnum[]
  }

  /**
   * Object.agency_contracts
   */
  export type Object$agency_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    where?: AgencyContractWhereInput
    orderBy?: AgencyContractOrderByWithRelationInput | AgencyContractOrderByWithRelationInput[]
    cursor?: AgencyContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyContractScalarFieldEnum | AgencyContractScalarFieldEnum[]
  }

  /**
   * Object without action
   */
  export type ObjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    pricing_products_id: number | null
    object_id: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    pricing_products_id: number | null
    object_id: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    pricing_products_id: number | null
    number: string | null
    product_category: $Enums.ProductCategory | null
    created_at: Date | null
    updated_at: Date | null
    object_id: number | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    pricing_products_id: number | null
    number: string | null
    product_category: $Enums.ProductCategory | null
    created_at: Date | null
    updated_at: Date | null
    object_id: number | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    pricing_products_id: number
    number: number
    product_category: number
    created_at: number
    updated_at: number
    object_id: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    pricing_products_id?: true
    object_id?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    pricing_products_id?: true
    object_id?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    pricing_products_id?: true
    number?: true
    product_category?: true
    created_at?: true
    updated_at?: true
    object_id?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    pricing_products_id?: true
    number?: true
    product_category?: true
    created_at?: true
    updated_at?: true
    object_id?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    pricing_products_id?: true
    number?: true
    product_category?: true
    created_at?: true
    updated_at?: true
    object_id?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    pricing_products_id: number
    number: string
    product_category: $Enums.ProductCategory
    created_at: Date
    updated_at: Date
    object_id: number
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pricing_products_id?: boolean
    number?: boolean
    product_category?: boolean
    created_at?: boolean
    updated_at?: boolean
    object_id?: boolean
    client_contract?: boolean | Product$client_contractArgs<ExtArgs>
    object?: boolean | ObjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>


  export type ProductSelectScalar = {
    id?: boolean
    pricing_products_id?: boolean
    number?: boolean
    product_category?: boolean
    created_at?: boolean
    updated_at?: boolean
    object_id?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_contract?: boolean | Product$client_contractArgs<ExtArgs>
    object?: boolean | ObjectDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      client_contract: Prisma.$ClientContractPayload<ExtArgs> | null
      object: Prisma.$ObjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pricing_products_id: number
      number: string
      product_category: $Enums.ProductCategory
      created_at: Date
      updated_at: Date
      object_id: number
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductCreateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client_contract<T extends Product$client_contractArgs<ExtArgs> = {}>(args?: Subset<T, Product$client_contractArgs<ExtArgs>>): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    object<T extends ObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectDefaultArgs<ExtArgs>>): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly pricing_products_id: FieldRef<"Product", 'Int'>
    readonly number: FieldRef<"Product", 'String'>
    readonly product_category: FieldRef<"Product", 'ProductCategory'>
    readonly created_at: FieldRef<"Product", 'DateTime'>
    readonly updated_at: FieldRef<"Product", 'DateTime'>
    readonly object_id: FieldRef<"Product", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.client_contract
   */
  export type Product$client_contractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    where?: ClientContractWhereInput
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Agency
   */

  export type AggregateAgency = {
    _count: AgencyCountAggregateOutputType | null
    _avg: AgencyAvgAggregateOutputType | null
    _sum: AgencySumAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  export type AgencyAvgAggregateOutputType = {
    id: number | null
    common_db_contractors_id: number | null
  }

  export type AgencySumAggregateOutputType = {
    id: number | null
    common_db_contractors_id: number | null
  }

  export type AgencyMinAggregateOutputType = {
    id: number | null
    common_db_contractors_id: number | null
    name: string | null
    inn: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AgencyMaxAggregateOutputType = {
    id: number | null
    common_db_contractors_id: number | null
    name: string | null
    inn: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AgencyCountAggregateOutputType = {
    id: number
    common_db_contractors_id: number
    name: number
    inn: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AgencyAvgAggregateInputType = {
    id?: true
    common_db_contractors_id?: true
  }

  export type AgencySumAggregateInputType = {
    id?: true
    common_db_contractors_id?: true
  }

  export type AgencyMinAggregateInputType = {
    id?: true
    common_db_contractors_id?: true
    name?: true
    inn?: true
    created_at?: true
    updated_at?: true
  }

  export type AgencyMaxAggregateInputType = {
    id?: true
    common_db_contractors_id?: true
    name?: true
    inn?: true
    created_at?: true
    updated_at?: true
  }

  export type AgencyCountAggregateInputType = {
    id?: true
    common_db_contractors_id?: true
    name?: true
    inn?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AgencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agency to aggregate.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agencies
    **/
    _count?: true | AgencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyMaxAggregateInputType
  }

  export type GetAgencyAggregateType<T extends AgencyAggregateArgs> = {
        [P in keyof T & keyof AggregateAgency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgency[P]>
      : GetScalarType<T[P], AggregateAgency[P]>
  }




  export type AgencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyWhereInput
    orderBy?: AgencyOrderByWithAggregationInput | AgencyOrderByWithAggregationInput[]
    by: AgencyScalarFieldEnum[] | AgencyScalarFieldEnum
    having?: AgencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyCountAggregateInputType | true
    _avg?: AgencyAvgAggregateInputType
    _sum?: AgencySumAggregateInputType
    _min?: AgencyMinAggregateInputType
    _max?: AgencyMaxAggregateInputType
  }

  export type AgencyGroupByOutputType = {
    id: number
    common_db_contractors_id: number
    name: string
    inn: string | null
    created_at: Date
    updated_at: Date
    _count: AgencyCountAggregateOutputType | null
    _avg: AgencyAvgAggregateOutputType | null
    _sum: AgencySumAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  type GetAgencyGroupByPayload<T extends AgencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyGroupByOutputType[P]>
        }
      >
    >


  export type AgencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    common_db_contractors_id?: boolean
    name?: boolean
    inn?: boolean
    created_at?: boolean
    updated_at?: boolean
    agency_contracts?: boolean | Agency$agency_contractsArgs<ExtArgs>
    real_estate_agents?: boolean | Agency$real_estate_agentsArgs<ExtArgs>
    agency_contract_signatory?: boolean | Agency$agency_contract_signatoryArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>


  export type AgencySelectScalar = {
    id?: boolean
    common_db_contractors_id?: boolean
    name?: boolean
    inn?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AgencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency_contracts?: boolean | Agency$agency_contractsArgs<ExtArgs>
    real_estate_agents?: boolean | Agency$real_estate_agentsArgs<ExtArgs>
    agency_contract_signatory?: boolean | Agency$agency_contract_signatoryArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AgencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agency"
    objects: {
      agency_contracts: Prisma.$AgencyContractPayload<ExtArgs>[]
      real_estate_agents: Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>[]
      agency_contract_signatory: Prisma.$AgencyContractSignatoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      common_db_contractors_id: number
      name: string
      inn: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["agency"]>
    composites: {}
  }

  type AgencyGetPayload<S extends boolean | null | undefined | AgencyDefaultArgs> = $Result.GetResult<Prisma.$AgencyPayload, S>

  type AgencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgencyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgencyCountAggregateInputType | true
    }

  export interface AgencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agency'], meta: { name: 'Agency' } }
    /**
     * Find zero or one Agency that matches the filter.
     * @param {AgencyFindUniqueArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgencyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyFindUniqueArgs<ExtArgs>>
    ): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Agency that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgencyFindUniqueOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgencyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Agency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgencyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyFindFirstArgs<ExtArgs>>
    ): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Agency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgencyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Agencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agencies
     * const agencies = await prisma.agency.findMany()
     * 
     * // Get first 10 Agencies
     * const agencies = await prisma.agency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyWithIdOnly = await prisma.agency.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgencyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Agency.
     * @param {AgencyCreateArgs} args - Arguments to create a Agency.
     * @example
     * // Create one Agency
     * const Agency = await prisma.agency.create({
     *   data: {
     *     // ... data to create a Agency
     *   }
     * })
     * 
    **/
    create<T extends AgencyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyCreateArgs<ExtArgs>>
    ): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Agencies.
     * @param {AgencyCreateManyArgs} args - Arguments to create many Agencies.
     * @example
     * // Create many Agencies
     * const agency = await prisma.agency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AgencyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Agency.
     * @param {AgencyDeleteArgs} args - Arguments to delete one Agency.
     * @example
     * // Delete one Agency
     * const Agency = await prisma.agency.delete({
     *   where: {
     *     // ... filter to delete one Agency
     *   }
     * })
     * 
    **/
    delete<T extends AgencyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyDeleteArgs<ExtArgs>>
    ): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Agency.
     * @param {AgencyUpdateArgs} args - Arguments to update one Agency.
     * @example
     * // Update one Agency
     * const agency = await prisma.agency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgencyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyUpdateArgs<ExtArgs>>
    ): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Agencies.
     * @param {AgencyDeleteManyArgs} args - Arguments to filter Agencies to delete.
     * @example
     * // Delete a few Agencies
     * const { count } = await prisma.agency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgencyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agencies
     * const agency = await prisma.agency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgencyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agency.
     * @param {AgencyUpsertArgs} args - Arguments to update or create a Agency.
     * @example
     * // Update or create a Agency
     * const agency = await prisma.agency.upsert({
     *   create: {
     *     // ... data to create a Agency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agency we want to update
     *   }
     * })
    **/
    upsert<T extends AgencyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyUpsertArgs<ExtArgs>>
    ): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyCountArgs} args - Arguments to filter Agencies to count.
     * @example
     * // Count the number of Agencies
     * const count = await prisma.agency.count({
     *   where: {
     *     // ... the filter for the Agencies we want to count
     *   }
     * })
    **/
    count<T extends AgencyCountArgs>(
      args?: Subset<T, AgencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyAggregateArgs>(args: Subset<T, AgencyAggregateArgs>): Prisma.PrismaPromise<GetAgencyAggregateType<T>>

    /**
     * Group by Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyGroupByArgs['orderBy'] }
        : { orderBy?: AgencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agency model
   */
  readonly fields: AgencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    agency_contracts<T extends Agency$agency_contractsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$agency_contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    real_estate_agents<T extends Agency$real_estate_agentsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$real_estate_agentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'findMany'> | Null>;

    agency_contract_signatory<T extends Agency$agency_contract_signatoryArgs<ExtArgs> = {}>(args?: Subset<T, Agency$agency_contract_signatoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Agency model
   */ 
  interface AgencyFieldRefs {
    readonly id: FieldRef<"Agency", 'Int'>
    readonly common_db_contractors_id: FieldRef<"Agency", 'Int'>
    readonly name: FieldRef<"Agency", 'String'>
    readonly inn: FieldRef<"Agency", 'String'>
    readonly created_at: FieldRef<"Agency", 'DateTime'>
    readonly updated_at: FieldRef<"Agency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agency findUnique
   */
  export type AgencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency findUniqueOrThrow
   */
  export type AgencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency findFirst
   */
  export type AgencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency findFirstOrThrow
   */
  export type AgencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency findMany
   */
  export type AgencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agencies to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency create
   */
  export type AgencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Agency.
     */
    data: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
  }

  /**
   * Agency createMany
   */
  export type AgencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agencies.
     */
    data: AgencyCreateManyInput | AgencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agency update
   */
  export type AgencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Agency.
     */
    data: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
    /**
     * Choose, which Agency to update.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency updateMany
   */
  export type AgencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agencies.
     */
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyInput>
    /**
     * Filter which Agencies to update
     */
    where?: AgencyWhereInput
  }

  /**
   * Agency upsert
   */
  export type AgencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Agency to update in case it exists.
     */
    where: AgencyWhereUniqueInput
    /**
     * In case the Agency found by the `where` argument doesn't exist, create a new Agency with this data.
     */
    create: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
    /**
     * In case the Agency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
  }

  /**
   * Agency delete
   */
  export type AgencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter which Agency to delete.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency deleteMany
   */
  export type AgencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agencies to delete
     */
    where?: AgencyWhereInput
  }

  /**
   * Agency.agency_contracts
   */
  export type Agency$agency_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    where?: AgencyContractWhereInput
    orderBy?: AgencyContractOrderByWithRelationInput | AgencyContractOrderByWithRelationInput[]
    cursor?: AgencyContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyContractScalarFieldEnum | AgencyContractScalarFieldEnum[]
  }

  /**
   * Agency.real_estate_agents
   */
  export type Agency$real_estate_agentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    where?: AgencyToRealEstateAgentWhereInput
    orderBy?: AgencyToRealEstateAgentOrderByWithRelationInput | AgencyToRealEstateAgentOrderByWithRelationInput[]
    cursor?: AgencyToRealEstateAgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyToRealEstateAgentScalarFieldEnum | AgencyToRealEstateAgentScalarFieldEnum[]
  }

  /**
   * Agency.agency_contract_signatory
   */
  export type Agency$agency_contract_signatoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    where?: AgencyContractSignatoryWhereInput
    orderBy?: AgencyContractSignatoryOrderByWithRelationInput | AgencyContractSignatoryOrderByWithRelationInput[]
    cursor?: AgencyContractSignatoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyContractSignatoryScalarFieldEnum | AgencyContractSignatoryScalarFieldEnum[]
  }

  /**
   * Agency without action
   */
  export type AgencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
  }


  /**
   * Model AgencyContract
   */

  export type AggregateAgencyContract = {
    _count: AgencyContractCountAggregateOutputType | null
    _avg: AgencyContractAvgAggregateOutputType | null
    _sum: AgencyContractSumAggregateOutputType | null
    _min: AgencyContractMinAggregateOutputType | null
    _max: AgencyContractMaxAggregateOutputType | null
  }

  export type AgencyContractAvgAggregateOutputType = {
    id: number | null
    responsible_user_id: number | null
    entity_id: number | null
    object_id: number | null
    agency_id: number | null
    agency_contract_signatory_id: number | null
    real_estate_agency_contract_properties_id: number | null
    mip_agency_contract_properties_id: number | null
  }

  export type AgencyContractSumAggregateOutputType = {
    id: number | null
    responsible_user_id: number | null
    entity_id: number | null
    object_id: number | null
    agency_id: number | null
    agency_contract_signatory_id: number | null
    real_estate_agency_contract_properties_id: number | null
    mip_agency_contract_properties_id: number | null
  }

  export type AgencyContractMinAggregateOutputType = {
    id: number | null
    number: string | null
    date: Date | null
    agency_contract_type: $Enums.AgencyContractType | null
    created_at: Date | null
    updated_at: Date | null
    responsible_user_id: number | null
    entity_id: number | null
    object_id: number | null
    agency_id: number | null
    agency_contract_signatory_id: number | null
    real_estate_agency_contract_properties_id: number | null
    mip_agency_contract_properties_id: number | null
  }

  export type AgencyContractMaxAggregateOutputType = {
    id: number | null
    number: string | null
    date: Date | null
    agency_contract_type: $Enums.AgencyContractType | null
    created_at: Date | null
    updated_at: Date | null
    responsible_user_id: number | null
    entity_id: number | null
    object_id: number | null
    agency_id: number | null
    agency_contract_signatory_id: number | null
    real_estate_agency_contract_properties_id: number | null
    mip_agency_contract_properties_id: number | null
  }

  export type AgencyContractCountAggregateOutputType = {
    id: number
    number: number
    date: number
    agency_contract_type: number
    created_at: number
    updated_at: number
    responsible_user_id: number
    entity_id: number
    object_id: number
    agency_id: number
    agency_contract_signatory_id: number
    real_estate_agency_contract_properties_id: number
    mip_agency_contract_properties_id: number
    _all: number
  }


  export type AgencyContractAvgAggregateInputType = {
    id?: true
    responsible_user_id?: true
    entity_id?: true
    object_id?: true
    agency_id?: true
    agency_contract_signatory_id?: true
    real_estate_agency_contract_properties_id?: true
    mip_agency_contract_properties_id?: true
  }

  export type AgencyContractSumAggregateInputType = {
    id?: true
    responsible_user_id?: true
    entity_id?: true
    object_id?: true
    agency_id?: true
    agency_contract_signatory_id?: true
    real_estate_agency_contract_properties_id?: true
    mip_agency_contract_properties_id?: true
  }

  export type AgencyContractMinAggregateInputType = {
    id?: true
    number?: true
    date?: true
    agency_contract_type?: true
    created_at?: true
    updated_at?: true
    responsible_user_id?: true
    entity_id?: true
    object_id?: true
    agency_id?: true
    agency_contract_signatory_id?: true
    real_estate_agency_contract_properties_id?: true
    mip_agency_contract_properties_id?: true
  }

  export type AgencyContractMaxAggregateInputType = {
    id?: true
    number?: true
    date?: true
    agency_contract_type?: true
    created_at?: true
    updated_at?: true
    responsible_user_id?: true
    entity_id?: true
    object_id?: true
    agency_id?: true
    agency_contract_signatory_id?: true
    real_estate_agency_contract_properties_id?: true
    mip_agency_contract_properties_id?: true
  }

  export type AgencyContractCountAggregateInputType = {
    id?: true
    number?: true
    date?: true
    agency_contract_type?: true
    created_at?: true
    updated_at?: true
    responsible_user_id?: true
    entity_id?: true
    object_id?: true
    agency_id?: true
    agency_contract_signatory_id?: true
    real_estate_agency_contract_properties_id?: true
    mip_agency_contract_properties_id?: true
    _all?: true
  }

  export type AgencyContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyContract to aggregate.
     */
    where?: AgencyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContracts to fetch.
     */
    orderBy?: AgencyContractOrderByWithRelationInput | AgencyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyContracts
    **/
    _count?: true | AgencyContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencyContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyContractMaxAggregateInputType
  }

  export type GetAgencyContractAggregateType<T extends AgencyContractAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyContract[P]>
      : GetScalarType<T[P], AggregateAgencyContract[P]>
  }




  export type AgencyContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyContractWhereInput
    orderBy?: AgencyContractOrderByWithAggregationInput | AgencyContractOrderByWithAggregationInput[]
    by: AgencyContractScalarFieldEnum[] | AgencyContractScalarFieldEnum
    having?: AgencyContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyContractCountAggregateInputType | true
    _avg?: AgencyContractAvgAggregateInputType
    _sum?: AgencyContractSumAggregateInputType
    _min?: AgencyContractMinAggregateInputType
    _max?: AgencyContractMaxAggregateInputType
  }

  export type AgencyContractGroupByOutputType = {
    id: number
    number: string
    date: Date
    agency_contract_type: $Enums.AgencyContractType
    created_at: Date
    updated_at: Date
    responsible_user_id: number | null
    entity_id: number
    object_id: number
    agency_id: number
    agency_contract_signatory_id: number | null
    real_estate_agency_contract_properties_id: number | null
    mip_agency_contract_properties_id: number | null
    _count: AgencyContractCountAggregateOutputType | null
    _avg: AgencyContractAvgAggregateOutputType | null
    _sum: AgencyContractSumAggregateOutputType | null
    _min: AgencyContractMinAggregateOutputType | null
    _max: AgencyContractMaxAggregateOutputType | null
  }

  type GetAgencyContractGroupByPayload<T extends AgencyContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyContractGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyContractGroupByOutputType[P]>
        }
      >
    >


  export type AgencyContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    agency_contract_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    responsible_user_id?: boolean
    entity_id?: boolean
    object_id?: boolean
    agency_id?: boolean
    agency_contract_signatory_id?: boolean
    real_estate_agency_contract_properties_id?: boolean
    mip_agency_contract_properties_id?: boolean
    responsible_user?: boolean | AgencyContract$responsible_userArgs<ExtArgs>
    entity?: boolean | EntityDefaultArgs<ExtArgs>
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    agency_contract_signatory?: boolean | AgencyContract$agency_contract_signatoryArgs<ExtArgs>
    real_estate_agency_contract_properties?: boolean | AgencyContract$real_estate_agency_contract_propertiesArgs<ExtArgs>
    mip_agency_contract_properties?: boolean | AgencyContract$mip_agency_contract_propertiesArgs<ExtArgs>
    client_contracts?: boolean | AgencyContract$client_contractsArgs<ExtArgs>
    _count?: boolean | AgencyContractCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyContract"]>


  export type AgencyContractSelectScalar = {
    id?: boolean
    number?: boolean
    date?: boolean
    agency_contract_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    responsible_user_id?: boolean
    entity_id?: boolean
    object_id?: boolean
    agency_id?: boolean
    agency_contract_signatory_id?: boolean
    real_estate_agency_contract_properties_id?: boolean
    mip_agency_contract_properties_id?: boolean
  }

  export type AgencyContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsible_user?: boolean | AgencyContract$responsible_userArgs<ExtArgs>
    entity?: boolean | EntityDefaultArgs<ExtArgs>
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    agency_contract_signatory?: boolean | AgencyContract$agency_contract_signatoryArgs<ExtArgs>
    real_estate_agency_contract_properties?: boolean | AgencyContract$real_estate_agency_contract_propertiesArgs<ExtArgs>
    mip_agency_contract_properties?: boolean | AgencyContract$mip_agency_contract_propertiesArgs<ExtArgs>
    client_contracts?: boolean | AgencyContract$client_contractsArgs<ExtArgs>
    _count?: boolean | AgencyContractCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AgencyContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyContract"
    objects: {
      responsible_user: Prisma.$UserPayload<ExtArgs> | null
      entity: Prisma.$EntityPayload<ExtArgs>
      object: Prisma.$ObjectPayload<ExtArgs>
      agency: Prisma.$AgencyPayload<ExtArgs>
      agency_contract_signatory: Prisma.$AgencyContractSignatoryPayload<ExtArgs> | null
      real_estate_agency_contract_properties: Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs> | null
      mip_agency_contract_properties: Prisma.$MIPAgencyContractPropertiesPayload<ExtArgs> | null
      client_contracts: Prisma.$ClientContractToAgencyContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      number: string
      date: Date
      agency_contract_type: $Enums.AgencyContractType
      created_at: Date
      updated_at: Date
      responsible_user_id: number | null
      entity_id: number
      object_id: number
      agency_id: number
      agency_contract_signatory_id: number | null
      real_estate_agency_contract_properties_id: number | null
      mip_agency_contract_properties_id: number | null
    }, ExtArgs["result"]["agencyContract"]>
    composites: {}
  }

  type AgencyContractGetPayload<S extends boolean | null | undefined | AgencyContractDefaultArgs> = $Result.GetResult<Prisma.$AgencyContractPayload, S>

  type AgencyContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgencyContractFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgencyContractCountAggregateInputType | true
    }

  export interface AgencyContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyContract'], meta: { name: 'AgencyContract' } }
    /**
     * Find zero or one AgencyContract that matches the filter.
     * @param {AgencyContractFindUniqueArgs} args - Arguments to find a AgencyContract
     * @example
     * // Get one AgencyContract
     * const agencyContract = await prisma.agencyContract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgencyContractFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractFindUniqueArgs<ExtArgs>>
    ): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AgencyContract that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgencyContractFindUniqueOrThrowArgs} args - Arguments to find a AgencyContract
     * @example
     * // Get one AgencyContract
     * const agencyContract = await prisma.agencyContract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgencyContractFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AgencyContract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractFindFirstArgs} args - Arguments to find a AgencyContract
     * @example
     * // Get one AgencyContract
     * const agencyContract = await prisma.agencyContract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgencyContractFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractFindFirstArgs<ExtArgs>>
    ): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AgencyContract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractFindFirstOrThrowArgs} args - Arguments to find a AgencyContract
     * @example
     * // Get one AgencyContract
     * const agencyContract = await prisma.agencyContract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgencyContractFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AgencyContracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyContracts
     * const agencyContracts = await prisma.agencyContract.findMany()
     * 
     * // Get first 10 AgencyContracts
     * const agencyContracts = await prisma.agencyContract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyContractWithIdOnly = await prisma.agencyContract.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgencyContractFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AgencyContract.
     * @param {AgencyContractCreateArgs} args - Arguments to create a AgencyContract.
     * @example
     * // Create one AgencyContract
     * const AgencyContract = await prisma.agencyContract.create({
     *   data: {
     *     // ... data to create a AgencyContract
     *   }
     * })
     * 
    **/
    create<T extends AgencyContractCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractCreateArgs<ExtArgs>>
    ): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AgencyContracts.
     * @param {AgencyContractCreateManyArgs} args - Arguments to create many AgencyContracts.
     * @example
     * // Create many AgencyContracts
     * const agencyContract = await prisma.agencyContract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AgencyContractCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgencyContract.
     * @param {AgencyContractDeleteArgs} args - Arguments to delete one AgencyContract.
     * @example
     * // Delete one AgencyContract
     * const AgencyContract = await prisma.agencyContract.delete({
     *   where: {
     *     // ... filter to delete one AgencyContract
     *   }
     * })
     * 
    **/
    delete<T extends AgencyContractDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractDeleteArgs<ExtArgs>>
    ): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AgencyContract.
     * @param {AgencyContractUpdateArgs} args - Arguments to update one AgencyContract.
     * @example
     * // Update one AgencyContract
     * const agencyContract = await prisma.agencyContract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgencyContractUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractUpdateArgs<ExtArgs>>
    ): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AgencyContracts.
     * @param {AgencyContractDeleteManyArgs} args - Arguments to filter AgencyContracts to delete.
     * @example
     * // Delete a few AgencyContracts
     * const { count } = await prisma.agencyContract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgencyContractDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyContracts
     * const agencyContract = await prisma.agencyContract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgencyContractUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgencyContract.
     * @param {AgencyContractUpsertArgs} args - Arguments to update or create a AgencyContract.
     * @example
     * // Update or create a AgencyContract
     * const agencyContract = await prisma.agencyContract.upsert({
     *   create: {
     *     // ... data to create a AgencyContract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyContract we want to update
     *   }
     * })
    **/
    upsert<T extends AgencyContractUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractUpsertArgs<ExtArgs>>
    ): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AgencyContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractCountArgs} args - Arguments to filter AgencyContracts to count.
     * @example
     * // Count the number of AgencyContracts
     * const count = await prisma.agencyContract.count({
     *   where: {
     *     // ... the filter for the AgencyContracts we want to count
     *   }
     * })
    **/
    count<T extends AgencyContractCountArgs>(
      args?: Subset<T, AgencyContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyContractAggregateArgs>(args: Subset<T, AgencyContractAggregateArgs>): Prisma.PrismaPromise<GetAgencyContractAggregateType<T>>

    /**
     * Group by AgencyContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyContractGroupByArgs['orderBy'] }
        : { orderBy?: AgencyContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyContract model
   */
  readonly fields: AgencyContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyContract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    responsible_user<T extends AgencyContract$responsible_userArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContract$responsible_userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    entity<T extends EntityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntityDefaultArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    object<T extends ObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectDefaultArgs<ExtArgs>>): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    agency_contract_signatory<T extends AgencyContract$agency_contract_signatoryArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContract$agency_contract_signatoryArgs<ExtArgs>>): Prisma__AgencyContractSignatoryClient<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    real_estate_agency_contract_properties<T extends AgencyContract$real_estate_agency_contract_propertiesArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContract$real_estate_agency_contract_propertiesArgs<ExtArgs>>): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    mip_agency_contract_properties<T extends AgencyContract$mip_agency_contract_propertiesArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContract$mip_agency_contract_propertiesArgs<ExtArgs>>): Prisma__MIPAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MIPAgencyContractPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    client_contracts<T extends AgencyContract$client_contractsArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContract$client_contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AgencyContract model
   */ 
  interface AgencyContractFieldRefs {
    readonly id: FieldRef<"AgencyContract", 'Int'>
    readonly number: FieldRef<"AgencyContract", 'String'>
    readonly date: FieldRef<"AgencyContract", 'DateTime'>
    readonly agency_contract_type: FieldRef<"AgencyContract", 'AgencyContractType'>
    readonly created_at: FieldRef<"AgencyContract", 'DateTime'>
    readonly updated_at: FieldRef<"AgencyContract", 'DateTime'>
    readonly responsible_user_id: FieldRef<"AgencyContract", 'Int'>
    readonly entity_id: FieldRef<"AgencyContract", 'Int'>
    readonly object_id: FieldRef<"AgencyContract", 'Int'>
    readonly agency_id: FieldRef<"AgencyContract", 'Int'>
    readonly agency_contract_signatory_id: FieldRef<"AgencyContract", 'Int'>
    readonly real_estate_agency_contract_properties_id: FieldRef<"AgencyContract", 'Int'>
    readonly mip_agency_contract_properties_id: FieldRef<"AgencyContract", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AgencyContract findUnique
   */
  export type AgencyContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContract to fetch.
     */
    where: AgencyContractWhereUniqueInput
  }

  /**
   * AgencyContract findUniqueOrThrow
   */
  export type AgencyContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContract to fetch.
     */
    where: AgencyContractWhereUniqueInput
  }

  /**
   * AgencyContract findFirst
   */
  export type AgencyContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContract to fetch.
     */
    where?: AgencyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContracts to fetch.
     */
    orderBy?: AgencyContractOrderByWithRelationInput | AgencyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyContracts.
     */
    cursor?: AgencyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyContracts.
     */
    distinct?: AgencyContractScalarFieldEnum | AgencyContractScalarFieldEnum[]
  }

  /**
   * AgencyContract findFirstOrThrow
   */
  export type AgencyContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContract to fetch.
     */
    where?: AgencyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContracts to fetch.
     */
    orderBy?: AgencyContractOrderByWithRelationInput | AgencyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyContracts.
     */
    cursor?: AgencyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyContracts.
     */
    distinct?: AgencyContractScalarFieldEnum | AgencyContractScalarFieldEnum[]
  }

  /**
   * AgencyContract findMany
   */
  export type AgencyContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContracts to fetch.
     */
    where?: AgencyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContracts to fetch.
     */
    orderBy?: AgencyContractOrderByWithRelationInput | AgencyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyContracts.
     */
    cursor?: AgencyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContracts.
     */
    skip?: number
    distinct?: AgencyContractScalarFieldEnum | AgencyContractScalarFieldEnum[]
  }

  /**
   * AgencyContract create
   */
  export type AgencyContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyContract.
     */
    data: XOR<AgencyContractCreateInput, AgencyContractUncheckedCreateInput>
  }

  /**
   * AgencyContract createMany
   */
  export type AgencyContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyContracts.
     */
    data: AgencyContractCreateManyInput | AgencyContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyContract update
   */
  export type AgencyContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyContract.
     */
    data: XOR<AgencyContractUpdateInput, AgencyContractUncheckedUpdateInput>
    /**
     * Choose, which AgencyContract to update.
     */
    where: AgencyContractWhereUniqueInput
  }

  /**
   * AgencyContract updateMany
   */
  export type AgencyContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyContracts.
     */
    data: XOR<AgencyContractUpdateManyMutationInput, AgencyContractUncheckedUpdateManyInput>
    /**
     * Filter which AgencyContracts to update
     */
    where?: AgencyContractWhereInput
  }

  /**
   * AgencyContract upsert
   */
  export type AgencyContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyContract to update in case it exists.
     */
    where: AgencyContractWhereUniqueInput
    /**
     * In case the AgencyContract found by the `where` argument doesn't exist, create a new AgencyContract with this data.
     */
    create: XOR<AgencyContractCreateInput, AgencyContractUncheckedCreateInput>
    /**
     * In case the AgencyContract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyContractUpdateInput, AgencyContractUncheckedUpdateInput>
  }

  /**
   * AgencyContract delete
   */
  export type AgencyContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    /**
     * Filter which AgencyContract to delete.
     */
    where: AgencyContractWhereUniqueInput
  }

  /**
   * AgencyContract deleteMany
   */
  export type AgencyContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyContracts to delete
     */
    where?: AgencyContractWhereInput
  }

  /**
   * AgencyContract.responsible_user
   */
  export type AgencyContract$responsible_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AgencyContract.agency_contract_signatory
   */
  export type AgencyContract$agency_contract_signatoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    where?: AgencyContractSignatoryWhereInput
  }

  /**
   * AgencyContract.real_estate_agency_contract_properties
   */
  export type AgencyContract$real_estate_agency_contract_propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    where?: RealEstateAgencyContractPropertiesWhereInput
  }

  /**
   * AgencyContract.mip_agency_contract_properties
   */
  export type AgencyContract$mip_agency_contract_propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MIPAgencyContractProperties
     */
    select?: MIPAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MIPAgencyContractPropertiesInclude<ExtArgs> | null
    where?: MIPAgencyContractPropertiesWhereInput
  }

  /**
   * AgencyContract.client_contracts
   */
  export type AgencyContract$client_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    where?: ClientContractToAgencyContractWhereInput
    orderBy?: ClientContractToAgencyContractOrderByWithRelationInput | ClientContractToAgencyContractOrderByWithRelationInput[]
    cursor?: ClientContractToAgencyContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientContractToAgencyContractScalarFieldEnum | ClientContractToAgencyContractScalarFieldEnum[]
  }

  /**
   * AgencyContract without action
   */
  export type AgencyContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
  }


  /**
   * Model AgencyContractSignatory
   */

  export type AggregateAgencyContractSignatory = {
    _count: AgencyContractSignatoryCountAggregateOutputType | null
    _avg: AgencyContractSignatoryAvgAggregateOutputType | null
    _sum: AgencyContractSignatorySumAggregateOutputType | null
    _min: AgencyContractSignatoryMinAggregateOutputType | null
    _max: AgencyContractSignatoryMaxAggregateOutputType | null
  }

  export type AgencyContractSignatoryAvgAggregateOutputType = {
    id: number | null
    agency_id: number | null
  }

  export type AgencyContractSignatorySumAggregateOutputType = {
    id: number | null
    agency_id: number | null
  }

  export type AgencyContractSignatoryMinAggregateOutputType = {
    id: number | null
    full_name: string | null
    email: string | null
    phone: string | null
    title: string | null
    based_on: string | null
    created_at: Date | null
    updated_at: Date | null
    agency_id: number | null
  }

  export type AgencyContractSignatoryMaxAggregateOutputType = {
    id: number | null
    full_name: string | null
    email: string | null
    phone: string | null
    title: string | null
    based_on: string | null
    created_at: Date | null
    updated_at: Date | null
    agency_id: number | null
  }

  export type AgencyContractSignatoryCountAggregateOutputType = {
    id: number
    full_name: number
    email: number
    phone: number
    title: number
    based_on: number
    created_at: number
    updated_at: number
    agency_id: number
    _all: number
  }


  export type AgencyContractSignatoryAvgAggregateInputType = {
    id?: true
    agency_id?: true
  }

  export type AgencyContractSignatorySumAggregateInputType = {
    id?: true
    agency_id?: true
  }

  export type AgencyContractSignatoryMinAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    phone?: true
    title?: true
    based_on?: true
    created_at?: true
    updated_at?: true
    agency_id?: true
  }

  export type AgencyContractSignatoryMaxAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    phone?: true
    title?: true
    based_on?: true
    created_at?: true
    updated_at?: true
    agency_id?: true
  }

  export type AgencyContractSignatoryCountAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    phone?: true
    title?: true
    based_on?: true
    created_at?: true
    updated_at?: true
    agency_id?: true
    _all?: true
  }

  export type AgencyContractSignatoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyContractSignatory to aggregate.
     */
    where?: AgencyContractSignatoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContractSignatories to fetch.
     */
    orderBy?: AgencyContractSignatoryOrderByWithRelationInput | AgencyContractSignatoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyContractSignatoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContractSignatories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContractSignatories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyContractSignatories
    **/
    _count?: true | AgencyContractSignatoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyContractSignatoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencyContractSignatorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyContractSignatoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyContractSignatoryMaxAggregateInputType
  }

  export type GetAgencyContractSignatoryAggregateType<T extends AgencyContractSignatoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyContractSignatory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyContractSignatory[P]>
      : GetScalarType<T[P], AggregateAgencyContractSignatory[P]>
  }




  export type AgencyContractSignatoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyContractSignatoryWhereInput
    orderBy?: AgencyContractSignatoryOrderByWithAggregationInput | AgencyContractSignatoryOrderByWithAggregationInput[]
    by: AgencyContractSignatoryScalarFieldEnum[] | AgencyContractSignatoryScalarFieldEnum
    having?: AgencyContractSignatoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyContractSignatoryCountAggregateInputType | true
    _avg?: AgencyContractSignatoryAvgAggregateInputType
    _sum?: AgencyContractSignatorySumAggregateInputType
    _min?: AgencyContractSignatoryMinAggregateInputType
    _max?: AgencyContractSignatoryMaxAggregateInputType
  }

  export type AgencyContractSignatoryGroupByOutputType = {
    id: number
    full_name: string
    email: string
    phone: string
    title: string
    based_on: string
    created_at: Date
    updated_at: Date
    agency_id: number
    _count: AgencyContractSignatoryCountAggregateOutputType | null
    _avg: AgencyContractSignatoryAvgAggregateOutputType | null
    _sum: AgencyContractSignatorySumAggregateOutputType | null
    _min: AgencyContractSignatoryMinAggregateOutputType | null
    _max: AgencyContractSignatoryMaxAggregateOutputType | null
  }

  type GetAgencyContractSignatoryGroupByPayload<T extends AgencyContractSignatoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyContractSignatoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyContractSignatoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyContractSignatoryGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyContractSignatoryGroupByOutputType[P]>
        }
      >
    >


  export type AgencyContractSignatorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    phone?: boolean
    title?: boolean
    based_on?: boolean
    created_at?: boolean
    updated_at?: boolean
    agency_id?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    agency_contract?: boolean | AgencyContractSignatory$agency_contractArgs<ExtArgs>
    _count?: boolean | AgencyContractSignatoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyContractSignatory"]>


  export type AgencyContractSignatorySelectScalar = {
    id?: boolean
    full_name?: boolean
    email?: boolean
    phone?: boolean
    title?: boolean
    based_on?: boolean
    created_at?: boolean
    updated_at?: boolean
    agency_id?: boolean
  }

  export type AgencyContractSignatoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    agency_contract?: boolean | AgencyContractSignatory$agency_contractArgs<ExtArgs>
    _count?: boolean | AgencyContractSignatoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AgencyContractSignatoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyContractSignatory"
    objects: {
      agency: Prisma.$AgencyPayload<ExtArgs>
      agency_contract: Prisma.$AgencyContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      full_name: string
      email: string
      phone: string
      title: string
      based_on: string
      created_at: Date
      updated_at: Date
      agency_id: number
    }, ExtArgs["result"]["agencyContractSignatory"]>
    composites: {}
  }

  type AgencyContractSignatoryGetPayload<S extends boolean | null | undefined | AgencyContractSignatoryDefaultArgs> = $Result.GetResult<Prisma.$AgencyContractSignatoryPayload, S>

  type AgencyContractSignatoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgencyContractSignatoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgencyContractSignatoryCountAggregateInputType | true
    }

  export interface AgencyContractSignatoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyContractSignatory'], meta: { name: 'AgencyContractSignatory' } }
    /**
     * Find zero or one AgencyContractSignatory that matches the filter.
     * @param {AgencyContractSignatoryFindUniqueArgs} args - Arguments to find a AgencyContractSignatory
     * @example
     * // Get one AgencyContractSignatory
     * const agencyContractSignatory = await prisma.agencyContractSignatory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgencyContractSignatoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractSignatoryFindUniqueArgs<ExtArgs>>
    ): Prisma__AgencyContractSignatoryClient<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AgencyContractSignatory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgencyContractSignatoryFindUniqueOrThrowArgs} args - Arguments to find a AgencyContractSignatory
     * @example
     * // Get one AgencyContractSignatory
     * const agencyContractSignatory = await prisma.agencyContractSignatory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgencyContractSignatoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractSignatoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyContractSignatoryClient<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AgencyContractSignatory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractSignatoryFindFirstArgs} args - Arguments to find a AgencyContractSignatory
     * @example
     * // Get one AgencyContractSignatory
     * const agencyContractSignatory = await prisma.agencyContractSignatory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgencyContractSignatoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractSignatoryFindFirstArgs<ExtArgs>>
    ): Prisma__AgencyContractSignatoryClient<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AgencyContractSignatory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractSignatoryFindFirstOrThrowArgs} args - Arguments to find a AgencyContractSignatory
     * @example
     * // Get one AgencyContractSignatory
     * const agencyContractSignatory = await prisma.agencyContractSignatory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgencyContractSignatoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractSignatoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyContractSignatoryClient<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AgencyContractSignatories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractSignatoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyContractSignatories
     * const agencyContractSignatories = await prisma.agencyContractSignatory.findMany()
     * 
     * // Get first 10 AgencyContractSignatories
     * const agencyContractSignatories = await prisma.agencyContractSignatory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyContractSignatoryWithIdOnly = await prisma.agencyContractSignatory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgencyContractSignatoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractSignatoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AgencyContractSignatory.
     * @param {AgencyContractSignatoryCreateArgs} args - Arguments to create a AgencyContractSignatory.
     * @example
     * // Create one AgencyContractSignatory
     * const AgencyContractSignatory = await prisma.agencyContractSignatory.create({
     *   data: {
     *     // ... data to create a AgencyContractSignatory
     *   }
     * })
     * 
    **/
    create<T extends AgencyContractSignatoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractSignatoryCreateArgs<ExtArgs>>
    ): Prisma__AgencyContractSignatoryClient<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AgencyContractSignatories.
     * @param {AgencyContractSignatoryCreateManyArgs} args - Arguments to create many AgencyContractSignatories.
     * @example
     * // Create many AgencyContractSignatories
     * const agencyContractSignatory = await prisma.agencyContractSignatory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AgencyContractSignatoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractSignatoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgencyContractSignatory.
     * @param {AgencyContractSignatoryDeleteArgs} args - Arguments to delete one AgencyContractSignatory.
     * @example
     * // Delete one AgencyContractSignatory
     * const AgencyContractSignatory = await prisma.agencyContractSignatory.delete({
     *   where: {
     *     // ... filter to delete one AgencyContractSignatory
     *   }
     * })
     * 
    **/
    delete<T extends AgencyContractSignatoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractSignatoryDeleteArgs<ExtArgs>>
    ): Prisma__AgencyContractSignatoryClient<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AgencyContractSignatory.
     * @param {AgencyContractSignatoryUpdateArgs} args - Arguments to update one AgencyContractSignatory.
     * @example
     * // Update one AgencyContractSignatory
     * const agencyContractSignatory = await prisma.agencyContractSignatory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgencyContractSignatoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractSignatoryUpdateArgs<ExtArgs>>
    ): Prisma__AgencyContractSignatoryClient<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AgencyContractSignatories.
     * @param {AgencyContractSignatoryDeleteManyArgs} args - Arguments to filter AgencyContractSignatories to delete.
     * @example
     * // Delete a few AgencyContractSignatories
     * const { count } = await prisma.agencyContractSignatory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgencyContractSignatoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractSignatoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyContractSignatories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractSignatoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyContractSignatories
     * const agencyContractSignatory = await prisma.agencyContractSignatory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgencyContractSignatoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractSignatoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgencyContractSignatory.
     * @param {AgencyContractSignatoryUpsertArgs} args - Arguments to update or create a AgencyContractSignatory.
     * @example
     * // Update or create a AgencyContractSignatory
     * const agencyContractSignatory = await prisma.agencyContractSignatory.upsert({
     *   create: {
     *     // ... data to create a AgencyContractSignatory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyContractSignatory we want to update
     *   }
     * })
    **/
    upsert<T extends AgencyContractSignatoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractSignatoryUpsertArgs<ExtArgs>>
    ): Prisma__AgencyContractSignatoryClient<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AgencyContractSignatories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractSignatoryCountArgs} args - Arguments to filter AgencyContractSignatories to count.
     * @example
     * // Count the number of AgencyContractSignatories
     * const count = await prisma.agencyContractSignatory.count({
     *   where: {
     *     // ... the filter for the AgencyContractSignatories we want to count
     *   }
     * })
    **/
    count<T extends AgencyContractSignatoryCountArgs>(
      args?: Subset<T, AgencyContractSignatoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyContractSignatoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyContractSignatory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractSignatoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyContractSignatoryAggregateArgs>(args: Subset<T, AgencyContractSignatoryAggregateArgs>): Prisma.PrismaPromise<GetAgencyContractSignatoryAggregateType<T>>

    /**
     * Group by AgencyContractSignatory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractSignatoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyContractSignatoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyContractSignatoryGroupByArgs['orderBy'] }
        : { orderBy?: AgencyContractSignatoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyContractSignatoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyContractSignatoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyContractSignatory model
   */
  readonly fields: AgencyContractSignatoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyContractSignatory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyContractSignatoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    agency_contract<T extends AgencyContractSignatory$agency_contractArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContractSignatory$agency_contractArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AgencyContractSignatory model
   */ 
  interface AgencyContractSignatoryFieldRefs {
    readonly id: FieldRef<"AgencyContractSignatory", 'Int'>
    readonly full_name: FieldRef<"AgencyContractSignatory", 'String'>
    readonly email: FieldRef<"AgencyContractSignatory", 'String'>
    readonly phone: FieldRef<"AgencyContractSignatory", 'String'>
    readonly title: FieldRef<"AgencyContractSignatory", 'String'>
    readonly based_on: FieldRef<"AgencyContractSignatory", 'String'>
    readonly created_at: FieldRef<"AgencyContractSignatory", 'DateTime'>
    readonly updated_at: FieldRef<"AgencyContractSignatory", 'DateTime'>
    readonly agency_id: FieldRef<"AgencyContractSignatory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AgencyContractSignatory findUnique
   */
  export type AgencyContractSignatoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractSignatory to fetch.
     */
    where: AgencyContractSignatoryWhereUniqueInput
  }

  /**
   * AgencyContractSignatory findUniqueOrThrow
   */
  export type AgencyContractSignatoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractSignatory to fetch.
     */
    where: AgencyContractSignatoryWhereUniqueInput
  }

  /**
   * AgencyContractSignatory findFirst
   */
  export type AgencyContractSignatoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractSignatory to fetch.
     */
    where?: AgencyContractSignatoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContractSignatories to fetch.
     */
    orderBy?: AgencyContractSignatoryOrderByWithRelationInput | AgencyContractSignatoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyContractSignatories.
     */
    cursor?: AgencyContractSignatoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContractSignatories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContractSignatories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyContractSignatories.
     */
    distinct?: AgencyContractSignatoryScalarFieldEnum | AgencyContractSignatoryScalarFieldEnum[]
  }

  /**
   * AgencyContractSignatory findFirstOrThrow
   */
  export type AgencyContractSignatoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractSignatory to fetch.
     */
    where?: AgencyContractSignatoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContractSignatories to fetch.
     */
    orderBy?: AgencyContractSignatoryOrderByWithRelationInput | AgencyContractSignatoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyContractSignatories.
     */
    cursor?: AgencyContractSignatoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContractSignatories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContractSignatories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyContractSignatories.
     */
    distinct?: AgencyContractSignatoryScalarFieldEnum | AgencyContractSignatoryScalarFieldEnum[]
  }

  /**
   * AgencyContractSignatory findMany
   */
  export type AgencyContractSignatoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractSignatories to fetch.
     */
    where?: AgencyContractSignatoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContractSignatories to fetch.
     */
    orderBy?: AgencyContractSignatoryOrderByWithRelationInput | AgencyContractSignatoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyContractSignatories.
     */
    cursor?: AgencyContractSignatoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContractSignatories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContractSignatories.
     */
    skip?: number
    distinct?: AgencyContractSignatoryScalarFieldEnum | AgencyContractSignatoryScalarFieldEnum[]
  }

  /**
   * AgencyContractSignatory create
   */
  export type AgencyContractSignatoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyContractSignatory.
     */
    data: XOR<AgencyContractSignatoryCreateInput, AgencyContractSignatoryUncheckedCreateInput>
  }

  /**
   * AgencyContractSignatory createMany
   */
  export type AgencyContractSignatoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyContractSignatories.
     */
    data: AgencyContractSignatoryCreateManyInput | AgencyContractSignatoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyContractSignatory update
   */
  export type AgencyContractSignatoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyContractSignatory.
     */
    data: XOR<AgencyContractSignatoryUpdateInput, AgencyContractSignatoryUncheckedUpdateInput>
    /**
     * Choose, which AgencyContractSignatory to update.
     */
    where: AgencyContractSignatoryWhereUniqueInput
  }

  /**
   * AgencyContractSignatory updateMany
   */
  export type AgencyContractSignatoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyContractSignatories.
     */
    data: XOR<AgencyContractSignatoryUpdateManyMutationInput, AgencyContractSignatoryUncheckedUpdateManyInput>
    /**
     * Filter which AgencyContractSignatories to update
     */
    where?: AgencyContractSignatoryWhereInput
  }

  /**
   * AgencyContractSignatory upsert
   */
  export type AgencyContractSignatoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyContractSignatory to update in case it exists.
     */
    where: AgencyContractSignatoryWhereUniqueInput
    /**
     * In case the AgencyContractSignatory found by the `where` argument doesn't exist, create a new AgencyContractSignatory with this data.
     */
    create: XOR<AgencyContractSignatoryCreateInput, AgencyContractSignatoryUncheckedCreateInput>
    /**
     * In case the AgencyContractSignatory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyContractSignatoryUpdateInput, AgencyContractSignatoryUncheckedUpdateInput>
  }

  /**
   * AgencyContractSignatory delete
   */
  export type AgencyContractSignatoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    /**
     * Filter which AgencyContractSignatory to delete.
     */
    where: AgencyContractSignatoryWhereUniqueInput
  }

  /**
   * AgencyContractSignatory deleteMany
   */
  export type AgencyContractSignatoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyContractSignatories to delete
     */
    where?: AgencyContractSignatoryWhereInput
  }

  /**
   * AgencyContractSignatory.agency_contract
   */
  export type AgencyContractSignatory$agency_contractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    where?: AgencyContractWhereInput
    orderBy?: AgencyContractOrderByWithRelationInput | AgencyContractOrderByWithRelationInput[]
    cursor?: AgencyContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyContractScalarFieldEnum | AgencyContractScalarFieldEnum[]
  }

  /**
   * AgencyContractSignatory without action
   */
  export type AgencyContractSignatoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
  }


  /**
   * Model RealEstateAgencyContractProperties
   */

  export type AggregateRealEstateAgencyContractProperties = {
    _count: RealEstateAgencyContractPropertiesCountAggregateOutputType | null
    _avg: RealEstateAgencyContractPropertiesAvgAggregateOutputType | null
    _sum: RealEstateAgencyContractPropertiesSumAggregateOutputType | null
    _min: RealEstateAgencyContractPropertiesMinAggregateOutputType | null
    _max: RealEstateAgencyContractPropertiesMaxAggregateOutputType | null
  }

  export type RealEstateAgencyContractPropertiesAvgAggregateOutputType = {
    id: number | null
    agency_contract_commission_id: number | null
  }

  export type RealEstateAgencyContractPropertiesSumAggregateOutputType = {
    id: number | null
    agency_contract_commission_id: number | null
  }

  export type RealEstateAgencyContractPropertiesMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    agency_contract_commission_id: number | null
  }

  export type RealEstateAgencyContractPropertiesMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    agency_contract_commission_id: number | null
  }

  export type RealEstateAgencyContractPropertiesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    agency_contract_commission_id: number
    _all: number
  }


  export type RealEstateAgencyContractPropertiesAvgAggregateInputType = {
    id?: true
    agency_contract_commission_id?: true
  }

  export type RealEstateAgencyContractPropertiesSumAggregateInputType = {
    id?: true
    agency_contract_commission_id?: true
  }

  export type RealEstateAgencyContractPropertiesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    agency_contract_commission_id?: true
  }

  export type RealEstateAgencyContractPropertiesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    agency_contract_commission_id?: true
  }

  export type RealEstateAgencyContractPropertiesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    agency_contract_commission_id?: true
    _all?: true
  }

  export type RealEstateAgencyContractPropertiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RealEstateAgencyContractProperties to aggregate.
     */
    where?: RealEstateAgencyContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgencyContractProperties to fetch.
     */
    orderBy?: RealEstateAgencyContractPropertiesOrderByWithRelationInput | RealEstateAgencyContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RealEstateAgencyContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgencyContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgencyContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RealEstateAgencyContractProperties
    **/
    _count?: true | RealEstateAgencyContractPropertiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RealEstateAgencyContractPropertiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RealEstateAgencyContractPropertiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RealEstateAgencyContractPropertiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RealEstateAgencyContractPropertiesMaxAggregateInputType
  }

  export type GetRealEstateAgencyContractPropertiesAggregateType<T extends RealEstateAgencyContractPropertiesAggregateArgs> = {
        [P in keyof T & keyof AggregateRealEstateAgencyContractProperties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRealEstateAgencyContractProperties[P]>
      : GetScalarType<T[P], AggregateRealEstateAgencyContractProperties[P]>
  }




  export type RealEstateAgencyContractPropertiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RealEstateAgencyContractPropertiesWhereInput
    orderBy?: RealEstateAgencyContractPropertiesOrderByWithAggregationInput | RealEstateAgencyContractPropertiesOrderByWithAggregationInput[]
    by: RealEstateAgencyContractPropertiesScalarFieldEnum[] | RealEstateAgencyContractPropertiesScalarFieldEnum
    having?: RealEstateAgencyContractPropertiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RealEstateAgencyContractPropertiesCountAggregateInputType | true
    _avg?: RealEstateAgencyContractPropertiesAvgAggregateInputType
    _sum?: RealEstateAgencyContractPropertiesSumAggregateInputType
    _min?: RealEstateAgencyContractPropertiesMinAggregateInputType
    _max?: RealEstateAgencyContractPropertiesMaxAggregateInputType
  }

  export type RealEstateAgencyContractPropertiesGroupByOutputType = {
    id: number
    created_at: Date
    updated_at: Date
    agency_contract_commission_id: number
    _count: RealEstateAgencyContractPropertiesCountAggregateOutputType | null
    _avg: RealEstateAgencyContractPropertiesAvgAggregateOutputType | null
    _sum: RealEstateAgencyContractPropertiesSumAggregateOutputType | null
    _min: RealEstateAgencyContractPropertiesMinAggregateOutputType | null
    _max: RealEstateAgencyContractPropertiesMaxAggregateOutputType | null
  }

  type GetRealEstateAgencyContractPropertiesGroupByPayload<T extends RealEstateAgencyContractPropertiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RealEstateAgencyContractPropertiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RealEstateAgencyContractPropertiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RealEstateAgencyContractPropertiesGroupByOutputType[P]>
            : GetScalarType<T[P], RealEstateAgencyContractPropertiesGroupByOutputType[P]>
        }
      >
    >


  export type RealEstateAgencyContractPropertiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    agency_contract_commission_id?: boolean
    agency_contract?: boolean | RealEstateAgencyContractProperties$agency_contractArgs<ExtArgs>
    agency_contract_commission?: boolean | AgencyContractCommissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["realEstateAgencyContractProperties"]>


  export type RealEstateAgencyContractPropertiesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    agency_contract_commission_id?: boolean
  }

  export type RealEstateAgencyContractPropertiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency_contract?: boolean | RealEstateAgencyContractProperties$agency_contractArgs<ExtArgs>
    agency_contract_commission?: boolean | AgencyContractCommissionDefaultArgs<ExtArgs>
  }

  export type $RealEstateAgencyContractPropertiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RealEstateAgencyContractProperties"
    objects: {
      agency_contract: Prisma.$AgencyContractPayload<ExtArgs> | null
      agency_contract_commission: Prisma.$AgencyContractCommissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      created_at: Date
      updated_at: Date
      agency_contract_commission_id: number
    }, ExtArgs["result"]["realEstateAgencyContractProperties"]>
    composites: {}
  }

  type RealEstateAgencyContractPropertiesGetPayload<S extends boolean | null | undefined | RealEstateAgencyContractPropertiesDefaultArgs> = $Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload, S>

  type RealEstateAgencyContractPropertiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RealEstateAgencyContractPropertiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RealEstateAgencyContractPropertiesCountAggregateInputType | true
    }

  export interface RealEstateAgencyContractPropertiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RealEstateAgencyContractProperties'], meta: { name: 'RealEstateAgencyContractProperties' } }
    /**
     * Find zero or one RealEstateAgencyContractProperties that matches the filter.
     * @param {RealEstateAgencyContractPropertiesFindUniqueArgs} args - Arguments to find a RealEstateAgencyContractProperties
     * @example
     * // Get one RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RealEstateAgencyContractPropertiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgencyContractPropertiesFindUniqueArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RealEstateAgencyContractProperties that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RealEstateAgencyContractPropertiesFindUniqueOrThrowArgs} args - Arguments to find a RealEstateAgencyContractProperties
     * @example
     * // Get one RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RealEstateAgencyContractPropertiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgencyContractPropertiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RealEstateAgencyContractProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyContractPropertiesFindFirstArgs} args - Arguments to find a RealEstateAgencyContractProperties
     * @example
     * // Get one RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RealEstateAgencyContractPropertiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgencyContractPropertiesFindFirstArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RealEstateAgencyContractProperties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyContractPropertiesFindFirstOrThrowArgs} args - Arguments to find a RealEstateAgencyContractProperties
     * @example
     * // Get one RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RealEstateAgencyContractPropertiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgencyContractPropertiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RealEstateAgencyContractProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyContractPropertiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.findMany()
     * 
     * // Get first 10 RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const realEstateAgencyContractPropertiesWithIdOnly = await prisma.realEstateAgencyContractProperties.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RealEstateAgencyContractPropertiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgencyContractPropertiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RealEstateAgencyContractProperties.
     * @param {RealEstateAgencyContractPropertiesCreateArgs} args - Arguments to create a RealEstateAgencyContractProperties.
     * @example
     * // Create one RealEstateAgencyContractProperties
     * const RealEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.create({
     *   data: {
     *     // ... data to create a RealEstateAgencyContractProperties
     *   }
     * })
     * 
    **/
    create<T extends RealEstateAgencyContractPropertiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgencyContractPropertiesCreateArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RealEstateAgencyContractProperties.
     * @param {RealEstateAgencyContractPropertiesCreateManyArgs} args - Arguments to create many RealEstateAgencyContractProperties.
     * @example
     * // Create many RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends RealEstateAgencyContractPropertiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgencyContractPropertiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RealEstateAgencyContractProperties.
     * @param {RealEstateAgencyContractPropertiesDeleteArgs} args - Arguments to delete one RealEstateAgencyContractProperties.
     * @example
     * // Delete one RealEstateAgencyContractProperties
     * const RealEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.delete({
     *   where: {
     *     // ... filter to delete one RealEstateAgencyContractProperties
     *   }
     * })
     * 
    **/
    delete<T extends RealEstateAgencyContractPropertiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgencyContractPropertiesDeleteArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RealEstateAgencyContractProperties.
     * @param {RealEstateAgencyContractPropertiesUpdateArgs} args - Arguments to update one RealEstateAgencyContractProperties.
     * @example
     * // Update one RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RealEstateAgencyContractPropertiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgencyContractPropertiesUpdateArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RealEstateAgencyContractProperties.
     * @param {RealEstateAgencyContractPropertiesDeleteManyArgs} args - Arguments to filter RealEstateAgencyContractProperties to delete.
     * @example
     * // Delete a few RealEstateAgencyContractProperties
     * const { count } = await prisma.realEstateAgencyContractProperties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RealEstateAgencyContractPropertiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgencyContractPropertiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RealEstateAgencyContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyContractPropertiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RealEstateAgencyContractPropertiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgencyContractPropertiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RealEstateAgencyContractProperties.
     * @param {RealEstateAgencyContractPropertiesUpsertArgs} args - Arguments to update or create a RealEstateAgencyContractProperties.
     * @example
     * // Update or create a RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.upsert({
     *   create: {
     *     // ... data to create a RealEstateAgencyContractProperties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RealEstateAgencyContractProperties we want to update
     *   }
     * })
    **/
    upsert<T extends RealEstateAgencyContractPropertiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgencyContractPropertiesUpsertArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RealEstateAgencyContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyContractPropertiesCountArgs} args - Arguments to filter RealEstateAgencyContractProperties to count.
     * @example
     * // Count the number of RealEstateAgencyContractProperties
     * const count = await prisma.realEstateAgencyContractProperties.count({
     *   where: {
     *     // ... the filter for the RealEstateAgencyContractProperties we want to count
     *   }
     * })
    **/
    count<T extends RealEstateAgencyContractPropertiesCountArgs>(
      args?: Subset<T, RealEstateAgencyContractPropertiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RealEstateAgencyContractPropertiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RealEstateAgencyContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyContractPropertiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RealEstateAgencyContractPropertiesAggregateArgs>(args: Subset<T, RealEstateAgencyContractPropertiesAggregateArgs>): Prisma.PrismaPromise<GetRealEstateAgencyContractPropertiesAggregateType<T>>

    /**
     * Group by RealEstateAgencyContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyContractPropertiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RealEstateAgencyContractPropertiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RealEstateAgencyContractPropertiesGroupByArgs['orderBy'] }
        : { orderBy?: RealEstateAgencyContractPropertiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RealEstateAgencyContractPropertiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRealEstateAgencyContractPropertiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RealEstateAgencyContractProperties model
   */
  readonly fields: RealEstateAgencyContractPropertiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RealEstateAgencyContractProperties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RealEstateAgencyContractPropertiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    agency_contract<T extends RealEstateAgencyContractProperties$agency_contractArgs<ExtArgs> = {}>(args?: Subset<T, RealEstateAgencyContractProperties$agency_contractArgs<ExtArgs>>): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    agency_contract_commission<T extends AgencyContractCommissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContractCommissionDefaultArgs<ExtArgs>>): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RealEstateAgencyContractProperties model
   */ 
  interface RealEstateAgencyContractPropertiesFieldRefs {
    readonly id: FieldRef<"RealEstateAgencyContractProperties", 'Int'>
    readonly created_at: FieldRef<"RealEstateAgencyContractProperties", 'DateTime'>
    readonly updated_at: FieldRef<"RealEstateAgencyContractProperties", 'DateTime'>
    readonly agency_contract_commission_id: FieldRef<"RealEstateAgencyContractProperties", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RealEstateAgencyContractProperties findUnique
   */
  export type RealEstateAgencyContractPropertiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgencyContractProperties to fetch.
     */
    where: RealEstateAgencyContractPropertiesWhereUniqueInput
  }

  /**
   * RealEstateAgencyContractProperties findUniqueOrThrow
   */
  export type RealEstateAgencyContractPropertiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgencyContractProperties to fetch.
     */
    where: RealEstateAgencyContractPropertiesWhereUniqueInput
  }

  /**
   * RealEstateAgencyContractProperties findFirst
   */
  export type RealEstateAgencyContractPropertiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgencyContractProperties to fetch.
     */
    where?: RealEstateAgencyContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgencyContractProperties to fetch.
     */
    orderBy?: RealEstateAgencyContractPropertiesOrderByWithRelationInput | RealEstateAgencyContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealEstateAgencyContractProperties.
     */
    cursor?: RealEstateAgencyContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgencyContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgencyContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealEstateAgencyContractProperties.
     */
    distinct?: RealEstateAgencyContractPropertiesScalarFieldEnum | RealEstateAgencyContractPropertiesScalarFieldEnum[]
  }

  /**
   * RealEstateAgencyContractProperties findFirstOrThrow
   */
  export type RealEstateAgencyContractPropertiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgencyContractProperties to fetch.
     */
    where?: RealEstateAgencyContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgencyContractProperties to fetch.
     */
    orderBy?: RealEstateAgencyContractPropertiesOrderByWithRelationInput | RealEstateAgencyContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealEstateAgencyContractProperties.
     */
    cursor?: RealEstateAgencyContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgencyContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgencyContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealEstateAgencyContractProperties.
     */
    distinct?: RealEstateAgencyContractPropertiesScalarFieldEnum | RealEstateAgencyContractPropertiesScalarFieldEnum[]
  }

  /**
   * RealEstateAgencyContractProperties findMany
   */
  export type RealEstateAgencyContractPropertiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgencyContractProperties to fetch.
     */
    where?: RealEstateAgencyContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgencyContractProperties to fetch.
     */
    orderBy?: RealEstateAgencyContractPropertiesOrderByWithRelationInput | RealEstateAgencyContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RealEstateAgencyContractProperties.
     */
    cursor?: RealEstateAgencyContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgencyContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgencyContractProperties.
     */
    skip?: number
    distinct?: RealEstateAgencyContractPropertiesScalarFieldEnum | RealEstateAgencyContractPropertiesScalarFieldEnum[]
  }

  /**
   * RealEstateAgencyContractProperties create
   */
  export type RealEstateAgencyContractPropertiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to create a RealEstateAgencyContractProperties.
     */
    data: XOR<RealEstateAgencyContractPropertiesCreateInput, RealEstateAgencyContractPropertiesUncheckedCreateInput>
  }

  /**
   * RealEstateAgencyContractProperties createMany
   */
  export type RealEstateAgencyContractPropertiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RealEstateAgencyContractProperties.
     */
    data: RealEstateAgencyContractPropertiesCreateManyInput | RealEstateAgencyContractPropertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RealEstateAgencyContractProperties update
   */
  export type RealEstateAgencyContractPropertiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to update a RealEstateAgencyContractProperties.
     */
    data: XOR<RealEstateAgencyContractPropertiesUpdateInput, RealEstateAgencyContractPropertiesUncheckedUpdateInput>
    /**
     * Choose, which RealEstateAgencyContractProperties to update.
     */
    where: RealEstateAgencyContractPropertiesWhereUniqueInput
  }

  /**
   * RealEstateAgencyContractProperties updateMany
   */
  export type RealEstateAgencyContractPropertiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RealEstateAgencyContractProperties.
     */
    data: XOR<RealEstateAgencyContractPropertiesUpdateManyMutationInput, RealEstateAgencyContractPropertiesUncheckedUpdateManyInput>
    /**
     * Filter which RealEstateAgencyContractProperties to update
     */
    where?: RealEstateAgencyContractPropertiesWhereInput
  }

  /**
   * RealEstateAgencyContractProperties upsert
   */
  export type RealEstateAgencyContractPropertiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * The filter to search for the RealEstateAgencyContractProperties to update in case it exists.
     */
    where: RealEstateAgencyContractPropertiesWhereUniqueInput
    /**
     * In case the RealEstateAgencyContractProperties found by the `where` argument doesn't exist, create a new RealEstateAgencyContractProperties with this data.
     */
    create: XOR<RealEstateAgencyContractPropertiesCreateInput, RealEstateAgencyContractPropertiesUncheckedCreateInput>
    /**
     * In case the RealEstateAgencyContractProperties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RealEstateAgencyContractPropertiesUpdateInput, RealEstateAgencyContractPropertiesUncheckedUpdateInput>
  }

  /**
   * RealEstateAgencyContractProperties delete
   */
  export type RealEstateAgencyContractPropertiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter which RealEstateAgencyContractProperties to delete.
     */
    where: RealEstateAgencyContractPropertiesWhereUniqueInput
  }

  /**
   * RealEstateAgencyContractProperties deleteMany
   */
  export type RealEstateAgencyContractPropertiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RealEstateAgencyContractProperties to delete
     */
    where?: RealEstateAgencyContractPropertiesWhereInput
  }

  /**
   * RealEstateAgencyContractProperties.agency_contract
   */
  export type RealEstateAgencyContractProperties$agency_contractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    where?: AgencyContractWhereInput
  }

  /**
   * RealEstateAgencyContractProperties without action
   */
  export type RealEstateAgencyContractPropertiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
  }


  /**
   * Model MIPAgencyContractProperties
   */

  export type AggregateMIPAgencyContractProperties = {
    _count: MIPAgencyContractPropertiesCountAggregateOutputType | null
    _avg: MIPAgencyContractPropertiesAvgAggregateOutputType | null
    _sum: MIPAgencyContractPropertiesSumAggregateOutputType | null
    _min: MIPAgencyContractPropertiesMinAggregateOutputType | null
    _max: MIPAgencyContractPropertiesMaxAggregateOutputType | null
  }

  export type MIPAgencyContractPropertiesAvgAggregateOutputType = {
    id: number | null
    agency_contract_commission_id: number | null
  }

  export type MIPAgencyContractPropertiesSumAggregateOutputType = {
    id: number | null
    agency_contract_commission_id: number | null
  }

  export type MIPAgencyContractPropertiesMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    agency_contract_commission_id: number | null
  }

  export type MIPAgencyContractPropertiesMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    agency_contract_commission_id: number | null
  }

  export type MIPAgencyContractPropertiesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    agency_contract_commission_id: number
    _all: number
  }


  export type MIPAgencyContractPropertiesAvgAggregateInputType = {
    id?: true
    agency_contract_commission_id?: true
  }

  export type MIPAgencyContractPropertiesSumAggregateInputType = {
    id?: true
    agency_contract_commission_id?: true
  }

  export type MIPAgencyContractPropertiesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    agency_contract_commission_id?: true
  }

  export type MIPAgencyContractPropertiesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    agency_contract_commission_id?: true
  }

  export type MIPAgencyContractPropertiesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    agency_contract_commission_id?: true
    _all?: true
  }

  export type MIPAgencyContractPropertiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MIPAgencyContractProperties to aggregate.
     */
    where?: MIPAgencyContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MIPAgencyContractProperties to fetch.
     */
    orderBy?: MIPAgencyContractPropertiesOrderByWithRelationInput | MIPAgencyContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MIPAgencyContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MIPAgencyContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MIPAgencyContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MIPAgencyContractProperties
    **/
    _count?: true | MIPAgencyContractPropertiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MIPAgencyContractPropertiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MIPAgencyContractPropertiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MIPAgencyContractPropertiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MIPAgencyContractPropertiesMaxAggregateInputType
  }

  export type GetMIPAgencyContractPropertiesAggregateType<T extends MIPAgencyContractPropertiesAggregateArgs> = {
        [P in keyof T & keyof AggregateMIPAgencyContractProperties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMIPAgencyContractProperties[P]>
      : GetScalarType<T[P], AggregateMIPAgencyContractProperties[P]>
  }




  export type MIPAgencyContractPropertiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MIPAgencyContractPropertiesWhereInput
    orderBy?: MIPAgencyContractPropertiesOrderByWithAggregationInput | MIPAgencyContractPropertiesOrderByWithAggregationInput[]
    by: MIPAgencyContractPropertiesScalarFieldEnum[] | MIPAgencyContractPropertiesScalarFieldEnum
    having?: MIPAgencyContractPropertiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MIPAgencyContractPropertiesCountAggregateInputType | true
    _avg?: MIPAgencyContractPropertiesAvgAggregateInputType
    _sum?: MIPAgencyContractPropertiesSumAggregateInputType
    _min?: MIPAgencyContractPropertiesMinAggregateInputType
    _max?: MIPAgencyContractPropertiesMaxAggregateInputType
  }

  export type MIPAgencyContractPropertiesGroupByOutputType = {
    id: number
    created_at: Date
    updated_at: Date
    agency_contract_commission_id: number
    _count: MIPAgencyContractPropertiesCountAggregateOutputType | null
    _avg: MIPAgencyContractPropertiesAvgAggregateOutputType | null
    _sum: MIPAgencyContractPropertiesSumAggregateOutputType | null
    _min: MIPAgencyContractPropertiesMinAggregateOutputType | null
    _max: MIPAgencyContractPropertiesMaxAggregateOutputType | null
  }

  type GetMIPAgencyContractPropertiesGroupByPayload<T extends MIPAgencyContractPropertiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MIPAgencyContractPropertiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MIPAgencyContractPropertiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MIPAgencyContractPropertiesGroupByOutputType[P]>
            : GetScalarType<T[P], MIPAgencyContractPropertiesGroupByOutputType[P]>
        }
      >
    >


  export type MIPAgencyContractPropertiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    agency_contract_commission_id?: boolean
    agency_contract?: boolean | MIPAgencyContractProperties$agency_contractArgs<ExtArgs>
    agency_contract_commission?: boolean | AgencyContractCommissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mIPAgencyContractProperties"]>


  export type MIPAgencyContractPropertiesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    agency_contract_commission_id?: boolean
  }

  export type MIPAgencyContractPropertiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency_contract?: boolean | MIPAgencyContractProperties$agency_contractArgs<ExtArgs>
    agency_contract_commission?: boolean | AgencyContractCommissionDefaultArgs<ExtArgs>
  }

  export type $MIPAgencyContractPropertiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MIPAgencyContractProperties"
    objects: {
      agency_contract: Prisma.$AgencyContractPayload<ExtArgs> | null
      agency_contract_commission: Prisma.$AgencyContractCommissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      created_at: Date
      updated_at: Date
      agency_contract_commission_id: number
    }, ExtArgs["result"]["mIPAgencyContractProperties"]>
    composites: {}
  }

  type MIPAgencyContractPropertiesGetPayload<S extends boolean | null | undefined | MIPAgencyContractPropertiesDefaultArgs> = $Result.GetResult<Prisma.$MIPAgencyContractPropertiesPayload, S>

  type MIPAgencyContractPropertiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MIPAgencyContractPropertiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MIPAgencyContractPropertiesCountAggregateInputType | true
    }

  export interface MIPAgencyContractPropertiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MIPAgencyContractProperties'], meta: { name: 'MIPAgencyContractProperties' } }
    /**
     * Find zero or one MIPAgencyContractProperties that matches the filter.
     * @param {MIPAgencyContractPropertiesFindUniqueArgs} args - Arguments to find a MIPAgencyContractProperties
     * @example
     * // Get one MIPAgencyContractProperties
     * const mIPAgencyContractProperties = await prisma.mIPAgencyContractProperties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MIPAgencyContractPropertiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MIPAgencyContractPropertiesFindUniqueArgs<ExtArgs>>
    ): Prisma__MIPAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MIPAgencyContractPropertiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MIPAgencyContractProperties that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MIPAgencyContractPropertiesFindUniqueOrThrowArgs} args - Arguments to find a MIPAgencyContractProperties
     * @example
     * // Get one MIPAgencyContractProperties
     * const mIPAgencyContractProperties = await prisma.mIPAgencyContractProperties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MIPAgencyContractPropertiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MIPAgencyContractPropertiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MIPAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MIPAgencyContractPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MIPAgencyContractProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MIPAgencyContractPropertiesFindFirstArgs} args - Arguments to find a MIPAgencyContractProperties
     * @example
     * // Get one MIPAgencyContractProperties
     * const mIPAgencyContractProperties = await prisma.mIPAgencyContractProperties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MIPAgencyContractPropertiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MIPAgencyContractPropertiesFindFirstArgs<ExtArgs>>
    ): Prisma__MIPAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MIPAgencyContractPropertiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MIPAgencyContractProperties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MIPAgencyContractPropertiesFindFirstOrThrowArgs} args - Arguments to find a MIPAgencyContractProperties
     * @example
     * // Get one MIPAgencyContractProperties
     * const mIPAgencyContractProperties = await prisma.mIPAgencyContractProperties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MIPAgencyContractPropertiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MIPAgencyContractPropertiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MIPAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MIPAgencyContractPropertiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MIPAgencyContractProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MIPAgencyContractPropertiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MIPAgencyContractProperties
     * const mIPAgencyContractProperties = await prisma.mIPAgencyContractProperties.findMany()
     * 
     * // Get first 10 MIPAgencyContractProperties
     * const mIPAgencyContractProperties = await prisma.mIPAgencyContractProperties.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mIPAgencyContractPropertiesWithIdOnly = await prisma.mIPAgencyContractProperties.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MIPAgencyContractPropertiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MIPAgencyContractPropertiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MIPAgencyContractPropertiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MIPAgencyContractProperties.
     * @param {MIPAgencyContractPropertiesCreateArgs} args - Arguments to create a MIPAgencyContractProperties.
     * @example
     * // Create one MIPAgencyContractProperties
     * const MIPAgencyContractProperties = await prisma.mIPAgencyContractProperties.create({
     *   data: {
     *     // ... data to create a MIPAgencyContractProperties
     *   }
     * })
     * 
    **/
    create<T extends MIPAgencyContractPropertiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MIPAgencyContractPropertiesCreateArgs<ExtArgs>>
    ): Prisma__MIPAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MIPAgencyContractPropertiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MIPAgencyContractProperties.
     * @param {MIPAgencyContractPropertiesCreateManyArgs} args - Arguments to create many MIPAgencyContractProperties.
     * @example
     * // Create many MIPAgencyContractProperties
     * const mIPAgencyContractProperties = await prisma.mIPAgencyContractProperties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends MIPAgencyContractPropertiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MIPAgencyContractPropertiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MIPAgencyContractProperties.
     * @param {MIPAgencyContractPropertiesDeleteArgs} args - Arguments to delete one MIPAgencyContractProperties.
     * @example
     * // Delete one MIPAgencyContractProperties
     * const MIPAgencyContractProperties = await prisma.mIPAgencyContractProperties.delete({
     *   where: {
     *     // ... filter to delete one MIPAgencyContractProperties
     *   }
     * })
     * 
    **/
    delete<T extends MIPAgencyContractPropertiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MIPAgencyContractPropertiesDeleteArgs<ExtArgs>>
    ): Prisma__MIPAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MIPAgencyContractPropertiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MIPAgencyContractProperties.
     * @param {MIPAgencyContractPropertiesUpdateArgs} args - Arguments to update one MIPAgencyContractProperties.
     * @example
     * // Update one MIPAgencyContractProperties
     * const mIPAgencyContractProperties = await prisma.mIPAgencyContractProperties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MIPAgencyContractPropertiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MIPAgencyContractPropertiesUpdateArgs<ExtArgs>>
    ): Prisma__MIPAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MIPAgencyContractPropertiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MIPAgencyContractProperties.
     * @param {MIPAgencyContractPropertiesDeleteManyArgs} args - Arguments to filter MIPAgencyContractProperties to delete.
     * @example
     * // Delete a few MIPAgencyContractProperties
     * const { count } = await prisma.mIPAgencyContractProperties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MIPAgencyContractPropertiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MIPAgencyContractPropertiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MIPAgencyContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MIPAgencyContractPropertiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MIPAgencyContractProperties
     * const mIPAgencyContractProperties = await prisma.mIPAgencyContractProperties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MIPAgencyContractPropertiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MIPAgencyContractPropertiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MIPAgencyContractProperties.
     * @param {MIPAgencyContractPropertiesUpsertArgs} args - Arguments to update or create a MIPAgencyContractProperties.
     * @example
     * // Update or create a MIPAgencyContractProperties
     * const mIPAgencyContractProperties = await prisma.mIPAgencyContractProperties.upsert({
     *   create: {
     *     // ... data to create a MIPAgencyContractProperties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MIPAgencyContractProperties we want to update
     *   }
     * })
    **/
    upsert<T extends MIPAgencyContractPropertiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MIPAgencyContractPropertiesUpsertArgs<ExtArgs>>
    ): Prisma__MIPAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MIPAgencyContractPropertiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MIPAgencyContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MIPAgencyContractPropertiesCountArgs} args - Arguments to filter MIPAgencyContractProperties to count.
     * @example
     * // Count the number of MIPAgencyContractProperties
     * const count = await prisma.mIPAgencyContractProperties.count({
     *   where: {
     *     // ... the filter for the MIPAgencyContractProperties we want to count
     *   }
     * })
    **/
    count<T extends MIPAgencyContractPropertiesCountArgs>(
      args?: Subset<T, MIPAgencyContractPropertiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MIPAgencyContractPropertiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MIPAgencyContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MIPAgencyContractPropertiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MIPAgencyContractPropertiesAggregateArgs>(args: Subset<T, MIPAgencyContractPropertiesAggregateArgs>): Prisma.PrismaPromise<GetMIPAgencyContractPropertiesAggregateType<T>>

    /**
     * Group by MIPAgencyContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MIPAgencyContractPropertiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MIPAgencyContractPropertiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MIPAgencyContractPropertiesGroupByArgs['orderBy'] }
        : { orderBy?: MIPAgencyContractPropertiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MIPAgencyContractPropertiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMIPAgencyContractPropertiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MIPAgencyContractProperties model
   */
  readonly fields: MIPAgencyContractPropertiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MIPAgencyContractProperties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MIPAgencyContractPropertiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    agency_contract<T extends MIPAgencyContractProperties$agency_contractArgs<ExtArgs> = {}>(args?: Subset<T, MIPAgencyContractProperties$agency_contractArgs<ExtArgs>>): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    agency_contract_commission<T extends AgencyContractCommissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContractCommissionDefaultArgs<ExtArgs>>): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MIPAgencyContractProperties model
   */ 
  interface MIPAgencyContractPropertiesFieldRefs {
    readonly id: FieldRef<"MIPAgencyContractProperties", 'Int'>
    readonly created_at: FieldRef<"MIPAgencyContractProperties", 'DateTime'>
    readonly updated_at: FieldRef<"MIPAgencyContractProperties", 'DateTime'>
    readonly agency_contract_commission_id: FieldRef<"MIPAgencyContractProperties", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MIPAgencyContractProperties findUnique
   */
  export type MIPAgencyContractPropertiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MIPAgencyContractProperties
     */
    select?: MIPAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MIPAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which MIPAgencyContractProperties to fetch.
     */
    where: MIPAgencyContractPropertiesWhereUniqueInput
  }

  /**
   * MIPAgencyContractProperties findUniqueOrThrow
   */
  export type MIPAgencyContractPropertiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MIPAgencyContractProperties
     */
    select?: MIPAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MIPAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which MIPAgencyContractProperties to fetch.
     */
    where: MIPAgencyContractPropertiesWhereUniqueInput
  }

  /**
   * MIPAgencyContractProperties findFirst
   */
  export type MIPAgencyContractPropertiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MIPAgencyContractProperties
     */
    select?: MIPAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MIPAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which MIPAgencyContractProperties to fetch.
     */
    where?: MIPAgencyContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MIPAgencyContractProperties to fetch.
     */
    orderBy?: MIPAgencyContractPropertiesOrderByWithRelationInput | MIPAgencyContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MIPAgencyContractProperties.
     */
    cursor?: MIPAgencyContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MIPAgencyContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MIPAgencyContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MIPAgencyContractProperties.
     */
    distinct?: MIPAgencyContractPropertiesScalarFieldEnum | MIPAgencyContractPropertiesScalarFieldEnum[]
  }

  /**
   * MIPAgencyContractProperties findFirstOrThrow
   */
  export type MIPAgencyContractPropertiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MIPAgencyContractProperties
     */
    select?: MIPAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MIPAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which MIPAgencyContractProperties to fetch.
     */
    where?: MIPAgencyContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MIPAgencyContractProperties to fetch.
     */
    orderBy?: MIPAgencyContractPropertiesOrderByWithRelationInput | MIPAgencyContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MIPAgencyContractProperties.
     */
    cursor?: MIPAgencyContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MIPAgencyContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MIPAgencyContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MIPAgencyContractProperties.
     */
    distinct?: MIPAgencyContractPropertiesScalarFieldEnum | MIPAgencyContractPropertiesScalarFieldEnum[]
  }

  /**
   * MIPAgencyContractProperties findMany
   */
  export type MIPAgencyContractPropertiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MIPAgencyContractProperties
     */
    select?: MIPAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MIPAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which MIPAgencyContractProperties to fetch.
     */
    where?: MIPAgencyContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MIPAgencyContractProperties to fetch.
     */
    orderBy?: MIPAgencyContractPropertiesOrderByWithRelationInput | MIPAgencyContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MIPAgencyContractProperties.
     */
    cursor?: MIPAgencyContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MIPAgencyContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MIPAgencyContractProperties.
     */
    skip?: number
    distinct?: MIPAgencyContractPropertiesScalarFieldEnum | MIPAgencyContractPropertiesScalarFieldEnum[]
  }

  /**
   * MIPAgencyContractProperties create
   */
  export type MIPAgencyContractPropertiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MIPAgencyContractProperties
     */
    select?: MIPAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MIPAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to create a MIPAgencyContractProperties.
     */
    data: XOR<MIPAgencyContractPropertiesCreateInput, MIPAgencyContractPropertiesUncheckedCreateInput>
  }

  /**
   * MIPAgencyContractProperties createMany
   */
  export type MIPAgencyContractPropertiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MIPAgencyContractProperties.
     */
    data: MIPAgencyContractPropertiesCreateManyInput | MIPAgencyContractPropertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MIPAgencyContractProperties update
   */
  export type MIPAgencyContractPropertiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MIPAgencyContractProperties
     */
    select?: MIPAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MIPAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to update a MIPAgencyContractProperties.
     */
    data: XOR<MIPAgencyContractPropertiesUpdateInput, MIPAgencyContractPropertiesUncheckedUpdateInput>
    /**
     * Choose, which MIPAgencyContractProperties to update.
     */
    where: MIPAgencyContractPropertiesWhereUniqueInput
  }

  /**
   * MIPAgencyContractProperties updateMany
   */
  export type MIPAgencyContractPropertiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MIPAgencyContractProperties.
     */
    data: XOR<MIPAgencyContractPropertiesUpdateManyMutationInput, MIPAgencyContractPropertiesUncheckedUpdateManyInput>
    /**
     * Filter which MIPAgencyContractProperties to update
     */
    where?: MIPAgencyContractPropertiesWhereInput
  }

  /**
   * MIPAgencyContractProperties upsert
   */
  export type MIPAgencyContractPropertiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MIPAgencyContractProperties
     */
    select?: MIPAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MIPAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * The filter to search for the MIPAgencyContractProperties to update in case it exists.
     */
    where: MIPAgencyContractPropertiesWhereUniqueInput
    /**
     * In case the MIPAgencyContractProperties found by the `where` argument doesn't exist, create a new MIPAgencyContractProperties with this data.
     */
    create: XOR<MIPAgencyContractPropertiesCreateInput, MIPAgencyContractPropertiesUncheckedCreateInput>
    /**
     * In case the MIPAgencyContractProperties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MIPAgencyContractPropertiesUpdateInput, MIPAgencyContractPropertiesUncheckedUpdateInput>
  }

  /**
   * MIPAgencyContractProperties delete
   */
  export type MIPAgencyContractPropertiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MIPAgencyContractProperties
     */
    select?: MIPAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MIPAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter which MIPAgencyContractProperties to delete.
     */
    where: MIPAgencyContractPropertiesWhereUniqueInput
  }

  /**
   * MIPAgencyContractProperties deleteMany
   */
  export type MIPAgencyContractPropertiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MIPAgencyContractProperties to delete
     */
    where?: MIPAgencyContractPropertiesWhereInput
  }

  /**
   * MIPAgencyContractProperties.agency_contract
   */
  export type MIPAgencyContractProperties$agency_contractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    where?: AgencyContractWhereInput
  }

  /**
   * MIPAgencyContractProperties without action
   */
  export type MIPAgencyContractPropertiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MIPAgencyContractProperties
     */
    select?: MIPAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MIPAgencyContractPropertiesInclude<ExtArgs> | null
  }


  /**
   * Model AgencyContractCommission
   */

  export type AggregateAgencyContractCommission = {
    _count: AgencyContractCommissionCountAggregateOutputType | null
    _avg: AgencyContractCommissionAvgAggregateOutputType | null
    _sum: AgencyContractCommissionSumAggregateOutputType | null
    _min: AgencyContractCommissionMinAggregateOutputType | null
    _max: AgencyContractCommissionMaxAggregateOutputType | null
  }

  export type AgencyContractCommissionAvgAggregateOutputType = {
    id: number | null
    percent: Decimal | null
    threshold: Decimal | null
    max_days: number | null
  }

  export type AgencyContractCommissionSumAggregateOutputType = {
    id: number | null
    percent: Decimal | null
    threshold: Decimal | null
    max_days: number | null
  }

  export type AgencyContractCommissionMinAggregateOutputType = {
    id: number | null
    percent: Decimal | null
    threshold: Decimal | null
    max_days: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AgencyContractCommissionMaxAggregateOutputType = {
    id: number | null
    percent: Decimal | null
    threshold: Decimal | null
    max_days: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AgencyContractCommissionCountAggregateOutputType = {
    id: number
    percent: number
    threshold: number
    max_days: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AgencyContractCommissionAvgAggregateInputType = {
    id?: true
    percent?: true
    threshold?: true
    max_days?: true
  }

  export type AgencyContractCommissionSumAggregateInputType = {
    id?: true
    percent?: true
    threshold?: true
    max_days?: true
  }

  export type AgencyContractCommissionMinAggregateInputType = {
    id?: true
    percent?: true
    threshold?: true
    max_days?: true
    created_at?: true
    updated_at?: true
  }

  export type AgencyContractCommissionMaxAggregateInputType = {
    id?: true
    percent?: true
    threshold?: true
    max_days?: true
    created_at?: true
    updated_at?: true
  }

  export type AgencyContractCommissionCountAggregateInputType = {
    id?: true
    percent?: true
    threshold?: true
    max_days?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AgencyContractCommissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyContractCommission to aggregate.
     */
    where?: AgencyContractCommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContractCommissions to fetch.
     */
    orderBy?: AgencyContractCommissionOrderByWithRelationInput | AgencyContractCommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyContractCommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContractCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContractCommissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyContractCommissions
    **/
    _count?: true | AgencyContractCommissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyContractCommissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencyContractCommissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyContractCommissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyContractCommissionMaxAggregateInputType
  }

  export type GetAgencyContractCommissionAggregateType<T extends AgencyContractCommissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyContractCommission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyContractCommission[P]>
      : GetScalarType<T[P], AggregateAgencyContractCommission[P]>
  }




  export type AgencyContractCommissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyContractCommissionWhereInput
    orderBy?: AgencyContractCommissionOrderByWithAggregationInput | AgencyContractCommissionOrderByWithAggregationInput[]
    by: AgencyContractCommissionScalarFieldEnum[] | AgencyContractCommissionScalarFieldEnum
    having?: AgencyContractCommissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyContractCommissionCountAggregateInputType | true
    _avg?: AgencyContractCommissionAvgAggregateInputType
    _sum?: AgencyContractCommissionSumAggregateInputType
    _min?: AgencyContractCommissionMinAggregateInputType
    _max?: AgencyContractCommissionMaxAggregateInputType
  }

  export type AgencyContractCommissionGroupByOutputType = {
    id: number
    percent: Decimal
    threshold: Decimal
    max_days: number
    created_at: Date
    updated_at: Date
    _count: AgencyContractCommissionCountAggregateOutputType | null
    _avg: AgencyContractCommissionAvgAggregateOutputType | null
    _sum: AgencyContractCommissionSumAggregateOutputType | null
    _min: AgencyContractCommissionMinAggregateOutputType | null
    _max: AgencyContractCommissionMaxAggregateOutputType | null
  }

  type GetAgencyContractCommissionGroupByPayload<T extends AgencyContractCommissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyContractCommissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyContractCommissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyContractCommissionGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyContractCommissionGroupByOutputType[P]>
        }
      >
    >


  export type AgencyContractCommissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    percent?: boolean
    threshold?: boolean
    max_days?: boolean
    created_at?: boolean
    updated_at?: boolean
    real_estate_agency_contract_properties?: boolean | AgencyContractCommission$real_estate_agency_contract_propertiesArgs<ExtArgs>
    mip_agency_contract_properties?: boolean | AgencyContractCommission$mip_agency_contract_propertiesArgs<ExtArgs>
  }, ExtArgs["result"]["agencyContractCommission"]>


  export type AgencyContractCommissionSelectScalar = {
    id?: boolean
    percent?: boolean
    threshold?: boolean
    max_days?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AgencyContractCommissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    real_estate_agency_contract_properties?: boolean | AgencyContractCommission$real_estate_agency_contract_propertiesArgs<ExtArgs>
    mip_agency_contract_properties?: boolean | AgencyContractCommission$mip_agency_contract_propertiesArgs<ExtArgs>
  }

  export type $AgencyContractCommissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyContractCommission"
    objects: {
      real_estate_agency_contract_properties: Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs> | null
      mip_agency_contract_properties: Prisma.$MIPAgencyContractPropertiesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      percent: Prisma.Decimal
      threshold: Prisma.Decimal
      max_days: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["agencyContractCommission"]>
    composites: {}
  }

  type AgencyContractCommissionGetPayload<S extends boolean | null | undefined | AgencyContractCommissionDefaultArgs> = $Result.GetResult<Prisma.$AgencyContractCommissionPayload, S>

  type AgencyContractCommissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgencyContractCommissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgencyContractCommissionCountAggregateInputType | true
    }

  export interface AgencyContractCommissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyContractCommission'], meta: { name: 'AgencyContractCommission' } }
    /**
     * Find zero or one AgencyContractCommission that matches the filter.
     * @param {AgencyContractCommissionFindUniqueArgs} args - Arguments to find a AgencyContractCommission
     * @example
     * // Get one AgencyContractCommission
     * const agencyContractCommission = await prisma.agencyContractCommission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgencyContractCommissionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractCommissionFindUniqueArgs<ExtArgs>>
    ): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AgencyContractCommission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgencyContractCommissionFindUniqueOrThrowArgs} args - Arguments to find a AgencyContractCommission
     * @example
     * // Get one AgencyContractCommission
     * const agencyContractCommission = await prisma.agencyContractCommission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgencyContractCommissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractCommissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AgencyContractCommission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractCommissionFindFirstArgs} args - Arguments to find a AgencyContractCommission
     * @example
     * // Get one AgencyContractCommission
     * const agencyContractCommission = await prisma.agencyContractCommission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgencyContractCommissionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractCommissionFindFirstArgs<ExtArgs>>
    ): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AgencyContractCommission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractCommissionFindFirstOrThrowArgs} args - Arguments to find a AgencyContractCommission
     * @example
     * // Get one AgencyContractCommission
     * const agencyContractCommission = await prisma.agencyContractCommission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgencyContractCommissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractCommissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AgencyContractCommissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractCommissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyContractCommissions
     * const agencyContractCommissions = await prisma.agencyContractCommission.findMany()
     * 
     * // Get first 10 AgencyContractCommissions
     * const agencyContractCommissions = await prisma.agencyContractCommission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyContractCommissionWithIdOnly = await prisma.agencyContractCommission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgencyContractCommissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractCommissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AgencyContractCommission.
     * @param {AgencyContractCommissionCreateArgs} args - Arguments to create a AgencyContractCommission.
     * @example
     * // Create one AgencyContractCommission
     * const AgencyContractCommission = await prisma.agencyContractCommission.create({
     *   data: {
     *     // ... data to create a AgencyContractCommission
     *   }
     * })
     * 
    **/
    create<T extends AgencyContractCommissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractCommissionCreateArgs<ExtArgs>>
    ): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AgencyContractCommissions.
     * @param {AgencyContractCommissionCreateManyArgs} args - Arguments to create many AgencyContractCommissions.
     * @example
     * // Create many AgencyContractCommissions
     * const agencyContractCommission = await prisma.agencyContractCommission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AgencyContractCommissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractCommissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgencyContractCommission.
     * @param {AgencyContractCommissionDeleteArgs} args - Arguments to delete one AgencyContractCommission.
     * @example
     * // Delete one AgencyContractCommission
     * const AgencyContractCommission = await prisma.agencyContractCommission.delete({
     *   where: {
     *     // ... filter to delete one AgencyContractCommission
     *   }
     * })
     * 
    **/
    delete<T extends AgencyContractCommissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractCommissionDeleteArgs<ExtArgs>>
    ): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AgencyContractCommission.
     * @param {AgencyContractCommissionUpdateArgs} args - Arguments to update one AgencyContractCommission.
     * @example
     * // Update one AgencyContractCommission
     * const agencyContractCommission = await prisma.agencyContractCommission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgencyContractCommissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractCommissionUpdateArgs<ExtArgs>>
    ): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AgencyContractCommissions.
     * @param {AgencyContractCommissionDeleteManyArgs} args - Arguments to filter AgencyContractCommissions to delete.
     * @example
     * // Delete a few AgencyContractCommissions
     * const { count } = await prisma.agencyContractCommission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgencyContractCommissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractCommissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyContractCommissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractCommissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyContractCommissions
     * const agencyContractCommission = await prisma.agencyContractCommission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgencyContractCommissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractCommissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgencyContractCommission.
     * @param {AgencyContractCommissionUpsertArgs} args - Arguments to update or create a AgencyContractCommission.
     * @example
     * // Update or create a AgencyContractCommission
     * const agencyContractCommission = await prisma.agencyContractCommission.upsert({
     *   create: {
     *     // ... data to create a AgencyContractCommission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyContractCommission we want to update
     *   }
     * })
    **/
    upsert<T extends AgencyContractCommissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractCommissionUpsertArgs<ExtArgs>>
    ): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AgencyContractCommissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractCommissionCountArgs} args - Arguments to filter AgencyContractCommissions to count.
     * @example
     * // Count the number of AgencyContractCommissions
     * const count = await prisma.agencyContractCommission.count({
     *   where: {
     *     // ... the filter for the AgencyContractCommissions we want to count
     *   }
     * })
    **/
    count<T extends AgencyContractCommissionCountArgs>(
      args?: Subset<T, AgencyContractCommissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyContractCommissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyContractCommission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractCommissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyContractCommissionAggregateArgs>(args: Subset<T, AgencyContractCommissionAggregateArgs>): Prisma.PrismaPromise<GetAgencyContractCommissionAggregateType<T>>

    /**
     * Group by AgencyContractCommission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractCommissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyContractCommissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyContractCommissionGroupByArgs['orderBy'] }
        : { orderBy?: AgencyContractCommissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyContractCommissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyContractCommissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyContractCommission model
   */
  readonly fields: AgencyContractCommissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyContractCommission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyContractCommissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    real_estate_agency_contract_properties<T extends AgencyContractCommission$real_estate_agency_contract_propertiesArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContractCommission$real_estate_agency_contract_propertiesArgs<ExtArgs>>): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    mip_agency_contract_properties<T extends AgencyContractCommission$mip_agency_contract_propertiesArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContractCommission$mip_agency_contract_propertiesArgs<ExtArgs>>): Prisma__MIPAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MIPAgencyContractPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AgencyContractCommission model
   */ 
  interface AgencyContractCommissionFieldRefs {
    readonly id: FieldRef<"AgencyContractCommission", 'Int'>
    readonly percent: FieldRef<"AgencyContractCommission", 'Decimal'>
    readonly threshold: FieldRef<"AgencyContractCommission", 'Decimal'>
    readonly max_days: FieldRef<"AgencyContractCommission", 'Int'>
    readonly created_at: FieldRef<"AgencyContractCommission", 'DateTime'>
    readonly updated_at: FieldRef<"AgencyContractCommission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgencyContractCommission findUnique
   */
  export type AgencyContractCommissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractCommission to fetch.
     */
    where: AgencyContractCommissionWhereUniqueInput
  }

  /**
   * AgencyContractCommission findUniqueOrThrow
   */
  export type AgencyContractCommissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractCommission to fetch.
     */
    where: AgencyContractCommissionWhereUniqueInput
  }

  /**
   * AgencyContractCommission findFirst
   */
  export type AgencyContractCommissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractCommission to fetch.
     */
    where?: AgencyContractCommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContractCommissions to fetch.
     */
    orderBy?: AgencyContractCommissionOrderByWithRelationInput | AgencyContractCommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyContractCommissions.
     */
    cursor?: AgencyContractCommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContractCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContractCommissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyContractCommissions.
     */
    distinct?: AgencyContractCommissionScalarFieldEnum | AgencyContractCommissionScalarFieldEnum[]
  }

  /**
   * AgencyContractCommission findFirstOrThrow
   */
  export type AgencyContractCommissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractCommission to fetch.
     */
    where?: AgencyContractCommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContractCommissions to fetch.
     */
    orderBy?: AgencyContractCommissionOrderByWithRelationInput | AgencyContractCommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyContractCommissions.
     */
    cursor?: AgencyContractCommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContractCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContractCommissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyContractCommissions.
     */
    distinct?: AgencyContractCommissionScalarFieldEnum | AgencyContractCommissionScalarFieldEnum[]
  }

  /**
   * AgencyContractCommission findMany
   */
  export type AgencyContractCommissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractCommissions to fetch.
     */
    where?: AgencyContractCommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContractCommissions to fetch.
     */
    orderBy?: AgencyContractCommissionOrderByWithRelationInput | AgencyContractCommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyContractCommissions.
     */
    cursor?: AgencyContractCommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContractCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContractCommissions.
     */
    skip?: number
    distinct?: AgencyContractCommissionScalarFieldEnum | AgencyContractCommissionScalarFieldEnum[]
  }

  /**
   * AgencyContractCommission create
   */
  export type AgencyContractCommissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyContractCommission.
     */
    data: XOR<AgencyContractCommissionCreateInput, AgencyContractCommissionUncheckedCreateInput>
  }

  /**
   * AgencyContractCommission createMany
   */
  export type AgencyContractCommissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyContractCommissions.
     */
    data: AgencyContractCommissionCreateManyInput | AgencyContractCommissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyContractCommission update
   */
  export type AgencyContractCommissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyContractCommission.
     */
    data: XOR<AgencyContractCommissionUpdateInput, AgencyContractCommissionUncheckedUpdateInput>
    /**
     * Choose, which AgencyContractCommission to update.
     */
    where: AgencyContractCommissionWhereUniqueInput
  }

  /**
   * AgencyContractCommission updateMany
   */
  export type AgencyContractCommissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyContractCommissions.
     */
    data: XOR<AgencyContractCommissionUpdateManyMutationInput, AgencyContractCommissionUncheckedUpdateManyInput>
    /**
     * Filter which AgencyContractCommissions to update
     */
    where?: AgencyContractCommissionWhereInput
  }

  /**
   * AgencyContractCommission upsert
   */
  export type AgencyContractCommissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyContractCommission to update in case it exists.
     */
    where: AgencyContractCommissionWhereUniqueInput
    /**
     * In case the AgencyContractCommission found by the `where` argument doesn't exist, create a new AgencyContractCommission with this data.
     */
    create: XOR<AgencyContractCommissionCreateInput, AgencyContractCommissionUncheckedCreateInput>
    /**
     * In case the AgencyContractCommission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyContractCommissionUpdateInput, AgencyContractCommissionUncheckedUpdateInput>
  }

  /**
   * AgencyContractCommission delete
   */
  export type AgencyContractCommissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
    /**
     * Filter which AgencyContractCommission to delete.
     */
    where: AgencyContractCommissionWhereUniqueInput
  }

  /**
   * AgencyContractCommission deleteMany
   */
  export type AgencyContractCommissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyContractCommissions to delete
     */
    where?: AgencyContractCommissionWhereInput
  }

  /**
   * AgencyContractCommission.real_estate_agency_contract_properties
   */
  export type AgencyContractCommission$real_estate_agency_contract_propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    where?: RealEstateAgencyContractPropertiesWhereInput
  }

  /**
   * AgencyContractCommission.mip_agency_contract_properties
   */
  export type AgencyContractCommission$mip_agency_contract_propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MIPAgencyContractProperties
     */
    select?: MIPAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MIPAgencyContractPropertiesInclude<ExtArgs> | null
    where?: MIPAgencyContractPropertiesWhereInput
  }

  /**
   * AgencyContractCommission without action
   */
  export type AgencyContractCommissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
  }


  /**
   * Model RealEstateAgent
   */

  export type AggregateRealEstateAgent = {
    _count: RealEstateAgentCountAggregateOutputType | null
    _avg: RealEstateAgentAvgAggregateOutputType | null
    _sum: RealEstateAgentSumAggregateOutputType | null
    _min: RealEstateAgentMinAggregateOutputType | null
    _max: RealEstateAgentMaxAggregateOutputType | null
  }

  export type RealEstateAgentAvgAggregateOutputType = {
    id: number | null
  }

  export type RealEstateAgentSumAggregateOutputType = {
    id: number | null
  }

  export type RealEstateAgentMinAggregateOutputType = {
    id: number | null
    full_name: string | null
    phone: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RealEstateAgentMaxAggregateOutputType = {
    id: number | null
    full_name: string | null
    phone: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RealEstateAgentCountAggregateOutputType = {
    id: number
    full_name: number
    phone: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type RealEstateAgentAvgAggregateInputType = {
    id?: true
  }

  export type RealEstateAgentSumAggregateInputType = {
    id?: true
  }

  export type RealEstateAgentMinAggregateInputType = {
    id?: true
    full_name?: true
    phone?: true
    created_at?: true
    updated_at?: true
  }

  export type RealEstateAgentMaxAggregateInputType = {
    id?: true
    full_name?: true
    phone?: true
    created_at?: true
    updated_at?: true
  }

  export type RealEstateAgentCountAggregateInputType = {
    id?: true
    full_name?: true
    phone?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type RealEstateAgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RealEstateAgent to aggregate.
     */
    where?: RealEstateAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgents to fetch.
     */
    orderBy?: RealEstateAgentOrderByWithRelationInput | RealEstateAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RealEstateAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RealEstateAgents
    **/
    _count?: true | RealEstateAgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RealEstateAgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RealEstateAgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RealEstateAgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RealEstateAgentMaxAggregateInputType
  }

  export type GetRealEstateAgentAggregateType<T extends RealEstateAgentAggregateArgs> = {
        [P in keyof T & keyof AggregateRealEstateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRealEstateAgent[P]>
      : GetScalarType<T[P], AggregateRealEstateAgent[P]>
  }




  export type RealEstateAgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RealEstateAgentWhereInput
    orderBy?: RealEstateAgentOrderByWithAggregationInput | RealEstateAgentOrderByWithAggregationInput[]
    by: RealEstateAgentScalarFieldEnum[] | RealEstateAgentScalarFieldEnum
    having?: RealEstateAgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RealEstateAgentCountAggregateInputType | true
    _avg?: RealEstateAgentAvgAggregateInputType
    _sum?: RealEstateAgentSumAggregateInputType
    _min?: RealEstateAgentMinAggregateInputType
    _max?: RealEstateAgentMaxAggregateInputType
  }

  export type RealEstateAgentGroupByOutputType = {
    id: number
    full_name: string
    phone: string | null
    created_at: Date
    updated_at: Date
    _count: RealEstateAgentCountAggregateOutputType | null
    _avg: RealEstateAgentAvgAggregateOutputType | null
    _sum: RealEstateAgentSumAggregateOutputType | null
    _min: RealEstateAgentMinAggregateOutputType | null
    _max: RealEstateAgentMaxAggregateOutputType | null
  }

  type GetRealEstateAgentGroupByPayload<T extends RealEstateAgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RealEstateAgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RealEstateAgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RealEstateAgentGroupByOutputType[P]>
            : GetScalarType<T[P], RealEstateAgentGroupByOutputType[P]>
        }
      >
    >


  export type RealEstateAgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    phone?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_contracts?: boolean | RealEstateAgent$client_contractsArgs<ExtArgs>
    agencies?: boolean | RealEstateAgent$agenciesArgs<ExtArgs>
    _count?: boolean | RealEstateAgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["realEstateAgent"]>


  export type RealEstateAgentSelectScalar = {
    id?: boolean
    full_name?: boolean
    phone?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type RealEstateAgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_contracts?: boolean | RealEstateAgent$client_contractsArgs<ExtArgs>
    agencies?: boolean | RealEstateAgent$agenciesArgs<ExtArgs>
    _count?: boolean | RealEstateAgentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RealEstateAgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RealEstateAgent"
    objects: {
      client_contracts: Prisma.$ClientContractPayload<ExtArgs>[]
      agencies: Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      full_name: string
      phone: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["realEstateAgent"]>
    composites: {}
  }

  type RealEstateAgentGetPayload<S extends boolean | null | undefined | RealEstateAgentDefaultArgs> = $Result.GetResult<Prisma.$RealEstateAgentPayload, S>

  type RealEstateAgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RealEstateAgentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RealEstateAgentCountAggregateInputType | true
    }

  export interface RealEstateAgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RealEstateAgent'], meta: { name: 'RealEstateAgent' } }
    /**
     * Find zero or one RealEstateAgent that matches the filter.
     * @param {RealEstateAgentFindUniqueArgs} args - Arguments to find a RealEstateAgent
     * @example
     * // Get one RealEstateAgent
     * const realEstateAgent = await prisma.realEstateAgent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RealEstateAgentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgentFindUniqueArgs<ExtArgs>>
    ): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RealEstateAgent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RealEstateAgentFindUniqueOrThrowArgs} args - Arguments to find a RealEstateAgent
     * @example
     * // Get one RealEstateAgent
     * const realEstateAgent = await prisma.realEstateAgent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RealEstateAgentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RealEstateAgent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentFindFirstArgs} args - Arguments to find a RealEstateAgent
     * @example
     * // Get one RealEstateAgent
     * const realEstateAgent = await prisma.realEstateAgent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RealEstateAgentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgentFindFirstArgs<ExtArgs>>
    ): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RealEstateAgent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentFindFirstOrThrowArgs} args - Arguments to find a RealEstateAgent
     * @example
     * // Get one RealEstateAgent
     * const realEstateAgent = await prisma.realEstateAgent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RealEstateAgentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RealEstateAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RealEstateAgents
     * const realEstateAgents = await prisma.realEstateAgent.findMany()
     * 
     * // Get first 10 RealEstateAgents
     * const realEstateAgents = await prisma.realEstateAgent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const realEstateAgentWithIdOnly = await prisma.realEstateAgent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RealEstateAgentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RealEstateAgent.
     * @param {RealEstateAgentCreateArgs} args - Arguments to create a RealEstateAgent.
     * @example
     * // Create one RealEstateAgent
     * const RealEstateAgent = await prisma.realEstateAgent.create({
     *   data: {
     *     // ... data to create a RealEstateAgent
     *   }
     * })
     * 
    **/
    create<T extends RealEstateAgentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgentCreateArgs<ExtArgs>>
    ): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RealEstateAgents.
     * @param {RealEstateAgentCreateManyArgs} args - Arguments to create many RealEstateAgents.
     * @example
     * // Create many RealEstateAgents
     * const realEstateAgent = await prisma.realEstateAgent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends RealEstateAgentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RealEstateAgent.
     * @param {RealEstateAgentDeleteArgs} args - Arguments to delete one RealEstateAgent.
     * @example
     * // Delete one RealEstateAgent
     * const RealEstateAgent = await prisma.realEstateAgent.delete({
     *   where: {
     *     // ... filter to delete one RealEstateAgent
     *   }
     * })
     * 
    **/
    delete<T extends RealEstateAgentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgentDeleteArgs<ExtArgs>>
    ): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RealEstateAgent.
     * @param {RealEstateAgentUpdateArgs} args - Arguments to update one RealEstateAgent.
     * @example
     * // Update one RealEstateAgent
     * const realEstateAgent = await prisma.realEstateAgent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RealEstateAgentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgentUpdateArgs<ExtArgs>>
    ): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RealEstateAgents.
     * @param {RealEstateAgentDeleteManyArgs} args - Arguments to filter RealEstateAgents to delete.
     * @example
     * // Delete a few RealEstateAgents
     * const { count } = await prisma.realEstateAgent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RealEstateAgentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RealEstateAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RealEstateAgents
     * const realEstateAgent = await prisma.realEstateAgent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RealEstateAgentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RealEstateAgent.
     * @param {RealEstateAgentUpsertArgs} args - Arguments to update or create a RealEstateAgent.
     * @example
     * // Update or create a RealEstateAgent
     * const realEstateAgent = await prisma.realEstateAgent.upsert({
     *   create: {
     *     // ... data to create a RealEstateAgent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RealEstateAgent we want to update
     *   }
     * })
    **/
    upsert<T extends RealEstateAgentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgentUpsertArgs<ExtArgs>>
    ): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RealEstateAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentCountArgs} args - Arguments to filter RealEstateAgents to count.
     * @example
     * // Count the number of RealEstateAgents
     * const count = await prisma.realEstateAgent.count({
     *   where: {
     *     // ... the filter for the RealEstateAgents we want to count
     *   }
     * })
    **/
    count<T extends RealEstateAgentCountArgs>(
      args?: Subset<T, RealEstateAgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RealEstateAgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RealEstateAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RealEstateAgentAggregateArgs>(args: Subset<T, RealEstateAgentAggregateArgs>): Prisma.PrismaPromise<GetRealEstateAgentAggregateType<T>>

    /**
     * Group by RealEstateAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RealEstateAgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RealEstateAgentGroupByArgs['orderBy'] }
        : { orderBy?: RealEstateAgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RealEstateAgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRealEstateAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RealEstateAgent model
   */
  readonly fields: RealEstateAgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RealEstateAgent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RealEstateAgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client_contracts<T extends RealEstateAgent$client_contractsArgs<ExtArgs> = {}>(args?: Subset<T, RealEstateAgent$client_contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    agencies<T extends RealEstateAgent$agenciesArgs<ExtArgs> = {}>(args?: Subset<T, RealEstateAgent$agenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RealEstateAgent model
   */ 
  interface RealEstateAgentFieldRefs {
    readonly id: FieldRef<"RealEstateAgent", 'Int'>
    readonly full_name: FieldRef<"RealEstateAgent", 'String'>
    readonly phone: FieldRef<"RealEstateAgent", 'String'>
    readonly created_at: FieldRef<"RealEstateAgent", 'DateTime'>
    readonly updated_at: FieldRef<"RealEstateAgent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RealEstateAgent findUnique
   */
  export type RealEstateAgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgent to fetch.
     */
    where: RealEstateAgentWhereUniqueInput
  }

  /**
   * RealEstateAgent findUniqueOrThrow
   */
  export type RealEstateAgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgent to fetch.
     */
    where: RealEstateAgentWhereUniqueInput
  }

  /**
   * RealEstateAgent findFirst
   */
  export type RealEstateAgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgent to fetch.
     */
    where?: RealEstateAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgents to fetch.
     */
    orderBy?: RealEstateAgentOrderByWithRelationInput | RealEstateAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealEstateAgents.
     */
    cursor?: RealEstateAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealEstateAgents.
     */
    distinct?: RealEstateAgentScalarFieldEnum | RealEstateAgentScalarFieldEnum[]
  }

  /**
   * RealEstateAgent findFirstOrThrow
   */
  export type RealEstateAgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgent to fetch.
     */
    where?: RealEstateAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgents to fetch.
     */
    orderBy?: RealEstateAgentOrderByWithRelationInput | RealEstateAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealEstateAgents.
     */
    cursor?: RealEstateAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealEstateAgents.
     */
    distinct?: RealEstateAgentScalarFieldEnum | RealEstateAgentScalarFieldEnum[]
  }

  /**
   * RealEstateAgent findMany
   */
  export type RealEstateAgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgents to fetch.
     */
    where?: RealEstateAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgents to fetch.
     */
    orderBy?: RealEstateAgentOrderByWithRelationInput | RealEstateAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RealEstateAgents.
     */
    cursor?: RealEstateAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgents.
     */
    skip?: number
    distinct?: RealEstateAgentScalarFieldEnum | RealEstateAgentScalarFieldEnum[]
  }

  /**
   * RealEstateAgent create
   */
  export type RealEstateAgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    /**
     * The data needed to create a RealEstateAgent.
     */
    data: XOR<RealEstateAgentCreateInput, RealEstateAgentUncheckedCreateInput>
  }

  /**
   * RealEstateAgent createMany
   */
  export type RealEstateAgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RealEstateAgents.
     */
    data: RealEstateAgentCreateManyInput | RealEstateAgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RealEstateAgent update
   */
  export type RealEstateAgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    /**
     * The data needed to update a RealEstateAgent.
     */
    data: XOR<RealEstateAgentUpdateInput, RealEstateAgentUncheckedUpdateInput>
    /**
     * Choose, which RealEstateAgent to update.
     */
    where: RealEstateAgentWhereUniqueInput
  }

  /**
   * RealEstateAgent updateMany
   */
  export type RealEstateAgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RealEstateAgents.
     */
    data: XOR<RealEstateAgentUpdateManyMutationInput, RealEstateAgentUncheckedUpdateManyInput>
    /**
     * Filter which RealEstateAgents to update
     */
    where?: RealEstateAgentWhereInput
  }

  /**
   * RealEstateAgent upsert
   */
  export type RealEstateAgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    /**
     * The filter to search for the RealEstateAgent to update in case it exists.
     */
    where: RealEstateAgentWhereUniqueInput
    /**
     * In case the RealEstateAgent found by the `where` argument doesn't exist, create a new RealEstateAgent with this data.
     */
    create: XOR<RealEstateAgentCreateInput, RealEstateAgentUncheckedCreateInput>
    /**
     * In case the RealEstateAgent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RealEstateAgentUpdateInput, RealEstateAgentUncheckedUpdateInput>
  }

  /**
   * RealEstateAgent delete
   */
  export type RealEstateAgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter which RealEstateAgent to delete.
     */
    where: RealEstateAgentWhereUniqueInput
  }

  /**
   * RealEstateAgent deleteMany
   */
  export type RealEstateAgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RealEstateAgents to delete
     */
    where?: RealEstateAgentWhereInput
  }

  /**
   * RealEstateAgent.client_contracts
   */
  export type RealEstateAgent$client_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    where?: ClientContractWhereInput
    orderBy?: ClientContractOrderByWithRelationInput | ClientContractOrderByWithRelationInput[]
    cursor?: ClientContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientContractScalarFieldEnum | ClientContractScalarFieldEnum[]
  }

  /**
   * RealEstateAgent.agencies
   */
  export type RealEstateAgent$agenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    where?: AgencyToRealEstateAgentWhereInput
    orderBy?: AgencyToRealEstateAgentOrderByWithRelationInput | AgencyToRealEstateAgentOrderByWithRelationInput[]
    cursor?: AgencyToRealEstateAgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyToRealEstateAgentScalarFieldEnum | AgencyToRealEstateAgentScalarFieldEnum[]
  }

  /**
   * RealEstateAgent without action
   */
  export type RealEstateAgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
  }


  /**
   * Model AgencyToRealEstateAgent
   */

  export type AggregateAgencyToRealEstateAgent = {
    _count: AgencyToRealEstateAgentCountAggregateOutputType | null
    _avg: AgencyToRealEstateAgentAvgAggregateOutputType | null
    _sum: AgencyToRealEstateAgentSumAggregateOutputType | null
    _min: AgencyToRealEstateAgentMinAggregateOutputType | null
    _max: AgencyToRealEstateAgentMaxAggregateOutputType | null
  }

  export type AgencyToRealEstateAgentAvgAggregateOutputType = {
    agency_id: number | null
    real_estate_agent_id: number | null
  }

  export type AgencyToRealEstateAgentSumAggregateOutputType = {
    agency_id: number | null
    real_estate_agent_id: number | null
  }

  export type AgencyToRealEstateAgentMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    agency_id: number | null
    real_estate_agent_id: number | null
  }

  export type AgencyToRealEstateAgentMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    agency_id: number | null
    real_estate_agent_id: number | null
  }

  export type AgencyToRealEstateAgentCountAggregateOutputType = {
    created_at: number
    updated_at: number
    agency_id: number
    real_estate_agent_id: number
    _all: number
  }


  export type AgencyToRealEstateAgentAvgAggregateInputType = {
    agency_id?: true
    real_estate_agent_id?: true
  }

  export type AgencyToRealEstateAgentSumAggregateInputType = {
    agency_id?: true
    real_estate_agent_id?: true
  }

  export type AgencyToRealEstateAgentMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    agency_id?: true
    real_estate_agent_id?: true
  }

  export type AgencyToRealEstateAgentMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    agency_id?: true
    real_estate_agent_id?: true
  }

  export type AgencyToRealEstateAgentCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    agency_id?: true
    real_estate_agent_id?: true
    _all?: true
  }

  export type AgencyToRealEstateAgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyToRealEstateAgent to aggregate.
     */
    where?: AgencyToRealEstateAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyToRealEstateAgents to fetch.
     */
    orderBy?: AgencyToRealEstateAgentOrderByWithRelationInput | AgencyToRealEstateAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyToRealEstateAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyToRealEstateAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyToRealEstateAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyToRealEstateAgents
    **/
    _count?: true | AgencyToRealEstateAgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyToRealEstateAgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencyToRealEstateAgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyToRealEstateAgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyToRealEstateAgentMaxAggregateInputType
  }

  export type GetAgencyToRealEstateAgentAggregateType<T extends AgencyToRealEstateAgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyToRealEstateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyToRealEstateAgent[P]>
      : GetScalarType<T[P], AggregateAgencyToRealEstateAgent[P]>
  }




  export type AgencyToRealEstateAgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyToRealEstateAgentWhereInput
    orderBy?: AgencyToRealEstateAgentOrderByWithAggregationInput | AgencyToRealEstateAgentOrderByWithAggregationInput[]
    by: AgencyToRealEstateAgentScalarFieldEnum[] | AgencyToRealEstateAgentScalarFieldEnum
    having?: AgencyToRealEstateAgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyToRealEstateAgentCountAggregateInputType | true
    _avg?: AgencyToRealEstateAgentAvgAggregateInputType
    _sum?: AgencyToRealEstateAgentSumAggregateInputType
    _min?: AgencyToRealEstateAgentMinAggregateInputType
    _max?: AgencyToRealEstateAgentMaxAggregateInputType
  }

  export type AgencyToRealEstateAgentGroupByOutputType = {
    created_at: Date
    updated_at: Date
    agency_id: number
    real_estate_agent_id: number
    _count: AgencyToRealEstateAgentCountAggregateOutputType | null
    _avg: AgencyToRealEstateAgentAvgAggregateOutputType | null
    _sum: AgencyToRealEstateAgentSumAggregateOutputType | null
    _min: AgencyToRealEstateAgentMinAggregateOutputType | null
    _max: AgencyToRealEstateAgentMaxAggregateOutputType | null
  }

  type GetAgencyToRealEstateAgentGroupByPayload<T extends AgencyToRealEstateAgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyToRealEstateAgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyToRealEstateAgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyToRealEstateAgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyToRealEstateAgentGroupByOutputType[P]>
        }
      >
    >


  export type AgencyToRealEstateAgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    agency_id?: boolean
    real_estate_agent_id?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    real_estate_agent?: boolean | RealEstateAgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyToRealEstateAgent"]>


  export type AgencyToRealEstateAgentSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    agency_id?: boolean
    real_estate_agent_id?: boolean
  }

  export type AgencyToRealEstateAgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    real_estate_agent?: boolean | RealEstateAgentDefaultArgs<ExtArgs>
  }

  export type $AgencyToRealEstateAgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyToRealEstateAgent"
    objects: {
      agency: Prisma.$AgencyPayload<ExtArgs>
      real_estate_agent: Prisma.$RealEstateAgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      created_at: Date
      updated_at: Date
      agency_id: number
      real_estate_agent_id: number
    }, ExtArgs["result"]["agencyToRealEstateAgent"]>
    composites: {}
  }

  type AgencyToRealEstateAgentGetPayload<S extends boolean | null | undefined | AgencyToRealEstateAgentDefaultArgs> = $Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload, S>

  type AgencyToRealEstateAgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgencyToRealEstateAgentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgencyToRealEstateAgentCountAggregateInputType | true
    }

  export interface AgencyToRealEstateAgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyToRealEstateAgent'], meta: { name: 'AgencyToRealEstateAgent' } }
    /**
     * Find zero or one AgencyToRealEstateAgent that matches the filter.
     * @param {AgencyToRealEstateAgentFindUniqueArgs} args - Arguments to find a AgencyToRealEstateAgent
     * @example
     * // Get one AgencyToRealEstateAgent
     * const agencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgencyToRealEstateAgentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyToRealEstateAgentFindUniqueArgs<ExtArgs>>
    ): Prisma__AgencyToRealEstateAgentClient<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AgencyToRealEstateAgent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgencyToRealEstateAgentFindUniqueOrThrowArgs} args - Arguments to find a AgencyToRealEstateAgent
     * @example
     * // Get one AgencyToRealEstateAgent
     * const agencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgencyToRealEstateAgentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyToRealEstateAgentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyToRealEstateAgentClient<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AgencyToRealEstateAgent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyToRealEstateAgentFindFirstArgs} args - Arguments to find a AgencyToRealEstateAgent
     * @example
     * // Get one AgencyToRealEstateAgent
     * const agencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgencyToRealEstateAgentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyToRealEstateAgentFindFirstArgs<ExtArgs>>
    ): Prisma__AgencyToRealEstateAgentClient<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AgencyToRealEstateAgent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyToRealEstateAgentFindFirstOrThrowArgs} args - Arguments to find a AgencyToRealEstateAgent
     * @example
     * // Get one AgencyToRealEstateAgent
     * const agencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgencyToRealEstateAgentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyToRealEstateAgentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyToRealEstateAgentClient<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AgencyToRealEstateAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyToRealEstateAgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyToRealEstateAgents
     * const agencyToRealEstateAgents = await prisma.agencyToRealEstateAgent.findMany()
     * 
     * // Get first 10 AgencyToRealEstateAgents
     * const agencyToRealEstateAgents = await prisma.agencyToRealEstateAgent.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const agencyToRealEstateAgentWithCreated_atOnly = await prisma.agencyToRealEstateAgent.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends AgencyToRealEstateAgentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyToRealEstateAgentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AgencyToRealEstateAgent.
     * @param {AgencyToRealEstateAgentCreateArgs} args - Arguments to create a AgencyToRealEstateAgent.
     * @example
     * // Create one AgencyToRealEstateAgent
     * const AgencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.create({
     *   data: {
     *     // ... data to create a AgencyToRealEstateAgent
     *   }
     * })
     * 
    **/
    create<T extends AgencyToRealEstateAgentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyToRealEstateAgentCreateArgs<ExtArgs>>
    ): Prisma__AgencyToRealEstateAgentClient<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AgencyToRealEstateAgents.
     * @param {AgencyToRealEstateAgentCreateManyArgs} args - Arguments to create many AgencyToRealEstateAgents.
     * @example
     * // Create many AgencyToRealEstateAgents
     * const agencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AgencyToRealEstateAgentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyToRealEstateAgentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgencyToRealEstateAgent.
     * @param {AgencyToRealEstateAgentDeleteArgs} args - Arguments to delete one AgencyToRealEstateAgent.
     * @example
     * // Delete one AgencyToRealEstateAgent
     * const AgencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.delete({
     *   where: {
     *     // ... filter to delete one AgencyToRealEstateAgent
     *   }
     * })
     * 
    **/
    delete<T extends AgencyToRealEstateAgentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyToRealEstateAgentDeleteArgs<ExtArgs>>
    ): Prisma__AgencyToRealEstateAgentClient<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AgencyToRealEstateAgent.
     * @param {AgencyToRealEstateAgentUpdateArgs} args - Arguments to update one AgencyToRealEstateAgent.
     * @example
     * // Update one AgencyToRealEstateAgent
     * const agencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgencyToRealEstateAgentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyToRealEstateAgentUpdateArgs<ExtArgs>>
    ): Prisma__AgencyToRealEstateAgentClient<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AgencyToRealEstateAgents.
     * @param {AgencyToRealEstateAgentDeleteManyArgs} args - Arguments to filter AgencyToRealEstateAgents to delete.
     * @example
     * // Delete a few AgencyToRealEstateAgents
     * const { count } = await prisma.agencyToRealEstateAgent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgencyToRealEstateAgentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyToRealEstateAgentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyToRealEstateAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyToRealEstateAgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyToRealEstateAgents
     * const agencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgencyToRealEstateAgentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyToRealEstateAgentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgencyToRealEstateAgent.
     * @param {AgencyToRealEstateAgentUpsertArgs} args - Arguments to update or create a AgencyToRealEstateAgent.
     * @example
     * // Update or create a AgencyToRealEstateAgent
     * const agencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.upsert({
     *   create: {
     *     // ... data to create a AgencyToRealEstateAgent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyToRealEstateAgent we want to update
     *   }
     * })
    **/
    upsert<T extends AgencyToRealEstateAgentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyToRealEstateAgentUpsertArgs<ExtArgs>>
    ): Prisma__AgencyToRealEstateAgentClient<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AgencyToRealEstateAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyToRealEstateAgentCountArgs} args - Arguments to filter AgencyToRealEstateAgents to count.
     * @example
     * // Count the number of AgencyToRealEstateAgents
     * const count = await prisma.agencyToRealEstateAgent.count({
     *   where: {
     *     // ... the filter for the AgencyToRealEstateAgents we want to count
     *   }
     * })
    **/
    count<T extends AgencyToRealEstateAgentCountArgs>(
      args?: Subset<T, AgencyToRealEstateAgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyToRealEstateAgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyToRealEstateAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyToRealEstateAgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyToRealEstateAgentAggregateArgs>(args: Subset<T, AgencyToRealEstateAgentAggregateArgs>): Prisma.PrismaPromise<GetAgencyToRealEstateAgentAggregateType<T>>

    /**
     * Group by AgencyToRealEstateAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyToRealEstateAgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyToRealEstateAgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyToRealEstateAgentGroupByArgs['orderBy'] }
        : { orderBy?: AgencyToRealEstateAgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyToRealEstateAgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyToRealEstateAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyToRealEstateAgent model
   */
  readonly fields: AgencyToRealEstateAgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyToRealEstateAgent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyToRealEstateAgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    real_estate_agent<T extends RealEstateAgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RealEstateAgentDefaultArgs<ExtArgs>>): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AgencyToRealEstateAgent model
   */ 
  interface AgencyToRealEstateAgentFieldRefs {
    readonly created_at: FieldRef<"AgencyToRealEstateAgent", 'DateTime'>
    readonly updated_at: FieldRef<"AgencyToRealEstateAgent", 'DateTime'>
    readonly agency_id: FieldRef<"AgencyToRealEstateAgent", 'Int'>
    readonly real_estate_agent_id: FieldRef<"AgencyToRealEstateAgent", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AgencyToRealEstateAgent findUnique
   */
  export type AgencyToRealEstateAgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which AgencyToRealEstateAgent to fetch.
     */
    where: AgencyToRealEstateAgentWhereUniqueInput
  }

  /**
   * AgencyToRealEstateAgent findUniqueOrThrow
   */
  export type AgencyToRealEstateAgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which AgencyToRealEstateAgent to fetch.
     */
    where: AgencyToRealEstateAgentWhereUniqueInput
  }

  /**
   * AgencyToRealEstateAgent findFirst
   */
  export type AgencyToRealEstateAgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which AgencyToRealEstateAgent to fetch.
     */
    where?: AgencyToRealEstateAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyToRealEstateAgents to fetch.
     */
    orderBy?: AgencyToRealEstateAgentOrderByWithRelationInput | AgencyToRealEstateAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyToRealEstateAgents.
     */
    cursor?: AgencyToRealEstateAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyToRealEstateAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyToRealEstateAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyToRealEstateAgents.
     */
    distinct?: AgencyToRealEstateAgentScalarFieldEnum | AgencyToRealEstateAgentScalarFieldEnum[]
  }

  /**
   * AgencyToRealEstateAgent findFirstOrThrow
   */
  export type AgencyToRealEstateAgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which AgencyToRealEstateAgent to fetch.
     */
    where?: AgencyToRealEstateAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyToRealEstateAgents to fetch.
     */
    orderBy?: AgencyToRealEstateAgentOrderByWithRelationInput | AgencyToRealEstateAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyToRealEstateAgents.
     */
    cursor?: AgencyToRealEstateAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyToRealEstateAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyToRealEstateAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyToRealEstateAgents.
     */
    distinct?: AgencyToRealEstateAgentScalarFieldEnum | AgencyToRealEstateAgentScalarFieldEnum[]
  }

  /**
   * AgencyToRealEstateAgent findMany
   */
  export type AgencyToRealEstateAgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which AgencyToRealEstateAgents to fetch.
     */
    where?: AgencyToRealEstateAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyToRealEstateAgents to fetch.
     */
    orderBy?: AgencyToRealEstateAgentOrderByWithRelationInput | AgencyToRealEstateAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyToRealEstateAgents.
     */
    cursor?: AgencyToRealEstateAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyToRealEstateAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyToRealEstateAgents.
     */
    skip?: number
    distinct?: AgencyToRealEstateAgentScalarFieldEnum | AgencyToRealEstateAgentScalarFieldEnum[]
  }

  /**
   * AgencyToRealEstateAgent create
   */
  export type AgencyToRealEstateAgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyToRealEstateAgent.
     */
    data: XOR<AgencyToRealEstateAgentCreateInput, AgencyToRealEstateAgentUncheckedCreateInput>
  }

  /**
   * AgencyToRealEstateAgent createMany
   */
  export type AgencyToRealEstateAgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyToRealEstateAgents.
     */
    data: AgencyToRealEstateAgentCreateManyInput | AgencyToRealEstateAgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyToRealEstateAgent update
   */
  export type AgencyToRealEstateAgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyToRealEstateAgent.
     */
    data: XOR<AgencyToRealEstateAgentUpdateInput, AgencyToRealEstateAgentUncheckedUpdateInput>
    /**
     * Choose, which AgencyToRealEstateAgent to update.
     */
    where: AgencyToRealEstateAgentWhereUniqueInput
  }

  /**
   * AgencyToRealEstateAgent updateMany
   */
  export type AgencyToRealEstateAgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyToRealEstateAgents.
     */
    data: XOR<AgencyToRealEstateAgentUpdateManyMutationInput, AgencyToRealEstateAgentUncheckedUpdateManyInput>
    /**
     * Filter which AgencyToRealEstateAgents to update
     */
    where?: AgencyToRealEstateAgentWhereInput
  }

  /**
   * AgencyToRealEstateAgent upsert
   */
  export type AgencyToRealEstateAgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyToRealEstateAgent to update in case it exists.
     */
    where: AgencyToRealEstateAgentWhereUniqueInput
    /**
     * In case the AgencyToRealEstateAgent found by the `where` argument doesn't exist, create a new AgencyToRealEstateAgent with this data.
     */
    create: XOR<AgencyToRealEstateAgentCreateInput, AgencyToRealEstateAgentUncheckedCreateInput>
    /**
     * In case the AgencyToRealEstateAgent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyToRealEstateAgentUpdateInput, AgencyToRealEstateAgentUncheckedUpdateInput>
  }

  /**
   * AgencyToRealEstateAgent delete
   */
  export type AgencyToRealEstateAgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter which AgencyToRealEstateAgent to delete.
     */
    where: AgencyToRealEstateAgentWhereUniqueInput
  }

  /**
   * AgencyToRealEstateAgent deleteMany
   */
  export type AgencyToRealEstateAgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyToRealEstateAgents to delete
     */
    where?: AgencyToRealEstateAgentWhereInput
  }

  /**
   * AgencyToRealEstateAgent without action
   */
  export type AgencyToRealEstateAgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
  }


  /**
   * Model Entity
   */

  export type AggregateEntity = {
    _count: EntityCountAggregateOutputType | null
    _avg: EntityAvgAggregateOutputType | null
    _sum: EntitySumAggregateOutputType | null
    _min: EntityMinAggregateOutputType | null
    _max: EntityMaxAggregateOutputType | null
  }

  export type EntityAvgAggregateOutputType = {
    id: number | null
    common_db_entities_id: number | null
  }

  export type EntitySumAggregateOutputType = {
    id: number | null
    common_db_entities_id: number | null
  }

  export type EntityMinAggregateOutputType = {
    id: number | null
    common_db_entities_id: number | null
    name: string | null
    website: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EntityMaxAggregateOutputType = {
    id: number | null
    common_db_entities_id: number | null
    name: string | null
    website: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EntityCountAggregateOutputType = {
    id: number
    common_db_entities_id: number
    name: number
    website: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type EntityAvgAggregateInputType = {
    id?: true
    common_db_entities_id?: true
  }

  export type EntitySumAggregateInputType = {
    id?: true
    common_db_entities_id?: true
  }

  export type EntityMinAggregateInputType = {
    id?: true
    common_db_entities_id?: true
    name?: true
    website?: true
    created_at?: true
    updated_at?: true
  }

  export type EntityMaxAggregateInputType = {
    id?: true
    common_db_entities_id?: true
    name?: true
    website?: true
    created_at?: true
    updated_at?: true
  }

  export type EntityCountAggregateInputType = {
    id?: true
    common_db_entities_id?: true
    name?: true
    website?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type EntityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entity to aggregate.
     */
    where?: EntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entities to fetch.
     */
    orderBy?: EntityOrderByWithRelationInput | EntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Entities
    **/
    _count?: true | EntityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntityMaxAggregateInputType
  }

  export type GetEntityAggregateType<T extends EntityAggregateArgs> = {
        [P in keyof T & keyof AggregateEntity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntity[P]>
      : GetScalarType<T[P], AggregateEntity[P]>
  }




  export type EntityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityWhereInput
    orderBy?: EntityOrderByWithAggregationInput | EntityOrderByWithAggregationInput[]
    by: EntityScalarFieldEnum[] | EntityScalarFieldEnum
    having?: EntityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntityCountAggregateInputType | true
    _avg?: EntityAvgAggregateInputType
    _sum?: EntitySumAggregateInputType
    _min?: EntityMinAggregateInputType
    _max?: EntityMaxAggregateInputType
  }

  export type EntityGroupByOutputType = {
    id: number
    common_db_entities_id: number
    name: string
    website: string | null
    created_at: Date
    updated_at: Date
    _count: EntityCountAggregateOutputType | null
    _avg: EntityAvgAggregateOutputType | null
    _sum: EntitySumAggregateOutputType | null
    _min: EntityMinAggregateOutputType | null
    _max: EntityMaxAggregateOutputType | null
  }

  type GetEntityGroupByPayload<T extends EntityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntityGroupByOutputType[P]>
            : GetScalarType<T[P], EntityGroupByOutputType[P]>
        }
      >
    >


  export type EntitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    common_db_entities_id?: boolean
    name?: boolean
    website?: boolean
    created_at?: boolean
    updated_at?: boolean
    agency_contracts?: boolean | Entity$agency_contractsArgs<ExtArgs>
    objects?: boolean | Entity$objectsArgs<ExtArgs>
    entity_forbidden_websites?: boolean | Entity$entity_forbidden_websitesArgs<ExtArgs>
    entity_forbidden_brands?: boolean | Entity$entity_forbidden_brandsArgs<ExtArgs>
    _count?: boolean | EntityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entity"]>


  export type EntitySelectScalar = {
    id?: boolean
    common_db_entities_id?: boolean
    name?: boolean
    website?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type EntityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency_contracts?: boolean | Entity$agency_contractsArgs<ExtArgs>
    objects?: boolean | Entity$objectsArgs<ExtArgs>
    entity_forbidden_websites?: boolean | Entity$entity_forbidden_websitesArgs<ExtArgs>
    entity_forbidden_brands?: boolean | Entity$entity_forbidden_brandsArgs<ExtArgs>
    _count?: boolean | EntityCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EntityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Entity"
    objects: {
      agency_contracts: Prisma.$AgencyContractPayload<ExtArgs>[]
      objects: Prisma.$ObjectPayload<ExtArgs>[]
      entity_forbidden_websites: Prisma.$EntityForbiddenWebsitePayload<ExtArgs>[]
      entity_forbidden_brands: Prisma.$EntityForbiddenBrandPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      common_db_entities_id: number
      name: string
      website: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["entity"]>
    composites: {}
  }

  type EntityGetPayload<S extends boolean | null | undefined | EntityDefaultArgs> = $Result.GetResult<Prisma.$EntityPayload, S>

  type EntityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EntityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntityCountAggregateInputType | true
    }

  export interface EntityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Entity'], meta: { name: 'Entity' } }
    /**
     * Find zero or one Entity that matches the filter.
     * @param {EntityFindUniqueArgs} args - Arguments to find a Entity
     * @example
     * // Get one Entity
     * const entity = await prisma.entity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EntityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EntityFindUniqueArgs<ExtArgs>>
    ): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Entity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EntityFindUniqueOrThrowArgs} args - Arguments to find a Entity
     * @example
     * // Get one Entity
     * const entity = await prisma.entity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EntityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Entity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityFindFirstArgs} args - Arguments to find a Entity
     * @example
     * // Get one Entity
     * const entity = await prisma.entity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EntityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityFindFirstArgs<ExtArgs>>
    ): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Entity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityFindFirstOrThrowArgs} args - Arguments to find a Entity
     * @example
     * // Get one Entity
     * const entity = await prisma.entity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EntityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Entities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entities
     * const entities = await prisma.entity.findMany()
     * 
     * // Get first 10 Entities
     * const entities = await prisma.entity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entityWithIdOnly = await prisma.entity.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EntityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Entity.
     * @param {EntityCreateArgs} args - Arguments to create a Entity.
     * @example
     * // Create one Entity
     * const Entity = await prisma.entity.create({
     *   data: {
     *     // ... data to create a Entity
     *   }
     * })
     * 
    **/
    create<T extends EntityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EntityCreateArgs<ExtArgs>>
    ): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Entities.
     * @param {EntityCreateManyArgs} args - Arguments to create many Entities.
     * @example
     * // Create many Entities
     * const entity = await prisma.entity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends EntityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Entity.
     * @param {EntityDeleteArgs} args - Arguments to delete one Entity.
     * @example
     * // Delete one Entity
     * const Entity = await prisma.entity.delete({
     *   where: {
     *     // ... filter to delete one Entity
     *   }
     * })
     * 
    **/
    delete<T extends EntityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EntityDeleteArgs<ExtArgs>>
    ): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Entity.
     * @param {EntityUpdateArgs} args - Arguments to update one Entity.
     * @example
     * // Update one Entity
     * const entity = await prisma.entity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EntityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EntityUpdateArgs<ExtArgs>>
    ): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Entities.
     * @param {EntityDeleteManyArgs} args - Arguments to filter Entities to delete.
     * @example
     * // Delete a few Entities
     * const { count } = await prisma.entity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EntityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entities
     * const entity = await prisma.entity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EntityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EntityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entity.
     * @param {EntityUpsertArgs} args - Arguments to update or create a Entity.
     * @example
     * // Update or create a Entity
     * const entity = await prisma.entity.upsert({
     *   create: {
     *     // ... data to create a Entity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entity we want to update
     *   }
     * })
    **/
    upsert<T extends EntityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EntityUpsertArgs<ExtArgs>>
    ): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityCountArgs} args - Arguments to filter Entities to count.
     * @example
     * // Count the number of Entities
     * const count = await prisma.entity.count({
     *   where: {
     *     // ... the filter for the Entities we want to count
     *   }
     * })
    **/
    count<T extends EntityCountArgs>(
      args?: Subset<T, EntityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntityAggregateArgs>(args: Subset<T, EntityAggregateArgs>): Prisma.PrismaPromise<GetEntityAggregateType<T>>

    /**
     * Group by Entity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntityGroupByArgs['orderBy'] }
        : { orderBy?: EntityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Entity model
   */
  readonly fields: EntityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Entity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    agency_contracts<T extends Entity$agency_contractsArgs<ExtArgs> = {}>(args?: Subset<T, Entity$agency_contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    objects<T extends Entity$objectsArgs<ExtArgs> = {}>(args?: Subset<T, Entity$objectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findMany'> | Null>;

    entity_forbidden_websites<T extends Entity$entity_forbidden_websitesArgs<ExtArgs> = {}>(args?: Subset<T, Entity$entity_forbidden_websitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'findMany'> | Null>;

    entity_forbidden_brands<T extends Entity$entity_forbidden_brandsArgs<ExtArgs> = {}>(args?: Subset<T, Entity$entity_forbidden_brandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Entity model
   */ 
  interface EntityFieldRefs {
    readonly id: FieldRef<"Entity", 'Int'>
    readonly common_db_entities_id: FieldRef<"Entity", 'Int'>
    readonly name: FieldRef<"Entity", 'String'>
    readonly website: FieldRef<"Entity", 'String'>
    readonly created_at: FieldRef<"Entity", 'DateTime'>
    readonly updated_at: FieldRef<"Entity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Entity findUnique
   */
  export type EntityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * Filter, which Entity to fetch.
     */
    where: EntityWhereUniqueInput
  }

  /**
   * Entity findUniqueOrThrow
   */
  export type EntityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * Filter, which Entity to fetch.
     */
    where: EntityWhereUniqueInput
  }

  /**
   * Entity findFirst
   */
  export type EntityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * Filter, which Entity to fetch.
     */
    where?: EntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entities to fetch.
     */
    orderBy?: EntityOrderByWithRelationInput | EntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entities.
     */
    cursor?: EntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entities.
     */
    distinct?: EntityScalarFieldEnum | EntityScalarFieldEnum[]
  }

  /**
   * Entity findFirstOrThrow
   */
  export type EntityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * Filter, which Entity to fetch.
     */
    where?: EntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entities to fetch.
     */
    orderBy?: EntityOrderByWithRelationInput | EntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entities.
     */
    cursor?: EntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entities.
     */
    distinct?: EntityScalarFieldEnum | EntityScalarFieldEnum[]
  }

  /**
   * Entity findMany
   */
  export type EntityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * Filter, which Entities to fetch.
     */
    where?: EntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entities to fetch.
     */
    orderBy?: EntityOrderByWithRelationInput | EntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Entities.
     */
    cursor?: EntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entities.
     */
    skip?: number
    distinct?: EntityScalarFieldEnum | EntityScalarFieldEnum[]
  }

  /**
   * Entity create
   */
  export type EntityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * The data needed to create a Entity.
     */
    data: XOR<EntityCreateInput, EntityUncheckedCreateInput>
  }

  /**
   * Entity createMany
   */
  export type EntityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Entities.
     */
    data: EntityCreateManyInput | EntityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Entity update
   */
  export type EntityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * The data needed to update a Entity.
     */
    data: XOR<EntityUpdateInput, EntityUncheckedUpdateInput>
    /**
     * Choose, which Entity to update.
     */
    where: EntityWhereUniqueInput
  }

  /**
   * Entity updateMany
   */
  export type EntityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Entities.
     */
    data: XOR<EntityUpdateManyMutationInput, EntityUncheckedUpdateManyInput>
    /**
     * Filter which Entities to update
     */
    where?: EntityWhereInput
  }

  /**
   * Entity upsert
   */
  export type EntityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * The filter to search for the Entity to update in case it exists.
     */
    where: EntityWhereUniqueInput
    /**
     * In case the Entity found by the `where` argument doesn't exist, create a new Entity with this data.
     */
    create: XOR<EntityCreateInput, EntityUncheckedCreateInput>
    /**
     * In case the Entity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntityUpdateInput, EntityUncheckedUpdateInput>
  }

  /**
   * Entity delete
   */
  export type EntityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * Filter which Entity to delete.
     */
    where: EntityWhereUniqueInput
  }

  /**
   * Entity deleteMany
   */
  export type EntityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entities to delete
     */
    where?: EntityWhereInput
  }

  /**
   * Entity.agency_contracts
   */
  export type Entity$agency_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    where?: AgencyContractWhereInput
    orderBy?: AgencyContractOrderByWithRelationInput | AgencyContractOrderByWithRelationInput[]
    cursor?: AgencyContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyContractScalarFieldEnum | AgencyContractScalarFieldEnum[]
  }

  /**
   * Entity.objects
   */
  export type Entity$objectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    where?: ObjectWhereInput
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    cursor?: ObjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * Entity.entity_forbidden_websites
   */
  export type Entity$entity_forbidden_websitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    where?: EntityForbiddenWebsiteWhereInput
    orderBy?: EntityForbiddenWebsiteOrderByWithRelationInput | EntityForbiddenWebsiteOrderByWithRelationInput[]
    cursor?: EntityForbiddenWebsiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntityForbiddenWebsiteScalarFieldEnum | EntityForbiddenWebsiteScalarFieldEnum[]
  }

  /**
   * Entity.entity_forbidden_brands
   */
  export type Entity$entity_forbidden_brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    where?: EntityForbiddenBrandWhereInput
    orderBy?: EntityForbiddenBrandOrderByWithRelationInput | EntityForbiddenBrandOrderByWithRelationInput[]
    cursor?: EntityForbiddenBrandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntityForbiddenBrandScalarFieldEnum | EntityForbiddenBrandScalarFieldEnum[]
  }

  /**
   * Entity without action
   */
  export type EntityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
  }


  /**
   * Model EntityForbiddenWebsite
   */

  export type AggregateEntityForbiddenWebsite = {
    _count: EntityForbiddenWebsiteCountAggregateOutputType | null
    _avg: EntityForbiddenWebsiteAvgAggregateOutputType | null
    _sum: EntityForbiddenWebsiteSumAggregateOutputType | null
    _min: EntityForbiddenWebsiteMinAggregateOutputType | null
    _max: EntityForbiddenWebsiteMaxAggregateOutputType | null
  }

  export type EntityForbiddenWebsiteAvgAggregateOutputType = {
    id: number | null
    entity_id: number | null
  }

  export type EntityForbiddenWebsiteSumAggregateOutputType = {
    id: number | null
    entity_id: number | null
  }

  export type EntityForbiddenWebsiteMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    entity_id: number | null
  }

  export type EntityForbiddenWebsiteMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    entity_id: number | null
  }

  export type EntityForbiddenWebsiteCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    entity_id: number
    _all: number
  }


  export type EntityForbiddenWebsiteAvgAggregateInputType = {
    id?: true
    entity_id?: true
  }

  export type EntityForbiddenWebsiteSumAggregateInputType = {
    id?: true
    entity_id?: true
  }

  export type EntityForbiddenWebsiteMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    entity_id?: true
  }

  export type EntityForbiddenWebsiteMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    entity_id?: true
  }

  export type EntityForbiddenWebsiteCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    entity_id?: true
    _all?: true
  }

  export type EntityForbiddenWebsiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntityForbiddenWebsite to aggregate.
     */
    where?: EntityForbiddenWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityForbiddenWebsites to fetch.
     */
    orderBy?: EntityForbiddenWebsiteOrderByWithRelationInput | EntityForbiddenWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntityForbiddenWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityForbiddenWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityForbiddenWebsites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EntityForbiddenWebsites
    **/
    _count?: true | EntityForbiddenWebsiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntityForbiddenWebsiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntityForbiddenWebsiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntityForbiddenWebsiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntityForbiddenWebsiteMaxAggregateInputType
  }

  export type GetEntityForbiddenWebsiteAggregateType<T extends EntityForbiddenWebsiteAggregateArgs> = {
        [P in keyof T & keyof AggregateEntityForbiddenWebsite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntityForbiddenWebsite[P]>
      : GetScalarType<T[P], AggregateEntityForbiddenWebsite[P]>
  }




  export type EntityForbiddenWebsiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityForbiddenWebsiteWhereInput
    orderBy?: EntityForbiddenWebsiteOrderByWithAggregationInput | EntityForbiddenWebsiteOrderByWithAggregationInput[]
    by: EntityForbiddenWebsiteScalarFieldEnum[] | EntityForbiddenWebsiteScalarFieldEnum
    having?: EntityForbiddenWebsiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntityForbiddenWebsiteCountAggregateInputType | true
    _avg?: EntityForbiddenWebsiteAvgAggregateInputType
    _sum?: EntityForbiddenWebsiteSumAggregateInputType
    _min?: EntityForbiddenWebsiteMinAggregateInputType
    _max?: EntityForbiddenWebsiteMaxAggregateInputType
  }

  export type EntityForbiddenWebsiteGroupByOutputType = {
    id: number
    name: string
    created_at: Date
    updated_at: Date
    entity_id: number
    _count: EntityForbiddenWebsiteCountAggregateOutputType | null
    _avg: EntityForbiddenWebsiteAvgAggregateOutputType | null
    _sum: EntityForbiddenWebsiteSumAggregateOutputType | null
    _min: EntityForbiddenWebsiteMinAggregateOutputType | null
    _max: EntityForbiddenWebsiteMaxAggregateOutputType | null
  }

  type GetEntityForbiddenWebsiteGroupByPayload<T extends EntityForbiddenWebsiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntityForbiddenWebsiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntityForbiddenWebsiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntityForbiddenWebsiteGroupByOutputType[P]>
            : GetScalarType<T[P], EntityForbiddenWebsiteGroupByOutputType[P]>
        }
      >
    >


  export type EntityForbiddenWebsiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    entity_id?: boolean
    entity?: boolean | EntityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entityForbiddenWebsite"]>


  export type EntityForbiddenWebsiteSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    entity_id?: boolean
  }

  export type EntityForbiddenWebsiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entity?: boolean | EntityDefaultArgs<ExtArgs>
  }

  export type $EntityForbiddenWebsitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EntityForbiddenWebsite"
    objects: {
      entity: Prisma.$EntityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      created_at: Date
      updated_at: Date
      entity_id: number
    }, ExtArgs["result"]["entityForbiddenWebsite"]>
    composites: {}
  }

  type EntityForbiddenWebsiteGetPayload<S extends boolean | null | undefined | EntityForbiddenWebsiteDefaultArgs> = $Result.GetResult<Prisma.$EntityForbiddenWebsitePayload, S>

  type EntityForbiddenWebsiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EntityForbiddenWebsiteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntityForbiddenWebsiteCountAggregateInputType | true
    }

  export interface EntityForbiddenWebsiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EntityForbiddenWebsite'], meta: { name: 'EntityForbiddenWebsite' } }
    /**
     * Find zero or one EntityForbiddenWebsite that matches the filter.
     * @param {EntityForbiddenWebsiteFindUniqueArgs} args - Arguments to find a EntityForbiddenWebsite
     * @example
     * // Get one EntityForbiddenWebsite
     * const entityForbiddenWebsite = await prisma.entityForbiddenWebsite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EntityForbiddenWebsiteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenWebsiteFindUniqueArgs<ExtArgs>>
    ): Prisma__EntityForbiddenWebsiteClient<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EntityForbiddenWebsite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EntityForbiddenWebsiteFindUniqueOrThrowArgs} args - Arguments to find a EntityForbiddenWebsite
     * @example
     * // Get one EntityForbiddenWebsite
     * const entityForbiddenWebsite = await prisma.entityForbiddenWebsite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EntityForbiddenWebsiteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenWebsiteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EntityForbiddenWebsiteClient<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EntityForbiddenWebsite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenWebsiteFindFirstArgs} args - Arguments to find a EntityForbiddenWebsite
     * @example
     * // Get one EntityForbiddenWebsite
     * const entityForbiddenWebsite = await prisma.entityForbiddenWebsite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EntityForbiddenWebsiteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenWebsiteFindFirstArgs<ExtArgs>>
    ): Prisma__EntityForbiddenWebsiteClient<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EntityForbiddenWebsite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenWebsiteFindFirstOrThrowArgs} args - Arguments to find a EntityForbiddenWebsite
     * @example
     * // Get one EntityForbiddenWebsite
     * const entityForbiddenWebsite = await prisma.entityForbiddenWebsite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EntityForbiddenWebsiteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenWebsiteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EntityForbiddenWebsiteClient<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EntityForbiddenWebsites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenWebsiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EntityForbiddenWebsites
     * const entityForbiddenWebsites = await prisma.entityForbiddenWebsite.findMany()
     * 
     * // Get first 10 EntityForbiddenWebsites
     * const entityForbiddenWebsites = await prisma.entityForbiddenWebsite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entityForbiddenWebsiteWithIdOnly = await prisma.entityForbiddenWebsite.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EntityForbiddenWebsiteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenWebsiteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EntityForbiddenWebsite.
     * @param {EntityForbiddenWebsiteCreateArgs} args - Arguments to create a EntityForbiddenWebsite.
     * @example
     * // Create one EntityForbiddenWebsite
     * const EntityForbiddenWebsite = await prisma.entityForbiddenWebsite.create({
     *   data: {
     *     // ... data to create a EntityForbiddenWebsite
     *   }
     * })
     * 
    **/
    create<T extends EntityForbiddenWebsiteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenWebsiteCreateArgs<ExtArgs>>
    ): Prisma__EntityForbiddenWebsiteClient<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EntityForbiddenWebsites.
     * @param {EntityForbiddenWebsiteCreateManyArgs} args - Arguments to create many EntityForbiddenWebsites.
     * @example
     * // Create many EntityForbiddenWebsites
     * const entityForbiddenWebsite = await prisma.entityForbiddenWebsite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends EntityForbiddenWebsiteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenWebsiteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EntityForbiddenWebsite.
     * @param {EntityForbiddenWebsiteDeleteArgs} args - Arguments to delete one EntityForbiddenWebsite.
     * @example
     * // Delete one EntityForbiddenWebsite
     * const EntityForbiddenWebsite = await prisma.entityForbiddenWebsite.delete({
     *   where: {
     *     // ... filter to delete one EntityForbiddenWebsite
     *   }
     * })
     * 
    **/
    delete<T extends EntityForbiddenWebsiteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenWebsiteDeleteArgs<ExtArgs>>
    ): Prisma__EntityForbiddenWebsiteClient<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EntityForbiddenWebsite.
     * @param {EntityForbiddenWebsiteUpdateArgs} args - Arguments to update one EntityForbiddenWebsite.
     * @example
     * // Update one EntityForbiddenWebsite
     * const entityForbiddenWebsite = await prisma.entityForbiddenWebsite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EntityForbiddenWebsiteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenWebsiteUpdateArgs<ExtArgs>>
    ): Prisma__EntityForbiddenWebsiteClient<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EntityForbiddenWebsites.
     * @param {EntityForbiddenWebsiteDeleteManyArgs} args - Arguments to filter EntityForbiddenWebsites to delete.
     * @example
     * // Delete a few EntityForbiddenWebsites
     * const { count } = await prisma.entityForbiddenWebsite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EntityForbiddenWebsiteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenWebsiteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EntityForbiddenWebsites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenWebsiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EntityForbiddenWebsites
     * const entityForbiddenWebsite = await prisma.entityForbiddenWebsite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EntityForbiddenWebsiteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenWebsiteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EntityForbiddenWebsite.
     * @param {EntityForbiddenWebsiteUpsertArgs} args - Arguments to update or create a EntityForbiddenWebsite.
     * @example
     * // Update or create a EntityForbiddenWebsite
     * const entityForbiddenWebsite = await prisma.entityForbiddenWebsite.upsert({
     *   create: {
     *     // ... data to create a EntityForbiddenWebsite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EntityForbiddenWebsite we want to update
     *   }
     * })
    **/
    upsert<T extends EntityForbiddenWebsiteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenWebsiteUpsertArgs<ExtArgs>>
    ): Prisma__EntityForbiddenWebsiteClient<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EntityForbiddenWebsites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenWebsiteCountArgs} args - Arguments to filter EntityForbiddenWebsites to count.
     * @example
     * // Count the number of EntityForbiddenWebsites
     * const count = await prisma.entityForbiddenWebsite.count({
     *   where: {
     *     // ... the filter for the EntityForbiddenWebsites we want to count
     *   }
     * })
    **/
    count<T extends EntityForbiddenWebsiteCountArgs>(
      args?: Subset<T, EntityForbiddenWebsiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntityForbiddenWebsiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EntityForbiddenWebsite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenWebsiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntityForbiddenWebsiteAggregateArgs>(args: Subset<T, EntityForbiddenWebsiteAggregateArgs>): Prisma.PrismaPromise<GetEntityForbiddenWebsiteAggregateType<T>>

    /**
     * Group by EntityForbiddenWebsite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenWebsiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntityForbiddenWebsiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntityForbiddenWebsiteGroupByArgs['orderBy'] }
        : { orderBy?: EntityForbiddenWebsiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntityForbiddenWebsiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityForbiddenWebsiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EntityForbiddenWebsite model
   */
  readonly fields: EntityForbiddenWebsiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EntityForbiddenWebsite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntityForbiddenWebsiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entity<T extends EntityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntityDefaultArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EntityForbiddenWebsite model
   */ 
  interface EntityForbiddenWebsiteFieldRefs {
    readonly id: FieldRef<"EntityForbiddenWebsite", 'Int'>
    readonly name: FieldRef<"EntityForbiddenWebsite", 'String'>
    readonly created_at: FieldRef<"EntityForbiddenWebsite", 'DateTime'>
    readonly updated_at: FieldRef<"EntityForbiddenWebsite", 'DateTime'>
    readonly entity_id: FieldRef<"EntityForbiddenWebsite", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EntityForbiddenWebsite findUnique
   */
  export type EntityForbiddenWebsiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenWebsite to fetch.
     */
    where: EntityForbiddenWebsiteWhereUniqueInput
  }

  /**
   * EntityForbiddenWebsite findUniqueOrThrow
   */
  export type EntityForbiddenWebsiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenWebsite to fetch.
     */
    where: EntityForbiddenWebsiteWhereUniqueInput
  }

  /**
   * EntityForbiddenWebsite findFirst
   */
  export type EntityForbiddenWebsiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenWebsite to fetch.
     */
    where?: EntityForbiddenWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityForbiddenWebsites to fetch.
     */
    orderBy?: EntityForbiddenWebsiteOrderByWithRelationInput | EntityForbiddenWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityForbiddenWebsites.
     */
    cursor?: EntityForbiddenWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityForbiddenWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityForbiddenWebsites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityForbiddenWebsites.
     */
    distinct?: EntityForbiddenWebsiteScalarFieldEnum | EntityForbiddenWebsiteScalarFieldEnum[]
  }

  /**
   * EntityForbiddenWebsite findFirstOrThrow
   */
  export type EntityForbiddenWebsiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenWebsite to fetch.
     */
    where?: EntityForbiddenWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityForbiddenWebsites to fetch.
     */
    orderBy?: EntityForbiddenWebsiteOrderByWithRelationInput | EntityForbiddenWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityForbiddenWebsites.
     */
    cursor?: EntityForbiddenWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityForbiddenWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityForbiddenWebsites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityForbiddenWebsites.
     */
    distinct?: EntityForbiddenWebsiteScalarFieldEnum | EntityForbiddenWebsiteScalarFieldEnum[]
  }

  /**
   * EntityForbiddenWebsite findMany
   */
  export type EntityForbiddenWebsiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenWebsites to fetch.
     */
    where?: EntityForbiddenWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityForbiddenWebsites to fetch.
     */
    orderBy?: EntityForbiddenWebsiteOrderByWithRelationInput | EntityForbiddenWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EntityForbiddenWebsites.
     */
    cursor?: EntityForbiddenWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityForbiddenWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityForbiddenWebsites.
     */
    skip?: number
    distinct?: EntityForbiddenWebsiteScalarFieldEnum | EntityForbiddenWebsiteScalarFieldEnum[]
  }

  /**
   * EntityForbiddenWebsite create
   */
  export type EntityForbiddenWebsiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    /**
     * The data needed to create a EntityForbiddenWebsite.
     */
    data: XOR<EntityForbiddenWebsiteCreateInput, EntityForbiddenWebsiteUncheckedCreateInput>
  }

  /**
   * EntityForbiddenWebsite createMany
   */
  export type EntityForbiddenWebsiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EntityForbiddenWebsites.
     */
    data: EntityForbiddenWebsiteCreateManyInput | EntityForbiddenWebsiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EntityForbiddenWebsite update
   */
  export type EntityForbiddenWebsiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    /**
     * The data needed to update a EntityForbiddenWebsite.
     */
    data: XOR<EntityForbiddenWebsiteUpdateInput, EntityForbiddenWebsiteUncheckedUpdateInput>
    /**
     * Choose, which EntityForbiddenWebsite to update.
     */
    where: EntityForbiddenWebsiteWhereUniqueInput
  }

  /**
   * EntityForbiddenWebsite updateMany
   */
  export type EntityForbiddenWebsiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EntityForbiddenWebsites.
     */
    data: XOR<EntityForbiddenWebsiteUpdateManyMutationInput, EntityForbiddenWebsiteUncheckedUpdateManyInput>
    /**
     * Filter which EntityForbiddenWebsites to update
     */
    where?: EntityForbiddenWebsiteWhereInput
  }

  /**
   * EntityForbiddenWebsite upsert
   */
  export type EntityForbiddenWebsiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    /**
     * The filter to search for the EntityForbiddenWebsite to update in case it exists.
     */
    where: EntityForbiddenWebsiteWhereUniqueInput
    /**
     * In case the EntityForbiddenWebsite found by the `where` argument doesn't exist, create a new EntityForbiddenWebsite with this data.
     */
    create: XOR<EntityForbiddenWebsiteCreateInput, EntityForbiddenWebsiteUncheckedCreateInput>
    /**
     * In case the EntityForbiddenWebsite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntityForbiddenWebsiteUpdateInput, EntityForbiddenWebsiteUncheckedUpdateInput>
  }

  /**
   * EntityForbiddenWebsite delete
   */
  export type EntityForbiddenWebsiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    /**
     * Filter which EntityForbiddenWebsite to delete.
     */
    where: EntityForbiddenWebsiteWhereUniqueInput
  }

  /**
   * EntityForbiddenWebsite deleteMany
   */
  export type EntityForbiddenWebsiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntityForbiddenWebsites to delete
     */
    where?: EntityForbiddenWebsiteWhereInput
  }

  /**
   * EntityForbiddenWebsite without action
   */
  export type EntityForbiddenWebsiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
  }


  /**
   * Model EntityForbiddenBrand
   */

  export type AggregateEntityForbiddenBrand = {
    _count: EntityForbiddenBrandCountAggregateOutputType | null
    _avg: EntityForbiddenBrandAvgAggregateOutputType | null
    _sum: EntityForbiddenBrandSumAggregateOutputType | null
    _min: EntityForbiddenBrandMinAggregateOutputType | null
    _max: EntityForbiddenBrandMaxAggregateOutputType | null
  }

  export type EntityForbiddenBrandAvgAggregateOutputType = {
    id: number | null
    entity_id: number | null
  }

  export type EntityForbiddenBrandSumAggregateOutputType = {
    id: number | null
    entity_id: number | null
  }

  export type EntityForbiddenBrandMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    entity_id: number | null
  }

  export type EntityForbiddenBrandMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    entity_id: number | null
  }

  export type EntityForbiddenBrandCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    entity_id: number
    _all: number
  }


  export type EntityForbiddenBrandAvgAggregateInputType = {
    id?: true
    entity_id?: true
  }

  export type EntityForbiddenBrandSumAggregateInputType = {
    id?: true
    entity_id?: true
  }

  export type EntityForbiddenBrandMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    entity_id?: true
  }

  export type EntityForbiddenBrandMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    entity_id?: true
  }

  export type EntityForbiddenBrandCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    entity_id?: true
    _all?: true
  }

  export type EntityForbiddenBrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntityForbiddenBrand to aggregate.
     */
    where?: EntityForbiddenBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityForbiddenBrands to fetch.
     */
    orderBy?: EntityForbiddenBrandOrderByWithRelationInput | EntityForbiddenBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntityForbiddenBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityForbiddenBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityForbiddenBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EntityForbiddenBrands
    **/
    _count?: true | EntityForbiddenBrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntityForbiddenBrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntityForbiddenBrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntityForbiddenBrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntityForbiddenBrandMaxAggregateInputType
  }

  export type GetEntityForbiddenBrandAggregateType<T extends EntityForbiddenBrandAggregateArgs> = {
        [P in keyof T & keyof AggregateEntityForbiddenBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntityForbiddenBrand[P]>
      : GetScalarType<T[P], AggregateEntityForbiddenBrand[P]>
  }




  export type EntityForbiddenBrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityForbiddenBrandWhereInput
    orderBy?: EntityForbiddenBrandOrderByWithAggregationInput | EntityForbiddenBrandOrderByWithAggregationInput[]
    by: EntityForbiddenBrandScalarFieldEnum[] | EntityForbiddenBrandScalarFieldEnum
    having?: EntityForbiddenBrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntityForbiddenBrandCountAggregateInputType | true
    _avg?: EntityForbiddenBrandAvgAggregateInputType
    _sum?: EntityForbiddenBrandSumAggregateInputType
    _min?: EntityForbiddenBrandMinAggregateInputType
    _max?: EntityForbiddenBrandMaxAggregateInputType
  }

  export type EntityForbiddenBrandGroupByOutputType = {
    id: number
    name: string
    created_at: Date
    updated_at: Date
    entity_id: number
    _count: EntityForbiddenBrandCountAggregateOutputType | null
    _avg: EntityForbiddenBrandAvgAggregateOutputType | null
    _sum: EntityForbiddenBrandSumAggregateOutputType | null
    _min: EntityForbiddenBrandMinAggregateOutputType | null
    _max: EntityForbiddenBrandMaxAggregateOutputType | null
  }

  type GetEntityForbiddenBrandGroupByPayload<T extends EntityForbiddenBrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntityForbiddenBrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntityForbiddenBrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntityForbiddenBrandGroupByOutputType[P]>
            : GetScalarType<T[P], EntityForbiddenBrandGroupByOutputType[P]>
        }
      >
    >


  export type EntityForbiddenBrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    entity_id?: boolean
    entity?: boolean | EntityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entityForbiddenBrand"]>


  export type EntityForbiddenBrandSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    entity_id?: boolean
  }

  export type EntityForbiddenBrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entity?: boolean | EntityDefaultArgs<ExtArgs>
  }

  export type $EntityForbiddenBrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EntityForbiddenBrand"
    objects: {
      entity: Prisma.$EntityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      created_at: Date
      updated_at: Date
      entity_id: number
    }, ExtArgs["result"]["entityForbiddenBrand"]>
    composites: {}
  }

  type EntityForbiddenBrandGetPayload<S extends boolean | null | undefined | EntityForbiddenBrandDefaultArgs> = $Result.GetResult<Prisma.$EntityForbiddenBrandPayload, S>

  type EntityForbiddenBrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EntityForbiddenBrandFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntityForbiddenBrandCountAggregateInputType | true
    }

  export interface EntityForbiddenBrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EntityForbiddenBrand'], meta: { name: 'EntityForbiddenBrand' } }
    /**
     * Find zero or one EntityForbiddenBrand that matches the filter.
     * @param {EntityForbiddenBrandFindUniqueArgs} args - Arguments to find a EntityForbiddenBrand
     * @example
     * // Get one EntityForbiddenBrand
     * const entityForbiddenBrand = await prisma.entityForbiddenBrand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EntityForbiddenBrandFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenBrandFindUniqueArgs<ExtArgs>>
    ): Prisma__EntityForbiddenBrandClient<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EntityForbiddenBrand that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EntityForbiddenBrandFindUniqueOrThrowArgs} args - Arguments to find a EntityForbiddenBrand
     * @example
     * // Get one EntityForbiddenBrand
     * const entityForbiddenBrand = await prisma.entityForbiddenBrand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EntityForbiddenBrandFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenBrandFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EntityForbiddenBrandClient<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EntityForbiddenBrand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenBrandFindFirstArgs} args - Arguments to find a EntityForbiddenBrand
     * @example
     * // Get one EntityForbiddenBrand
     * const entityForbiddenBrand = await prisma.entityForbiddenBrand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EntityForbiddenBrandFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenBrandFindFirstArgs<ExtArgs>>
    ): Prisma__EntityForbiddenBrandClient<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EntityForbiddenBrand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenBrandFindFirstOrThrowArgs} args - Arguments to find a EntityForbiddenBrand
     * @example
     * // Get one EntityForbiddenBrand
     * const entityForbiddenBrand = await prisma.entityForbiddenBrand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EntityForbiddenBrandFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenBrandFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EntityForbiddenBrandClient<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EntityForbiddenBrands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenBrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EntityForbiddenBrands
     * const entityForbiddenBrands = await prisma.entityForbiddenBrand.findMany()
     * 
     * // Get first 10 EntityForbiddenBrands
     * const entityForbiddenBrands = await prisma.entityForbiddenBrand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entityForbiddenBrandWithIdOnly = await prisma.entityForbiddenBrand.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EntityForbiddenBrandFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenBrandFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EntityForbiddenBrand.
     * @param {EntityForbiddenBrandCreateArgs} args - Arguments to create a EntityForbiddenBrand.
     * @example
     * // Create one EntityForbiddenBrand
     * const EntityForbiddenBrand = await prisma.entityForbiddenBrand.create({
     *   data: {
     *     // ... data to create a EntityForbiddenBrand
     *   }
     * })
     * 
    **/
    create<T extends EntityForbiddenBrandCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenBrandCreateArgs<ExtArgs>>
    ): Prisma__EntityForbiddenBrandClient<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EntityForbiddenBrands.
     * @param {EntityForbiddenBrandCreateManyArgs} args - Arguments to create many EntityForbiddenBrands.
     * @example
     * // Create many EntityForbiddenBrands
     * const entityForbiddenBrand = await prisma.entityForbiddenBrand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends EntityForbiddenBrandCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenBrandCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EntityForbiddenBrand.
     * @param {EntityForbiddenBrandDeleteArgs} args - Arguments to delete one EntityForbiddenBrand.
     * @example
     * // Delete one EntityForbiddenBrand
     * const EntityForbiddenBrand = await prisma.entityForbiddenBrand.delete({
     *   where: {
     *     // ... filter to delete one EntityForbiddenBrand
     *   }
     * })
     * 
    **/
    delete<T extends EntityForbiddenBrandDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenBrandDeleteArgs<ExtArgs>>
    ): Prisma__EntityForbiddenBrandClient<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EntityForbiddenBrand.
     * @param {EntityForbiddenBrandUpdateArgs} args - Arguments to update one EntityForbiddenBrand.
     * @example
     * // Update one EntityForbiddenBrand
     * const entityForbiddenBrand = await prisma.entityForbiddenBrand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EntityForbiddenBrandUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenBrandUpdateArgs<ExtArgs>>
    ): Prisma__EntityForbiddenBrandClient<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EntityForbiddenBrands.
     * @param {EntityForbiddenBrandDeleteManyArgs} args - Arguments to filter EntityForbiddenBrands to delete.
     * @example
     * // Delete a few EntityForbiddenBrands
     * const { count } = await prisma.entityForbiddenBrand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EntityForbiddenBrandDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenBrandDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EntityForbiddenBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenBrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EntityForbiddenBrands
     * const entityForbiddenBrand = await prisma.entityForbiddenBrand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EntityForbiddenBrandUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenBrandUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EntityForbiddenBrand.
     * @param {EntityForbiddenBrandUpsertArgs} args - Arguments to update or create a EntityForbiddenBrand.
     * @example
     * // Update or create a EntityForbiddenBrand
     * const entityForbiddenBrand = await prisma.entityForbiddenBrand.upsert({
     *   create: {
     *     // ... data to create a EntityForbiddenBrand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EntityForbiddenBrand we want to update
     *   }
     * })
    **/
    upsert<T extends EntityForbiddenBrandUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenBrandUpsertArgs<ExtArgs>>
    ): Prisma__EntityForbiddenBrandClient<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EntityForbiddenBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenBrandCountArgs} args - Arguments to filter EntityForbiddenBrands to count.
     * @example
     * // Count the number of EntityForbiddenBrands
     * const count = await prisma.entityForbiddenBrand.count({
     *   where: {
     *     // ... the filter for the EntityForbiddenBrands we want to count
     *   }
     * })
    **/
    count<T extends EntityForbiddenBrandCountArgs>(
      args?: Subset<T, EntityForbiddenBrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntityForbiddenBrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EntityForbiddenBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenBrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntityForbiddenBrandAggregateArgs>(args: Subset<T, EntityForbiddenBrandAggregateArgs>): Prisma.PrismaPromise<GetEntityForbiddenBrandAggregateType<T>>

    /**
     * Group by EntityForbiddenBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenBrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntityForbiddenBrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntityForbiddenBrandGroupByArgs['orderBy'] }
        : { orderBy?: EntityForbiddenBrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntityForbiddenBrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityForbiddenBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EntityForbiddenBrand model
   */
  readonly fields: EntityForbiddenBrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EntityForbiddenBrand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntityForbiddenBrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entity<T extends EntityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntityDefaultArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EntityForbiddenBrand model
   */ 
  interface EntityForbiddenBrandFieldRefs {
    readonly id: FieldRef<"EntityForbiddenBrand", 'Int'>
    readonly name: FieldRef<"EntityForbiddenBrand", 'String'>
    readonly created_at: FieldRef<"EntityForbiddenBrand", 'DateTime'>
    readonly updated_at: FieldRef<"EntityForbiddenBrand", 'DateTime'>
    readonly entity_id: FieldRef<"EntityForbiddenBrand", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EntityForbiddenBrand findUnique
   */
  export type EntityForbiddenBrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenBrand to fetch.
     */
    where: EntityForbiddenBrandWhereUniqueInput
  }

  /**
   * EntityForbiddenBrand findUniqueOrThrow
   */
  export type EntityForbiddenBrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenBrand to fetch.
     */
    where: EntityForbiddenBrandWhereUniqueInput
  }

  /**
   * EntityForbiddenBrand findFirst
   */
  export type EntityForbiddenBrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenBrand to fetch.
     */
    where?: EntityForbiddenBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityForbiddenBrands to fetch.
     */
    orderBy?: EntityForbiddenBrandOrderByWithRelationInput | EntityForbiddenBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityForbiddenBrands.
     */
    cursor?: EntityForbiddenBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityForbiddenBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityForbiddenBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityForbiddenBrands.
     */
    distinct?: EntityForbiddenBrandScalarFieldEnum | EntityForbiddenBrandScalarFieldEnum[]
  }

  /**
   * EntityForbiddenBrand findFirstOrThrow
   */
  export type EntityForbiddenBrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenBrand to fetch.
     */
    where?: EntityForbiddenBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityForbiddenBrands to fetch.
     */
    orderBy?: EntityForbiddenBrandOrderByWithRelationInput | EntityForbiddenBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityForbiddenBrands.
     */
    cursor?: EntityForbiddenBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityForbiddenBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityForbiddenBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityForbiddenBrands.
     */
    distinct?: EntityForbiddenBrandScalarFieldEnum | EntityForbiddenBrandScalarFieldEnum[]
  }

  /**
   * EntityForbiddenBrand findMany
   */
  export type EntityForbiddenBrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenBrands to fetch.
     */
    where?: EntityForbiddenBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityForbiddenBrands to fetch.
     */
    orderBy?: EntityForbiddenBrandOrderByWithRelationInput | EntityForbiddenBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EntityForbiddenBrands.
     */
    cursor?: EntityForbiddenBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityForbiddenBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityForbiddenBrands.
     */
    skip?: number
    distinct?: EntityForbiddenBrandScalarFieldEnum | EntityForbiddenBrandScalarFieldEnum[]
  }

  /**
   * EntityForbiddenBrand create
   */
  export type EntityForbiddenBrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    /**
     * The data needed to create a EntityForbiddenBrand.
     */
    data: XOR<EntityForbiddenBrandCreateInput, EntityForbiddenBrandUncheckedCreateInput>
  }

  /**
   * EntityForbiddenBrand createMany
   */
  export type EntityForbiddenBrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EntityForbiddenBrands.
     */
    data: EntityForbiddenBrandCreateManyInput | EntityForbiddenBrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EntityForbiddenBrand update
   */
  export type EntityForbiddenBrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    /**
     * The data needed to update a EntityForbiddenBrand.
     */
    data: XOR<EntityForbiddenBrandUpdateInput, EntityForbiddenBrandUncheckedUpdateInput>
    /**
     * Choose, which EntityForbiddenBrand to update.
     */
    where: EntityForbiddenBrandWhereUniqueInput
  }

  /**
   * EntityForbiddenBrand updateMany
   */
  export type EntityForbiddenBrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EntityForbiddenBrands.
     */
    data: XOR<EntityForbiddenBrandUpdateManyMutationInput, EntityForbiddenBrandUncheckedUpdateManyInput>
    /**
     * Filter which EntityForbiddenBrands to update
     */
    where?: EntityForbiddenBrandWhereInput
  }

  /**
   * EntityForbiddenBrand upsert
   */
  export type EntityForbiddenBrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    /**
     * The filter to search for the EntityForbiddenBrand to update in case it exists.
     */
    where: EntityForbiddenBrandWhereUniqueInput
    /**
     * In case the EntityForbiddenBrand found by the `where` argument doesn't exist, create a new EntityForbiddenBrand with this data.
     */
    create: XOR<EntityForbiddenBrandCreateInput, EntityForbiddenBrandUncheckedCreateInput>
    /**
     * In case the EntityForbiddenBrand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntityForbiddenBrandUpdateInput, EntityForbiddenBrandUncheckedUpdateInput>
  }

  /**
   * EntityForbiddenBrand delete
   */
  export type EntityForbiddenBrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    /**
     * Filter which EntityForbiddenBrand to delete.
     */
    where: EntityForbiddenBrandWhereUniqueInput
  }

  /**
   * EntityForbiddenBrand deleteMany
   */
  export type EntityForbiddenBrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntityForbiddenBrands to delete
     */
    where?: EntityForbiddenBrandWhereInput
  }

  /**
   * EntityForbiddenBrand without action
   */
  export type EntityForbiddenBrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
  }


  /**
   * Model Bank
   */

  export type AggregateBank = {
    _count: BankCountAggregateOutputType | null
    _avg: BankAvgAggregateOutputType | null
    _sum: BankSumAggregateOutputType | null
    _min: BankMinAggregateOutputType | null
    _max: BankMaxAggregateOutputType | null
  }

  export type BankAvgAggregateOutputType = {
    id: number | null
  }

  export type BankSumAggregateOutputType = {
    id: number | null
  }

  export type BankMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BankMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BankCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BankAvgAggregateInputType = {
    id?: true
  }

  export type BankSumAggregateInputType = {
    id?: true
  }

  export type BankMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type BankMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type BankCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BankAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bank to aggregate.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: BankOrderByWithRelationInput | BankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banks
    **/
    _count?: true | BankCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankMaxAggregateInputType
  }

  export type GetBankAggregateType<T extends BankAggregateArgs> = {
        [P in keyof T & keyof AggregateBank]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBank[P]>
      : GetScalarType<T[P], AggregateBank[P]>
  }




  export type BankGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankWhereInput
    orderBy?: BankOrderByWithAggregationInput | BankOrderByWithAggregationInput[]
    by: BankScalarFieldEnum[] | BankScalarFieldEnum
    having?: BankScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankCountAggregateInputType | true
    _avg?: BankAvgAggregateInputType
    _sum?: BankSumAggregateInputType
    _min?: BankMinAggregateInputType
    _max?: BankMaxAggregateInputType
  }

  export type BankGroupByOutputType = {
    id: number
    name: string
    created_at: Date
    updated_at: Date
    _count: BankCountAggregateOutputType | null
    _avg: BankAvgAggregateOutputType | null
    _sum: BankSumAggregateOutputType | null
    _min: BankMinAggregateOutputType | null
    _max: BankMaxAggregateOutputType | null
  }

  type GetBankGroupByPayload<T extends BankGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankGroupByOutputType[P]>
            : GetScalarType<T[P], BankGroupByOutputType[P]>
        }
      >
    >


  export type BankSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_contracts?: boolean | Bank$client_contractsArgs<ExtArgs>
    _count?: boolean | BankCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bank"]>


  export type BankSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type BankInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_contracts?: boolean | Bank$client_contractsArgs<ExtArgs>
    _count?: boolean | BankCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BankPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bank"
    objects: {
      client_contracts: Prisma.$ClientContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["bank"]>
    composites: {}
  }

  type BankGetPayload<S extends boolean | null | undefined | BankDefaultArgs> = $Result.GetResult<Prisma.$BankPayload, S>

  type BankCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BankFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BankCountAggregateInputType | true
    }

  export interface BankDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bank'], meta: { name: 'Bank' } }
    /**
     * Find zero or one Bank that matches the filter.
     * @param {BankFindUniqueArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BankFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BankFindUniqueArgs<ExtArgs>>
    ): Prisma__BankClient<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bank that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BankFindUniqueOrThrowArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BankFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BankClient<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bank that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFindFirstArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BankFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFindFirstArgs<ExtArgs>>
    ): Prisma__BankClient<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bank that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFindFirstOrThrowArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BankFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BankClient<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Banks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banks
     * const banks = await prisma.bank.findMany()
     * 
     * // Get first 10 Banks
     * const banks = await prisma.bank.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankWithIdOnly = await prisma.bank.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BankFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bank.
     * @param {BankCreateArgs} args - Arguments to create a Bank.
     * @example
     * // Create one Bank
     * const Bank = await prisma.bank.create({
     *   data: {
     *     // ... data to create a Bank
     *   }
     * })
     * 
    **/
    create<T extends BankCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BankCreateArgs<ExtArgs>>
    ): Prisma__BankClient<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Banks.
     * @param {BankCreateManyArgs} args - Arguments to create many Banks.
     * @example
     * // Create many Banks
     * const bank = await prisma.bank.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends BankCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bank.
     * @param {BankDeleteArgs} args - Arguments to delete one Bank.
     * @example
     * // Delete one Bank
     * const Bank = await prisma.bank.delete({
     *   where: {
     *     // ... filter to delete one Bank
     *   }
     * })
     * 
    **/
    delete<T extends BankDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BankDeleteArgs<ExtArgs>>
    ): Prisma__BankClient<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bank.
     * @param {BankUpdateArgs} args - Arguments to update one Bank.
     * @example
     * // Update one Bank
     * const bank = await prisma.bank.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BankUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BankUpdateArgs<ExtArgs>>
    ): Prisma__BankClient<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Banks.
     * @param {BankDeleteManyArgs} args - Arguments to filter Banks to delete.
     * @example
     * // Delete a few Banks
     * const { count } = await prisma.bank.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BankDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banks
     * const bank = await prisma.bank.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BankUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BankUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bank.
     * @param {BankUpsertArgs} args - Arguments to update or create a Bank.
     * @example
     * // Update or create a Bank
     * const bank = await prisma.bank.upsert({
     *   create: {
     *     // ... data to create a Bank
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bank we want to update
     *   }
     * })
    **/
    upsert<T extends BankUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BankUpsertArgs<ExtArgs>>
    ): Prisma__BankClient<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankCountArgs} args - Arguments to filter Banks to count.
     * @example
     * // Count the number of Banks
     * const count = await prisma.bank.count({
     *   where: {
     *     // ... the filter for the Banks we want to count
     *   }
     * })
    **/
    count<T extends BankCountArgs>(
      args?: Subset<T, BankCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAggregateArgs>(args: Subset<T, BankAggregateArgs>): Prisma.PrismaPromise<GetBankAggregateType<T>>

    /**
     * Group by Bank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankGroupByArgs['orderBy'] }
        : { orderBy?: BankGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bank model
   */
  readonly fields: BankFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bank.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client_contracts<T extends Bank$client_contractsArgs<ExtArgs> = {}>(args?: Subset<T, Bank$client_contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Bank model
   */ 
  interface BankFieldRefs {
    readonly id: FieldRef<"Bank", 'Int'>
    readonly name: FieldRef<"Bank", 'String'>
    readonly created_at: FieldRef<"Bank", 'DateTime'>
    readonly updated_at: FieldRef<"Bank", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bank findUnique
   */
  export type BankFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    /**
     * Filter, which Bank to fetch.
     */
    where: BankWhereUniqueInput
  }

  /**
   * Bank findUniqueOrThrow
   */
  export type BankFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    /**
     * Filter, which Bank to fetch.
     */
    where: BankWhereUniqueInput
  }

  /**
   * Bank findFirst
   */
  export type BankFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    /**
     * Filter, which Bank to fetch.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: BankOrderByWithRelationInput | BankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banks.
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banks.
     */
    distinct?: BankScalarFieldEnum | BankScalarFieldEnum[]
  }

  /**
   * Bank findFirstOrThrow
   */
  export type BankFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    /**
     * Filter, which Bank to fetch.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: BankOrderByWithRelationInput | BankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banks.
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banks.
     */
    distinct?: BankScalarFieldEnum | BankScalarFieldEnum[]
  }

  /**
   * Bank findMany
   */
  export type BankFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    /**
     * Filter, which Banks to fetch.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: BankOrderByWithRelationInput | BankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banks.
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    distinct?: BankScalarFieldEnum | BankScalarFieldEnum[]
  }

  /**
   * Bank create
   */
  export type BankCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    /**
     * The data needed to create a Bank.
     */
    data: XOR<BankCreateInput, BankUncheckedCreateInput>
  }

  /**
   * Bank createMany
   */
  export type BankCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Banks.
     */
    data: BankCreateManyInput | BankCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bank update
   */
  export type BankUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    /**
     * The data needed to update a Bank.
     */
    data: XOR<BankUpdateInput, BankUncheckedUpdateInput>
    /**
     * Choose, which Bank to update.
     */
    where: BankWhereUniqueInput
  }

  /**
   * Bank updateMany
   */
  export type BankUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Banks.
     */
    data: XOR<BankUpdateManyMutationInput, BankUncheckedUpdateManyInput>
    /**
     * Filter which Banks to update
     */
    where?: BankWhereInput
  }

  /**
   * Bank upsert
   */
  export type BankUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    /**
     * The filter to search for the Bank to update in case it exists.
     */
    where: BankWhereUniqueInput
    /**
     * In case the Bank found by the `where` argument doesn't exist, create a new Bank with this data.
     */
    create: XOR<BankCreateInput, BankUncheckedCreateInput>
    /**
     * In case the Bank was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankUpdateInput, BankUncheckedUpdateInput>
  }

  /**
   * Bank delete
   */
  export type BankDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    /**
     * Filter which Bank to delete.
     */
    where: BankWhereUniqueInput
  }

  /**
   * Bank deleteMany
   */
  export type BankDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banks to delete
     */
    where?: BankWhereInput
  }

  /**
   * Bank.client_contracts
   */
  export type Bank$client_contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    where?: ClientContractWhereInput
    orderBy?: ClientContractOrderByWithRelationInput | ClientContractOrderByWithRelationInput[]
    cursor?: ClientContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientContractScalarFieldEnum | ClientContractScalarFieldEnum[]
  }

  /**
   * Bank without action
   */
  export type BankDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    full_name: 'full_name',
    email: 'email',
    phone: 'phone',
    is_manager: 'is_manager',
    user_role: 'user_role',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    full_name: 'full_name',
    inn: 'inn',
    phone: 'phone',
    email: 'email',
    address: 'address',
    client_category: 'client_category',
    created_at: 'created_at',
    updated_at: 'updated_at',
    client_individual_properties_id: 'client_individual_properties_id',
    client_individual_minor_properties_id: 'client_individual_minor_properties_id',
    client_entity_properties_id: 'client_entity_properties_id'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ClientIndividualPropertiesScalarFieldEnum: {
    id: 'id',
    dob: 'dob',
    snils: 'snils',
    created_at: 'created_at',
    updated_at: 'updated_at',
    client_passport_id: 'client_passport_id'
  };

  export type ClientIndividualPropertiesScalarFieldEnum = (typeof ClientIndividualPropertiesScalarFieldEnum)[keyof typeof ClientIndividualPropertiesScalarFieldEnum]


  export const ClientIndividualMinorPropertiesScalarFieldEnum: {
    id: 'id',
    dob: 'dob',
    snils: 'snils',
    birth_certificate: 'birth_certificate',
    created_at: 'created_at',
    updated_at: 'updated_at',
    client_passport_id: 'client_passport_id'
  };

  export type ClientIndividualMinorPropertiesScalarFieldEnum = (typeof ClientIndividualMinorPropertiesScalarFieldEnum)[keyof typeof ClientIndividualMinorPropertiesScalarFieldEnum]


  export const ClientEntityPropertiesScalarFieldEnum: {
    id: 'id',
    kpp: 'kpp',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ClientEntityPropertiesScalarFieldEnum = (typeof ClientEntityPropertiesScalarFieldEnum)[keyof typeof ClientEntityPropertiesScalarFieldEnum]


  export const ClientToClientIndividualMinorPropertiesScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    client_id: 'client_id',
    client_individual_minor_properties_id: 'client_individual_minor_properties_id'
  };

  export type ClientToClientIndividualMinorPropertiesScalarFieldEnum = (typeof ClientToClientIndividualMinorPropertiesScalarFieldEnum)[keyof typeof ClientToClientIndividualMinorPropertiesScalarFieldEnum]


  export const ClientPassportScalarFieldEnum: {
    id: 'id',
    number: 'number',
    issued: 'issued',
    code: 'code',
    place_of_birth: 'place_of_birth',
    registration_address: 'registration_address',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ClientPassportScalarFieldEnum = (typeof ClientPassportScalarFieldEnum)[keyof typeof ClientPassportScalarFieldEnum]


  export const ClientContractScalarFieldEnum: {
    id: 'id',
    number: 'number',
    date: 'date',
    registration_date: 'registration_date',
    price: 'price',
    client_contract_type: 'client_contract_type',
    created_at: 'created_at',
    updated_at: 'updated_at',
    object_id: 'object_id',
    product_id: 'product_id',
    real_estate_agent_id: 'real_estate_agent_id',
    manager_id: 'manager_id',
    bank_id: 'bank_id',
    ddu_client_contract_properties_id: 'ddu_client_contract_properties_id'
  };

  export type ClientContractScalarFieldEnum = (typeof ClientContractScalarFieldEnum)[keyof typeof ClientContractScalarFieldEnum]


  export const DDUClientContractPropertiesScalarFieldEnum: {
    id: 'id',
    ddu_link: 'ddu_link',
    return_account: 'return_account',
    escrow_account_opening_date: 'escrow_account_opening_date',
    escrow_period: 'escrow_period',
    escrow_account_number: 'escrow_account_number',
    is_escrow_discount: 'is_escrow_discount',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DDUClientContractPropertiesScalarFieldEnum = (typeof DDUClientContractPropertiesScalarFieldEnum)[keyof typeof DDUClientContractPropertiesScalarFieldEnum]


  export const ClientContractToAgencyContractScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    client_contract_id: 'client_contract_id',
    agency_contract_id: 'agency_contract_id'
  };

  export type ClientContractToAgencyContractScalarFieldEnum = (typeof ClientContractToAgencyContractScalarFieldEnum)[keyof typeof ClientContractToAgencyContractScalarFieldEnum]


  export const ClientContractToClientScalarFieldEnum: {
    is_main: 'is_main',
    share: 'share',
    created_at: 'created_at',
    updated_at: 'updated_at',
    client_contract_id: 'client_contract_id',
    client_id: 'client_id'
  };

  export type ClientContractToClientScalarFieldEnum = (typeof ClientContractToClientScalarFieldEnum)[keyof typeof ClientContractToClientScalarFieldEnum]


  export const ScheduledPaymentScalarFieldEnum: {
    id: 'id',
    payment: 'payment',
    date: 'date',
    scheduled_payment_type: 'scheduled_payment_type',
    created_at: 'created_at',
    updated_at: 'updated_at',
    client_contract_id: 'client_contract_id'
  };

  export type ScheduledPaymentScalarFieldEnum = (typeof ScheduledPaymentScalarFieldEnum)[keyof typeof ScheduledPaymentScalarFieldEnum]


  export const ActualPaymentScalarFieldEnum: {
    id: 'id',
    payment: 'payment',
    date: 'date',
    created_at: 'created_at',
    updated_at: 'updated_at',
    client_contract_id: 'client_contract_id'
  };

  export type ActualPaymentScalarFieldEnum = (typeof ActualPaymentScalarFieldEnum)[keyof typeof ActualPaymentScalarFieldEnum]


  export const ObjectScalarFieldEnum: {
    id: 'id',
    common_db_objects_id: 'common_db_objects_id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    entity_id: 'entity_id'
  };

  export type ObjectScalarFieldEnum = (typeof ObjectScalarFieldEnum)[keyof typeof ObjectScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    pricing_products_id: 'pricing_products_id',
    number: 'number',
    product_category: 'product_category',
    created_at: 'created_at',
    updated_at: 'updated_at',
    object_id: 'object_id'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const AgencyScalarFieldEnum: {
    id: 'id',
    common_db_contractors_id: 'common_db_contractors_id',
    name: 'name',
    inn: 'inn',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AgencyScalarFieldEnum = (typeof AgencyScalarFieldEnum)[keyof typeof AgencyScalarFieldEnum]


  export const AgencyContractScalarFieldEnum: {
    id: 'id',
    number: 'number',
    date: 'date',
    agency_contract_type: 'agency_contract_type',
    created_at: 'created_at',
    updated_at: 'updated_at',
    responsible_user_id: 'responsible_user_id',
    entity_id: 'entity_id',
    object_id: 'object_id',
    agency_id: 'agency_id',
    agency_contract_signatory_id: 'agency_contract_signatory_id',
    real_estate_agency_contract_properties_id: 'real_estate_agency_contract_properties_id',
    mip_agency_contract_properties_id: 'mip_agency_contract_properties_id'
  };

  export type AgencyContractScalarFieldEnum = (typeof AgencyContractScalarFieldEnum)[keyof typeof AgencyContractScalarFieldEnum]


  export const AgencyContractSignatoryScalarFieldEnum: {
    id: 'id',
    full_name: 'full_name',
    email: 'email',
    phone: 'phone',
    title: 'title',
    based_on: 'based_on',
    created_at: 'created_at',
    updated_at: 'updated_at',
    agency_id: 'agency_id'
  };

  export type AgencyContractSignatoryScalarFieldEnum = (typeof AgencyContractSignatoryScalarFieldEnum)[keyof typeof AgencyContractSignatoryScalarFieldEnum]


  export const RealEstateAgencyContractPropertiesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    agency_contract_commission_id: 'agency_contract_commission_id'
  };

  export type RealEstateAgencyContractPropertiesScalarFieldEnum = (typeof RealEstateAgencyContractPropertiesScalarFieldEnum)[keyof typeof RealEstateAgencyContractPropertiesScalarFieldEnum]


  export const MIPAgencyContractPropertiesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    agency_contract_commission_id: 'agency_contract_commission_id'
  };

  export type MIPAgencyContractPropertiesScalarFieldEnum = (typeof MIPAgencyContractPropertiesScalarFieldEnum)[keyof typeof MIPAgencyContractPropertiesScalarFieldEnum]


  export const AgencyContractCommissionScalarFieldEnum: {
    id: 'id',
    percent: 'percent',
    threshold: 'threshold',
    max_days: 'max_days',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AgencyContractCommissionScalarFieldEnum = (typeof AgencyContractCommissionScalarFieldEnum)[keyof typeof AgencyContractCommissionScalarFieldEnum]


  export const RealEstateAgentScalarFieldEnum: {
    id: 'id',
    full_name: 'full_name',
    phone: 'phone',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type RealEstateAgentScalarFieldEnum = (typeof RealEstateAgentScalarFieldEnum)[keyof typeof RealEstateAgentScalarFieldEnum]


  export const AgencyToRealEstateAgentScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    agency_id: 'agency_id',
    real_estate_agent_id: 'real_estate_agent_id'
  };

  export type AgencyToRealEstateAgentScalarFieldEnum = (typeof AgencyToRealEstateAgentScalarFieldEnum)[keyof typeof AgencyToRealEstateAgentScalarFieldEnum]


  export const EntityScalarFieldEnum: {
    id: 'id',
    common_db_entities_id: 'common_db_entities_id',
    name: 'name',
    website: 'website',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type EntityScalarFieldEnum = (typeof EntityScalarFieldEnum)[keyof typeof EntityScalarFieldEnum]


  export const EntityForbiddenWebsiteScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    entity_id: 'entity_id'
  };

  export type EntityForbiddenWebsiteScalarFieldEnum = (typeof EntityForbiddenWebsiteScalarFieldEnum)[keyof typeof EntityForbiddenWebsiteScalarFieldEnum]


  export const EntityForbiddenBrandScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    entity_id: 'entity_id'
  };

  export type EntityForbiddenBrandScalarFieldEnum = (typeof EntityForbiddenBrandScalarFieldEnum)[keyof typeof EntityForbiddenBrandScalarFieldEnum]


  export const BankScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BankScalarFieldEnum = (typeof BankScalarFieldEnum)[keyof typeof BankScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'ClientCategory'
   */
  export type EnumClientCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientCategory'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'ClientContractType'
   */
  export type EnumClientContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientContractType'>
    


  /**
   * Reference to a field of type 'ScheduledPaymentType'
   */
  export type EnumScheduledPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduledPaymentType'>
    


  /**
   * Reference to a field of type 'ProductCategory'
   */
  export type EnumProductCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductCategory'>
    


  /**
   * Reference to a field of type 'AgencyContractType'
   */
  export type EnumAgencyContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgencyContractType'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    full_name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    is_manager?: BoolFilter<"User"> | boolean
    user_role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    client_contracts?: ClientContractListRelationFilter
    agency_contracts?: AgencyContractListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    is_manager?: SortOrder
    user_role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contracts?: ClientContractOrderByRelationAggregateInput
    agency_contracts?: AgencyContractOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    full_name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    is_manager?: BoolFilter<"User"> | boolean
    user_role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    client_contracts?: ClientContractListRelationFilter
    agency_contracts?: AgencyContractListRelationFilter
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    is_manager?: SortOrder
    user_role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    full_name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    is_manager?: BoolWithAggregatesFilter<"User"> | boolean
    user_role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: IntFilter<"Client"> | number
    full_name?: StringFilter<"Client"> | string
    inn?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    email?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    client_category?: EnumClientCategoryFilter<"Client"> | $Enums.ClientCategory
    created_at?: DateTimeFilter<"Client"> | Date | string
    updated_at?: DateTimeFilter<"Client"> | Date | string
    client_individual_properties_id?: IntNullableFilter<"Client"> | number | null
    client_individual_minor_properties_id?: IntNullableFilter<"Client"> | number | null
    client_entity_properties_id?: IntNullableFilter<"Client"> | number | null
    client_individual_properties?: XOR<ClientIndividualPropertiesNullableRelationFilter, ClientIndividualPropertiesWhereInput> | null
    client_individual_minor_properties?: XOR<ClientIndividualMinorPropertiesNullableRelationFilter, ClientIndividualMinorPropertiesWhereInput> | null
    client_entity_properties?: XOR<ClientEntityPropertiesNullableRelationFilter, ClientEntityPropertiesWhereInput> | null
    client_contracts?: ClientContractToClientListRelationFilter
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    full_name?: SortOrder
    inn?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    client_category?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_individual_properties_id?: SortOrderInput | SortOrder
    client_individual_minor_properties_id?: SortOrderInput | SortOrder
    client_entity_properties_id?: SortOrderInput | SortOrder
    client_individual_properties?: ClientIndividualPropertiesOrderByWithRelationInput
    client_individual_minor_properties?: ClientIndividualMinorPropertiesOrderByWithRelationInput
    client_entity_properties?: ClientEntityPropertiesOrderByWithRelationInput
    client_contracts?: ClientContractToClientOrderByRelationAggregateInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    client_individual_properties_id?: number
    client_individual_minor_properties_id?: number
    client_entity_properties_id?: number
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    full_name?: StringFilter<"Client"> | string
    inn?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    email?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    client_category?: EnumClientCategoryFilter<"Client"> | $Enums.ClientCategory
    created_at?: DateTimeFilter<"Client"> | Date | string
    updated_at?: DateTimeFilter<"Client"> | Date | string
    client_individual_properties?: XOR<ClientIndividualPropertiesNullableRelationFilter, ClientIndividualPropertiesWhereInput> | null
    client_individual_minor_properties?: XOR<ClientIndividualMinorPropertiesNullableRelationFilter, ClientIndividualMinorPropertiesWhereInput> | null
    client_entity_properties?: XOR<ClientEntityPropertiesNullableRelationFilter, ClientEntityPropertiesWhereInput> | null
    client_contracts?: ClientContractToClientListRelationFilter
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesListRelationFilter
  }, "id" | "client_individual_properties_id" | "client_individual_minor_properties_id" | "client_entity_properties_id">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    full_name?: SortOrder
    inn?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    client_category?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_individual_properties_id?: SortOrderInput | SortOrder
    client_individual_minor_properties_id?: SortOrderInput | SortOrder
    client_entity_properties_id?: SortOrderInput | SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Client"> | number
    full_name?: StringWithAggregatesFilter<"Client"> | string
    inn?: StringNullableWithAggregatesFilter<"Client"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Client"> | string | null
    email?: StringNullableWithAggregatesFilter<"Client"> | string | null
    address?: StringNullableWithAggregatesFilter<"Client"> | string | null
    client_category?: EnumClientCategoryWithAggregatesFilter<"Client"> | $Enums.ClientCategory
    created_at?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    client_individual_properties_id?: IntNullableWithAggregatesFilter<"Client"> | number | null
    client_individual_minor_properties_id?: IntNullableWithAggregatesFilter<"Client"> | number | null
    client_entity_properties_id?: IntNullableWithAggregatesFilter<"Client"> | number | null
  }

  export type ClientIndividualPropertiesWhereInput = {
    AND?: ClientIndividualPropertiesWhereInput | ClientIndividualPropertiesWhereInput[]
    OR?: ClientIndividualPropertiesWhereInput[]
    NOT?: ClientIndividualPropertiesWhereInput | ClientIndividualPropertiesWhereInput[]
    id?: IntFilter<"ClientIndividualProperties"> | number
    dob?: DateTimeNullableFilter<"ClientIndividualProperties"> | Date | string | null
    snils?: StringNullableFilter<"ClientIndividualProperties"> | string | null
    created_at?: DateTimeFilter<"ClientIndividualProperties"> | Date | string
    updated_at?: DateTimeFilter<"ClientIndividualProperties"> | Date | string
    client_passport_id?: IntNullableFilter<"ClientIndividualProperties"> | number | null
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    client_passport?: XOR<ClientPassportNullableRelationFilter, ClientPassportWhereInput> | null
  }

  export type ClientIndividualPropertiesOrderByWithRelationInput = {
    id?: SortOrder
    dob?: SortOrderInput | SortOrder
    snils?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_passport_id?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
    client_passport?: ClientPassportOrderByWithRelationInput
  }

  export type ClientIndividualPropertiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    client_passport_id?: number
    AND?: ClientIndividualPropertiesWhereInput | ClientIndividualPropertiesWhereInput[]
    OR?: ClientIndividualPropertiesWhereInput[]
    NOT?: ClientIndividualPropertiesWhereInput | ClientIndividualPropertiesWhereInput[]
    dob?: DateTimeNullableFilter<"ClientIndividualProperties"> | Date | string | null
    snils?: StringNullableFilter<"ClientIndividualProperties"> | string | null
    created_at?: DateTimeFilter<"ClientIndividualProperties"> | Date | string
    updated_at?: DateTimeFilter<"ClientIndividualProperties"> | Date | string
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    client_passport?: XOR<ClientPassportNullableRelationFilter, ClientPassportWhereInput> | null
  }, "id" | "client_passport_id">

  export type ClientIndividualPropertiesOrderByWithAggregationInput = {
    id?: SortOrder
    dob?: SortOrderInput | SortOrder
    snils?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_passport_id?: SortOrderInput | SortOrder
    _count?: ClientIndividualPropertiesCountOrderByAggregateInput
    _avg?: ClientIndividualPropertiesAvgOrderByAggregateInput
    _max?: ClientIndividualPropertiesMaxOrderByAggregateInput
    _min?: ClientIndividualPropertiesMinOrderByAggregateInput
    _sum?: ClientIndividualPropertiesSumOrderByAggregateInput
  }

  export type ClientIndividualPropertiesScalarWhereWithAggregatesInput = {
    AND?: ClientIndividualPropertiesScalarWhereWithAggregatesInput | ClientIndividualPropertiesScalarWhereWithAggregatesInput[]
    OR?: ClientIndividualPropertiesScalarWhereWithAggregatesInput[]
    NOT?: ClientIndividualPropertiesScalarWhereWithAggregatesInput | ClientIndividualPropertiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClientIndividualProperties"> | number
    dob?: DateTimeNullableWithAggregatesFilter<"ClientIndividualProperties"> | Date | string | null
    snils?: StringNullableWithAggregatesFilter<"ClientIndividualProperties"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ClientIndividualProperties"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ClientIndividualProperties"> | Date | string
    client_passport_id?: IntNullableWithAggregatesFilter<"ClientIndividualProperties"> | number | null
  }

  export type ClientIndividualMinorPropertiesWhereInput = {
    AND?: ClientIndividualMinorPropertiesWhereInput | ClientIndividualMinorPropertiesWhereInput[]
    OR?: ClientIndividualMinorPropertiesWhereInput[]
    NOT?: ClientIndividualMinorPropertiesWhereInput | ClientIndividualMinorPropertiesWhereInput[]
    id?: IntFilter<"ClientIndividualMinorProperties"> | number
    dob?: DateTimeNullableFilter<"ClientIndividualMinorProperties"> | Date | string | null
    snils?: StringNullableFilter<"ClientIndividualMinorProperties"> | string | null
    birth_certificate?: StringNullableFilter<"ClientIndividualMinorProperties"> | string | null
    created_at?: DateTimeFilter<"ClientIndividualMinorProperties"> | Date | string
    updated_at?: DateTimeFilter<"ClientIndividualMinorProperties"> | Date | string
    client_passport_id?: IntNullableFilter<"ClientIndividualMinorProperties"> | number | null
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    client_passport?: XOR<ClientPassportNullableRelationFilter, ClientPassportWhereInput> | null
    representatives?: ClientToClientIndividualMinorPropertiesListRelationFilter
  }

  export type ClientIndividualMinorPropertiesOrderByWithRelationInput = {
    id?: SortOrder
    dob?: SortOrderInput | SortOrder
    snils?: SortOrderInput | SortOrder
    birth_certificate?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_passport_id?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
    client_passport?: ClientPassportOrderByWithRelationInput
    representatives?: ClientToClientIndividualMinorPropertiesOrderByRelationAggregateInput
  }

  export type ClientIndividualMinorPropertiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    client_passport_id?: number
    AND?: ClientIndividualMinorPropertiesWhereInput | ClientIndividualMinorPropertiesWhereInput[]
    OR?: ClientIndividualMinorPropertiesWhereInput[]
    NOT?: ClientIndividualMinorPropertiesWhereInput | ClientIndividualMinorPropertiesWhereInput[]
    dob?: DateTimeNullableFilter<"ClientIndividualMinorProperties"> | Date | string | null
    snils?: StringNullableFilter<"ClientIndividualMinorProperties"> | string | null
    birth_certificate?: StringNullableFilter<"ClientIndividualMinorProperties"> | string | null
    created_at?: DateTimeFilter<"ClientIndividualMinorProperties"> | Date | string
    updated_at?: DateTimeFilter<"ClientIndividualMinorProperties"> | Date | string
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    client_passport?: XOR<ClientPassportNullableRelationFilter, ClientPassportWhereInput> | null
    representatives?: ClientToClientIndividualMinorPropertiesListRelationFilter
  }, "id" | "client_passport_id">

  export type ClientIndividualMinorPropertiesOrderByWithAggregationInput = {
    id?: SortOrder
    dob?: SortOrderInput | SortOrder
    snils?: SortOrderInput | SortOrder
    birth_certificate?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_passport_id?: SortOrderInput | SortOrder
    _count?: ClientIndividualMinorPropertiesCountOrderByAggregateInput
    _avg?: ClientIndividualMinorPropertiesAvgOrderByAggregateInput
    _max?: ClientIndividualMinorPropertiesMaxOrderByAggregateInput
    _min?: ClientIndividualMinorPropertiesMinOrderByAggregateInput
    _sum?: ClientIndividualMinorPropertiesSumOrderByAggregateInput
  }

  export type ClientIndividualMinorPropertiesScalarWhereWithAggregatesInput = {
    AND?: ClientIndividualMinorPropertiesScalarWhereWithAggregatesInput | ClientIndividualMinorPropertiesScalarWhereWithAggregatesInput[]
    OR?: ClientIndividualMinorPropertiesScalarWhereWithAggregatesInput[]
    NOT?: ClientIndividualMinorPropertiesScalarWhereWithAggregatesInput | ClientIndividualMinorPropertiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClientIndividualMinorProperties"> | number
    dob?: DateTimeNullableWithAggregatesFilter<"ClientIndividualMinorProperties"> | Date | string | null
    snils?: StringNullableWithAggregatesFilter<"ClientIndividualMinorProperties"> | string | null
    birth_certificate?: StringNullableWithAggregatesFilter<"ClientIndividualMinorProperties"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ClientIndividualMinorProperties"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ClientIndividualMinorProperties"> | Date | string
    client_passport_id?: IntNullableWithAggregatesFilter<"ClientIndividualMinorProperties"> | number | null
  }

  export type ClientEntityPropertiesWhereInput = {
    AND?: ClientEntityPropertiesWhereInput | ClientEntityPropertiesWhereInput[]
    OR?: ClientEntityPropertiesWhereInput[]
    NOT?: ClientEntityPropertiesWhereInput | ClientEntityPropertiesWhereInput[]
    id?: IntFilter<"ClientEntityProperties"> | number
    kpp?: StringNullableFilter<"ClientEntityProperties"> | string | null
    created_at?: DateTimeFilter<"ClientEntityProperties"> | Date | string
    updated_at?: DateTimeFilter<"ClientEntityProperties"> | Date | string
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
  }

  export type ClientEntityPropertiesOrderByWithRelationInput = {
    id?: SortOrder
    kpp?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type ClientEntityPropertiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClientEntityPropertiesWhereInput | ClientEntityPropertiesWhereInput[]
    OR?: ClientEntityPropertiesWhereInput[]
    NOT?: ClientEntityPropertiesWhereInput | ClientEntityPropertiesWhereInput[]
    kpp?: StringNullableFilter<"ClientEntityProperties"> | string | null
    created_at?: DateTimeFilter<"ClientEntityProperties"> | Date | string
    updated_at?: DateTimeFilter<"ClientEntityProperties"> | Date | string
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
  }, "id">

  export type ClientEntityPropertiesOrderByWithAggregationInput = {
    id?: SortOrder
    kpp?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ClientEntityPropertiesCountOrderByAggregateInput
    _avg?: ClientEntityPropertiesAvgOrderByAggregateInput
    _max?: ClientEntityPropertiesMaxOrderByAggregateInput
    _min?: ClientEntityPropertiesMinOrderByAggregateInput
    _sum?: ClientEntityPropertiesSumOrderByAggregateInput
  }

  export type ClientEntityPropertiesScalarWhereWithAggregatesInput = {
    AND?: ClientEntityPropertiesScalarWhereWithAggregatesInput | ClientEntityPropertiesScalarWhereWithAggregatesInput[]
    OR?: ClientEntityPropertiesScalarWhereWithAggregatesInput[]
    NOT?: ClientEntityPropertiesScalarWhereWithAggregatesInput | ClientEntityPropertiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClientEntityProperties"> | number
    kpp?: StringNullableWithAggregatesFilter<"ClientEntityProperties"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ClientEntityProperties"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ClientEntityProperties"> | Date | string
  }

  export type ClientToClientIndividualMinorPropertiesWhereInput = {
    AND?: ClientToClientIndividualMinorPropertiesWhereInput | ClientToClientIndividualMinorPropertiesWhereInput[]
    OR?: ClientToClientIndividualMinorPropertiesWhereInput[]
    NOT?: ClientToClientIndividualMinorPropertiesWhereInput | ClientToClientIndividualMinorPropertiesWhereInput[]
    created_at?: DateTimeFilter<"ClientToClientIndividualMinorProperties"> | Date | string
    updated_at?: DateTimeFilter<"ClientToClientIndividualMinorProperties"> | Date | string
    client_id?: IntFilter<"ClientToClientIndividualMinorProperties"> | number
    client_individual_minor_properties_id?: IntFilter<"ClientToClientIndividualMinorProperties"> | number
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    client_individual_minor_properties?: XOR<ClientIndividualMinorPropertiesRelationFilter, ClientIndividualMinorPropertiesWhereInput>
  }

  export type ClientToClientIndividualMinorPropertiesOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    client_id?: SortOrder
    client_individual_minor_properties_id?: SortOrder
    client?: ClientOrderByWithRelationInput
    client_individual_minor_properties?: ClientIndividualMinorPropertiesOrderByWithRelationInput
  }

  export type ClientToClientIndividualMinorPropertiesWhereUniqueInput = Prisma.AtLeast<{
    client_id_client_individual_minor_properties_id?: ClientToClientIndividualMinorPropertiesClient_idClient_individual_minor_properties_idCompoundUniqueInput
    AND?: ClientToClientIndividualMinorPropertiesWhereInput | ClientToClientIndividualMinorPropertiesWhereInput[]
    OR?: ClientToClientIndividualMinorPropertiesWhereInput[]
    NOT?: ClientToClientIndividualMinorPropertiesWhereInput | ClientToClientIndividualMinorPropertiesWhereInput[]
    created_at?: DateTimeFilter<"ClientToClientIndividualMinorProperties"> | Date | string
    updated_at?: DateTimeFilter<"ClientToClientIndividualMinorProperties"> | Date | string
    client_id?: IntFilter<"ClientToClientIndividualMinorProperties"> | number
    client_individual_minor_properties_id?: IntFilter<"ClientToClientIndividualMinorProperties"> | number
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    client_individual_minor_properties?: XOR<ClientIndividualMinorPropertiesRelationFilter, ClientIndividualMinorPropertiesWhereInput>
  }, "client_id_client_individual_minor_properties_id">

  export type ClientToClientIndividualMinorPropertiesOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    client_id?: SortOrder
    client_individual_minor_properties_id?: SortOrder
    _count?: ClientToClientIndividualMinorPropertiesCountOrderByAggregateInput
    _avg?: ClientToClientIndividualMinorPropertiesAvgOrderByAggregateInput
    _max?: ClientToClientIndividualMinorPropertiesMaxOrderByAggregateInput
    _min?: ClientToClientIndividualMinorPropertiesMinOrderByAggregateInput
    _sum?: ClientToClientIndividualMinorPropertiesSumOrderByAggregateInput
  }

  export type ClientToClientIndividualMinorPropertiesScalarWhereWithAggregatesInput = {
    AND?: ClientToClientIndividualMinorPropertiesScalarWhereWithAggregatesInput | ClientToClientIndividualMinorPropertiesScalarWhereWithAggregatesInput[]
    OR?: ClientToClientIndividualMinorPropertiesScalarWhereWithAggregatesInput[]
    NOT?: ClientToClientIndividualMinorPropertiesScalarWhereWithAggregatesInput | ClientToClientIndividualMinorPropertiesScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"ClientToClientIndividualMinorProperties"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ClientToClientIndividualMinorProperties"> | Date | string
    client_id?: IntWithAggregatesFilter<"ClientToClientIndividualMinorProperties"> | number
    client_individual_minor_properties_id?: IntWithAggregatesFilter<"ClientToClientIndividualMinorProperties"> | number
  }

  export type ClientPassportWhereInput = {
    AND?: ClientPassportWhereInput | ClientPassportWhereInput[]
    OR?: ClientPassportWhereInput[]
    NOT?: ClientPassportWhereInput | ClientPassportWhereInput[]
    id?: IntFilter<"ClientPassport"> | number
    number?: StringNullableFilter<"ClientPassport"> | string | null
    issued?: StringNullableFilter<"ClientPassport"> | string | null
    code?: StringNullableFilter<"ClientPassport"> | string | null
    place_of_birth?: StringNullableFilter<"ClientPassport"> | string | null
    registration_address?: StringNullableFilter<"ClientPassport"> | string | null
    created_at?: DateTimeFilter<"ClientPassport"> | Date | string
    updated_at?: DateTimeFilter<"ClientPassport"> | Date | string
    client_individual_properties?: XOR<ClientIndividualPropertiesNullableRelationFilter, ClientIndividualPropertiesWhereInput> | null
    client_individual_minor_properties?: XOR<ClientIndividualMinorPropertiesNullableRelationFilter, ClientIndividualMinorPropertiesWhereInput> | null
  }

  export type ClientPassportOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrderInput | SortOrder
    issued?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    place_of_birth?: SortOrderInput | SortOrder
    registration_address?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_individual_properties?: ClientIndividualPropertiesOrderByWithRelationInput
    client_individual_minor_properties?: ClientIndividualMinorPropertiesOrderByWithRelationInput
  }

  export type ClientPassportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClientPassportWhereInput | ClientPassportWhereInput[]
    OR?: ClientPassportWhereInput[]
    NOT?: ClientPassportWhereInput | ClientPassportWhereInput[]
    number?: StringNullableFilter<"ClientPassport"> | string | null
    issued?: StringNullableFilter<"ClientPassport"> | string | null
    code?: StringNullableFilter<"ClientPassport"> | string | null
    place_of_birth?: StringNullableFilter<"ClientPassport"> | string | null
    registration_address?: StringNullableFilter<"ClientPassport"> | string | null
    created_at?: DateTimeFilter<"ClientPassport"> | Date | string
    updated_at?: DateTimeFilter<"ClientPassport"> | Date | string
    client_individual_properties?: XOR<ClientIndividualPropertiesNullableRelationFilter, ClientIndividualPropertiesWhereInput> | null
    client_individual_minor_properties?: XOR<ClientIndividualMinorPropertiesNullableRelationFilter, ClientIndividualMinorPropertiesWhereInput> | null
  }, "id">

  export type ClientPassportOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrderInput | SortOrder
    issued?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    place_of_birth?: SortOrderInput | SortOrder
    registration_address?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ClientPassportCountOrderByAggregateInput
    _avg?: ClientPassportAvgOrderByAggregateInput
    _max?: ClientPassportMaxOrderByAggregateInput
    _min?: ClientPassportMinOrderByAggregateInput
    _sum?: ClientPassportSumOrderByAggregateInput
  }

  export type ClientPassportScalarWhereWithAggregatesInput = {
    AND?: ClientPassportScalarWhereWithAggregatesInput | ClientPassportScalarWhereWithAggregatesInput[]
    OR?: ClientPassportScalarWhereWithAggregatesInput[]
    NOT?: ClientPassportScalarWhereWithAggregatesInput | ClientPassportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClientPassport"> | number
    number?: StringNullableWithAggregatesFilter<"ClientPassport"> | string | null
    issued?: StringNullableWithAggregatesFilter<"ClientPassport"> | string | null
    code?: StringNullableWithAggregatesFilter<"ClientPassport"> | string | null
    place_of_birth?: StringNullableWithAggregatesFilter<"ClientPassport"> | string | null
    registration_address?: StringNullableWithAggregatesFilter<"ClientPassport"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ClientPassport"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ClientPassport"> | Date | string
  }

  export type ClientContractWhereInput = {
    AND?: ClientContractWhereInput | ClientContractWhereInput[]
    OR?: ClientContractWhereInput[]
    NOT?: ClientContractWhereInput | ClientContractWhereInput[]
    id?: IntFilter<"ClientContract"> | number
    number?: StringFilter<"ClientContract"> | string
    date?: DateTimeFilter<"ClientContract"> | Date | string
    registration_date?: DateTimeNullableFilter<"ClientContract"> | Date | string | null
    price?: DecimalFilter<"ClientContract"> | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFilter<"ClientContract"> | $Enums.ClientContractType
    created_at?: DateTimeFilter<"ClientContract"> | Date | string
    updated_at?: DateTimeFilter<"ClientContract"> | Date | string
    object_id?: IntFilter<"ClientContract"> | number
    product_id?: IntFilter<"ClientContract"> | number
    real_estate_agent_id?: IntNullableFilter<"ClientContract"> | number | null
    manager_id?: IntNullableFilter<"ClientContract"> | number | null
    bank_id?: IntNullableFilter<"ClientContract"> | number | null
    ddu_client_contract_properties_id?: IntNullableFilter<"ClientContract"> | number | null
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    real_estate_agent?: XOR<RealEstateAgentNullableRelationFilter, RealEstateAgentWhereInput> | null
    manager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    bank?: XOR<BankNullableRelationFilter, BankWhereInput> | null
    ddu_client_contract_properties?: XOR<DDUClientContractPropertiesNullableRelationFilter, DDUClientContractPropertiesWhereInput> | null
    clients?: ClientContractToClientListRelationFilter
    agency_contracts?: ClientContractToAgencyContractListRelationFilter
    scheduled_payments?: ScheduledPaymentListRelationFilter
    actual_payment?: ActualPaymentListRelationFilter
  }

  export type ClientContractOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    registration_date?: SortOrderInput | SortOrder
    price?: SortOrder
    client_contract_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    object_id?: SortOrder
    product_id?: SortOrder
    real_estate_agent_id?: SortOrderInput | SortOrder
    manager_id?: SortOrderInput | SortOrder
    bank_id?: SortOrderInput | SortOrder
    ddu_client_contract_properties_id?: SortOrderInput | SortOrder
    object?: ObjectOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    real_estate_agent?: RealEstateAgentOrderByWithRelationInput
    manager?: UserOrderByWithRelationInput
    bank?: BankOrderByWithRelationInput
    ddu_client_contract_properties?: DDUClientContractPropertiesOrderByWithRelationInput
    clients?: ClientContractToClientOrderByRelationAggregateInput
    agency_contracts?: ClientContractToAgencyContractOrderByRelationAggregateInput
    scheduled_payments?: ScheduledPaymentOrderByRelationAggregateInput
    actual_payment?: ActualPaymentOrderByRelationAggregateInput
  }

  export type ClientContractWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    product_id?: number
    ddu_client_contract_properties_id?: number
    AND?: ClientContractWhereInput | ClientContractWhereInput[]
    OR?: ClientContractWhereInput[]
    NOT?: ClientContractWhereInput | ClientContractWhereInput[]
    number?: StringFilter<"ClientContract"> | string
    date?: DateTimeFilter<"ClientContract"> | Date | string
    registration_date?: DateTimeNullableFilter<"ClientContract"> | Date | string | null
    price?: DecimalFilter<"ClientContract"> | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFilter<"ClientContract"> | $Enums.ClientContractType
    created_at?: DateTimeFilter<"ClientContract"> | Date | string
    updated_at?: DateTimeFilter<"ClientContract"> | Date | string
    object_id?: IntFilter<"ClientContract"> | number
    real_estate_agent_id?: IntNullableFilter<"ClientContract"> | number | null
    manager_id?: IntNullableFilter<"ClientContract"> | number | null
    bank_id?: IntNullableFilter<"ClientContract"> | number | null
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    real_estate_agent?: XOR<RealEstateAgentNullableRelationFilter, RealEstateAgentWhereInput> | null
    manager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    bank?: XOR<BankNullableRelationFilter, BankWhereInput> | null
    ddu_client_contract_properties?: XOR<DDUClientContractPropertiesNullableRelationFilter, DDUClientContractPropertiesWhereInput> | null
    clients?: ClientContractToClientListRelationFilter
    agency_contracts?: ClientContractToAgencyContractListRelationFilter
    scheduled_payments?: ScheduledPaymentListRelationFilter
    actual_payment?: ActualPaymentListRelationFilter
  }, "id" | "product_id" | "ddu_client_contract_properties_id">

  export type ClientContractOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    registration_date?: SortOrderInput | SortOrder
    price?: SortOrder
    client_contract_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    object_id?: SortOrder
    product_id?: SortOrder
    real_estate_agent_id?: SortOrderInput | SortOrder
    manager_id?: SortOrderInput | SortOrder
    bank_id?: SortOrderInput | SortOrder
    ddu_client_contract_properties_id?: SortOrderInput | SortOrder
    _count?: ClientContractCountOrderByAggregateInput
    _avg?: ClientContractAvgOrderByAggregateInput
    _max?: ClientContractMaxOrderByAggregateInput
    _min?: ClientContractMinOrderByAggregateInput
    _sum?: ClientContractSumOrderByAggregateInput
  }

  export type ClientContractScalarWhereWithAggregatesInput = {
    AND?: ClientContractScalarWhereWithAggregatesInput | ClientContractScalarWhereWithAggregatesInput[]
    OR?: ClientContractScalarWhereWithAggregatesInput[]
    NOT?: ClientContractScalarWhereWithAggregatesInput | ClientContractScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClientContract"> | number
    number?: StringWithAggregatesFilter<"ClientContract"> | string
    date?: DateTimeWithAggregatesFilter<"ClientContract"> | Date | string
    registration_date?: DateTimeNullableWithAggregatesFilter<"ClientContract"> | Date | string | null
    price?: DecimalWithAggregatesFilter<"ClientContract"> | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeWithAggregatesFilter<"ClientContract"> | $Enums.ClientContractType
    created_at?: DateTimeWithAggregatesFilter<"ClientContract"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ClientContract"> | Date | string
    object_id?: IntWithAggregatesFilter<"ClientContract"> | number
    product_id?: IntWithAggregatesFilter<"ClientContract"> | number
    real_estate_agent_id?: IntNullableWithAggregatesFilter<"ClientContract"> | number | null
    manager_id?: IntNullableWithAggregatesFilter<"ClientContract"> | number | null
    bank_id?: IntNullableWithAggregatesFilter<"ClientContract"> | number | null
    ddu_client_contract_properties_id?: IntNullableWithAggregatesFilter<"ClientContract"> | number | null
  }

  export type DDUClientContractPropertiesWhereInput = {
    AND?: DDUClientContractPropertiesWhereInput | DDUClientContractPropertiesWhereInput[]
    OR?: DDUClientContractPropertiesWhereInput[]
    NOT?: DDUClientContractPropertiesWhereInput | DDUClientContractPropertiesWhereInput[]
    id?: IntFilter<"DDUClientContractProperties"> | number
    ddu_link?: StringNullableFilter<"DDUClientContractProperties"> | string | null
    return_account?: StringNullableFilter<"DDUClientContractProperties"> | string | null
    escrow_account_opening_date?: DateTimeNullableFilter<"DDUClientContractProperties"> | Date | string | null
    escrow_period?: DateTimeNullableFilter<"DDUClientContractProperties"> | Date | string | null
    escrow_account_number?: StringNullableFilter<"DDUClientContractProperties"> | string | null
    is_escrow_discount?: BoolNullableFilter<"DDUClientContractProperties"> | boolean | null
    created_at?: DateTimeFilter<"DDUClientContractProperties"> | Date | string
    updated_at?: DateTimeFilter<"DDUClientContractProperties"> | Date | string
    client_contract?: XOR<ClientContractNullableRelationFilter, ClientContractWhereInput> | null
  }

  export type DDUClientContractPropertiesOrderByWithRelationInput = {
    id?: SortOrder
    ddu_link?: SortOrderInput | SortOrder
    return_account?: SortOrderInput | SortOrder
    escrow_account_opening_date?: SortOrderInput | SortOrder
    escrow_period?: SortOrderInput | SortOrder
    escrow_account_number?: SortOrderInput | SortOrder
    is_escrow_discount?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract?: ClientContractOrderByWithRelationInput
  }

  export type DDUClientContractPropertiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DDUClientContractPropertiesWhereInput | DDUClientContractPropertiesWhereInput[]
    OR?: DDUClientContractPropertiesWhereInput[]
    NOT?: DDUClientContractPropertiesWhereInput | DDUClientContractPropertiesWhereInput[]
    ddu_link?: StringNullableFilter<"DDUClientContractProperties"> | string | null
    return_account?: StringNullableFilter<"DDUClientContractProperties"> | string | null
    escrow_account_opening_date?: DateTimeNullableFilter<"DDUClientContractProperties"> | Date | string | null
    escrow_period?: DateTimeNullableFilter<"DDUClientContractProperties"> | Date | string | null
    escrow_account_number?: StringNullableFilter<"DDUClientContractProperties"> | string | null
    is_escrow_discount?: BoolNullableFilter<"DDUClientContractProperties"> | boolean | null
    created_at?: DateTimeFilter<"DDUClientContractProperties"> | Date | string
    updated_at?: DateTimeFilter<"DDUClientContractProperties"> | Date | string
    client_contract?: XOR<ClientContractNullableRelationFilter, ClientContractWhereInput> | null
  }, "id">

  export type DDUClientContractPropertiesOrderByWithAggregationInput = {
    id?: SortOrder
    ddu_link?: SortOrderInput | SortOrder
    return_account?: SortOrderInput | SortOrder
    escrow_account_opening_date?: SortOrderInput | SortOrder
    escrow_period?: SortOrderInput | SortOrder
    escrow_account_number?: SortOrderInput | SortOrder
    is_escrow_discount?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DDUClientContractPropertiesCountOrderByAggregateInput
    _avg?: DDUClientContractPropertiesAvgOrderByAggregateInput
    _max?: DDUClientContractPropertiesMaxOrderByAggregateInput
    _min?: DDUClientContractPropertiesMinOrderByAggregateInput
    _sum?: DDUClientContractPropertiesSumOrderByAggregateInput
  }

  export type DDUClientContractPropertiesScalarWhereWithAggregatesInput = {
    AND?: DDUClientContractPropertiesScalarWhereWithAggregatesInput | DDUClientContractPropertiesScalarWhereWithAggregatesInput[]
    OR?: DDUClientContractPropertiesScalarWhereWithAggregatesInput[]
    NOT?: DDUClientContractPropertiesScalarWhereWithAggregatesInput | DDUClientContractPropertiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DDUClientContractProperties"> | number
    ddu_link?: StringNullableWithAggregatesFilter<"DDUClientContractProperties"> | string | null
    return_account?: StringNullableWithAggregatesFilter<"DDUClientContractProperties"> | string | null
    escrow_account_opening_date?: DateTimeNullableWithAggregatesFilter<"DDUClientContractProperties"> | Date | string | null
    escrow_period?: DateTimeNullableWithAggregatesFilter<"DDUClientContractProperties"> | Date | string | null
    escrow_account_number?: StringNullableWithAggregatesFilter<"DDUClientContractProperties"> | string | null
    is_escrow_discount?: BoolNullableWithAggregatesFilter<"DDUClientContractProperties"> | boolean | null
    created_at?: DateTimeWithAggregatesFilter<"DDUClientContractProperties"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"DDUClientContractProperties"> | Date | string
  }

  export type ClientContractToAgencyContractWhereInput = {
    AND?: ClientContractToAgencyContractWhereInput | ClientContractToAgencyContractWhereInput[]
    OR?: ClientContractToAgencyContractWhereInput[]
    NOT?: ClientContractToAgencyContractWhereInput | ClientContractToAgencyContractWhereInput[]
    created_at?: DateTimeFilter<"ClientContractToAgencyContract"> | Date | string
    updated_at?: DateTimeFilter<"ClientContractToAgencyContract"> | Date | string
    client_contract_id?: IntFilter<"ClientContractToAgencyContract"> | number
    agency_contract_id?: IntFilter<"ClientContractToAgencyContract"> | number
    client_contract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
    agency_contract?: XOR<AgencyContractRelationFilter, AgencyContractWhereInput>
  }

  export type ClientContractToAgencyContractOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
    agency_contract_id?: SortOrder
    client_contract?: ClientContractOrderByWithRelationInput
    agency_contract?: AgencyContractOrderByWithRelationInput
  }

  export type ClientContractToAgencyContractWhereUniqueInput = Prisma.AtLeast<{
    client_contract_id_agency_contract_id?: ClientContractToAgencyContractClient_contract_idAgency_contract_idCompoundUniqueInput
    AND?: ClientContractToAgencyContractWhereInput | ClientContractToAgencyContractWhereInput[]
    OR?: ClientContractToAgencyContractWhereInput[]
    NOT?: ClientContractToAgencyContractWhereInput | ClientContractToAgencyContractWhereInput[]
    created_at?: DateTimeFilter<"ClientContractToAgencyContract"> | Date | string
    updated_at?: DateTimeFilter<"ClientContractToAgencyContract"> | Date | string
    client_contract_id?: IntFilter<"ClientContractToAgencyContract"> | number
    agency_contract_id?: IntFilter<"ClientContractToAgencyContract"> | number
    client_contract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
    agency_contract?: XOR<AgencyContractRelationFilter, AgencyContractWhereInput>
  }, "client_contract_id_agency_contract_id">

  export type ClientContractToAgencyContractOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
    agency_contract_id?: SortOrder
    _count?: ClientContractToAgencyContractCountOrderByAggregateInput
    _avg?: ClientContractToAgencyContractAvgOrderByAggregateInput
    _max?: ClientContractToAgencyContractMaxOrderByAggregateInput
    _min?: ClientContractToAgencyContractMinOrderByAggregateInput
    _sum?: ClientContractToAgencyContractSumOrderByAggregateInput
  }

  export type ClientContractToAgencyContractScalarWhereWithAggregatesInput = {
    AND?: ClientContractToAgencyContractScalarWhereWithAggregatesInput | ClientContractToAgencyContractScalarWhereWithAggregatesInput[]
    OR?: ClientContractToAgencyContractScalarWhereWithAggregatesInput[]
    NOT?: ClientContractToAgencyContractScalarWhereWithAggregatesInput | ClientContractToAgencyContractScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"ClientContractToAgencyContract"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ClientContractToAgencyContract"> | Date | string
    client_contract_id?: IntWithAggregatesFilter<"ClientContractToAgencyContract"> | number
    agency_contract_id?: IntWithAggregatesFilter<"ClientContractToAgencyContract"> | number
  }

  export type ClientContractToClientWhereInput = {
    AND?: ClientContractToClientWhereInput | ClientContractToClientWhereInput[]
    OR?: ClientContractToClientWhereInput[]
    NOT?: ClientContractToClientWhereInput | ClientContractToClientWhereInput[]
    is_main?: BoolFilter<"ClientContractToClient"> | boolean
    share?: IntFilter<"ClientContractToClient"> | number
    created_at?: DateTimeFilter<"ClientContractToClient"> | Date | string
    updated_at?: DateTimeFilter<"ClientContractToClient"> | Date | string
    client_contract_id?: IntFilter<"ClientContractToClient"> | number
    client_id?: IntFilter<"ClientContractToClient"> | number
    client_contract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
    client?: XOR<ClientRelationFilter, ClientWhereInput>
  }

  export type ClientContractToClientOrderByWithRelationInput = {
    is_main?: SortOrder
    share?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
    client_id?: SortOrder
    client_contract?: ClientContractOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
  }

  export type ClientContractToClientWhereUniqueInput = Prisma.AtLeast<{
    client_contract_id_client_id?: ClientContractToClientClient_contract_idClient_idCompoundUniqueInput
    AND?: ClientContractToClientWhereInput | ClientContractToClientWhereInput[]
    OR?: ClientContractToClientWhereInput[]
    NOT?: ClientContractToClientWhereInput | ClientContractToClientWhereInput[]
    is_main?: BoolFilter<"ClientContractToClient"> | boolean
    share?: IntFilter<"ClientContractToClient"> | number
    created_at?: DateTimeFilter<"ClientContractToClient"> | Date | string
    updated_at?: DateTimeFilter<"ClientContractToClient"> | Date | string
    client_contract_id?: IntFilter<"ClientContractToClient"> | number
    client_id?: IntFilter<"ClientContractToClient"> | number
    client_contract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
    client?: XOR<ClientRelationFilter, ClientWhereInput>
  }, "client_contract_id_client_id">

  export type ClientContractToClientOrderByWithAggregationInput = {
    is_main?: SortOrder
    share?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
    client_id?: SortOrder
    _count?: ClientContractToClientCountOrderByAggregateInput
    _avg?: ClientContractToClientAvgOrderByAggregateInput
    _max?: ClientContractToClientMaxOrderByAggregateInput
    _min?: ClientContractToClientMinOrderByAggregateInput
    _sum?: ClientContractToClientSumOrderByAggregateInput
  }

  export type ClientContractToClientScalarWhereWithAggregatesInput = {
    AND?: ClientContractToClientScalarWhereWithAggregatesInput | ClientContractToClientScalarWhereWithAggregatesInput[]
    OR?: ClientContractToClientScalarWhereWithAggregatesInput[]
    NOT?: ClientContractToClientScalarWhereWithAggregatesInput | ClientContractToClientScalarWhereWithAggregatesInput[]
    is_main?: BoolWithAggregatesFilter<"ClientContractToClient"> | boolean
    share?: IntWithAggregatesFilter<"ClientContractToClient"> | number
    created_at?: DateTimeWithAggregatesFilter<"ClientContractToClient"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ClientContractToClient"> | Date | string
    client_contract_id?: IntWithAggregatesFilter<"ClientContractToClient"> | number
    client_id?: IntWithAggregatesFilter<"ClientContractToClient"> | number
  }

  export type ScheduledPaymentWhereInput = {
    AND?: ScheduledPaymentWhereInput | ScheduledPaymentWhereInput[]
    OR?: ScheduledPaymentWhereInput[]
    NOT?: ScheduledPaymentWhereInput | ScheduledPaymentWhereInput[]
    id?: IntFilter<"ScheduledPayment"> | number
    payment?: DecimalFilter<"ScheduledPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"ScheduledPayment"> | Date | string
    scheduled_payment_type?: EnumScheduledPaymentTypeFilter<"ScheduledPayment"> | $Enums.ScheduledPaymentType
    created_at?: DateTimeFilter<"ScheduledPayment"> | Date | string
    updated_at?: DateTimeFilter<"ScheduledPayment"> | Date | string
    client_contract_id?: IntFilter<"ScheduledPayment"> | number
    client_contract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
  }

  export type ScheduledPaymentOrderByWithRelationInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    scheduled_payment_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
    client_contract?: ClientContractOrderByWithRelationInput
  }

  export type ScheduledPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ScheduledPaymentWhereInput | ScheduledPaymentWhereInput[]
    OR?: ScheduledPaymentWhereInput[]
    NOT?: ScheduledPaymentWhereInput | ScheduledPaymentWhereInput[]
    payment?: DecimalFilter<"ScheduledPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"ScheduledPayment"> | Date | string
    scheduled_payment_type?: EnumScheduledPaymentTypeFilter<"ScheduledPayment"> | $Enums.ScheduledPaymentType
    created_at?: DateTimeFilter<"ScheduledPayment"> | Date | string
    updated_at?: DateTimeFilter<"ScheduledPayment"> | Date | string
    client_contract_id?: IntFilter<"ScheduledPayment"> | number
    client_contract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
  }, "id">

  export type ScheduledPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    scheduled_payment_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
    _count?: ScheduledPaymentCountOrderByAggregateInput
    _avg?: ScheduledPaymentAvgOrderByAggregateInput
    _max?: ScheduledPaymentMaxOrderByAggregateInput
    _min?: ScheduledPaymentMinOrderByAggregateInput
    _sum?: ScheduledPaymentSumOrderByAggregateInput
  }

  export type ScheduledPaymentScalarWhereWithAggregatesInput = {
    AND?: ScheduledPaymentScalarWhereWithAggregatesInput | ScheduledPaymentScalarWhereWithAggregatesInput[]
    OR?: ScheduledPaymentScalarWhereWithAggregatesInput[]
    NOT?: ScheduledPaymentScalarWhereWithAggregatesInput | ScheduledPaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ScheduledPayment"> | number
    payment?: DecimalWithAggregatesFilter<"ScheduledPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeWithAggregatesFilter<"ScheduledPayment"> | Date | string
    scheduled_payment_type?: EnumScheduledPaymentTypeWithAggregatesFilter<"ScheduledPayment"> | $Enums.ScheduledPaymentType
    created_at?: DateTimeWithAggregatesFilter<"ScheduledPayment"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ScheduledPayment"> | Date | string
    client_contract_id?: IntWithAggregatesFilter<"ScheduledPayment"> | number
  }

  export type ActualPaymentWhereInput = {
    AND?: ActualPaymentWhereInput | ActualPaymentWhereInput[]
    OR?: ActualPaymentWhereInput[]
    NOT?: ActualPaymentWhereInput | ActualPaymentWhereInput[]
    id?: IntFilter<"ActualPayment"> | number
    payment?: DecimalFilter<"ActualPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"ActualPayment"> | Date | string
    created_at?: DateTimeFilter<"ActualPayment"> | Date | string
    updated_at?: DateTimeFilter<"ActualPayment"> | Date | string
    client_contract_id?: IntFilter<"ActualPayment"> | number
    client_contract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
  }

  export type ActualPaymentOrderByWithRelationInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
    client_contract?: ClientContractOrderByWithRelationInput
  }

  export type ActualPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ActualPaymentWhereInput | ActualPaymentWhereInput[]
    OR?: ActualPaymentWhereInput[]
    NOT?: ActualPaymentWhereInput | ActualPaymentWhereInput[]
    payment?: DecimalFilter<"ActualPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"ActualPayment"> | Date | string
    created_at?: DateTimeFilter<"ActualPayment"> | Date | string
    updated_at?: DateTimeFilter<"ActualPayment"> | Date | string
    client_contract_id?: IntFilter<"ActualPayment"> | number
    client_contract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
  }, "id">

  export type ActualPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
    _count?: ActualPaymentCountOrderByAggregateInput
    _avg?: ActualPaymentAvgOrderByAggregateInput
    _max?: ActualPaymentMaxOrderByAggregateInput
    _min?: ActualPaymentMinOrderByAggregateInput
    _sum?: ActualPaymentSumOrderByAggregateInput
  }

  export type ActualPaymentScalarWhereWithAggregatesInput = {
    AND?: ActualPaymentScalarWhereWithAggregatesInput | ActualPaymentScalarWhereWithAggregatesInput[]
    OR?: ActualPaymentScalarWhereWithAggregatesInput[]
    NOT?: ActualPaymentScalarWhereWithAggregatesInput | ActualPaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActualPayment"> | number
    payment?: DecimalWithAggregatesFilter<"ActualPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeWithAggregatesFilter<"ActualPayment"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"ActualPayment"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ActualPayment"> | Date | string
    client_contract_id?: IntWithAggregatesFilter<"ActualPayment"> | number
  }

  export type ObjectWhereInput = {
    AND?: ObjectWhereInput | ObjectWhereInput[]
    OR?: ObjectWhereInput[]
    NOT?: ObjectWhereInput | ObjectWhereInput[]
    id?: IntFilter<"Object"> | number
    common_db_objects_id?: IntFilter<"Object"> | number
    name?: StringFilter<"Object"> | string
    created_at?: DateTimeFilter<"Object"> | Date | string
    updated_at?: DateTimeFilter<"Object"> | Date | string
    entity_id?: IntFilter<"Object"> | number
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
    products?: ProductListRelationFilter
    client_contracts?: ClientContractListRelationFilter
    agency_contracts?: AgencyContractListRelationFilter
  }

  export type ObjectOrderByWithRelationInput = {
    id?: SortOrder
    common_db_objects_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    entity_id?: SortOrder
    entity?: EntityOrderByWithRelationInput
    products?: ProductOrderByRelationAggregateInput
    client_contracts?: ClientContractOrderByRelationAggregateInput
    agency_contracts?: AgencyContractOrderByRelationAggregateInput
  }

  export type ObjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    common_db_objects_id?: number
    AND?: ObjectWhereInput | ObjectWhereInput[]
    OR?: ObjectWhereInput[]
    NOT?: ObjectWhereInput | ObjectWhereInput[]
    name?: StringFilter<"Object"> | string
    created_at?: DateTimeFilter<"Object"> | Date | string
    updated_at?: DateTimeFilter<"Object"> | Date | string
    entity_id?: IntFilter<"Object"> | number
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
    products?: ProductListRelationFilter
    client_contracts?: ClientContractListRelationFilter
    agency_contracts?: AgencyContractListRelationFilter
  }, "id" | "common_db_objects_id">

  export type ObjectOrderByWithAggregationInput = {
    id?: SortOrder
    common_db_objects_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    entity_id?: SortOrder
    _count?: ObjectCountOrderByAggregateInput
    _avg?: ObjectAvgOrderByAggregateInput
    _max?: ObjectMaxOrderByAggregateInput
    _min?: ObjectMinOrderByAggregateInput
    _sum?: ObjectSumOrderByAggregateInput
  }

  export type ObjectScalarWhereWithAggregatesInput = {
    AND?: ObjectScalarWhereWithAggregatesInput | ObjectScalarWhereWithAggregatesInput[]
    OR?: ObjectScalarWhereWithAggregatesInput[]
    NOT?: ObjectScalarWhereWithAggregatesInput | ObjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Object"> | number
    common_db_objects_id?: IntWithAggregatesFilter<"Object"> | number
    name?: StringWithAggregatesFilter<"Object"> | string
    created_at?: DateTimeWithAggregatesFilter<"Object"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Object"> | Date | string
    entity_id?: IntWithAggregatesFilter<"Object"> | number
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    pricing_products_id?: IntFilter<"Product"> | number
    number?: StringFilter<"Product"> | string
    product_category?: EnumProductCategoryFilter<"Product"> | $Enums.ProductCategory
    created_at?: DateTimeFilter<"Product"> | Date | string
    updated_at?: DateTimeFilter<"Product"> | Date | string
    object_id?: IntFilter<"Product"> | number
    client_contract?: XOR<ClientContractNullableRelationFilter, ClientContractWhereInput> | null
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    pricing_products_id?: SortOrder
    number?: SortOrder
    product_category?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    object_id?: SortOrder
    client_contract?: ClientContractOrderByWithRelationInput
    object?: ObjectOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    pricing_products_id?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    number?: StringFilter<"Product"> | string
    product_category?: EnumProductCategoryFilter<"Product"> | $Enums.ProductCategory
    created_at?: DateTimeFilter<"Product"> | Date | string
    updated_at?: DateTimeFilter<"Product"> | Date | string
    object_id?: IntFilter<"Product"> | number
    client_contract?: XOR<ClientContractNullableRelationFilter, ClientContractWhereInput> | null
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
  }, "id" | "pricing_products_id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    pricing_products_id?: SortOrder
    number?: SortOrder
    product_category?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    object_id?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    pricing_products_id?: IntWithAggregatesFilter<"Product"> | number
    number?: StringWithAggregatesFilter<"Product"> | string
    product_category?: EnumProductCategoryWithAggregatesFilter<"Product"> | $Enums.ProductCategory
    created_at?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    object_id?: IntWithAggregatesFilter<"Product"> | number
  }

  export type AgencyWhereInput = {
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    id?: IntFilter<"Agency"> | number
    common_db_contractors_id?: IntFilter<"Agency"> | number
    name?: StringFilter<"Agency"> | string
    inn?: StringNullableFilter<"Agency"> | string | null
    created_at?: DateTimeFilter<"Agency"> | Date | string
    updated_at?: DateTimeFilter<"Agency"> | Date | string
    agency_contracts?: AgencyContractListRelationFilter
    real_estate_agents?: AgencyToRealEstateAgentListRelationFilter
    agency_contract_signatory?: AgencyContractSignatoryListRelationFilter
  }

  export type AgencyOrderByWithRelationInput = {
    id?: SortOrder
    common_db_contractors_id?: SortOrder
    name?: SortOrder
    inn?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_contracts?: AgencyContractOrderByRelationAggregateInput
    real_estate_agents?: AgencyToRealEstateAgentOrderByRelationAggregateInput
    agency_contract_signatory?: AgencyContractSignatoryOrderByRelationAggregateInput
  }

  export type AgencyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    common_db_contractors_id?: number
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    name?: StringFilter<"Agency"> | string
    inn?: StringNullableFilter<"Agency"> | string | null
    created_at?: DateTimeFilter<"Agency"> | Date | string
    updated_at?: DateTimeFilter<"Agency"> | Date | string
    agency_contracts?: AgencyContractListRelationFilter
    real_estate_agents?: AgencyToRealEstateAgentListRelationFilter
    agency_contract_signatory?: AgencyContractSignatoryListRelationFilter
  }, "id" | "common_db_contractors_id">

  export type AgencyOrderByWithAggregationInput = {
    id?: SortOrder
    common_db_contractors_id?: SortOrder
    name?: SortOrder
    inn?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AgencyCountOrderByAggregateInput
    _avg?: AgencyAvgOrderByAggregateInput
    _max?: AgencyMaxOrderByAggregateInput
    _min?: AgencyMinOrderByAggregateInput
    _sum?: AgencySumOrderByAggregateInput
  }

  export type AgencyScalarWhereWithAggregatesInput = {
    AND?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    OR?: AgencyScalarWhereWithAggregatesInput[]
    NOT?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Agency"> | number
    common_db_contractors_id?: IntWithAggregatesFilter<"Agency"> | number
    name?: StringWithAggregatesFilter<"Agency"> | string
    inn?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
  }

  export type AgencyContractWhereInput = {
    AND?: AgencyContractWhereInput | AgencyContractWhereInput[]
    OR?: AgencyContractWhereInput[]
    NOT?: AgencyContractWhereInput | AgencyContractWhereInput[]
    id?: IntFilter<"AgencyContract"> | number
    number?: StringFilter<"AgencyContract"> | string
    date?: DateTimeFilter<"AgencyContract"> | Date | string
    agency_contract_type?: EnumAgencyContractTypeFilter<"AgencyContract"> | $Enums.AgencyContractType
    created_at?: DateTimeFilter<"AgencyContract"> | Date | string
    updated_at?: DateTimeFilter<"AgencyContract"> | Date | string
    responsible_user_id?: IntNullableFilter<"AgencyContract"> | number | null
    entity_id?: IntFilter<"AgencyContract"> | number
    object_id?: IntFilter<"AgencyContract"> | number
    agency_id?: IntFilter<"AgencyContract"> | number
    agency_contract_signatory_id?: IntNullableFilter<"AgencyContract"> | number | null
    real_estate_agency_contract_properties_id?: IntNullableFilter<"AgencyContract"> | number | null
    mip_agency_contract_properties_id?: IntNullableFilter<"AgencyContract"> | number | null
    responsible_user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
    agency?: XOR<AgencyRelationFilter, AgencyWhereInput>
    agency_contract_signatory?: XOR<AgencyContractSignatoryNullableRelationFilter, AgencyContractSignatoryWhereInput> | null
    real_estate_agency_contract_properties?: XOR<RealEstateAgencyContractPropertiesNullableRelationFilter, RealEstateAgencyContractPropertiesWhereInput> | null
    mip_agency_contract_properties?: XOR<MIPAgencyContractPropertiesNullableRelationFilter, MIPAgencyContractPropertiesWhereInput> | null
    client_contracts?: ClientContractToAgencyContractListRelationFilter
  }

  export type AgencyContractOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    agency_contract_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    responsible_user_id?: SortOrderInput | SortOrder
    entity_id?: SortOrder
    object_id?: SortOrder
    agency_id?: SortOrder
    agency_contract_signatory_id?: SortOrderInput | SortOrder
    real_estate_agency_contract_properties_id?: SortOrderInput | SortOrder
    mip_agency_contract_properties_id?: SortOrderInput | SortOrder
    responsible_user?: UserOrderByWithRelationInput
    entity?: EntityOrderByWithRelationInput
    object?: ObjectOrderByWithRelationInput
    agency?: AgencyOrderByWithRelationInput
    agency_contract_signatory?: AgencyContractSignatoryOrderByWithRelationInput
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesOrderByWithRelationInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesOrderByWithRelationInput
    client_contracts?: ClientContractToAgencyContractOrderByRelationAggregateInput
  }

  export type AgencyContractWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    real_estate_agency_contract_properties_id?: number
    mip_agency_contract_properties_id?: number
    AND?: AgencyContractWhereInput | AgencyContractWhereInput[]
    OR?: AgencyContractWhereInput[]
    NOT?: AgencyContractWhereInput | AgencyContractWhereInput[]
    number?: StringFilter<"AgencyContract"> | string
    date?: DateTimeFilter<"AgencyContract"> | Date | string
    agency_contract_type?: EnumAgencyContractTypeFilter<"AgencyContract"> | $Enums.AgencyContractType
    created_at?: DateTimeFilter<"AgencyContract"> | Date | string
    updated_at?: DateTimeFilter<"AgencyContract"> | Date | string
    responsible_user_id?: IntNullableFilter<"AgencyContract"> | number | null
    entity_id?: IntFilter<"AgencyContract"> | number
    object_id?: IntFilter<"AgencyContract"> | number
    agency_id?: IntFilter<"AgencyContract"> | number
    agency_contract_signatory_id?: IntNullableFilter<"AgencyContract"> | number | null
    responsible_user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
    agency?: XOR<AgencyRelationFilter, AgencyWhereInput>
    agency_contract_signatory?: XOR<AgencyContractSignatoryNullableRelationFilter, AgencyContractSignatoryWhereInput> | null
    real_estate_agency_contract_properties?: XOR<RealEstateAgencyContractPropertiesNullableRelationFilter, RealEstateAgencyContractPropertiesWhereInput> | null
    mip_agency_contract_properties?: XOR<MIPAgencyContractPropertiesNullableRelationFilter, MIPAgencyContractPropertiesWhereInput> | null
    client_contracts?: ClientContractToAgencyContractListRelationFilter
  }, "id" | "real_estate_agency_contract_properties_id" | "mip_agency_contract_properties_id">

  export type AgencyContractOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    agency_contract_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    responsible_user_id?: SortOrderInput | SortOrder
    entity_id?: SortOrder
    object_id?: SortOrder
    agency_id?: SortOrder
    agency_contract_signatory_id?: SortOrderInput | SortOrder
    real_estate_agency_contract_properties_id?: SortOrderInput | SortOrder
    mip_agency_contract_properties_id?: SortOrderInput | SortOrder
    _count?: AgencyContractCountOrderByAggregateInput
    _avg?: AgencyContractAvgOrderByAggregateInput
    _max?: AgencyContractMaxOrderByAggregateInput
    _min?: AgencyContractMinOrderByAggregateInput
    _sum?: AgencyContractSumOrderByAggregateInput
  }

  export type AgencyContractScalarWhereWithAggregatesInput = {
    AND?: AgencyContractScalarWhereWithAggregatesInput | AgencyContractScalarWhereWithAggregatesInput[]
    OR?: AgencyContractScalarWhereWithAggregatesInput[]
    NOT?: AgencyContractScalarWhereWithAggregatesInput | AgencyContractScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AgencyContract"> | number
    number?: StringWithAggregatesFilter<"AgencyContract"> | string
    date?: DateTimeWithAggregatesFilter<"AgencyContract"> | Date | string
    agency_contract_type?: EnumAgencyContractTypeWithAggregatesFilter<"AgencyContract"> | $Enums.AgencyContractType
    created_at?: DateTimeWithAggregatesFilter<"AgencyContract"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"AgencyContract"> | Date | string
    responsible_user_id?: IntNullableWithAggregatesFilter<"AgencyContract"> | number | null
    entity_id?: IntWithAggregatesFilter<"AgencyContract"> | number
    object_id?: IntWithAggregatesFilter<"AgencyContract"> | number
    agency_id?: IntWithAggregatesFilter<"AgencyContract"> | number
    agency_contract_signatory_id?: IntNullableWithAggregatesFilter<"AgencyContract"> | number | null
    real_estate_agency_contract_properties_id?: IntNullableWithAggregatesFilter<"AgencyContract"> | number | null
    mip_agency_contract_properties_id?: IntNullableWithAggregatesFilter<"AgencyContract"> | number | null
  }

  export type AgencyContractSignatoryWhereInput = {
    AND?: AgencyContractSignatoryWhereInput | AgencyContractSignatoryWhereInput[]
    OR?: AgencyContractSignatoryWhereInput[]
    NOT?: AgencyContractSignatoryWhereInput | AgencyContractSignatoryWhereInput[]
    id?: IntFilter<"AgencyContractSignatory"> | number
    full_name?: StringFilter<"AgencyContractSignatory"> | string
    email?: StringFilter<"AgencyContractSignatory"> | string
    phone?: StringFilter<"AgencyContractSignatory"> | string
    title?: StringFilter<"AgencyContractSignatory"> | string
    based_on?: StringFilter<"AgencyContractSignatory"> | string
    created_at?: DateTimeFilter<"AgencyContractSignatory"> | Date | string
    updated_at?: DateTimeFilter<"AgencyContractSignatory"> | Date | string
    agency_id?: IntFilter<"AgencyContractSignatory"> | number
    agency?: XOR<AgencyRelationFilter, AgencyWhereInput>
    agency_contract?: AgencyContractListRelationFilter
  }

  export type AgencyContractSignatoryOrderByWithRelationInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    title?: SortOrder
    based_on?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_id?: SortOrder
    agency?: AgencyOrderByWithRelationInput
    agency_contract?: AgencyContractOrderByRelationAggregateInput
  }

  export type AgencyContractSignatoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AgencyContractSignatoryWhereInput | AgencyContractSignatoryWhereInput[]
    OR?: AgencyContractSignatoryWhereInput[]
    NOT?: AgencyContractSignatoryWhereInput | AgencyContractSignatoryWhereInput[]
    full_name?: StringFilter<"AgencyContractSignatory"> | string
    email?: StringFilter<"AgencyContractSignatory"> | string
    phone?: StringFilter<"AgencyContractSignatory"> | string
    title?: StringFilter<"AgencyContractSignatory"> | string
    based_on?: StringFilter<"AgencyContractSignatory"> | string
    created_at?: DateTimeFilter<"AgencyContractSignatory"> | Date | string
    updated_at?: DateTimeFilter<"AgencyContractSignatory"> | Date | string
    agency_id?: IntFilter<"AgencyContractSignatory"> | number
    agency?: XOR<AgencyRelationFilter, AgencyWhereInput>
    agency_contract?: AgencyContractListRelationFilter
  }, "id">

  export type AgencyContractSignatoryOrderByWithAggregationInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    title?: SortOrder
    based_on?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_id?: SortOrder
    _count?: AgencyContractSignatoryCountOrderByAggregateInput
    _avg?: AgencyContractSignatoryAvgOrderByAggregateInput
    _max?: AgencyContractSignatoryMaxOrderByAggregateInput
    _min?: AgencyContractSignatoryMinOrderByAggregateInput
    _sum?: AgencyContractSignatorySumOrderByAggregateInput
  }

  export type AgencyContractSignatoryScalarWhereWithAggregatesInput = {
    AND?: AgencyContractSignatoryScalarWhereWithAggregatesInput | AgencyContractSignatoryScalarWhereWithAggregatesInput[]
    OR?: AgencyContractSignatoryScalarWhereWithAggregatesInput[]
    NOT?: AgencyContractSignatoryScalarWhereWithAggregatesInput | AgencyContractSignatoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AgencyContractSignatory"> | number
    full_name?: StringWithAggregatesFilter<"AgencyContractSignatory"> | string
    email?: StringWithAggregatesFilter<"AgencyContractSignatory"> | string
    phone?: StringWithAggregatesFilter<"AgencyContractSignatory"> | string
    title?: StringWithAggregatesFilter<"AgencyContractSignatory"> | string
    based_on?: StringWithAggregatesFilter<"AgencyContractSignatory"> | string
    created_at?: DateTimeWithAggregatesFilter<"AgencyContractSignatory"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"AgencyContractSignatory"> | Date | string
    agency_id?: IntWithAggregatesFilter<"AgencyContractSignatory"> | number
  }

  export type RealEstateAgencyContractPropertiesWhereInput = {
    AND?: RealEstateAgencyContractPropertiesWhereInput | RealEstateAgencyContractPropertiesWhereInput[]
    OR?: RealEstateAgencyContractPropertiesWhereInput[]
    NOT?: RealEstateAgencyContractPropertiesWhereInput | RealEstateAgencyContractPropertiesWhereInput[]
    id?: IntFilter<"RealEstateAgencyContractProperties"> | number
    created_at?: DateTimeFilter<"RealEstateAgencyContractProperties"> | Date | string
    updated_at?: DateTimeFilter<"RealEstateAgencyContractProperties"> | Date | string
    agency_contract_commission_id?: IntFilter<"RealEstateAgencyContractProperties"> | number
    agency_contract?: XOR<AgencyContractNullableRelationFilter, AgencyContractWhereInput> | null
    agency_contract_commission?: XOR<AgencyContractCommissionRelationFilter, AgencyContractCommissionWhereInput>
  }

  export type RealEstateAgencyContractPropertiesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_contract_commission_id?: SortOrder
    agency_contract?: AgencyContractOrderByWithRelationInput
    agency_contract_commission?: AgencyContractCommissionOrderByWithRelationInput
  }

  export type RealEstateAgencyContractPropertiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    agency_contract_commission_id?: number
    AND?: RealEstateAgencyContractPropertiesWhereInput | RealEstateAgencyContractPropertiesWhereInput[]
    OR?: RealEstateAgencyContractPropertiesWhereInput[]
    NOT?: RealEstateAgencyContractPropertiesWhereInput | RealEstateAgencyContractPropertiesWhereInput[]
    created_at?: DateTimeFilter<"RealEstateAgencyContractProperties"> | Date | string
    updated_at?: DateTimeFilter<"RealEstateAgencyContractProperties"> | Date | string
    agency_contract?: XOR<AgencyContractNullableRelationFilter, AgencyContractWhereInput> | null
    agency_contract_commission?: XOR<AgencyContractCommissionRelationFilter, AgencyContractCommissionWhereInput>
  }, "id" | "agency_contract_commission_id">

  export type RealEstateAgencyContractPropertiesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_contract_commission_id?: SortOrder
    _count?: RealEstateAgencyContractPropertiesCountOrderByAggregateInput
    _avg?: RealEstateAgencyContractPropertiesAvgOrderByAggregateInput
    _max?: RealEstateAgencyContractPropertiesMaxOrderByAggregateInput
    _min?: RealEstateAgencyContractPropertiesMinOrderByAggregateInput
    _sum?: RealEstateAgencyContractPropertiesSumOrderByAggregateInput
  }

  export type RealEstateAgencyContractPropertiesScalarWhereWithAggregatesInput = {
    AND?: RealEstateAgencyContractPropertiesScalarWhereWithAggregatesInput | RealEstateAgencyContractPropertiesScalarWhereWithAggregatesInput[]
    OR?: RealEstateAgencyContractPropertiesScalarWhereWithAggregatesInput[]
    NOT?: RealEstateAgencyContractPropertiesScalarWhereWithAggregatesInput | RealEstateAgencyContractPropertiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RealEstateAgencyContractProperties"> | number
    created_at?: DateTimeWithAggregatesFilter<"RealEstateAgencyContractProperties"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"RealEstateAgencyContractProperties"> | Date | string
    agency_contract_commission_id?: IntWithAggregatesFilter<"RealEstateAgencyContractProperties"> | number
  }

  export type MIPAgencyContractPropertiesWhereInput = {
    AND?: MIPAgencyContractPropertiesWhereInput | MIPAgencyContractPropertiesWhereInput[]
    OR?: MIPAgencyContractPropertiesWhereInput[]
    NOT?: MIPAgencyContractPropertiesWhereInput | MIPAgencyContractPropertiesWhereInput[]
    id?: IntFilter<"MIPAgencyContractProperties"> | number
    created_at?: DateTimeFilter<"MIPAgencyContractProperties"> | Date | string
    updated_at?: DateTimeFilter<"MIPAgencyContractProperties"> | Date | string
    agency_contract_commission_id?: IntFilter<"MIPAgencyContractProperties"> | number
    agency_contract?: XOR<AgencyContractNullableRelationFilter, AgencyContractWhereInput> | null
    agency_contract_commission?: XOR<AgencyContractCommissionRelationFilter, AgencyContractCommissionWhereInput>
  }

  export type MIPAgencyContractPropertiesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_contract_commission_id?: SortOrder
    agency_contract?: AgencyContractOrderByWithRelationInput
    agency_contract_commission?: AgencyContractCommissionOrderByWithRelationInput
  }

  export type MIPAgencyContractPropertiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    agency_contract_commission_id?: number
    AND?: MIPAgencyContractPropertiesWhereInput | MIPAgencyContractPropertiesWhereInput[]
    OR?: MIPAgencyContractPropertiesWhereInput[]
    NOT?: MIPAgencyContractPropertiesWhereInput | MIPAgencyContractPropertiesWhereInput[]
    created_at?: DateTimeFilter<"MIPAgencyContractProperties"> | Date | string
    updated_at?: DateTimeFilter<"MIPAgencyContractProperties"> | Date | string
    agency_contract?: XOR<AgencyContractNullableRelationFilter, AgencyContractWhereInput> | null
    agency_contract_commission?: XOR<AgencyContractCommissionRelationFilter, AgencyContractCommissionWhereInput>
  }, "id" | "agency_contract_commission_id">

  export type MIPAgencyContractPropertiesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_contract_commission_id?: SortOrder
    _count?: MIPAgencyContractPropertiesCountOrderByAggregateInput
    _avg?: MIPAgencyContractPropertiesAvgOrderByAggregateInput
    _max?: MIPAgencyContractPropertiesMaxOrderByAggregateInput
    _min?: MIPAgencyContractPropertiesMinOrderByAggregateInput
    _sum?: MIPAgencyContractPropertiesSumOrderByAggregateInput
  }

  export type MIPAgencyContractPropertiesScalarWhereWithAggregatesInput = {
    AND?: MIPAgencyContractPropertiesScalarWhereWithAggregatesInput | MIPAgencyContractPropertiesScalarWhereWithAggregatesInput[]
    OR?: MIPAgencyContractPropertiesScalarWhereWithAggregatesInput[]
    NOT?: MIPAgencyContractPropertiesScalarWhereWithAggregatesInput | MIPAgencyContractPropertiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MIPAgencyContractProperties"> | number
    created_at?: DateTimeWithAggregatesFilter<"MIPAgencyContractProperties"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MIPAgencyContractProperties"> | Date | string
    agency_contract_commission_id?: IntWithAggregatesFilter<"MIPAgencyContractProperties"> | number
  }

  export type AgencyContractCommissionWhereInput = {
    AND?: AgencyContractCommissionWhereInput | AgencyContractCommissionWhereInput[]
    OR?: AgencyContractCommissionWhereInput[]
    NOT?: AgencyContractCommissionWhereInput | AgencyContractCommissionWhereInput[]
    id?: IntFilter<"AgencyContractCommission"> | number
    percent?: DecimalFilter<"AgencyContractCommission"> | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFilter<"AgencyContractCommission"> | Decimal | DecimalJsLike | number | string
    max_days?: IntFilter<"AgencyContractCommission"> | number
    created_at?: DateTimeFilter<"AgencyContractCommission"> | Date | string
    updated_at?: DateTimeFilter<"AgencyContractCommission"> | Date | string
    real_estate_agency_contract_properties?: XOR<RealEstateAgencyContractPropertiesNullableRelationFilter, RealEstateAgencyContractPropertiesWhereInput> | null
    mip_agency_contract_properties?: XOR<MIPAgencyContractPropertiesNullableRelationFilter, MIPAgencyContractPropertiesWhereInput> | null
  }

  export type AgencyContractCommissionOrderByWithRelationInput = {
    id?: SortOrder
    percent?: SortOrder
    threshold?: SortOrder
    max_days?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesOrderByWithRelationInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesOrderByWithRelationInput
  }

  export type AgencyContractCommissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AgencyContractCommissionWhereInput | AgencyContractCommissionWhereInput[]
    OR?: AgencyContractCommissionWhereInput[]
    NOT?: AgencyContractCommissionWhereInput | AgencyContractCommissionWhereInput[]
    percent?: DecimalFilter<"AgencyContractCommission"> | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFilter<"AgencyContractCommission"> | Decimal | DecimalJsLike | number | string
    max_days?: IntFilter<"AgencyContractCommission"> | number
    created_at?: DateTimeFilter<"AgencyContractCommission"> | Date | string
    updated_at?: DateTimeFilter<"AgencyContractCommission"> | Date | string
    real_estate_agency_contract_properties?: XOR<RealEstateAgencyContractPropertiesNullableRelationFilter, RealEstateAgencyContractPropertiesWhereInput> | null
    mip_agency_contract_properties?: XOR<MIPAgencyContractPropertiesNullableRelationFilter, MIPAgencyContractPropertiesWhereInput> | null
  }, "id">

  export type AgencyContractCommissionOrderByWithAggregationInput = {
    id?: SortOrder
    percent?: SortOrder
    threshold?: SortOrder
    max_days?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AgencyContractCommissionCountOrderByAggregateInput
    _avg?: AgencyContractCommissionAvgOrderByAggregateInput
    _max?: AgencyContractCommissionMaxOrderByAggregateInput
    _min?: AgencyContractCommissionMinOrderByAggregateInput
    _sum?: AgencyContractCommissionSumOrderByAggregateInput
  }

  export type AgencyContractCommissionScalarWhereWithAggregatesInput = {
    AND?: AgencyContractCommissionScalarWhereWithAggregatesInput | AgencyContractCommissionScalarWhereWithAggregatesInput[]
    OR?: AgencyContractCommissionScalarWhereWithAggregatesInput[]
    NOT?: AgencyContractCommissionScalarWhereWithAggregatesInput | AgencyContractCommissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AgencyContractCommission"> | number
    percent?: DecimalWithAggregatesFilter<"AgencyContractCommission"> | Decimal | DecimalJsLike | number | string
    threshold?: DecimalWithAggregatesFilter<"AgencyContractCommission"> | Decimal | DecimalJsLike | number | string
    max_days?: IntWithAggregatesFilter<"AgencyContractCommission"> | number
    created_at?: DateTimeWithAggregatesFilter<"AgencyContractCommission"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"AgencyContractCommission"> | Date | string
  }

  export type RealEstateAgentWhereInput = {
    AND?: RealEstateAgentWhereInput | RealEstateAgentWhereInput[]
    OR?: RealEstateAgentWhereInput[]
    NOT?: RealEstateAgentWhereInput | RealEstateAgentWhereInput[]
    id?: IntFilter<"RealEstateAgent"> | number
    full_name?: StringFilter<"RealEstateAgent"> | string
    phone?: StringNullableFilter<"RealEstateAgent"> | string | null
    created_at?: DateTimeFilter<"RealEstateAgent"> | Date | string
    updated_at?: DateTimeFilter<"RealEstateAgent"> | Date | string
    client_contracts?: ClientContractListRelationFilter
    agencies?: AgencyToRealEstateAgentListRelationFilter
  }

  export type RealEstateAgentOrderByWithRelationInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contracts?: ClientContractOrderByRelationAggregateInput
    agencies?: AgencyToRealEstateAgentOrderByRelationAggregateInput
  }

  export type RealEstateAgentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RealEstateAgentWhereInput | RealEstateAgentWhereInput[]
    OR?: RealEstateAgentWhereInput[]
    NOT?: RealEstateAgentWhereInput | RealEstateAgentWhereInput[]
    full_name?: StringFilter<"RealEstateAgent"> | string
    phone?: StringNullableFilter<"RealEstateAgent"> | string | null
    created_at?: DateTimeFilter<"RealEstateAgent"> | Date | string
    updated_at?: DateTimeFilter<"RealEstateAgent"> | Date | string
    client_contracts?: ClientContractListRelationFilter
    agencies?: AgencyToRealEstateAgentListRelationFilter
  }, "id">

  export type RealEstateAgentOrderByWithAggregationInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: RealEstateAgentCountOrderByAggregateInput
    _avg?: RealEstateAgentAvgOrderByAggregateInput
    _max?: RealEstateAgentMaxOrderByAggregateInput
    _min?: RealEstateAgentMinOrderByAggregateInput
    _sum?: RealEstateAgentSumOrderByAggregateInput
  }

  export type RealEstateAgentScalarWhereWithAggregatesInput = {
    AND?: RealEstateAgentScalarWhereWithAggregatesInput | RealEstateAgentScalarWhereWithAggregatesInput[]
    OR?: RealEstateAgentScalarWhereWithAggregatesInput[]
    NOT?: RealEstateAgentScalarWhereWithAggregatesInput | RealEstateAgentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RealEstateAgent"> | number
    full_name?: StringWithAggregatesFilter<"RealEstateAgent"> | string
    phone?: StringNullableWithAggregatesFilter<"RealEstateAgent"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"RealEstateAgent"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"RealEstateAgent"> | Date | string
  }

  export type AgencyToRealEstateAgentWhereInput = {
    AND?: AgencyToRealEstateAgentWhereInput | AgencyToRealEstateAgentWhereInput[]
    OR?: AgencyToRealEstateAgentWhereInput[]
    NOT?: AgencyToRealEstateAgentWhereInput | AgencyToRealEstateAgentWhereInput[]
    created_at?: DateTimeFilter<"AgencyToRealEstateAgent"> | Date | string
    updated_at?: DateTimeFilter<"AgencyToRealEstateAgent"> | Date | string
    agency_id?: IntFilter<"AgencyToRealEstateAgent"> | number
    real_estate_agent_id?: IntFilter<"AgencyToRealEstateAgent"> | number
    agency?: XOR<AgencyRelationFilter, AgencyWhereInput>
    real_estate_agent?: XOR<RealEstateAgentRelationFilter, RealEstateAgentWhereInput>
  }

  export type AgencyToRealEstateAgentOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_id?: SortOrder
    real_estate_agent_id?: SortOrder
    agency?: AgencyOrderByWithRelationInput
    real_estate_agent?: RealEstateAgentOrderByWithRelationInput
  }

  export type AgencyToRealEstateAgentWhereUniqueInput = Prisma.AtLeast<{
    agency_id_real_estate_agent_id?: AgencyToRealEstateAgentAgency_idReal_estate_agent_idCompoundUniqueInput
    AND?: AgencyToRealEstateAgentWhereInput | AgencyToRealEstateAgentWhereInput[]
    OR?: AgencyToRealEstateAgentWhereInput[]
    NOT?: AgencyToRealEstateAgentWhereInput | AgencyToRealEstateAgentWhereInput[]
    created_at?: DateTimeFilter<"AgencyToRealEstateAgent"> | Date | string
    updated_at?: DateTimeFilter<"AgencyToRealEstateAgent"> | Date | string
    agency_id?: IntFilter<"AgencyToRealEstateAgent"> | number
    real_estate_agent_id?: IntFilter<"AgencyToRealEstateAgent"> | number
    agency?: XOR<AgencyRelationFilter, AgencyWhereInput>
    real_estate_agent?: XOR<RealEstateAgentRelationFilter, RealEstateAgentWhereInput>
  }, "agency_id_real_estate_agent_id">

  export type AgencyToRealEstateAgentOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_id?: SortOrder
    real_estate_agent_id?: SortOrder
    _count?: AgencyToRealEstateAgentCountOrderByAggregateInput
    _avg?: AgencyToRealEstateAgentAvgOrderByAggregateInput
    _max?: AgencyToRealEstateAgentMaxOrderByAggregateInput
    _min?: AgencyToRealEstateAgentMinOrderByAggregateInput
    _sum?: AgencyToRealEstateAgentSumOrderByAggregateInput
  }

  export type AgencyToRealEstateAgentScalarWhereWithAggregatesInput = {
    AND?: AgencyToRealEstateAgentScalarWhereWithAggregatesInput | AgencyToRealEstateAgentScalarWhereWithAggregatesInput[]
    OR?: AgencyToRealEstateAgentScalarWhereWithAggregatesInput[]
    NOT?: AgencyToRealEstateAgentScalarWhereWithAggregatesInput | AgencyToRealEstateAgentScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"AgencyToRealEstateAgent"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"AgencyToRealEstateAgent"> | Date | string
    agency_id?: IntWithAggregatesFilter<"AgencyToRealEstateAgent"> | number
    real_estate_agent_id?: IntWithAggregatesFilter<"AgencyToRealEstateAgent"> | number
  }

  export type EntityWhereInput = {
    AND?: EntityWhereInput | EntityWhereInput[]
    OR?: EntityWhereInput[]
    NOT?: EntityWhereInput | EntityWhereInput[]
    id?: IntFilter<"Entity"> | number
    common_db_entities_id?: IntFilter<"Entity"> | number
    name?: StringFilter<"Entity"> | string
    website?: StringNullableFilter<"Entity"> | string | null
    created_at?: DateTimeFilter<"Entity"> | Date | string
    updated_at?: DateTimeFilter<"Entity"> | Date | string
    agency_contracts?: AgencyContractListRelationFilter
    objects?: ObjectListRelationFilter
    entity_forbidden_websites?: EntityForbiddenWebsiteListRelationFilter
    entity_forbidden_brands?: EntityForbiddenBrandListRelationFilter
  }

  export type EntityOrderByWithRelationInput = {
    id?: SortOrder
    common_db_entities_id?: SortOrder
    name?: SortOrder
    website?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_contracts?: AgencyContractOrderByRelationAggregateInput
    objects?: ObjectOrderByRelationAggregateInput
    entity_forbidden_websites?: EntityForbiddenWebsiteOrderByRelationAggregateInput
    entity_forbidden_brands?: EntityForbiddenBrandOrderByRelationAggregateInput
  }

  export type EntityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    common_db_entities_id?: number
    AND?: EntityWhereInput | EntityWhereInput[]
    OR?: EntityWhereInput[]
    NOT?: EntityWhereInput | EntityWhereInput[]
    name?: StringFilter<"Entity"> | string
    website?: StringNullableFilter<"Entity"> | string | null
    created_at?: DateTimeFilter<"Entity"> | Date | string
    updated_at?: DateTimeFilter<"Entity"> | Date | string
    agency_contracts?: AgencyContractListRelationFilter
    objects?: ObjectListRelationFilter
    entity_forbidden_websites?: EntityForbiddenWebsiteListRelationFilter
    entity_forbidden_brands?: EntityForbiddenBrandListRelationFilter
  }, "id" | "common_db_entities_id">

  export type EntityOrderByWithAggregationInput = {
    id?: SortOrder
    common_db_entities_id?: SortOrder
    name?: SortOrder
    website?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: EntityCountOrderByAggregateInput
    _avg?: EntityAvgOrderByAggregateInput
    _max?: EntityMaxOrderByAggregateInput
    _min?: EntityMinOrderByAggregateInput
    _sum?: EntitySumOrderByAggregateInput
  }

  export type EntityScalarWhereWithAggregatesInput = {
    AND?: EntityScalarWhereWithAggregatesInput | EntityScalarWhereWithAggregatesInput[]
    OR?: EntityScalarWhereWithAggregatesInput[]
    NOT?: EntityScalarWhereWithAggregatesInput | EntityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Entity"> | number
    common_db_entities_id?: IntWithAggregatesFilter<"Entity"> | number
    name?: StringWithAggregatesFilter<"Entity"> | string
    website?: StringNullableWithAggregatesFilter<"Entity"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Entity"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Entity"> | Date | string
  }

  export type EntityForbiddenWebsiteWhereInput = {
    AND?: EntityForbiddenWebsiteWhereInput | EntityForbiddenWebsiteWhereInput[]
    OR?: EntityForbiddenWebsiteWhereInput[]
    NOT?: EntityForbiddenWebsiteWhereInput | EntityForbiddenWebsiteWhereInput[]
    id?: IntFilter<"EntityForbiddenWebsite"> | number
    name?: StringFilter<"EntityForbiddenWebsite"> | string
    created_at?: DateTimeFilter<"EntityForbiddenWebsite"> | Date | string
    updated_at?: DateTimeFilter<"EntityForbiddenWebsite"> | Date | string
    entity_id?: IntFilter<"EntityForbiddenWebsite"> | number
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
  }

  export type EntityForbiddenWebsiteOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    entity_id?: SortOrder
    entity?: EntityOrderByWithRelationInput
  }

  export type EntityForbiddenWebsiteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EntityForbiddenWebsiteWhereInput | EntityForbiddenWebsiteWhereInput[]
    OR?: EntityForbiddenWebsiteWhereInput[]
    NOT?: EntityForbiddenWebsiteWhereInput | EntityForbiddenWebsiteWhereInput[]
    name?: StringFilter<"EntityForbiddenWebsite"> | string
    created_at?: DateTimeFilter<"EntityForbiddenWebsite"> | Date | string
    updated_at?: DateTimeFilter<"EntityForbiddenWebsite"> | Date | string
    entity_id?: IntFilter<"EntityForbiddenWebsite"> | number
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
  }, "id">

  export type EntityForbiddenWebsiteOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    entity_id?: SortOrder
    _count?: EntityForbiddenWebsiteCountOrderByAggregateInput
    _avg?: EntityForbiddenWebsiteAvgOrderByAggregateInput
    _max?: EntityForbiddenWebsiteMaxOrderByAggregateInput
    _min?: EntityForbiddenWebsiteMinOrderByAggregateInput
    _sum?: EntityForbiddenWebsiteSumOrderByAggregateInput
  }

  export type EntityForbiddenWebsiteScalarWhereWithAggregatesInput = {
    AND?: EntityForbiddenWebsiteScalarWhereWithAggregatesInput | EntityForbiddenWebsiteScalarWhereWithAggregatesInput[]
    OR?: EntityForbiddenWebsiteScalarWhereWithAggregatesInput[]
    NOT?: EntityForbiddenWebsiteScalarWhereWithAggregatesInput | EntityForbiddenWebsiteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EntityForbiddenWebsite"> | number
    name?: StringWithAggregatesFilter<"EntityForbiddenWebsite"> | string
    created_at?: DateTimeWithAggregatesFilter<"EntityForbiddenWebsite"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"EntityForbiddenWebsite"> | Date | string
    entity_id?: IntWithAggregatesFilter<"EntityForbiddenWebsite"> | number
  }

  export type EntityForbiddenBrandWhereInput = {
    AND?: EntityForbiddenBrandWhereInput | EntityForbiddenBrandWhereInput[]
    OR?: EntityForbiddenBrandWhereInput[]
    NOT?: EntityForbiddenBrandWhereInput | EntityForbiddenBrandWhereInput[]
    id?: IntFilter<"EntityForbiddenBrand"> | number
    name?: StringFilter<"EntityForbiddenBrand"> | string
    created_at?: DateTimeFilter<"EntityForbiddenBrand"> | Date | string
    updated_at?: DateTimeFilter<"EntityForbiddenBrand"> | Date | string
    entity_id?: IntFilter<"EntityForbiddenBrand"> | number
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
  }

  export type EntityForbiddenBrandOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    entity_id?: SortOrder
    entity?: EntityOrderByWithRelationInput
  }

  export type EntityForbiddenBrandWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EntityForbiddenBrandWhereInput | EntityForbiddenBrandWhereInput[]
    OR?: EntityForbiddenBrandWhereInput[]
    NOT?: EntityForbiddenBrandWhereInput | EntityForbiddenBrandWhereInput[]
    name?: StringFilter<"EntityForbiddenBrand"> | string
    created_at?: DateTimeFilter<"EntityForbiddenBrand"> | Date | string
    updated_at?: DateTimeFilter<"EntityForbiddenBrand"> | Date | string
    entity_id?: IntFilter<"EntityForbiddenBrand"> | number
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
  }, "id">

  export type EntityForbiddenBrandOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    entity_id?: SortOrder
    _count?: EntityForbiddenBrandCountOrderByAggregateInput
    _avg?: EntityForbiddenBrandAvgOrderByAggregateInput
    _max?: EntityForbiddenBrandMaxOrderByAggregateInput
    _min?: EntityForbiddenBrandMinOrderByAggregateInput
    _sum?: EntityForbiddenBrandSumOrderByAggregateInput
  }

  export type EntityForbiddenBrandScalarWhereWithAggregatesInput = {
    AND?: EntityForbiddenBrandScalarWhereWithAggregatesInput | EntityForbiddenBrandScalarWhereWithAggregatesInput[]
    OR?: EntityForbiddenBrandScalarWhereWithAggregatesInput[]
    NOT?: EntityForbiddenBrandScalarWhereWithAggregatesInput | EntityForbiddenBrandScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EntityForbiddenBrand"> | number
    name?: StringWithAggregatesFilter<"EntityForbiddenBrand"> | string
    created_at?: DateTimeWithAggregatesFilter<"EntityForbiddenBrand"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"EntityForbiddenBrand"> | Date | string
    entity_id?: IntWithAggregatesFilter<"EntityForbiddenBrand"> | number
  }

  export type BankWhereInput = {
    AND?: BankWhereInput | BankWhereInput[]
    OR?: BankWhereInput[]
    NOT?: BankWhereInput | BankWhereInput[]
    id?: IntFilter<"Bank"> | number
    name?: StringFilter<"Bank"> | string
    created_at?: DateTimeFilter<"Bank"> | Date | string
    updated_at?: DateTimeFilter<"Bank"> | Date | string
    client_contracts?: ClientContractListRelationFilter
  }

  export type BankOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contracts?: ClientContractOrderByRelationAggregateInput
  }

  export type BankWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BankWhereInput | BankWhereInput[]
    OR?: BankWhereInput[]
    NOT?: BankWhereInput | BankWhereInput[]
    name?: StringFilter<"Bank"> | string
    created_at?: DateTimeFilter<"Bank"> | Date | string
    updated_at?: DateTimeFilter<"Bank"> | Date | string
    client_contracts?: ClientContractListRelationFilter
  }, "id">

  export type BankOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: BankCountOrderByAggregateInput
    _avg?: BankAvgOrderByAggregateInput
    _max?: BankMaxOrderByAggregateInput
    _min?: BankMinOrderByAggregateInput
    _sum?: BankSumOrderByAggregateInput
  }

  export type BankScalarWhereWithAggregatesInput = {
    AND?: BankScalarWhereWithAggregatesInput | BankScalarWhereWithAggregatesInput[]
    OR?: BankScalarWhereWithAggregatesInput[]
    NOT?: BankScalarWhereWithAggregatesInput | BankScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bank"> | number
    name?: StringWithAggregatesFilter<"Bank"> | string
    created_at?: DateTimeWithAggregatesFilter<"Bank"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Bank"> | Date | string
  }

  export type UserCreateInput = {
    full_name: string
    email: string
    phone?: string | null
    is_manager: boolean
    user_role: $Enums.UserRole
    created_at?: Date | string
    updated_at?: Date | string
    client_contracts?: ClientContractCreateNestedManyWithoutManagerInput
    agency_contracts?: AgencyContractCreateNestedManyWithoutResponsible_userInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    full_name: string
    email: string
    phone?: string | null
    is_manager: boolean
    user_role: $Enums.UserRole
    created_at?: Date | string
    updated_at?: Date | string
    client_contracts?: ClientContractUncheckedCreateNestedManyWithoutManagerInput
    agency_contracts?: AgencyContractUncheckedCreateNestedManyWithoutResponsible_userInput
  }

  export type UserUpdateInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_manager?: BoolFieldUpdateOperationsInput | boolean
    user_role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contracts?: ClientContractUpdateManyWithoutManagerNestedInput
    agency_contracts?: AgencyContractUpdateManyWithoutResponsible_userNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_manager?: BoolFieldUpdateOperationsInput | boolean
    user_role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contracts?: ClientContractUncheckedUpdateManyWithoutManagerNestedInput
    agency_contracts?: AgencyContractUncheckedUpdateManyWithoutResponsible_userNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    full_name: string
    email: string
    phone?: string | null
    is_manager: boolean
    user_role: $Enums.UserRole
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_manager?: BoolFieldUpdateOperationsInput | boolean
    user_role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_manager?: BoolFieldUpdateOperationsInput | boolean
    user_role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    full_name: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    client_category: $Enums.ClientCategory
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_properties?: ClientIndividualPropertiesCreateNestedOneWithoutClientInput
    client_individual_minor_properties?: ClientIndividualMinorPropertiesCreateNestedOneWithoutClientInput
    client_entity_properties?: ClientEntityPropertiesCreateNestedOneWithoutClientInput
    client_contracts?: ClientContractToClientCreateNestedManyWithoutClientInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: number
    full_name: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    client_category: $Enums.ClientCategory
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_properties_id?: number | null
    client_individual_minor_properties_id?: number | null
    client_entity_properties_id?: number | null
    client_contracts?: ClientContractToClientUncheckedCreateNestedManyWithoutClientInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    client_category?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_properties?: ClientIndividualPropertiesUpdateOneWithoutClientNestedInput
    client_individual_minor_properties?: ClientIndividualMinorPropertiesUpdateOneWithoutClientNestedInput
    client_entity_properties?: ClientEntityPropertiesUpdateOneWithoutClientNestedInput
    client_contracts?: ClientContractToClientUpdateManyWithoutClientNestedInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    client_category?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_individual_minor_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_entity_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_contracts?: ClientContractToClientUncheckedUpdateManyWithoutClientNestedInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: number
    full_name: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    client_category: $Enums.ClientCategory
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_properties_id?: number | null
    client_individual_minor_properties_id?: number | null
    client_entity_properties_id?: number | null
  }

  export type ClientUpdateManyMutationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    client_category?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    client_category?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_individual_minor_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_entity_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClientIndividualPropertiesCreateInput = {
    dob?: Date | string | null
    snils?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client?: ClientCreateNestedOneWithoutClient_individual_propertiesInput
    client_passport?: ClientPassportCreateNestedOneWithoutClient_individual_propertiesInput
  }

  export type ClientIndividualPropertiesUncheckedCreateInput = {
    id?: number
    dob?: Date | string | null
    snils?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_passport_id?: number | null
    client?: ClientUncheckedCreateNestedOneWithoutClient_individual_propertiesInput
  }

  export type ClientIndividualPropertiesUpdateInput = {
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutClient_individual_propertiesNestedInput
    client_passport?: ClientPassportUpdateOneWithoutClient_individual_propertiesNestedInput
  }

  export type ClientIndividualPropertiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_passport_id?: NullableIntFieldUpdateOperationsInput | number | null
    client?: ClientUncheckedUpdateOneWithoutClient_individual_propertiesNestedInput
  }

  export type ClientIndividualPropertiesCreateManyInput = {
    id?: number
    dob?: Date | string | null
    snils?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_passport_id?: number | null
  }

  export type ClientIndividualPropertiesUpdateManyMutationInput = {
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientIndividualPropertiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_passport_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClientIndividualMinorPropertiesCreateInput = {
    dob?: Date | string | null
    snils?: string | null
    birth_certificate?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client?: ClientCreateNestedOneWithoutClient_individual_minor_propertiesInput
    client_passport?: ClientPassportCreateNestedOneWithoutClient_individual_minor_propertiesInput
    representatives?: ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClient_individual_minor_propertiesInput
  }

  export type ClientIndividualMinorPropertiesUncheckedCreateInput = {
    id?: number
    dob?: Date | string | null
    snils?: string | null
    birth_certificate?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_passport_id?: number | null
    client?: ClientUncheckedCreateNestedOneWithoutClient_individual_minor_propertiesInput
    representatives?: ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClient_individual_minor_propertiesInput
  }

  export type ClientIndividualMinorPropertiesUpdateInput = {
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birth_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutClient_individual_minor_propertiesNestedInput
    client_passport?: ClientPassportUpdateOneWithoutClient_individual_minor_propertiesNestedInput
    representatives?: ClientToClientIndividualMinorPropertiesUpdateManyWithoutClient_individual_minor_propertiesNestedInput
  }

  export type ClientIndividualMinorPropertiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birth_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_passport_id?: NullableIntFieldUpdateOperationsInput | number | null
    client?: ClientUncheckedUpdateOneWithoutClient_individual_minor_propertiesNestedInput
    representatives?: ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClient_individual_minor_propertiesNestedInput
  }

  export type ClientIndividualMinorPropertiesCreateManyInput = {
    id?: number
    dob?: Date | string | null
    snils?: string | null
    birth_certificate?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_passport_id?: number | null
  }

  export type ClientIndividualMinorPropertiesUpdateManyMutationInput = {
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birth_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientIndividualMinorPropertiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birth_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_passport_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClientEntityPropertiesCreateInput = {
    kpp?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client?: ClientCreateNestedOneWithoutClient_entity_propertiesInput
  }

  export type ClientEntityPropertiesUncheckedCreateInput = {
    id?: number
    kpp?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client?: ClientUncheckedCreateNestedOneWithoutClient_entity_propertiesInput
  }

  export type ClientEntityPropertiesUpdateInput = {
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutClient_entity_propertiesNestedInput
  }

  export type ClientEntityPropertiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUncheckedUpdateOneWithoutClient_entity_propertiesNestedInput
  }

  export type ClientEntityPropertiesCreateManyInput = {
    id?: number
    kpp?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientEntityPropertiesUpdateManyMutationInput = {
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEntityPropertiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientToClientIndividualMinorPropertiesCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    client: ClientCreateNestedOneWithoutClients_to_client_individual_minor_propertiesInput
    client_individual_minor_properties: ClientIndividualMinorPropertiesCreateNestedOneWithoutRepresentativesInput
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    client_id: number
    client_individual_minor_properties_id: number
  }

  export type ClientToClientIndividualMinorPropertiesUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutClients_to_client_individual_minor_propertiesNestedInput
    client_individual_minor_properties?: ClientIndividualMinorPropertiesUpdateOneRequiredWithoutRepresentativesNestedInput
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: IntFieldUpdateOperationsInput | number
    client_individual_minor_properties_id?: IntFieldUpdateOperationsInput | number
  }

  export type ClientToClientIndividualMinorPropertiesCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    client_id: number
    client_individual_minor_properties_id: number
  }

  export type ClientToClientIndividualMinorPropertiesUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: IntFieldUpdateOperationsInput | number
    client_individual_minor_properties_id?: IntFieldUpdateOperationsInput | number
  }

  export type ClientPassportCreateInput = {
    number?: string | null
    issued?: string | null
    code?: string | null
    place_of_birth?: string | null
    registration_address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_properties?: ClientIndividualPropertiesCreateNestedOneWithoutClient_passportInput
    client_individual_minor_properties?: ClientIndividualMinorPropertiesCreateNestedOneWithoutClient_passportInput
  }

  export type ClientPassportUncheckedCreateInput = {
    id?: number
    number?: string | null
    issued?: string | null
    code?: string | null
    place_of_birth?: string | null
    registration_address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_properties?: ClientIndividualPropertiesUncheckedCreateNestedOneWithoutClient_passportInput
    client_individual_minor_properties?: ClientIndividualMinorPropertiesUncheckedCreateNestedOneWithoutClient_passportInput
  }

  export type ClientPassportUpdateInput = {
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issued?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    registration_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_properties?: ClientIndividualPropertiesUpdateOneWithoutClient_passportNestedInput
    client_individual_minor_properties?: ClientIndividualMinorPropertiesUpdateOneWithoutClient_passportNestedInput
  }

  export type ClientPassportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issued?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    registration_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_properties?: ClientIndividualPropertiesUncheckedUpdateOneWithoutClient_passportNestedInput
    client_individual_minor_properties?: ClientIndividualMinorPropertiesUncheckedUpdateOneWithoutClient_passportNestedInput
  }

  export type ClientPassportCreateManyInput = {
    id?: number
    number?: string | null
    issued?: string | null
    code?: string | null
    place_of_birth?: string | null
    registration_address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientPassportUpdateManyMutationInput = {
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issued?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    registration_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientPassportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issued?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    registration_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractCreateInput = {
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object: ObjectCreateNestedOneWithoutClient_contractsInput
    product: ProductCreateNestedOneWithoutClient_contractInput
    real_estate_agent?: RealEstateAgentCreateNestedOneWithoutClient_contractsInput
    manager?: UserCreateNestedOneWithoutClient_contractsInput
    bank?: BankCreateNestedOneWithoutClient_contractsInput
    ddu_client_contract_properties?: DDUClientContractPropertiesCreateNestedOneWithoutClient_contractInput
    clients?: ClientContractToClientCreateNestedManyWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractUncheckedCreateInput = {
    id?: number
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object_id: number
    product_id: number
    real_estate_agent_id?: number | null
    manager_id?: number | null
    bank_id?: number | null
    ddu_client_contract_properties_id?: number | null
    clients?: ClientContractToClientUncheckedCreateNestedManyWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentUncheckedCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractUpdateInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object?: ObjectUpdateOneRequiredWithoutClient_contractsNestedInput
    product?: ProductUpdateOneRequiredWithoutClient_contractNestedInput
    real_estate_agent?: RealEstateAgentUpdateOneWithoutClient_contractsNestedInput
    manager?: UserUpdateOneWithoutClient_contractsNestedInput
    bank?: BankUpdateOneWithoutClient_contractsNestedInput
    ddu_client_contract_properties?: DDUClientContractPropertiesUpdateOneWithoutClient_contractNestedInput
    clients?: ClientContractToClientUpdateManyWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientContractUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    real_estate_agent_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    bank_id?: NullableIntFieldUpdateOperationsInput | number | null
    ddu_client_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    clients?: ClientContractToClientUncheckedUpdateManyWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientContractCreateManyInput = {
    id?: number
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object_id: number
    product_id: number
    real_estate_agent_id?: number | null
    manager_id?: number | null
    bank_id?: number | null
    ddu_client_contract_properties_id?: number | null
  }

  export type ClientContractUpdateManyMutationInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    real_estate_agent_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    bank_id?: NullableIntFieldUpdateOperationsInput | number | null
    ddu_client_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DDUClientContractPropertiesCreateInput = {
    ddu_link?: string | null
    return_account?: string | null
    escrow_account_opening_date?: Date | string | null
    escrow_period?: Date | string | null
    escrow_account_number?: string | null
    is_escrow_discount?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    client_contract?: ClientContractCreateNestedOneWithoutDdu_client_contract_propertiesInput
  }

  export type DDUClientContractPropertiesUncheckedCreateInput = {
    id?: number
    ddu_link?: string | null
    return_account?: string | null
    escrow_account_opening_date?: Date | string | null
    escrow_period?: Date | string | null
    escrow_account_number?: string | null
    is_escrow_discount?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    client_contract?: ClientContractUncheckedCreateNestedOneWithoutDdu_client_contract_propertiesInput
  }

  export type DDUClientContractPropertiesUpdateInput = {
    ddu_link?: NullableStringFieldUpdateOperationsInput | string | null
    return_account?: NullableStringFieldUpdateOperationsInput | string | null
    escrow_account_opening_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrow_period?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrow_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_escrow_discount?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract?: ClientContractUpdateOneWithoutDdu_client_contract_propertiesNestedInput
  }

  export type DDUClientContractPropertiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ddu_link?: NullableStringFieldUpdateOperationsInput | string | null
    return_account?: NullableStringFieldUpdateOperationsInput | string | null
    escrow_account_opening_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrow_period?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrow_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_escrow_discount?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract?: ClientContractUncheckedUpdateOneWithoutDdu_client_contract_propertiesNestedInput
  }

  export type DDUClientContractPropertiesCreateManyInput = {
    id?: number
    ddu_link?: string | null
    return_account?: string | null
    escrow_account_opening_date?: Date | string | null
    escrow_period?: Date | string | null
    escrow_account_number?: string | null
    is_escrow_discount?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DDUClientContractPropertiesUpdateManyMutationInput = {
    ddu_link?: NullableStringFieldUpdateOperationsInput | string | null
    return_account?: NullableStringFieldUpdateOperationsInput | string | null
    escrow_account_opening_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrow_period?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrow_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_escrow_discount?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DDUClientContractPropertiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ddu_link?: NullableStringFieldUpdateOperationsInput | string | null
    return_account?: NullableStringFieldUpdateOperationsInput | string | null
    escrow_account_opening_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrow_period?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrow_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_escrow_discount?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToAgencyContractCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    client_contract: ClientContractCreateNestedOneWithoutAgency_contractsInput
    agency_contract: AgencyContractCreateNestedOneWithoutClient_contractsInput
  }

  export type ClientContractToAgencyContractUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    client_contract_id: number
    agency_contract_id: number
  }

  export type ClientContractToAgencyContractUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract?: ClientContractUpdateOneRequiredWithoutAgency_contractsNestedInput
    agency_contract?: AgencyContractUpdateOneRequiredWithoutClient_contractsNestedInput
  }

  export type ClientContractToAgencyContractUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract_id?: IntFieldUpdateOperationsInput | number
    agency_contract_id?: IntFieldUpdateOperationsInput | number
  }

  export type ClientContractToAgencyContractCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    client_contract_id: number
    agency_contract_id: number
  }

  export type ClientContractToAgencyContractUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToAgencyContractUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract_id?: IntFieldUpdateOperationsInput | number
    agency_contract_id?: IntFieldUpdateOperationsInput | number
  }

  export type ClientContractToClientCreateInput = {
    is_main: boolean
    share: number
    created_at?: Date | string
    updated_at?: Date | string
    client_contract: ClientContractCreateNestedOneWithoutClientsInput
    client: ClientCreateNestedOneWithoutClient_contractsInput
  }

  export type ClientContractToClientUncheckedCreateInput = {
    is_main: boolean
    share: number
    created_at?: Date | string
    updated_at?: Date | string
    client_contract_id: number
    client_id: number
  }

  export type ClientContractToClientUpdateInput = {
    is_main?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract?: ClientContractUpdateOneRequiredWithoutClientsNestedInput
    client?: ClientUpdateOneRequiredWithoutClient_contractsNestedInput
  }

  export type ClientContractToClientUncheckedUpdateInput = {
    is_main?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
  }

  export type ClientContractToClientCreateManyInput = {
    is_main: boolean
    share: number
    created_at?: Date | string
    updated_at?: Date | string
    client_contract_id: number
    client_id: number
  }

  export type ClientContractToClientUpdateManyMutationInput = {
    is_main?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToClientUncheckedUpdateManyInput = {
    is_main?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
  }

  export type ScheduledPaymentCreateInput = {
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    scheduled_payment_type: $Enums.ScheduledPaymentType
    created_at?: Date | string
    updated_at?: Date | string
    client_contract: ClientContractCreateNestedOneWithoutScheduled_paymentsInput
  }

  export type ScheduledPaymentUncheckedCreateInput = {
    id?: number
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    scheduled_payment_type: $Enums.ScheduledPaymentType
    created_at?: Date | string
    updated_at?: Date | string
    client_contract_id: number
  }

  export type ScheduledPaymentUpdateInput = {
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduled_payment_type?: EnumScheduledPaymentTypeFieldUpdateOperationsInput | $Enums.ScheduledPaymentType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract?: ClientContractUpdateOneRequiredWithoutScheduled_paymentsNestedInput
  }

  export type ScheduledPaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduled_payment_type?: EnumScheduledPaymentTypeFieldUpdateOperationsInput | $Enums.ScheduledPaymentType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract_id?: IntFieldUpdateOperationsInput | number
  }

  export type ScheduledPaymentCreateManyInput = {
    id?: number
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    scheduled_payment_type: $Enums.ScheduledPaymentType
    created_at?: Date | string
    updated_at?: Date | string
    client_contract_id: number
  }

  export type ScheduledPaymentUpdateManyMutationInput = {
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduled_payment_type?: EnumScheduledPaymentTypeFieldUpdateOperationsInput | $Enums.ScheduledPaymentType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduled_payment_type?: EnumScheduledPaymentTypeFieldUpdateOperationsInput | $Enums.ScheduledPaymentType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract_id?: IntFieldUpdateOperationsInput | number
  }

  export type ActualPaymentCreateInput = {
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    client_contract: ClientContractCreateNestedOneWithoutActual_paymentInput
  }

  export type ActualPaymentUncheckedCreateInput = {
    id?: number
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    client_contract_id: number
  }

  export type ActualPaymentUpdateInput = {
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract?: ClientContractUpdateOneRequiredWithoutActual_paymentNestedInput
  }

  export type ActualPaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract_id?: IntFieldUpdateOperationsInput | number
  }

  export type ActualPaymentCreateManyInput = {
    id?: number
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    client_contract_id: number
  }

  export type ActualPaymentUpdateManyMutationInput = {
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActualPaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract_id?: IntFieldUpdateOperationsInput | number
  }

  export type ObjectCreateInput = {
    common_db_objects_id: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entity: EntityCreateNestedOneWithoutObjectsInput
    products?: ProductCreateNestedManyWithoutObjectInput
    client_contracts?: ClientContractCreateNestedManyWithoutObjectInput
    agency_contracts?: AgencyContractCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateInput = {
    id?: number
    common_db_objects_id: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entity_id: number
    products?: ProductUncheckedCreateNestedManyWithoutObjectInput
    client_contracts?: ClientContractUncheckedCreateNestedManyWithoutObjectInput
    agency_contracts?: AgencyContractUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectUpdateInput = {
    common_db_objects_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: EntityUpdateOneRequiredWithoutObjectsNestedInput
    products?: ProductUpdateManyWithoutObjectNestedInput
    client_contracts?: ClientContractUpdateManyWithoutObjectNestedInput
    agency_contracts?: AgencyContractUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    common_db_objects_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entity_id?: IntFieldUpdateOperationsInput | number
    products?: ProductUncheckedUpdateManyWithoutObjectNestedInput
    client_contracts?: ClientContractUncheckedUpdateManyWithoutObjectNestedInput
    agency_contracts?: AgencyContractUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type ObjectCreateManyInput = {
    id?: number
    common_db_objects_id: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entity_id: number
  }

  export type ObjectUpdateManyMutationInput = {
    common_db_objects_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    common_db_objects_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entity_id?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateInput = {
    pricing_products_id: number
    number: string
    product_category: $Enums.ProductCategory
    created_at?: Date | string
    updated_at?: Date | string
    client_contract?: ClientContractCreateNestedOneWithoutProductInput
    object: ObjectCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    pricing_products_id: number
    number: string
    product_category: $Enums.ProductCategory
    created_at?: Date | string
    updated_at?: Date | string
    object_id: number
    client_contract?: ClientContractUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductUpdateInput = {
    pricing_products_id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    product_category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract?: ClientContractUpdateOneWithoutProductNestedInput
    object?: ObjectUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pricing_products_id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    product_category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: IntFieldUpdateOperationsInput | number
    client_contract?: ClientContractUncheckedUpdateOneWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    pricing_products_id: number
    number: string
    product_category: $Enums.ProductCategory
    created_at?: Date | string
    updated_at?: Date | string
    object_id: number
  }

  export type ProductUpdateManyMutationInput = {
    pricing_products_id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    product_category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pricing_products_id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    product_category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: IntFieldUpdateOperationsInput | number
  }

  export type AgencyCreateInput = {
    common_db_contractors_id: number
    name: string
    inn?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agency_contracts?: AgencyContractCreateNestedManyWithoutAgencyInput
    real_estate_agents?: AgencyToRealEstateAgentCreateNestedManyWithoutAgencyInput
    agency_contract_signatory?: AgencyContractSignatoryCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateInput = {
    id?: number
    common_db_contractors_id: number
    name: string
    inn?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agency_contracts?: AgencyContractUncheckedCreateNestedManyWithoutAgencyInput
    real_estate_agents?: AgencyToRealEstateAgentUncheckedCreateNestedManyWithoutAgencyInput
    agency_contract_signatory?: AgencyContractSignatoryUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUpdateInput = {
    common_db_contractors_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contracts?: AgencyContractUpdateManyWithoutAgencyNestedInput
    real_estate_agents?: AgencyToRealEstateAgentUpdateManyWithoutAgencyNestedInput
    agency_contract_signatory?: AgencyContractSignatoryUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    common_db_contractors_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contracts?: AgencyContractUncheckedUpdateManyWithoutAgencyNestedInput
    real_estate_agents?: AgencyToRealEstateAgentUncheckedUpdateManyWithoutAgencyNestedInput
    agency_contract_signatory?: AgencyContractSignatoryUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyCreateManyInput = {
    id?: number
    common_db_contractors_id: number
    name: string
    inn?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AgencyUpdateManyMutationInput = {
    common_db_contractors_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    common_db_contractors_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyContractCreateInput = {
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user?: UserCreateNestedOneWithoutAgency_contractsInput
    entity: EntityCreateNestedOneWithoutAgency_contractsInput
    object: ObjectCreateNestedOneWithoutAgency_contractsInput
    agency: AgencyCreateNestedOneWithoutAgency_contractsInput
    agency_contract_signatory?: AgencyContractSignatoryCreateNestedOneWithoutAgency_contractInput
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgency_contractInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesCreateNestedOneWithoutAgency_contractInput
    client_contracts?: ClientContractToAgencyContractCreateNestedManyWithoutAgency_contractInput
  }

  export type AgencyContractUncheckedCreateInput = {
    id?: number
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user_id?: number | null
    entity_id: number
    object_id: number
    agency_id: number
    agency_contract_signatory_id?: number | null
    real_estate_agency_contract_properties_id?: number | null
    mip_agency_contract_properties_id?: number | null
    client_contracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgency_contractInput
  }

  export type AgencyContractUpdateInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user?: UserUpdateOneWithoutAgency_contractsNestedInput
    entity?: EntityUpdateOneRequiredWithoutAgency_contractsNestedInput
    object?: ObjectUpdateOneRequiredWithoutAgency_contractsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgency_contractsNestedInput
    agency_contract_signatory?: AgencyContractSignatoryUpdateOneWithoutAgency_contractNestedInput
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgency_contractNestedInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesUpdateOneWithoutAgency_contractNestedInput
    client_contracts?: ClientContractToAgencyContractUpdateManyWithoutAgency_contractNestedInput
  }

  export type AgencyContractUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_id?: IntFieldUpdateOperationsInput | number
    object_id?: IntFieldUpdateOperationsInput | number
    agency_id?: IntFieldUpdateOperationsInput | number
    agency_contract_signatory_id?: NullableIntFieldUpdateOperationsInput | number | null
    real_estate_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    mip_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_contracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutAgency_contractNestedInput
  }

  export type AgencyContractCreateManyInput = {
    id?: number
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user_id?: number | null
    entity_id: number
    object_id: number
    agency_id: number
    agency_contract_signatory_id?: number | null
    real_estate_agency_contract_properties_id?: number | null
    mip_agency_contract_properties_id?: number | null
  }

  export type AgencyContractUpdateManyMutationInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyContractUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_id?: IntFieldUpdateOperationsInput | number
    object_id?: IntFieldUpdateOperationsInput | number
    agency_id?: IntFieldUpdateOperationsInput | number
    agency_contract_signatory_id?: NullableIntFieldUpdateOperationsInput | number | null
    real_estate_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    mip_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AgencyContractSignatoryCreateInput = {
    full_name: string
    email: string
    phone: string
    title: string
    based_on: string
    created_at?: Date | string
    updated_at?: Date | string
    agency: AgencyCreateNestedOneWithoutAgency_contract_signatoryInput
    agency_contract?: AgencyContractCreateNestedManyWithoutAgency_contract_signatoryInput
  }

  export type AgencyContractSignatoryUncheckedCreateInput = {
    id?: number
    full_name: string
    email: string
    phone: string
    title: string
    based_on: string
    created_at?: Date | string
    updated_at?: Date | string
    agency_id: number
    agency_contract?: AgencyContractUncheckedCreateNestedManyWithoutAgency_contract_signatoryInput
  }

  export type AgencyContractSignatoryUpdateInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    based_on?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutAgency_contract_signatoryNestedInput
    agency_contract?: AgencyContractUpdateManyWithoutAgency_contract_signatoryNestedInput
  }

  export type AgencyContractSignatoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    based_on?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_id?: IntFieldUpdateOperationsInput | number
    agency_contract?: AgencyContractUncheckedUpdateManyWithoutAgency_contract_signatoryNestedInput
  }

  export type AgencyContractSignatoryCreateManyInput = {
    id?: number
    full_name: string
    email: string
    phone: string
    title: string
    based_on: string
    created_at?: Date | string
    updated_at?: Date | string
    agency_id: number
  }

  export type AgencyContractSignatoryUpdateManyMutationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    based_on?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyContractSignatoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    based_on?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_id?: IntFieldUpdateOperationsInput | number
  }

  export type RealEstateAgencyContractPropertiesCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract?: AgencyContractCreateNestedOneWithoutReal_estate_agency_contract_propertiesInput
    agency_contract_commission: AgencyContractCommissionCreateNestedOneWithoutReal_estate_agency_contract_propertiesInput
  }

  export type RealEstateAgencyContractPropertiesUncheckedCreateInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract_commission_id: number
    agency_contract?: AgencyContractUncheckedCreateNestedOneWithoutReal_estate_agency_contract_propertiesInput
  }

  export type RealEstateAgencyContractPropertiesUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract?: AgencyContractUpdateOneWithoutReal_estate_agency_contract_propertiesNestedInput
    agency_contract_commission?: AgencyContractCommissionUpdateOneRequiredWithoutReal_estate_agency_contract_propertiesNestedInput
  }

  export type RealEstateAgencyContractPropertiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_commission_id?: IntFieldUpdateOperationsInput | number
    agency_contract?: AgencyContractUncheckedUpdateOneWithoutReal_estate_agency_contract_propertiesNestedInput
  }

  export type RealEstateAgencyContractPropertiesCreateManyInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract_commission_id: number
  }

  export type RealEstateAgencyContractPropertiesUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealEstateAgencyContractPropertiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_commission_id?: IntFieldUpdateOperationsInput | number
  }

  export type MIPAgencyContractPropertiesCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract?: AgencyContractCreateNestedOneWithoutMip_agency_contract_propertiesInput
    agency_contract_commission: AgencyContractCommissionCreateNestedOneWithoutMip_agency_contract_propertiesInput
  }

  export type MIPAgencyContractPropertiesUncheckedCreateInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract_commission_id: number
    agency_contract?: AgencyContractUncheckedCreateNestedOneWithoutMip_agency_contract_propertiesInput
  }

  export type MIPAgencyContractPropertiesUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract?: AgencyContractUpdateOneWithoutMip_agency_contract_propertiesNestedInput
    agency_contract_commission?: AgencyContractCommissionUpdateOneRequiredWithoutMip_agency_contract_propertiesNestedInput
  }

  export type MIPAgencyContractPropertiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_commission_id?: IntFieldUpdateOperationsInput | number
    agency_contract?: AgencyContractUncheckedUpdateOneWithoutMip_agency_contract_propertiesNestedInput
  }

  export type MIPAgencyContractPropertiesCreateManyInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract_commission_id: number
  }

  export type MIPAgencyContractPropertiesUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MIPAgencyContractPropertiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_commission_id?: IntFieldUpdateOperationsInput | number
  }

  export type AgencyContractCommissionCreateInput = {
    percent: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    max_days: number
    created_at?: Date | string
    updated_at?: Date | string
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgency_contract_commissionInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesCreateNestedOneWithoutAgency_contract_commissionInput
  }

  export type AgencyContractCommissionUncheckedCreateInput = {
    id?: number
    percent: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    max_days: number
    created_at?: Date | string
    updated_at?: Date | string
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesUncheckedCreateNestedOneWithoutAgency_contract_commissionInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesUncheckedCreateNestedOneWithoutAgency_contract_commissionInput
  }

  export type AgencyContractCommissionUpdateInput = {
    percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgency_contract_commissionNestedInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesUpdateOneWithoutAgency_contract_commissionNestedInput
  }

  export type AgencyContractCommissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesUncheckedUpdateOneWithoutAgency_contract_commissionNestedInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesUncheckedUpdateOneWithoutAgency_contract_commissionNestedInput
  }

  export type AgencyContractCommissionCreateManyInput = {
    id?: number
    percent: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    max_days: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AgencyContractCommissionUpdateManyMutationInput = {
    percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyContractCommissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealEstateAgentCreateInput = {
    full_name: string
    phone?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_contracts?: ClientContractCreateNestedManyWithoutReal_estate_agentInput
    agencies?: AgencyToRealEstateAgentCreateNestedManyWithoutReal_estate_agentInput
  }

  export type RealEstateAgentUncheckedCreateInput = {
    id?: number
    full_name: string
    phone?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_contracts?: ClientContractUncheckedCreateNestedManyWithoutReal_estate_agentInput
    agencies?: AgencyToRealEstateAgentUncheckedCreateNestedManyWithoutReal_estate_agentInput
  }

  export type RealEstateAgentUpdateInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contracts?: ClientContractUpdateManyWithoutReal_estate_agentNestedInput
    agencies?: AgencyToRealEstateAgentUpdateManyWithoutReal_estate_agentNestedInput
  }

  export type RealEstateAgentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contracts?: ClientContractUncheckedUpdateManyWithoutReal_estate_agentNestedInput
    agencies?: AgencyToRealEstateAgentUncheckedUpdateManyWithoutReal_estate_agentNestedInput
  }

  export type RealEstateAgentCreateManyInput = {
    id?: number
    full_name: string
    phone?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RealEstateAgentUpdateManyMutationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealEstateAgentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyToRealEstateAgentCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    agency: AgencyCreateNestedOneWithoutReal_estate_agentsInput
    real_estate_agent: RealEstateAgentCreateNestedOneWithoutAgenciesInput
  }

  export type AgencyToRealEstateAgentUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    agency_id: number
    real_estate_agent_id: number
  }

  export type AgencyToRealEstateAgentUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutReal_estate_agentsNestedInput
    real_estate_agent?: RealEstateAgentUpdateOneRequiredWithoutAgenciesNestedInput
  }

  export type AgencyToRealEstateAgentUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_id?: IntFieldUpdateOperationsInput | number
    real_estate_agent_id?: IntFieldUpdateOperationsInput | number
  }

  export type AgencyToRealEstateAgentCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    agency_id: number
    real_estate_agent_id: number
  }

  export type AgencyToRealEstateAgentUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyToRealEstateAgentUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_id?: IntFieldUpdateOperationsInput | number
    real_estate_agent_id?: IntFieldUpdateOperationsInput | number
  }

  export type EntityCreateInput = {
    common_db_entities_id: number
    name: string
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agency_contracts?: AgencyContractCreateNestedManyWithoutEntityInput
    objects?: ObjectCreateNestedManyWithoutEntityInput
    entity_forbidden_websites?: EntityForbiddenWebsiteCreateNestedManyWithoutEntityInput
    entity_forbidden_brands?: EntityForbiddenBrandCreateNestedManyWithoutEntityInput
  }

  export type EntityUncheckedCreateInput = {
    id?: number
    common_db_entities_id: number
    name: string
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agency_contracts?: AgencyContractUncheckedCreateNestedManyWithoutEntityInput
    objects?: ObjectUncheckedCreateNestedManyWithoutEntityInput
    entity_forbidden_websites?: EntityForbiddenWebsiteUncheckedCreateNestedManyWithoutEntityInput
    entity_forbidden_brands?: EntityForbiddenBrandUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityUpdateInput = {
    common_db_entities_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contracts?: AgencyContractUpdateManyWithoutEntityNestedInput
    objects?: ObjectUpdateManyWithoutEntityNestedInput
    entity_forbidden_websites?: EntityForbiddenWebsiteUpdateManyWithoutEntityNestedInput
    entity_forbidden_brands?: EntityForbiddenBrandUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    common_db_entities_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contracts?: AgencyContractUncheckedUpdateManyWithoutEntityNestedInput
    objects?: ObjectUncheckedUpdateManyWithoutEntityNestedInput
    entity_forbidden_websites?: EntityForbiddenWebsiteUncheckedUpdateManyWithoutEntityNestedInput
    entity_forbidden_brands?: EntityForbiddenBrandUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type EntityCreateManyInput = {
    id?: number
    common_db_entities_id: number
    name: string
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EntityUpdateManyMutationInput = {
    common_db_entities_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    common_db_entities_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenWebsiteCreateInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entity: EntityCreateNestedOneWithoutEntity_forbidden_websitesInput
  }

  export type EntityForbiddenWebsiteUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entity_id: number
  }

  export type EntityForbiddenWebsiteUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: EntityUpdateOneRequiredWithoutEntity_forbidden_websitesNestedInput
  }

  export type EntityForbiddenWebsiteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entity_id?: IntFieldUpdateOperationsInput | number
  }

  export type EntityForbiddenWebsiteCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entity_id: number
  }

  export type EntityForbiddenWebsiteUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenWebsiteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entity_id?: IntFieldUpdateOperationsInput | number
  }

  export type EntityForbiddenBrandCreateInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entity: EntityCreateNestedOneWithoutEntity_forbidden_brandsInput
  }

  export type EntityForbiddenBrandUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entity_id: number
  }

  export type EntityForbiddenBrandUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: EntityUpdateOneRequiredWithoutEntity_forbidden_brandsNestedInput
  }

  export type EntityForbiddenBrandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entity_id?: IntFieldUpdateOperationsInput | number
  }

  export type EntityForbiddenBrandCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entity_id: number
  }

  export type EntityForbiddenBrandUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenBrandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entity_id?: IntFieldUpdateOperationsInput | number
  }

  export type BankCreateInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    client_contracts?: ClientContractCreateNestedManyWithoutBankInput
  }

  export type BankUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    client_contracts?: ClientContractUncheckedCreateNestedManyWithoutBankInput
  }

  export type BankUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contracts?: ClientContractUpdateManyWithoutBankNestedInput
  }

  export type BankUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contracts?: ClientContractUncheckedUpdateManyWithoutBankNestedInput
  }

  export type BankCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BankUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ClientContractListRelationFilter = {
    every?: ClientContractWhereInput
    some?: ClientContractWhereInput
    none?: ClientContractWhereInput
  }

  export type AgencyContractListRelationFilter = {
    every?: AgencyContractWhereInput
    some?: AgencyContractWhereInput
    none?: AgencyContractWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ClientContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    is_manager?: SortOrder
    user_role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    is_manager?: SortOrder
    user_role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    is_manager?: SortOrder
    user_role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumClientCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientCategory | EnumClientCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ClientCategory[]
    notIn?: $Enums.ClientCategory[]
    not?: NestedEnumClientCategoryFilter<$PrismaModel> | $Enums.ClientCategory
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ClientIndividualPropertiesNullableRelationFilter = {
    is?: ClientIndividualPropertiesWhereInput | null
    isNot?: ClientIndividualPropertiesWhereInput | null
  }

  export type ClientIndividualMinorPropertiesNullableRelationFilter = {
    is?: ClientIndividualMinorPropertiesWhereInput | null
    isNot?: ClientIndividualMinorPropertiesWhereInput | null
  }

  export type ClientEntityPropertiesNullableRelationFilter = {
    is?: ClientEntityPropertiesWhereInput | null
    isNot?: ClientEntityPropertiesWhereInput | null
  }

  export type ClientContractToClientListRelationFilter = {
    every?: ClientContractToClientWhereInput
    some?: ClientContractToClientWhereInput
    none?: ClientContractToClientWhereInput
  }

  export type ClientToClientIndividualMinorPropertiesListRelationFilter = {
    every?: ClientToClientIndividualMinorPropertiesWhereInput
    some?: ClientToClientIndividualMinorPropertiesWhereInput
    none?: ClientToClientIndividualMinorPropertiesWhereInput
  }

  export type ClientContractToClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientToClientIndividualMinorPropertiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    inn?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    client_category?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_individual_properties_id?: SortOrder
    client_individual_minor_properties_id?: SortOrder
    client_entity_properties_id?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    id?: SortOrder
    client_individual_properties_id?: SortOrder
    client_individual_minor_properties_id?: SortOrder
    client_entity_properties_id?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    inn?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    client_category?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_individual_properties_id?: SortOrder
    client_individual_minor_properties_id?: SortOrder
    client_entity_properties_id?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    inn?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    client_category?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_individual_properties_id?: SortOrder
    client_individual_minor_properties_id?: SortOrder
    client_entity_properties_id?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    id?: SortOrder
    client_individual_properties_id?: SortOrder
    client_individual_minor_properties_id?: SortOrder
    client_entity_properties_id?: SortOrder
  }

  export type EnumClientCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientCategory | EnumClientCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ClientCategory[]
    notIn?: $Enums.ClientCategory[]
    not?: NestedEnumClientCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ClientCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientCategoryFilter<$PrismaModel>
    _max?: NestedEnumClientCategoryFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ClientNullableRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type ClientPassportNullableRelationFilter = {
    is?: ClientPassportWhereInput | null
    isNot?: ClientPassportWhereInput | null
  }

  export type ClientIndividualPropertiesCountOrderByAggregateInput = {
    id?: SortOrder
    dob?: SortOrder
    snils?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_passport_id?: SortOrder
  }

  export type ClientIndividualPropertiesAvgOrderByAggregateInput = {
    id?: SortOrder
    client_passport_id?: SortOrder
  }

  export type ClientIndividualPropertiesMaxOrderByAggregateInput = {
    id?: SortOrder
    dob?: SortOrder
    snils?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_passport_id?: SortOrder
  }

  export type ClientIndividualPropertiesMinOrderByAggregateInput = {
    id?: SortOrder
    dob?: SortOrder
    snils?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_passport_id?: SortOrder
  }

  export type ClientIndividualPropertiesSumOrderByAggregateInput = {
    id?: SortOrder
    client_passport_id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ClientIndividualMinorPropertiesCountOrderByAggregateInput = {
    id?: SortOrder
    dob?: SortOrder
    snils?: SortOrder
    birth_certificate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_passport_id?: SortOrder
  }

  export type ClientIndividualMinorPropertiesAvgOrderByAggregateInput = {
    id?: SortOrder
    client_passport_id?: SortOrder
  }

  export type ClientIndividualMinorPropertiesMaxOrderByAggregateInput = {
    id?: SortOrder
    dob?: SortOrder
    snils?: SortOrder
    birth_certificate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_passport_id?: SortOrder
  }

  export type ClientIndividualMinorPropertiesMinOrderByAggregateInput = {
    id?: SortOrder
    dob?: SortOrder
    snils?: SortOrder
    birth_certificate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_passport_id?: SortOrder
  }

  export type ClientIndividualMinorPropertiesSumOrderByAggregateInput = {
    id?: SortOrder
    client_passport_id?: SortOrder
  }

  export type ClientEntityPropertiesCountOrderByAggregateInput = {
    id?: SortOrder
    kpp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientEntityPropertiesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClientEntityPropertiesMaxOrderByAggregateInput = {
    id?: SortOrder
    kpp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientEntityPropertiesMinOrderByAggregateInput = {
    id?: SortOrder
    kpp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientEntityPropertiesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClientRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type ClientIndividualMinorPropertiesRelationFilter = {
    is?: ClientIndividualMinorPropertiesWhereInput
    isNot?: ClientIndividualMinorPropertiesWhereInput
  }

  export type ClientToClientIndividualMinorPropertiesClient_idClient_individual_minor_properties_idCompoundUniqueInput = {
    client_id: number
    client_individual_minor_properties_id: number
  }

  export type ClientToClientIndividualMinorPropertiesCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    client_id?: SortOrder
    client_individual_minor_properties_id?: SortOrder
  }

  export type ClientToClientIndividualMinorPropertiesAvgOrderByAggregateInput = {
    client_id?: SortOrder
    client_individual_minor_properties_id?: SortOrder
  }

  export type ClientToClientIndividualMinorPropertiesMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    client_id?: SortOrder
    client_individual_minor_properties_id?: SortOrder
  }

  export type ClientToClientIndividualMinorPropertiesMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    client_id?: SortOrder
    client_individual_minor_properties_id?: SortOrder
  }

  export type ClientToClientIndividualMinorPropertiesSumOrderByAggregateInput = {
    client_id?: SortOrder
    client_individual_minor_properties_id?: SortOrder
  }

  export type ClientPassportCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    issued?: SortOrder
    code?: SortOrder
    place_of_birth?: SortOrder
    registration_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientPassportAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClientPassportMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    issued?: SortOrder
    code?: SortOrder
    place_of_birth?: SortOrder
    registration_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientPassportMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    issued?: SortOrder
    code?: SortOrder
    place_of_birth?: SortOrder
    registration_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientPassportSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumClientContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientContractType | EnumClientContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientContractType[]
    notIn?: $Enums.ClientContractType[]
    not?: NestedEnumClientContractTypeFilter<$PrismaModel> | $Enums.ClientContractType
  }

  export type ObjectRelationFilter = {
    is?: ObjectWhereInput
    isNot?: ObjectWhereInput
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type RealEstateAgentNullableRelationFilter = {
    is?: RealEstateAgentWhereInput | null
    isNot?: RealEstateAgentWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type BankNullableRelationFilter = {
    is?: BankWhereInput | null
    isNot?: BankWhereInput | null
  }

  export type DDUClientContractPropertiesNullableRelationFilter = {
    is?: DDUClientContractPropertiesWhereInput | null
    isNot?: DDUClientContractPropertiesWhereInput | null
  }

  export type ClientContractToAgencyContractListRelationFilter = {
    every?: ClientContractToAgencyContractWhereInput
    some?: ClientContractToAgencyContractWhereInput
    none?: ClientContractToAgencyContractWhereInput
  }

  export type ScheduledPaymentListRelationFilter = {
    every?: ScheduledPaymentWhereInput
    some?: ScheduledPaymentWhereInput
    none?: ScheduledPaymentWhereInput
  }

  export type ActualPaymentListRelationFilter = {
    every?: ActualPaymentWhereInput
    some?: ActualPaymentWhereInput
    none?: ActualPaymentWhereInput
  }

  export type ClientContractToAgencyContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduledPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActualPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientContractCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    registration_date?: SortOrder
    price?: SortOrder
    client_contract_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    object_id?: SortOrder
    product_id?: SortOrder
    real_estate_agent_id?: SortOrder
    manager_id?: SortOrder
    bank_id?: SortOrder
    ddu_client_contract_properties_id?: SortOrder
  }

  export type ClientContractAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    object_id?: SortOrder
    product_id?: SortOrder
    real_estate_agent_id?: SortOrder
    manager_id?: SortOrder
    bank_id?: SortOrder
    ddu_client_contract_properties_id?: SortOrder
  }

  export type ClientContractMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    registration_date?: SortOrder
    price?: SortOrder
    client_contract_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    object_id?: SortOrder
    product_id?: SortOrder
    real_estate_agent_id?: SortOrder
    manager_id?: SortOrder
    bank_id?: SortOrder
    ddu_client_contract_properties_id?: SortOrder
  }

  export type ClientContractMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    registration_date?: SortOrder
    price?: SortOrder
    client_contract_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    object_id?: SortOrder
    product_id?: SortOrder
    real_estate_agent_id?: SortOrder
    manager_id?: SortOrder
    bank_id?: SortOrder
    ddu_client_contract_properties_id?: SortOrder
  }

  export type ClientContractSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    object_id?: SortOrder
    product_id?: SortOrder
    real_estate_agent_id?: SortOrder
    manager_id?: SortOrder
    bank_id?: SortOrder
    ddu_client_contract_properties_id?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumClientContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientContractType | EnumClientContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientContractType[]
    notIn?: $Enums.ClientContractType[]
    not?: NestedEnumClientContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientContractTypeFilter<$PrismaModel>
    _max?: NestedEnumClientContractTypeFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ClientContractNullableRelationFilter = {
    is?: ClientContractWhereInput | null
    isNot?: ClientContractWhereInput | null
  }

  export type DDUClientContractPropertiesCountOrderByAggregateInput = {
    id?: SortOrder
    ddu_link?: SortOrder
    return_account?: SortOrder
    escrow_account_opening_date?: SortOrder
    escrow_period?: SortOrder
    escrow_account_number?: SortOrder
    is_escrow_discount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DDUClientContractPropertiesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DDUClientContractPropertiesMaxOrderByAggregateInput = {
    id?: SortOrder
    ddu_link?: SortOrder
    return_account?: SortOrder
    escrow_account_opening_date?: SortOrder
    escrow_period?: SortOrder
    escrow_account_number?: SortOrder
    is_escrow_discount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DDUClientContractPropertiesMinOrderByAggregateInput = {
    id?: SortOrder
    ddu_link?: SortOrder
    return_account?: SortOrder
    escrow_account_opening_date?: SortOrder
    escrow_period?: SortOrder
    escrow_account_number?: SortOrder
    is_escrow_discount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DDUClientContractPropertiesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ClientContractRelationFilter = {
    is?: ClientContractWhereInput
    isNot?: ClientContractWhereInput
  }

  export type AgencyContractRelationFilter = {
    is?: AgencyContractWhereInput
    isNot?: AgencyContractWhereInput
  }

  export type ClientContractToAgencyContractClient_contract_idAgency_contract_idCompoundUniqueInput = {
    client_contract_id: number
    agency_contract_id: number
  }

  export type ClientContractToAgencyContractCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
    agency_contract_id?: SortOrder
  }

  export type ClientContractToAgencyContractAvgOrderByAggregateInput = {
    client_contract_id?: SortOrder
    agency_contract_id?: SortOrder
  }

  export type ClientContractToAgencyContractMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
    agency_contract_id?: SortOrder
  }

  export type ClientContractToAgencyContractMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
    agency_contract_id?: SortOrder
  }

  export type ClientContractToAgencyContractSumOrderByAggregateInput = {
    client_contract_id?: SortOrder
    agency_contract_id?: SortOrder
  }

  export type ClientContractToClientClient_contract_idClient_idCompoundUniqueInput = {
    client_contract_id: number
    client_id: number
  }

  export type ClientContractToClientCountOrderByAggregateInput = {
    is_main?: SortOrder
    share?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
    client_id?: SortOrder
  }

  export type ClientContractToClientAvgOrderByAggregateInput = {
    share?: SortOrder
    client_contract_id?: SortOrder
    client_id?: SortOrder
  }

  export type ClientContractToClientMaxOrderByAggregateInput = {
    is_main?: SortOrder
    share?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
    client_id?: SortOrder
  }

  export type ClientContractToClientMinOrderByAggregateInput = {
    is_main?: SortOrder
    share?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
    client_id?: SortOrder
  }

  export type ClientContractToClientSumOrderByAggregateInput = {
    share?: SortOrder
    client_contract_id?: SortOrder
    client_id?: SortOrder
  }

  export type EnumScheduledPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledPaymentType | EnumScheduledPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledPaymentType[]
    notIn?: $Enums.ScheduledPaymentType[]
    not?: NestedEnumScheduledPaymentTypeFilter<$PrismaModel> | $Enums.ScheduledPaymentType
  }

  export type ScheduledPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    scheduled_payment_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
  }

  export type ScheduledPaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    client_contract_id?: SortOrder
  }

  export type ScheduledPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    scheduled_payment_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
  }

  export type ScheduledPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    scheduled_payment_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
  }

  export type ScheduledPaymentSumOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    client_contract_id?: SortOrder
  }

  export type EnumScheduledPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledPaymentType | EnumScheduledPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledPaymentType[]
    notIn?: $Enums.ScheduledPaymentType[]
    not?: NestedEnumScheduledPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScheduledPaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduledPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumScheduledPaymentTypeFilter<$PrismaModel>
  }

  export type ActualPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
  }

  export type ActualPaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    client_contract_id?: SortOrder
  }

  export type ActualPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
  }

  export type ActualPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_contract_id?: SortOrder
  }

  export type ActualPaymentSumOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    client_contract_id?: SortOrder
  }

  export type EntityRelationFilter = {
    is?: EntityWhereInput
    isNot?: EntityWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObjectCountOrderByAggregateInput = {
    id?: SortOrder
    common_db_objects_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    entity_id?: SortOrder
  }

  export type ObjectAvgOrderByAggregateInput = {
    id?: SortOrder
    common_db_objects_id?: SortOrder
    entity_id?: SortOrder
  }

  export type ObjectMaxOrderByAggregateInput = {
    id?: SortOrder
    common_db_objects_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    entity_id?: SortOrder
  }

  export type ObjectMinOrderByAggregateInput = {
    id?: SortOrder
    common_db_objects_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    entity_id?: SortOrder
  }

  export type ObjectSumOrderByAggregateInput = {
    id?: SortOrder
    common_db_objects_id?: SortOrder
    entity_id?: SortOrder
  }

  export type EnumProductCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCategory | EnumProductCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCategory[]
    notIn?: $Enums.ProductCategory[]
    not?: NestedEnumProductCategoryFilter<$PrismaModel> | $Enums.ProductCategory
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    pricing_products_id?: SortOrder
    number?: SortOrder
    product_category?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    object_id?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    pricing_products_id?: SortOrder
    object_id?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    pricing_products_id?: SortOrder
    number?: SortOrder
    product_category?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    object_id?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    pricing_products_id?: SortOrder
    number?: SortOrder
    product_category?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    object_id?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    pricing_products_id?: SortOrder
    object_id?: SortOrder
  }

  export type EnumProductCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCategory | EnumProductCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCategory[]
    notIn?: $Enums.ProductCategory[]
    not?: NestedEnumProductCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ProductCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductCategoryFilter<$PrismaModel>
    _max?: NestedEnumProductCategoryFilter<$PrismaModel>
  }

  export type AgencyToRealEstateAgentListRelationFilter = {
    every?: AgencyToRealEstateAgentWhereInput
    some?: AgencyToRealEstateAgentWhereInput
    none?: AgencyToRealEstateAgentWhereInput
  }

  export type AgencyContractSignatoryListRelationFilter = {
    every?: AgencyContractSignatoryWhereInput
    some?: AgencyContractSignatoryWhereInput
    none?: AgencyContractSignatoryWhereInput
  }

  export type AgencyToRealEstateAgentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyContractSignatoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyCountOrderByAggregateInput = {
    id?: SortOrder
    common_db_contractors_id?: SortOrder
    name?: SortOrder
    inn?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AgencyAvgOrderByAggregateInput = {
    id?: SortOrder
    common_db_contractors_id?: SortOrder
  }

  export type AgencyMaxOrderByAggregateInput = {
    id?: SortOrder
    common_db_contractors_id?: SortOrder
    name?: SortOrder
    inn?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AgencyMinOrderByAggregateInput = {
    id?: SortOrder
    common_db_contractors_id?: SortOrder
    name?: SortOrder
    inn?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AgencySumOrderByAggregateInput = {
    id?: SortOrder
    common_db_contractors_id?: SortOrder
  }

  export type EnumAgencyContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyContractType | EnumAgencyContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyContractType[]
    notIn?: $Enums.AgencyContractType[]
    not?: NestedEnumAgencyContractTypeFilter<$PrismaModel> | $Enums.AgencyContractType
  }

  export type AgencyRelationFilter = {
    is?: AgencyWhereInput
    isNot?: AgencyWhereInput
  }

  export type AgencyContractSignatoryNullableRelationFilter = {
    is?: AgencyContractSignatoryWhereInput | null
    isNot?: AgencyContractSignatoryWhereInput | null
  }

  export type RealEstateAgencyContractPropertiesNullableRelationFilter = {
    is?: RealEstateAgencyContractPropertiesWhereInput | null
    isNot?: RealEstateAgencyContractPropertiesWhereInput | null
  }

  export type MIPAgencyContractPropertiesNullableRelationFilter = {
    is?: MIPAgencyContractPropertiesWhereInput | null
    isNot?: MIPAgencyContractPropertiesWhereInput | null
  }

  export type AgencyContractCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    agency_contract_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    responsible_user_id?: SortOrder
    entity_id?: SortOrder
    object_id?: SortOrder
    agency_id?: SortOrder
    agency_contract_signatory_id?: SortOrder
    real_estate_agency_contract_properties_id?: SortOrder
    mip_agency_contract_properties_id?: SortOrder
  }

  export type AgencyContractAvgOrderByAggregateInput = {
    id?: SortOrder
    responsible_user_id?: SortOrder
    entity_id?: SortOrder
    object_id?: SortOrder
    agency_id?: SortOrder
    agency_contract_signatory_id?: SortOrder
    real_estate_agency_contract_properties_id?: SortOrder
    mip_agency_contract_properties_id?: SortOrder
  }

  export type AgencyContractMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    agency_contract_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    responsible_user_id?: SortOrder
    entity_id?: SortOrder
    object_id?: SortOrder
    agency_id?: SortOrder
    agency_contract_signatory_id?: SortOrder
    real_estate_agency_contract_properties_id?: SortOrder
    mip_agency_contract_properties_id?: SortOrder
  }

  export type AgencyContractMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    agency_contract_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    responsible_user_id?: SortOrder
    entity_id?: SortOrder
    object_id?: SortOrder
    agency_id?: SortOrder
    agency_contract_signatory_id?: SortOrder
    real_estate_agency_contract_properties_id?: SortOrder
    mip_agency_contract_properties_id?: SortOrder
  }

  export type AgencyContractSumOrderByAggregateInput = {
    id?: SortOrder
    responsible_user_id?: SortOrder
    entity_id?: SortOrder
    object_id?: SortOrder
    agency_id?: SortOrder
    agency_contract_signatory_id?: SortOrder
    real_estate_agency_contract_properties_id?: SortOrder
    mip_agency_contract_properties_id?: SortOrder
  }

  export type EnumAgencyContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyContractType | EnumAgencyContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyContractType[]
    notIn?: $Enums.AgencyContractType[]
    not?: NestedEnumAgencyContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.AgencyContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgencyContractTypeFilter<$PrismaModel>
    _max?: NestedEnumAgencyContractTypeFilter<$PrismaModel>
  }

  export type AgencyContractSignatoryCountOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    title?: SortOrder
    based_on?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_id?: SortOrder
  }

  export type AgencyContractSignatoryAvgOrderByAggregateInput = {
    id?: SortOrder
    agency_id?: SortOrder
  }

  export type AgencyContractSignatoryMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    title?: SortOrder
    based_on?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_id?: SortOrder
  }

  export type AgencyContractSignatoryMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    title?: SortOrder
    based_on?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_id?: SortOrder
  }

  export type AgencyContractSignatorySumOrderByAggregateInput = {
    id?: SortOrder
    agency_id?: SortOrder
  }

  export type AgencyContractNullableRelationFilter = {
    is?: AgencyContractWhereInput | null
    isNot?: AgencyContractWhereInput | null
  }

  export type AgencyContractCommissionRelationFilter = {
    is?: AgencyContractCommissionWhereInput
    isNot?: AgencyContractCommissionWhereInput
  }

  export type RealEstateAgencyContractPropertiesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_contract_commission_id?: SortOrder
  }

  export type RealEstateAgencyContractPropertiesAvgOrderByAggregateInput = {
    id?: SortOrder
    agency_contract_commission_id?: SortOrder
  }

  export type RealEstateAgencyContractPropertiesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_contract_commission_id?: SortOrder
  }

  export type RealEstateAgencyContractPropertiesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_contract_commission_id?: SortOrder
  }

  export type RealEstateAgencyContractPropertiesSumOrderByAggregateInput = {
    id?: SortOrder
    agency_contract_commission_id?: SortOrder
  }

  export type MIPAgencyContractPropertiesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_contract_commission_id?: SortOrder
  }

  export type MIPAgencyContractPropertiesAvgOrderByAggregateInput = {
    id?: SortOrder
    agency_contract_commission_id?: SortOrder
  }

  export type MIPAgencyContractPropertiesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_contract_commission_id?: SortOrder
  }

  export type MIPAgencyContractPropertiesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_contract_commission_id?: SortOrder
  }

  export type MIPAgencyContractPropertiesSumOrderByAggregateInput = {
    id?: SortOrder
    agency_contract_commission_id?: SortOrder
  }

  export type AgencyContractCommissionCountOrderByAggregateInput = {
    id?: SortOrder
    percent?: SortOrder
    threshold?: SortOrder
    max_days?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AgencyContractCommissionAvgOrderByAggregateInput = {
    id?: SortOrder
    percent?: SortOrder
    threshold?: SortOrder
    max_days?: SortOrder
  }

  export type AgencyContractCommissionMaxOrderByAggregateInput = {
    id?: SortOrder
    percent?: SortOrder
    threshold?: SortOrder
    max_days?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AgencyContractCommissionMinOrderByAggregateInput = {
    id?: SortOrder
    percent?: SortOrder
    threshold?: SortOrder
    max_days?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AgencyContractCommissionSumOrderByAggregateInput = {
    id?: SortOrder
    percent?: SortOrder
    threshold?: SortOrder
    max_days?: SortOrder
  }

  export type RealEstateAgentCountOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RealEstateAgentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RealEstateAgentMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RealEstateAgentMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RealEstateAgentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RealEstateAgentRelationFilter = {
    is?: RealEstateAgentWhereInput
    isNot?: RealEstateAgentWhereInput
  }

  export type AgencyToRealEstateAgentAgency_idReal_estate_agent_idCompoundUniqueInput = {
    agency_id: number
    real_estate_agent_id: number
  }

  export type AgencyToRealEstateAgentCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_id?: SortOrder
    real_estate_agent_id?: SortOrder
  }

  export type AgencyToRealEstateAgentAvgOrderByAggregateInput = {
    agency_id?: SortOrder
    real_estate_agent_id?: SortOrder
  }

  export type AgencyToRealEstateAgentMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_id?: SortOrder
    real_estate_agent_id?: SortOrder
  }

  export type AgencyToRealEstateAgentMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    agency_id?: SortOrder
    real_estate_agent_id?: SortOrder
  }

  export type AgencyToRealEstateAgentSumOrderByAggregateInput = {
    agency_id?: SortOrder
    real_estate_agent_id?: SortOrder
  }

  export type ObjectListRelationFilter = {
    every?: ObjectWhereInput
    some?: ObjectWhereInput
    none?: ObjectWhereInput
  }

  export type EntityForbiddenWebsiteListRelationFilter = {
    every?: EntityForbiddenWebsiteWhereInput
    some?: EntityForbiddenWebsiteWhereInput
    none?: EntityForbiddenWebsiteWhereInput
  }

  export type EntityForbiddenBrandListRelationFilter = {
    every?: EntityForbiddenBrandWhereInput
    some?: EntityForbiddenBrandWhereInput
    none?: EntityForbiddenBrandWhereInput
  }

  export type ObjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntityForbiddenWebsiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntityForbiddenBrandOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntityCountOrderByAggregateInput = {
    id?: SortOrder
    common_db_entities_id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EntityAvgOrderByAggregateInput = {
    id?: SortOrder
    common_db_entities_id?: SortOrder
  }

  export type EntityMaxOrderByAggregateInput = {
    id?: SortOrder
    common_db_entities_id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EntityMinOrderByAggregateInput = {
    id?: SortOrder
    common_db_entities_id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EntitySumOrderByAggregateInput = {
    id?: SortOrder
    common_db_entities_id?: SortOrder
  }

  export type EntityForbiddenWebsiteCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    entity_id?: SortOrder
  }

  export type EntityForbiddenWebsiteAvgOrderByAggregateInput = {
    id?: SortOrder
    entity_id?: SortOrder
  }

  export type EntityForbiddenWebsiteMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    entity_id?: SortOrder
  }

  export type EntityForbiddenWebsiteMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    entity_id?: SortOrder
  }

  export type EntityForbiddenWebsiteSumOrderByAggregateInput = {
    id?: SortOrder
    entity_id?: SortOrder
  }

  export type EntityForbiddenBrandCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    entity_id?: SortOrder
  }

  export type EntityForbiddenBrandAvgOrderByAggregateInput = {
    id?: SortOrder
    entity_id?: SortOrder
  }

  export type EntityForbiddenBrandMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    entity_id?: SortOrder
  }

  export type EntityForbiddenBrandMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    entity_id?: SortOrder
  }

  export type EntityForbiddenBrandSumOrderByAggregateInput = {
    id?: SortOrder
    entity_id?: SortOrder
  }

  export type BankCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BankAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BankMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BankMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BankSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClientContractCreateNestedManyWithoutManagerInput = {
    create?: XOR<ClientContractCreateWithoutManagerInput, ClientContractUncheckedCreateWithoutManagerInput> | ClientContractCreateWithoutManagerInput[] | ClientContractUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutManagerInput | ClientContractCreateOrConnectWithoutManagerInput[]
    createMany?: ClientContractCreateManyManagerInputEnvelope
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
  }

  export type AgencyContractCreateNestedManyWithoutResponsible_userInput = {
    create?: XOR<AgencyContractCreateWithoutResponsible_userInput, AgencyContractUncheckedCreateWithoutResponsible_userInput> | AgencyContractCreateWithoutResponsible_userInput[] | AgencyContractUncheckedCreateWithoutResponsible_userInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutResponsible_userInput | AgencyContractCreateOrConnectWithoutResponsible_userInput[]
    createMany?: AgencyContractCreateManyResponsible_userInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type ClientContractUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<ClientContractCreateWithoutManagerInput, ClientContractUncheckedCreateWithoutManagerInput> | ClientContractCreateWithoutManagerInput[] | ClientContractUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutManagerInput | ClientContractCreateOrConnectWithoutManagerInput[]
    createMany?: ClientContractCreateManyManagerInputEnvelope
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
  }

  export type AgencyContractUncheckedCreateNestedManyWithoutResponsible_userInput = {
    create?: XOR<AgencyContractCreateWithoutResponsible_userInput, AgencyContractUncheckedCreateWithoutResponsible_userInput> | AgencyContractCreateWithoutResponsible_userInput[] | AgencyContractUncheckedCreateWithoutResponsible_userInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutResponsible_userInput | AgencyContractCreateOrConnectWithoutResponsible_userInput[]
    createMany?: AgencyContractCreateManyResponsible_userInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ClientContractUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ClientContractCreateWithoutManagerInput, ClientContractUncheckedCreateWithoutManagerInput> | ClientContractCreateWithoutManagerInput[] | ClientContractUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutManagerInput | ClientContractCreateOrConnectWithoutManagerInput[]
    upsert?: ClientContractUpsertWithWhereUniqueWithoutManagerInput | ClientContractUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ClientContractCreateManyManagerInputEnvelope
    set?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    disconnect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    delete?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    update?: ClientContractUpdateWithWhereUniqueWithoutManagerInput | ClientContractUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ClientContractUpdateManyWithWhereWithoutManagerInput | ClientContractUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
  }

  export type AgencyContractUpdateManyWithoutResponsible_userNestedInput = {
    create?: XOR<AgencyContractCreateWithoutResponsible_userInput, AgencyContractUncheckedCreateWithoutResponsible_userInput> | AgencyContractCreateWithoutResponsible_userInput[] | AgencyContractUncheckedCreateWithoutResponsible_userInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutResponsible_userInput | AgencyContractCreateOrConnectWithoutResponsible_userInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutResponsible_userInput | AgencyContractUpsertWithWhereUniqueWithoutResponsible_userInput[]
    createMany?: AgencyContractCreateManyResponsible_userInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutResponsible_userInput | AgencyContractUpdateWithWhereUniqueWithoutResponsible_userInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutResponsible_userInput | AgencyContractUpdateManyWithWhereWithoutResponsible_userInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClientContractUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ClientContractCreateWithoutManagerInput, ClientContractUncheckedCreateWithoutManagerInput> | ClientContractCreateWithoutManagerInput[] | ClientContractUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutManagerInput | ClientContractCreateOrConnectWithoutManagerInput[]
    upsert?: ClientContractUpsertWithWhereUniqueWithoutManagerInput | ClientContractUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ClientContractCreateManyManagerInputEnvelope
    set?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    disconnect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    delete?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    update?: ClientContractUpdateWithWhereUniqueWithoutManagerInput | ClientContractUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ClientContractUpdateManyWithWhereWithoutManagerInput | ClientContractUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
  }

  export type AgencyContractUncheckedUpdateManyWithoutResponsible_userNestedInput = {
    create?: XOR<AgencyContractCreateWithoutResponsible_userInput, AgencyContractUncheckedCreateWithoutResponsible_userInput> | AgencyContractCreateWithoutResponsible_userInput[] | AgencyContractUncheckedCreateWithoutResponsible_userInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutResponsible_userInput | AgencyContractCreateOrConnectWithoutResponsible_userInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutResponsible_userInput | AgencyContractUpsertWithWhereUniqueWithoutResponsible_userInput[]
    createMany?: AgencyContractCreateManyResponsible_userInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutResponsible_userInput | AgencyContractUpdateWithWhereUniqueWithoutResponsible_userInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutResponsible_userInput | AgencyContractUpdateManyWithWhereWithoutResponsible_userInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type ClientIndividualPropertiesCreateNestedOneWithoutClientInput = {
    create?: XOR<ClientIndividualPropertiesCreateWithoutClientInput, ClientIndividualPropertiesUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientIndividualPropertiesCreateOrConnectWithoutClientInput
    connect?: ClientIndividualPropertiesWhereUniqueInput
  }

  export type ClientIndividualMinorPropertiesCreateNestedOneWithoutClientInput = {
    create?: XOR<ClientIndividualMinorPropertiesCreateWithoutClientInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput
    connect?: ClientIndividualMinorPropertiesWhereUniqueInput
  }

  export type ClientEntityPropertiesCreateNestedOneWithoutClientInput = {
    create?: XOR<ClientEntityPropertiesCreateWithoutClientInput, ClientEntityPropertiesUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientEntityPropertiesCreateOrConnectWithoutClientInput
    connect?: ClientEntityPropertiesWhereUniqueInput
  }

  export type ClientContractToClientCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientContractToClientCreateWithoutClientInput, ClientContractToClientUncheckedCreateWithoutClientInput> | ClientContractToClientCreateWithoutClientInput[] | ClientContractToClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientContractToClientCreateOrConnectWithoutClientInput | ClientContractToClientCreateOrConnectWithoutClientInput[]
    createMany?: ClientContractToClientCreateManyClientInputEnvelope
    connect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
  }

  export type ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClientInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput> | ClientToClientIndividualMinorPropertiesCreateWithoutClientInput[] | ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput | ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput[]
    createMany?: ClientToClientIndividualMinorPropertiesCreateManyClientInputEnvelope
    connect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
  }

  export type ClientContractToClientUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientContractToClientCreateWithoutClientInput, ClientContractToClientUncheckedCreateWithoutClientInput> | ClientContractToClientCreateWithoutClientInput[] | ClientContractToClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientContractToClientCreateOrConnectWithoutClientInput | ClientContractToClientCreateOrConnectWithoutClientInput[]
    createMany?: ClientContractToClientCreateManyClientInputEnvelope
    connect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClientInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput> | ClientToClientIndividualMinorPropertiesCreateWithoutClientInput[] | ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput | ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput[]
    createMany?: ClientToClientIndividualMinorPropertiesCreateManyClientInputEnvelope
    connect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
  }

  export type EnumClientCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ClientCategory
  }

  export type ClientIndividualPropertiesUpdateOneWithoutClientNestedInput = {
    create?: XOR<ClientIndividualPropertiesCreateWithoutClientInput, ClientIndividualPropertiesUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientIndividualPropertiesCreateOrConnectWithoutClientInput
    upsert?: ClientIndividualPropertiesUpsertWithoutClientInput
    disconnect?: ClientIndividualPropertiesWhereInput | boolean
    delete?: ClientIndividualPropertiesWhereInput | boolean
    connect?: ClientIndividualPropertiesWhereUniqueInput
    update?: XOR<XOR<ClientIndividualPropertiesUpdateToOneWithWhereWithoutClientInput, ClientIndividualPropertiesUpdateWithoutClientInput>, ClientIndividualPropertiesUncheckedUpdateWithoutClientInput>
  }

  export type ClientIndividualMinorPropertiesUpdateOneWithoutClientNestedInput = {
    create?: XOR<ClientIndividualMinorPropertiesCreateWithoutClientInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput
    upsert?: ClientIndividualMinorPropertiesUpsertWithoutClientInput
    disconnect?: ClientIndividualMinorPropertiesWhereInput | boolean
    delete?: ClientIndividualMinorPropertiesWhereInput | boolean
    connect?: ClientIndividualMinorPropertiesWhereUniqueInput
    update?: XOR<XOR<ClientIndividualMinorPropertiesUpdateToOneWithWhereWithoutClientInput, ClientIndividualMinorPropertiesUpdateWithoutClientInput>, ClientIndividualMinorPropertiesUncheckedUpdateWithoutClientInput>
  }

  export type ClientEntityPropertiesUpdateOneWithoutClientNestedInput = {
    create?: XOR<ClientEntityPropertiesCreateWithoutClientInput, ClientEntityPropertiesUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientEntityPropertiesCreateOrConnectWithoutClientInput
    upsert?: ClientEntityPropertiesUpsertWithoutClientInput
    disconnect?: ClientEntityPropertiesWhereInput | boolean
    delete?: ClientEntityPropertiesWhereInput | boolean
    connect?: ClientEntityPropertiesWhereUniqueInput
    update?: XOR<XOR<ClientEntityPropertiesUpdateToOneWithWhereWithoutClientInput, ClientEntityPropertiesUpdateWithoutClientInput>, ClientEntityPropertiesUncheckedUpdateWithoutClientInput>
  }

  export type ClientContractToClientUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientContractToClientCreateWithoutClientInput, ClientContractToClientUncheckedCreateWithoutClientInput> | ClientContractToClientCreateWithoutClientInput[] | ClientContractToClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientContractToClientCreateOrConnectWithoutClientInput | ClientContractToClientCreateOrConnectWithoutClientInput[]
    upsert?: ClientContractToClientUpsertWithWhereUniqueWithoutClientInput | ClientContractToClientUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientContractToClientCreateManyClientInputEnvelope
    set?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    disconnect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    delete?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    connect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    update?: ClientContractToClientUpdateWithWhereUniqueWithoutClientInput | ClientContractToClientUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientContractToClientUpdateManyWithWhereWithoutClientInput | ClientContractToClientUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientContractToClientScalarWhereInput | ClientContractToClientScalarWhereInput[]
  }

  export type ClientToClientIndividualMinorPropertiesUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClientInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput> | ClientToClientIndividualMinorPropertiesCreateWithoutClientInput[] | ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput | ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput[]
    upsert?: ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClientInput | ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientToClientIndividualMinorPropertiesCreateManyClientInputEnvelope
    set?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    disconnect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    delete?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    connect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    update?: ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClientInput | ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClientInput | ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientToClientIndividualMinorPropertiesScalarWhereInput | ClientToClientIndividualMinorPropertiesScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClientContractToClientUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientContractToClientCreateWithoutClientInput, ClientContractToClientUncheckedCreateWithoutClientInput> | ClientContractToClientCreateWithoutClientInput[] | ClientContractToClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientContractToClientCreateOrConnectWithoutClientInput | ClientContractToClientCreateOrConnectWithoutClientInput[]
    upsert?: ClientContractToClientUpsertWithWhereUniqueWithoutClientInput | ClientContractToClientUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientContractToClientCreateManyClientInputEnvelope
    set?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    disconnect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    delete?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    connect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    update?: ClientContractToClientUpdateWithWhereUniqueWithoutClientInput | ClientContractToClientUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientContractToClientUpdateManyWithWhereWithoutClientInput | ClientContractToClientUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientContractToClientScalarWhereInput | ClientContractToClientScalarWhereInput[]
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClientInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput> | ClientToClientIndividualMinorPropertiesCreateWithoutClientInput[] | ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput | ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput[]
    upsert?: ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClientInput | ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientToClientIndividualMinorPropertiesCreateManyClientInputEnvelope
    set?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    disconnect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    delete?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    connect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    update?: ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClientInput | ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClientInput | ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientToClientIndividualMinorPropertiesScalarWhereInput | ClientToClientIndividualMinorPropertiesScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutClient_individual_propertiesInput = {
    create?: XOR<ClientCreateWithoutClient_individual_propertiesInput, ClientUncheckedCreateWithoutClient_individual_propertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClient_individual_propertiesInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientPassportCreateNestedOneWithoutClient_individual_propertiesInput = {
    create?: XOR<ClientPassportCreateWithoutClient_individual_propertiesInput, ClientPassportUncheckedCreateWithoutClient_individual_propertiesInput>
    connectOrCreate?: ClientPassportCreateOrConnectWithoutClient_individual_propertiesInput
    connect?: ClientPassportWhereUniqueInput
  }

  export type ClientUncheckedCreateNestedOneWithoutClient_individual_propertiesInput = {
    create?: XOR<ClientCreateWithoutClient_individual_propertiesInput, ClientUncheckedCreateWithoutClient_individual_propertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClient_individual_propertiesInput
    connect?: ClientWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ClientUpdateOneWithoutClient_individual_propertiesNestedInput = {
    create?: XOR<ClientCreateWithoutClient_individual_propertiesInput, ClientUncheckedCreateWithoutClient_individual_propertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClient_individual_propertiesInput
    upsert?: ClientUpsertWithoutClient_individual_propertiesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClient_individual_propertiesInput, ClientUpdateWithoutClient_individual_propertiesInput>, ClientUncheckedUpdateWithoutClient_individual_propertiesInput>
  }

  export type ClientPassportUpdateOneWithoutClient_individual_propertiesNestedInput = {
    create?: XOR<ClientPassportCreateWithoutClient_individual_propertiesInput, ClientPassportUncheckedCreateWithoutClient_individual_propertiesInput>
    connectOrCreate?: ClientPassportCreateOrConnectWithoutClient_individual_propertiesInput
    upsert?: ClientPassportUpsertWithoutClient_individual_propertiesInput
    disconnect?: ClientPassportWhereInput | boolean
    delete?: ClientPassportWhereInput | boolean
    connect?: ClientPassportWhereUniqueInput
    update?: XOR<XOR<ClientPassportUpdateToOneWithWhereWithoutClient_individual_propertiesInput, ClientPassportUpdateWithoutClient_individual_propertiesInput>, ClientPassportUncheckedUpdateWithoutClient_individual_propertiesInput>
  }

  export type ClientUncheckedUpdateOneWithoutClient_individual_propertiesNestedInput = {
    create?: XOR<ClientCreateWithoutClient_individual_propertiesInput, ClientUncheckedCreateWithoutClient_individual_propertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClient_individual_propertiesInput
    upsert?: ClientUpsertWithoutClient_individual_propertiesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClient_individual_propertiesInput, ClientUpdateWithoutClient_individual_propertiesInput>, ClientUncheckedUpdateWithoutClient_individual_propertiesInput>
  }

  export type ClientCreateNestedOneWithoutClient_individual_minor_propertiesInput = {
    create?: XOR<ClientCreateWithoutClient_individual_minor_propertiesInput, ClientUncheckedCreateWithoutClient_individual_minor_propertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClient_individual_minor_propertiesInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientPassportCreateNestedOneWithoutClient_individual_minor_propertiesInput = {
    create?: XOR<ClientPassportCreateWithoutClient_individual_minor_propertiesInput, ClientPassportUncheckedCreateWithoutClient_individual_minor_propertiesInput>
    connectOrCreate?: ClientPassportCreateOrConnectWithoutClient_individual_minor_propertiesInput
    connect?: ClientPassportWhereUniqueInput
  }

  export type ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClient_individual_minor_propertiesInput = {
    create?: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClient_individual_minor_propertiesInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClient_individual_minor_propertiesInput> | ClientToClientIndividualMinorPropertiesCreateWithoutClient_individual_minor_propertiesInput[] | ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClient_individual_minor_propertiesInput[]
    connectOrCreate?: ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClient_individual_minor_propertiesInput | ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClient_individual_minor_propertiesInput[]
    createMany?: ClientToClientIndividualMinorPropertiesCreateManyClient_individual_minor_propertiesInputEnvelope
    connect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedOneWithoutClient_individual_minor_propertiesInput = {
    create?: XOR<ClientCreateWithoutClient_individual_minor_propertiesInput, ClientUncheckedCreateWithoutClient_individual_minor_propertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClient_individual_minor_propertiesInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClient_individual_minor_propertiesInput = {
    create?: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClient_individual_minor_propertiesInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClient_individual_minor_propertiesInput> | ClientToClientIndividualMinorPropertiesCreateWithoutClient_individual_minor_propertiesInput[] | ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClient_individual_minor_propertiesInput[]
    connectOrCreate?: ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClient_individual_minor_propertiesInput | ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClient_individual_minor_propertiesInput[]
    createMany?: ClientToClientIndividualMinorPropertiesCreateManyClient_individual_minor_propertiesInputEnvelope
    connect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
  }

  export type ClientUpdateOneWithoutClient_individual_minor_propertiesNestedInput = {
    create?: XOR<ClientCreateWithoutClient_individual_minor_propertiesInput, ClientUncheckedCreateWithoutClient_individual_minor_propertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClient_individual_minor_propertiesInput
    upsert?: ClientUpsertWithoutClient_individual_minor_propertiesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClient_individual_minor_propertiesInput, ClientUpdateWithoutClient_individual_minor_propertiesInput>, ClientUncheckedUpdateWithoutClient_individual_minor_propertiesInput>
  }

  export type ClientPassportUpdateOneWithoutClient_individual_minor_propertiesNestedInput = {
    create?: XOR<ClientPassportCreateWithoutClient_individual_minor_propertiesInput, ClientPassportUncheckedCreateWithoutClient_individual_minor_propertiesInput>
    connectOrCreate?: ClientPassportCreateOrConnectWithoutClient_individual_minor_propertiesInput
    upsert?: ClientPassportUpsertWithoutClient_individual_minor_propertiesInput
    disconnect?: ClientPassportWhereInput | boolean
    delete?: ClientPassportWhereInput | boolean
    connect?: ClientPassportWhereUniqueInput
    update?: XOR<XOR<ClientPassportUpdateToOneWithWhereWithoutClient_individual_minor_propertiesInput, ClientPassportUpdateWithoutClient_individual_minor_propertiesInput>, ClientPassportUncheckedUpdateWithoutClient_individual_minor_propertiesInput>
  }

  export type ClientToClientIndividualMinorPropertiesUpdateManyWithoutClient_individual_minor_propertiesNestedInput = {
    create?: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClient_individual_minor_propertiesInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClient_individual_minor_propertiesInput> | ClientToClientIndividualMinorPropertiesCreateWithoutClient_individual_minor_propertiesInput[] | ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClient_individual_minor_propertiesInput[]
    connectOrCreate?: ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClient_individual_minor_propertiesInput | ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClient_individual_minor_propertiesInput[]
    upsert?: ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClient_individual_minor_propertiesInput | ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClient_individual_minor_propertiesInput[]
    createMany?: ClientToClientIndividualMinorPropertiesCreateManyClient_individual_minor_propertiesInputEnvelope
    set?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    disconnect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    delete?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    connect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    update?: ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClient_individual_minor_propertiesInput | ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClient_individual_minor_propertiesInput[]
    updateMany?: ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClient_individual_minor_propertiesInput | ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClient_individual_minor_propertiesInput[]
    deleteMany?: ClientToClientIndividualMinorPropertiesScalarWhereInput | ClientToClientIndividualMinorPropertiesScalarWhereInput[]
  }

  export type ClientUncheckedUpdateOneWithoutClient_individual_minor_propertiesNestedInput = {
    create?: XOR<ClientCreateWithoutClient_individual_minor_propertiesInput, ClientUncheckedCreateWithoutClient_individual_minor_propertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClient_individual_minor_propertiesInput
    upsert?: ClientUpsertWithoutClient_individual_minor_propertiesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClient_individual_minor_propertiesInput, ClientUpdateWithoutClient_individual_minor_propertiesInput>, ClientUncheckedUpdateWithoutClient_individual_minor_propertiesInput>
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClient_individual_minor_propertiesNestedInput = {
    create?: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClient_individual_minor_propertiesInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClient_individual_minor_propertiesInput> | ClientToClientIndividualMinorPropertiesCreateWithoutClient_individual_minor_propertiesInput[] | ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClient_individual_minor_propertiesInput[]
    connectOrCreate?: ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClient_individual_minor_propertiesInput | ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClient_individual_minor_propertiesInput[]
    upsert?: ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClient_individual_minor_propertiesInput | ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClient_individual_minor_propertiesInput[]
    createMany?: ClientToClientIndividualMinorPropertiesCreateManyClient_individual_minor_propertiesInputEnvelope
    set?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    disconnect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    delete?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    connect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    update?: ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClient_individual_minor_propertiesInput | ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClient_individual_minor_propertiesInput[]
    updateMany?: ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClient_individual_minor_propertiesInput | ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClient_individual_minor_propertiesInput[]
    deleteMany?: ClientToClientIndividualMinorPropertiesScalarWhereInput | ClientToClientIndividualMinorPropertiesScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutClient_entity_propertiesInput = {
    create?: XOR<ClientCreateWithoutClient_entity_propertiesInput, ClientUncheckedCreateWithoutClient_entity_propertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClient_entity_propertiesInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUncheckedCreateNestedOneWithoutClient_entity_propertiesInput = {
    create?: XOR<ClientCreateWithoutClient_entity_propertiesInput, ClientUncheckedCreateWithoutClient_entity_propertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClient_entity_propertiesInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUpdateOneWithoutClient_entity_propertiesNestedInput = {
    create?: XOR<ClientCreateWithoutClient_entity_propertiesInput, ClientUncheckedCreateWithoutClient_entity_propertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClient_entity_propertiesInput
    upsert?: ClientUpsertWithoutClient_entity_propertiesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClient_entity_propertiesInput, ClientUpdateWithoutClient_entity_propertiesInput>, ClientUncheckedUpdateWithoutClient_entity_propertiesInput>
  }

  export type ClientUncheckedUpdateOneWithoutClient_entity_propertiesNestedInput = {
    create?: XOR<ClientCreateWithoutClient_entity_propertiesInput, ClientUncheckedCreateWithoutClient_entity_propertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClient_entity_propertiesInput
    upsert?: ClientUpsertWithoutClient_entity_propertiesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClient_entity_propertiesInput, ClientUpdateWithoutClient_entity_propertiesInput>, ClientUncheckedUpdateWithoutClient_entity_propertiesInput>
  }

  export type ClientCreateNestedOneWithoutClients_to_client_individual_minor_propertiesInput = {
    create?: XOR<ClientCreateWithoutClients_to_client_individual_minor_propertiesInput, ClientUncheckedCreateWithoutClients_to_client_individual_minor_propertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClients_to_client_individual_minor_propertiesInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientIndividualMinorPropertiesCreateNestedOneWithoutRepresentativesInput = {
    create?: XOR<ClientIndividualMinorPropertiesCreateWithoutRepresentativesInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutRepresentativesInput>
    connectOrCreate?: ClientIndividualMinorPropertiesCreateOrConnectWithoutRepresentativesInput
    connect?: ClientIndividualMinorPropertiesWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutClients_to_client_individual_minor_propertiesNestedInput = {
    create?: XOR<ClientCreateWithoutClients_to_client_individual_minor_propertiesInput, ClientUncheckedCreateWithoutClients_to_client_individual_minor_propertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClients_to_client_individual_minor_propertiesInput
    upsert?: ClientUpsertWithoutClients_to_client_individual_minor_propertiesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClients_to_client_individual_minor_propertiesInput, ClientUpdateWithoutClients_to_client_individual_minor_propertiesInput>, ClientUncheckedUpdateWithoutClients_to_client_individual_minor_propertiesInput>
  }

  export type ClientIndividualMinorPropertiesUpdateOneRequiredWithoutRepresentativesNestedInput = {
    create?: XOR<ClientIndividualMinorPropertiesCreateWithoutRepresentativesInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutRepresentativesInput>
    connectOrCreate?: ClientIndividualMinorPropertiesCreateOrConnectWithoutRepresentativesInput
    upsert?: ClientIndividualMinorPropertiesUpsertWithoutRepresentativesInput
    connect?: ClientIndividualMinorPropertiesWhereUniqueInput
    update?: XOR<XOR<ClientIndividualMinorPropertiesUpdateToOneWithWhereWithoutRepresentativesInput, ClientIndividualMinorPropertiesUpdateWithoutRepresentativesInput>, ClientIndividualMinorPropertiesUncheckedUpdateWithoutRepresentativesInput>
  }

  export type ClientIndividualPropertiesCreateNestedOneWithoutClient_passportInput = {
    create?: XOR<ClientIndividualPropertiesCreateWithoutClient_passportInput, ClientIndividualPropertiesUncheckedCreateWithoutClient_passportInput>
    connectOrCreate?: ClientIndividualPropertiesCreateOrConnectWithoutClient_passportInput
    connect?: ClientIndividualPropertiesWhereUniqueInput
  }

  export type ClientIndividualMinorPropertiesCreateNestedOneWithoutClient_passportInput = {
    create?: XOR<ClientIndividualMinorPropertiesCreateWithoutClient_passportInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClient_passportInput>
    connectOrCreate?: ClientIndividualMinorPropertiesCreateOrConnectWithoutClient_passportInput
    connect?: ClientIndividualMinorPropertiesWhereUniqueInput
  }

  export type ClientIndividualPropertiesUncheckedCreateNestedOneWithoutClient_passportInput = {
    create?: XOR<ClientIndividualPropertiesCreateWithoutClient_passportInput, ClientIndividualPropertiesUncheckedCreateWithoutClient_passportInput>
    connectOrCreate?: ClientIndividualPropertiesCreateOrConnectWithoutClient_passportInput
    connect?: ClientIndividualPropertiesWhereUniqueInput
  }

  export type ClientIndividualMinorPropertiesUncheckedCreateNestedOneWithoutClient_passportInput = {
    create?: XOR<ClientIndividualMinorPropertiesCreateWithoutClient_passportInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClient_passportInput>
    connectOrCreate?: ClientIndividualMinorPropertiesCreateOrConnectWithoutClient_passportInput
    connect?: ClientIndividualMinorPropertiesWhereUniqueInput
  }

  export type ClientIndividualPropertiesUpdateOneWithoutClient_passportNestedInput = {
    create?: XOR<ClientIndividualPropertiesCreateWithoutClient_passportInput, ClientIndividualPropertiesUncheckedCreateWithoutClient_passportInput>
    connectOrCreate?: ClientIndividualPropertiesCreateOrConnectWithoutClient_passportInput
    upsert?: ClientIndividualPropertiesUpsertWithoutClient_passportInput
    disconnect?: ClientIndividualPropertiesWhereInput | boolean
    delete?: ClientIndividualPropertiesWhereInput | boolean
    connect?: ClientIndividualPropertiesWhereUniqueInput
    update?: XOR<XOR<ClientIndividualPropertiesUpdateToOneWithWhereWithoutClient_passportInput, ClientIndividualPropertiesUpdateWithoutClient_passportInput>, ClientIndividualPropertiesUncheckedUpdateWithoutClient_passportInput>
  }

  export type ClientIndividualMinorPropertiesUpdateOneWithoutClient_passportNestedInput = {
    create?: XOR<ClientIndividualMinorPropertiesCreateWithoutClient_passportInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClient_passportInput>
    connectOrCreate?: ClientIndividualMinorPropertiesCreateOrConnectWithoutClient_passportInput
    upsert?: ClientIndividualMinorPropertiesUpsertWithoutClient_passportInput
    disconnect?: ClientIndividualMinorPropertiesWhereInput | boolean
    delete?: ClientIndividualMinorPropertiesWhereInput | boolean
    connect?: ClientIndividualMinorPropertiesWhereUniqueInput
    update?: XOR<XOR<ClientIndividualMinorPropertiesUpdateToOneWithWhereWithoutClient_passportInput, ClientIndividualMinorPropertiesUpdateWithoutClient_passportInput>, ClientIndividualMinorPropertiesUncheckedUpdateWithoutClient_passportInput>
  }

  export type ClientIndividualPropertiesUncheckedUpdateOneWithoutClient_passportNestedInput = {
    create?: XOR<ClientIndividualPropertiesCreateWithoutClient_passportInput, ClientIndividualPropertiesUncheckedCreateWithoutClient_passportInput>
    connectOrCreate?: ClientIndividualPropertiesCreateOrConnectWithoutClient_passportInput
    upsert?: ClientIndividualPropertiesUpsertWithoutClient_passportInput
    disconnect?: ClientIndividualPropertiesWhereInput | boolean
    delete?: ClientIndividualPropertiesWhereInput | boolean
    connect?: ClientIndividualPropertiesWhereUniqueInput
    update?: XOR<XOR<ClientIndividualPropertiesUpdateToOneWithWhereWithoutClient_passportInput, ClientIndividualPropertiesUpdateWithoutClient_passportInput>, ClientIndividualPropertiesUncheckedUpdateWithoutClient_passportInput>
  }

  export type ClientIndividualMinorPropertiesUncheckedUpdateOneWithoutClient_passportNestedInput = {
    create?: XOR<ClientIndividualMinorPropertiesCreateWithoutClient_passportInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClient_passportInput>
    connectOrCreate?: ClientIndividualMinorPropertiesCreateOrConnectWithoutClient_passportInput
    upsert?: ClientIndividualMinorPropertiesUpsertWithoutClient_passportInput
    disconnect?: ClientIndividualMinorPropertiesWhereInput | boolean
    delete?: ClientIndividualMinorPropertiesWhereInput | boolean
    connect?: ClientIndividualMinorPropertiesWhereUniqueInput
    update?: XOR<XOR<ClientIndividualMinorPropertiesUpdateToOneWithWhereWithoutClient_passportInput, ClientIndividualMinorPropertiesUpdateWithoutClient_passportInput>, ClientIndividualMinorPropertiesUncheckedUpdateWithoutClient_passportInput>
  }

  export type ObjectCreateNestedOneWithoutClient_contractsInput = {
    create?: XOR<ObjectCreateWithoutClient_contractsInput, ObjectUncheckedCreateWithoutClient_contractsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutClient_contractsInput
    connect?: ObjectWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutClient_contractInput = {
    create?: XOR<ProductCreateWithoutClient_contractInput, ProductUncheckedCreateWithoutClient_contractInput>
    connectOrCreate?: ProductCreateOrConnectWithoutClient_contractInput
    connect?: ProductWhereUniqueInput
  }

  export type RealEstateAgentCreateNestedOneWithoutClient_contractsInput = {
    create?: XOR<RealEstateAgentCreateWithoutClient_contractsInput, RealEstateAgentUncheckedCreateWithoutClient_contractsInput>
    connectOrCreate?: RealEstateAgentCreateOrConnectWithoutClient_contractsInput
    connect?: RealEstateAgentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClient_contractsInput = {
    create?: XOR<UserCreateWithoutClient_contractsInput, UserUncheckedCreateWithoutClient_contractsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClient_contractsInput
    connect?: UserWhereUniqueInput
  }

  export type BankCreateNestedOneWithoutClient_contractsInput = {
    create?: XOR<BankCreateWithoutClient_contractsInput, BankUncheckedCreateWithoutClient_contractsInput>
    connectOrCreate?: BankCreateOrConnectWithoutClient_contractsInput
    connect?: BankWhereUniqueInput
  }

  export type DDUClientContractPropertiesCreateNestedOneWithoutClient_contractInput = {
    create?: XOR<DDUClientContractPropertiesCreateWithoutClient_contractInput, DDUClientContractPropertiesUncheckedCreateWithoutClient_contractInput>
    connectOrCreate?: DDUClientContractPropertiesCreateOrConnectWithoutClient_contractInput
    connect?: DDUClientContractPropertiesWhereUniqueInput
  }

  export type ClientContractToClientCreateNestedManyWithoutClient_contractInput = {
    create?: XOR<ClientContractToClientCreateWithoutClient_contractInput, ClientContractToClientUncheckedCreateWithoutClient_contractInput> | ClientContractToClientCreateWithoutClient_contractInput[] | ClientContractToClientUncheckedCreateWithoutClient_contractInput[]
    connectOrCreate?: ClientContractToClientCreateOrConnectWithoutClient_contractInput | ClientContractToClientCreateOrConnectWithoutClient_contractInput[]
    createMany?: ClientContractToClientCreateManyClient_contractInputEnvelope
    connect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
  }

  export type ClientContractToAgencyContractCreateNestedManyWithoutClient_contractInput = {
    create?: XOR<ClientContractToAgencyContractCreateWithoutClient_contractInput, ClientContractToAgencyContractUncheckedCreateWithoutClient_contractInput> | ClientContractToAgencyContractCreateWithoutClient_contractInput[] | ClientContractToAgencyContractUncheckedCreateWithoutClient_contractInput[]
    connectOrCreate?: ClientContractToAgencyContractCreateOrConnectWithoutClient_contractInput | ClientContractToAgencyContractCreateOrConnectWithoutClient_contractInput[]
    createMany?: ClientContractToAgencyContractCreateManyClient_contractInputEnvelope
    connect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
  }

  export type ScheduledPaymentCreateNestedManyWithoutClient_contractInput = {
    create?: XOR<ScheduledPaymentCreateWithoutClient_contractInput, ScheduledPaymentUncheckedCreateWithoutClient_contractInput> | ScheduledPaymentCreateWithoutClient_contractInput[] | ScheduledPaymentUncheckedCreateWithoutClient_contractInput[]
    connectOrCreate?: ScheduledPaymentCreateOrConnectWithoutClient_contractInput | ScheduledPaymentCreateOrConnectWithoutClient_contractInput[]
    createMany?: ScheduledPaymentCreateManyClient_contractInputEnvelope
    connect?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
  }

  export type ActualPaymentCreateNestedManyWithoutClient_contractInput = {
    create?: XOR<ActualPaymentCreateWithoutClient_contractInput, ActualPaymentUncheckedCreateWithoutClient_contractInput> | ActualPaymentCreateWithoutClient_contractInput[] | ActualPaymentUncheckedCreateWithoutClient_contractInput[]
    connectOrCreate?: ActualPaymentCreateOrConnectWithoutClient_contractInput | ActualPaymentCreateOrConnectWithoutClient_contractInput[]
    createMany?: ActualPaymentCreateManyClient_contractInputEnvelope
    connect?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
  }

  export type ClientContractToClientUncheckedCreateNestedManyWithoutClient_contractInput = {
    create?: XOR<ClientContractToClientCreateWithoutClient_contractInput, ClientContractToClientUncheckedCreateWithoutClient_contractInput> | ClientContractToClientCreateWithoutClient_contractInput[] | ClientContractToClientUncheckedCreateWithoutClient_contractInput[]
    connectOrCreate?: ClientContractToClientCreateOrConnectWithoutClient_contractInput | ClientContractToClientCreateOrConnectWithoutClient_contractInput[]
    createMany?: ClientContractToClientCreateManyClient_contractInputEnvelope
    connect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
  }

  export type ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClient_contractInput = {
    create?: XOR<ClientContractToAgencyContractCreateWithoutClient_contractInput, ClientContractToAgencyContractUncheckedCreateWithoutClient_contractInput> | ClientContractToAgencyContractCreateWithoutClient_contractInput[] | ClientContractToAgencyContractUncheckedCreateWithoutClient_contractInput[]
    connectOrCreate?: ClientContractToAgencyContractCreateOrConnectWithoutClient_contractInput | ClientContractToAgencyContractCreateOrConnectWithoutClient_contractInput[]
    createMany?: ClientContractToAgencyContractCreateManyClient_contractInputEnvelope
    connect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
  }

  export type ScheduledPaymentUncheckedCreateNestedManyWithoutClient_contractInput = {
    create?: XOR<ScheduledPaymentCreateWithoutClient_contractInput, ScheduledPaymentUncheckedCreateWithoutClient_contractInput> | ScheduledPaymentCreateWithoutClient_contractInput[] | ScheduledPaymentUncheckedCreateWithoutClient_contractInput[]
    connectOrCreate?: ScheduledPaymentCreateOrConnectWithoutClient_contractInput | ScheduledPaymentCreateOrConnectWithoutClient_contractInput[]
    createMany?: ScheduledPaymentCreateManyClient_contractInputEnvelope
    connect?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
  }

  export type ActualPaymentUncheckedCreateNestedManyWithoutClient_contractInput = {
    create?: XOR<ActualPaymentCreateWithoutClient_contractInput, ActualPaymentUncheckedCreateWithoutClient_contractInput> | ActualPaymentCreateWithoutClient_contractInput[] | ActualPaymentUncheckedCreateWithoutClient_contractInput[]
    connectOrCreate?: ActualPaymentCreateOrConnectWithoutClient_contractInput | ActualPaymentCreateOrConnectWithoutClient_contractInput[]
    createMany?: ActualPaymentCreateManyClient_contractInputEnvelope
    connect?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumClientContractTypeFieldUpdateOperationsInput = {
    set?: $Enums.ClientContractType
  }

  export type ObjectUpdateOneRequiredWithoutClient_contractsNestedInput = {
    create?: XOR<ObjectCreateWithoutClient_contractsInput, ObjectUncheckedCreateWithoutClient_contractsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutClient_contractsInput
    upsert?: ObjectUpsertWithoutClient_contractsInput
    connect?: ObjectWhereUniqueInput
    update?: XOR<XOR<ObjectUpdateToOneWithWhereWithoutClient_contractsInput, ObjectUpdateWithoutClient_contractsInput>, ObjectUncheckedUpdateWithoutClient_contractsInput>
  }

  export type ProductUpdateOneRequiredWithoutClient_contractNestedInput = {
    create?: XOR<ProductCreateWithoutClient_contractInput, ProductUncheckedCreateWithoutClient_contractInput>
    connectOrCreate?: ProductCreateOrConnectWithoutClient_contractInput
    upsert?: ProductUpsertWithoutClient_contractInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutClient_contractInput, ProductUpdateWithoutClient_contractInput>, ProductUncheckedUpdateWithoutClient_contractInput>
  }

  export type RealEstateAgentUpdateOneWithoutClient_contractsNestedInput = {
    create?: XOR<RealEstateAgentCreateWithoutClient_contractsInput, RealEstateAgentUncheckedCreateWithoutClient_contractsInput>
    connectOrCreate?: RealEstateAgentCreateOrConnectWithoutClient_contractsInput
    upsert?: RealEstateAgentUpsertWithoutClient_contractsInput
    disconnect?: RealEstateAgentWhereInput | boolean
    delete?: RealEstateAgentWhereInput | boolean
    connect?: RealEstateAgentWhereUniqueInput
    update?: XOR<XOR<RealEstateAgentUpdateToOneWithWhereWithoutClient_contractsInput, RealEstateAgentUpdateWithoutClient_contractsInput>, RealEstateAgentUncheckedUpdateWithoutClient_contractsInput>
  }

  export type UserUpdateOneWithoutClient_contractsNestedInput = {
    create?: XOR<UserCreateWithoutClient_contractsInput, UserUncheckedCreateWithoutClient_contractsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClient_contractsInput
    upsert?: UserUpsertWithoutClient_contractsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClient_contractsInput, UserUpdateWithoutClient_contractsInput>, UserUncheckedUpdateWithoutClient_contractsInput>
  }

  export type BankUpdateOneWithoutClient_contractsNestedInput = {
    create?: XOR<BankCreateWithoutClient_contractsInput, BankUncheckedCreateWithoutClient_contractsInput>
    connectOrCreate?: BankCreateOrConnectWithoutClient_contractsInput
    upsert?: BankUpsertWithoutClient_contractsInput
    disconnect?: BankWhereInput | boolean
    delete?: BankWhereInput | boolean
    connect?: BankWhereUniqueInput
    update?: XOR<XOR<BankUpdateToOneWithWhereWithoutClient_contractsInput, BankUpdateWithoutClient_contractsInput>, BankUncheckedUpdateWithoutClient_contractsInput>
  }

  export type DDUClientContractPropertiesUpdateOneWithoutClient_contractNestedInput = {
    create?: XOR<DDUClientContractPropertiesCreateWithoutClient_contractInput, DDUClientContractPropertiesUncheckedCreateWithoutClient_contractInput>
    connectOrCreate?: DDUClientContractPropertiesCreateOrConnectWithoutClient_contractInput
    upsert?: DDUClientContractPropertiesUpsertWithoutClient_contractInput
    disconnect?: DDUClientContractPropertiesWhereInput | boolean
    delete?: DDUClientContractPropertiesWhereInput | boolean
    connect?: DDUClientContractPropertiesWhereUniqueInput
    update?: XOR<XOR<DDUClientContractPropertiesUpdateToOneWithWhereWithoutClient_contractInput, DDUClientContractPropertiesUpdateWithoutClient_contractInput>, DDUClientContractPropertiesUncheckedUpdateWithoutClient_contractInput>
  }

  export type ClientContractToClientUpdateManyWithoutClient_contractNestedInput = {
    create?: XOR<ClientContractToClientCreateWithoutClient_contractInput, ClientContractToClientUncheckedCreateWithoutClient_contractInput> | ClientContractToClientCreateWithoutClient_contractInput[] | ClientContractToClientUncheckedCreateWithoutClient_contractInput[]
    connectOrCreate?: ClientContractToClientCreateOrConnectWithoutClient_contractInput | ClientContractToClientCreateOrConnectWithoutClient_contractInput[]
    upsert?: ClientContractToClientUpsertWithWhereUniqueWithoutClient_contractInput | ClientContractToClientUpsertWithWhereUniqueWithoutClient_contractInput[]
    createMany?: ClientContractToClientCreateManyClient_contractInputEnvelope
    set?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    disconnect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    delete?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    connect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    update?: ClientContractToClientUpdateWithWhereUniqueWithoutClient_contractInput | ClientContractToClientUpdateWithWhereUniqueWithoutClient_contractInput[]
    updateMany?: ClientContractToClientUpdateManyWithWhereWithoutClient_contractInput | ClientContractToClientUpdateManyWithWhereWithoutClient_contractInput[]
    deleteMany?: ClientContractToClientScalarWhereInput | ClientContractToClientScalarWhereInput[]
  }

  export type ClientContractToAgencyContractUpdateManyWithoutClient_contractNestedInput = {
    create?: XOR<ClientContractToAgencyContractCreateWithoutClient_contractInput, ClientContractToAgencyContractUncheckedCreateWithoutClient_contractInput> | ClientContractToAgencyContractCreateWithoutClient_contractInput[] | ClientContractToAgencyContractUncheckedCreateWithoutClient_contractInput[]
    connectOrCreate?: ClientContractToAgencyContractCreateOrConnectWithoutClient_contractInput | ClientContractToAgencyContractCreateOrConnectWithoutClient_contractInput[]
    upsert?: ClientContractToAgencyContractUpsertWithWhereUniqueWithoutClient_contractInput | ClientContractToAgencyContractUpsertWithWhereUniqueWithoutClient_contractInput[]
    createMany?: ClientContractToAgencyContractCreateManyClient_contractInputEnvelope
    set?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    disconnect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    delete?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    connect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    update?: ClientContractToAgencyContractUpdateWithWhereUniqueWithoutClient_contractInput | ClientContractToAgencyContractUpdateWithWhereUniqueWithoutClient_contractInput[]
    updateMany?: ClientContractToAgencyContractUpdateManyWithWhereWithoutClient_contractInput | ClientContractToAgencyContractUpdateManyWithWhereWithoutClient_contractInput[]
    deleteMany?: ClientContractToAgencyContractScalarWhereInput | ClientContractToAgencyContractScalarWhereInput[]
  }

  export type ScheduledPaymentUpdateManyWithoutClient_contractNestedInput = {
    create?: XOR<ScheduledPaymentCreateWithoutClient_contractInput, ScheduledPaymentUncheckedCreateWithoutClient_contractInput> | ScheduledPaymentCreateWithoutClient_contractInput[] | ScheduledPaymentUncheckedCreateWithoutClient_contractInput[]
    connectOrCreate?: ScheduledPaymentCreateOrConnectWithoutClient_contractInput | ScheduledPaymentCreateOrConnectWithoutClient_contractInput[]
    upsert?: ScheduledPaymentUpsertWithWhereUniqueWithoutClient_contractInput | ScheduledPaymentUpsertWithWhereUniqueWithoutClient_contractInput[]
    createMany?: ScheduledPaymentCreateManyClient_contractInputEnvelope
    set?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
    disconnect?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
    delete?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
    connect?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
    update?: ScheduledPaymentUpdateWithWhereUniqueWithoutClient_contractInput | ScheduledPaymentUpdateWithWhereUniqueWithoutClient_contractInput[]
    updateMany?: ScheduledPaymentUpdateManyWithWhereWithoutClient_contractInput | ScheduledPaymentUpdateManyWithWhereWithoutClient_contractInput[]
    deleteMany?: ScheduledPaymentScalarWhereInput | ScheduledPaymentScalarWhereInput[]
  }

  export type ActualPaymentUpdateManyWithoutClient_contractNestedInput = {
    create?: XOR<ActualPaymentCreateWithoutClient_contractInput, ActualPaymentUncheckedCreateWithoutClient_contractInput> | ActualPaymentCreateWithoutClient_contractInput[] | ActualPaymentUncheckedCreateWithoutClient_contractInput[]
    connectOrCreate?: ActualPaymentCreateOrConnectWithoutClient_contractInput | ActualPaymentCreateOrConnectWithoutClient_contractInput[]
    upsert?: ActualPaymentUpsertWithWhereUniqueWithoutClient_contractInput | ActualPaymentUpsertWithWhereUniqueWithoutClient_contractInput[]
    createMany?: ActualPaymentCreateManyClient_contractInputEnvelope
    set?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
    disconnect?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
    delete?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
    connect?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
    update?: ActualPaymentUpdateWithWhereUniqueWithoutClient_contractInput | ActualPaymentUpdateWithWhereUniqueWithoutClient_contractInput[]
    updateMany?: ActualPaymentUpdateManyWithWhereWithoutClient_contractInput | ActualPaymentUpdateManyWithWhereWithoutClient_contractInput[]
    deleteMany?: ActualPaymentScalarWhereInput | ActualPaymentScalarWhereInput[]
  }

  export type ClientContractToClientUncheckedUpdateManyWithoutClient_contractNestedInput = {
    create?: XOR<ClientContractToClientCreateWithoutClient_contractInput, ClientContractToClientUncheckedCreateWithoutClient_contractInput> | ClientContractToClientCreateWithoutClient_contractInput[] | ClientContractToClientUncheckedCreateWithoutClient_contractInput[]
    connectOrCreate?: ClientContractToClientCreateOrConnectWithoutClient_contractInput | ClientContractToClientCreateOrConnectWithoutClient_contractInput[]
    upsert?: ClientContractToClientUpsertWithWhereUniqueWithoutClient_contractInput | ClientContractToClientUpsertWithWhereUniqueWithoutClient_contractInput[]
    createMany?: ClientContractToClientCreateManyClient_contractInputEnvelope
    set?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    disconnect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    delete?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    connect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    update?: ClientContractToClientUpdateWithWhereUniqueWithoutClient_contractInput | ClientContractToClientUpdateWithWhereUniqueWithoutClient_contractInput[]
    updateMany?: ClientContractToClientUpdateManyWithWhereWithoutClient_contractInput | ClientContractToClientUpdateManyWithWhereWithoutClient_contractInput[]
    deleteMany?: ClientContractToClientScalarWhereInput | ClientContractToClientScalarWhereInput[]
  }

  export type ClientContractToAgencyContractUncheckedUpdateManyWithoutClient_contractNestedInput = {
    create?: XOR<ClientContractToAgencyContractCreateWithoutClient_contractInput, ClientContractToAgencyContractUncheckedCreateWithoutClient_contractInput> | ClientContractToAgencyContractCreateWithoutClient_contractInput[] | ClientContractToAgencyContractUncheckedCreateWithoutClient_contractInput[]
    connectOrCreate?: ClientContractToAgencyContractCreateOrConnectWithoutClient_contractInput | ClientContractToAgencyContractCreateOrConnectWithoutClient_contractInput[]
    upsert?: ClientContractToAgencyContractUpsertWithWhereUniqueWithoutClient_contractInput | ClientContractToAgencyContractUpsertWithWhereUniqueWithoutClient_contractInput[]
    createMany?: ClientContractToAgencyContractCreateManyClient_contractInputEnvelope
    set?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    disconnect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    delete?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    connect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    update?: ClientContractToAgencyContractUpdateWithWhereUniqueWithoutClient_contractInput | ClientContractToAgencyContractUpdateWithWhereUniqueWithoutClient_contractInput[]
    updateMany?: ClientContractToAgencyContractUpdateManyWithWhereWithoutClient_contractInput | ClientContractToAgencyContractUpdateManyWithWhereWithoutClient_contractInput[]
    deleteMany?: ClientContractToAgencyContractScalarWhereInput | ClientContractToAgencyContractScalarWhereInput[]
  }

  export type ScheduledPaymentUncheckedUpdateManyWithoutClient_contractNestedInput = {
    create?: XOR<ScheduledPaymentCreateWithoutClient_contractInput, ScheduledPaymentUncheckedCreateWithoutClient_contractInput> | ScheduledPaymentCreateWithoutClient_contractInput[] | ScheduledPaymentUncheckedCreateWithoutClient_contractInput[]
    connectOrCreate?: ScheduledPaymentCreateOrConnectWithoutClient_contractInput | ScheduledPaymentCreateOrConnectWithoutClient_contractInput[]
    upsert?: ScheduledPaymentUpsertWithWhereUniqueWithoutClient_contractInput | ScheduledPaymentUpsertWithWhereUniqueWithoutClient_contractInput[]
    createMany?: ScheduledPaymentCreateManyClient_contractInputEnvelope
    set?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
    disconnect?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
    delete?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
    connect?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
    update?: ScheduledPaymentUpdateWithWhereUniqueWithoutClient_contractInput | ScheduledPaymentUpdateWithWhereUniqueWithoutClient_contractInput[]
    updateMany?: ScheduledPaymentUpdateManyWithWhereWithoutClient_contractInput | ScheduledPaymentUpdateManyWithWhereWithoutClient_contractInput[]
    deleteMany?: ScheduledPaymentScalarWhereInput | ScheduledPaymentScalarWhereInput[]
  }

  export type ActualPaymentUncheckedUpdateManyWithoutClient_contractNestedInput = {
    create?: XOR<ActualPaymentCreateWithoutClient_contractInput, ActualPaymentUncheckedCreateWithoutClient_contractInput> | ActualPaymentCreateWithoutClient_contractInput[] | ActualPaymentUncheckedCreateWithoutClient_contractInput[]
    connectOrCreate?: ActualPaymentCreateOrConnectWithoutClient_contractInput | ActualPaymentCreateOrConnectWithoutClient_contractInput[]
    upsert?: ActualPaymentUpsertWithWhereUniqueWithoutClient_contractInput | ActualPaymentUpsertWithWhereUniqueWithoutClient_contractInput[]
    createMany?: ActualPaymentCreateManyClient_contractInputEnvelope
    set?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
    disconnect?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
    delete?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
    connect?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
    update?: ActualPaymentUpdateWithWhereUniqueWithoutClient_contractInput | ActualPaymentUpdateWithWhereUniqueWithoutClient_contractInput[]
    updateMany?: ActualPaymentUpdateManyWithWhereWithoutClient_contractInput | ActualPaymentUpdateManyWithWhereWithoutClient_contractInput[]
    deleteMany?: ActualPaymentScalarWhereInput | ActualPaymentScalarWhereInput[]
  }

  export type ClientContractCreateNestedOneWithoutDdu_client_contract_propertiesInput = {
    create?: XOR<ClientContractCreateWithoutDdu_client_contract_propertiesInput, ClientContractUncheckedCreateWithoutDdu_client_contract_propertiesInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutDdu_client_contract_propertiesInput
    connect?: ClientContractWhereUniqueInput
  }

  export type ClientContractUncheckedCreateNestedOneWithoutDdu_client_contract_propertiesInput = {
    create?: XOR<ClientContractCreateWithoutDdu_client_contract_propertiesInput, ClientContractUncheckedCreateWithoutDdu_client_contract_propertiesInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutDdu_client_contract_propertiesInput
    connect?: ClientContractWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ClientContractUpdateOneWithoutDdu_client_contract_propertiesNestedInput = {
    create?: XOR<ClientContractCreateWithoutDdu_client_contract_propertiesInput, ClientContractUncheckedCreateWithoutDdu_client_contract_propertiesInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutDdu_client_contract_propertiesInput
    upsert?: ClientContractUpsertWithoutDdu_client_contract_propertiesInput
    disconnect?: ClientContractWhereInput | boolean
    delete?: ClientContractWhereInput | boolean
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutDdu_client_contract_propertiesInput, ClientContractUpdateWithoutDdu_client_contract_propertiesInput>, ClientContractUncheckedUpdateWithoutDdu_client_contract_propertiesInput>
  }

  export type ClientContractUncheckedUpdateOneWithoutDdu_client_contract_propertiesNestedInput = {
    create?: XOR<ClientContractCreateWithoutDdu_client_contract_propertiesInput, ClientContractUncheckedCreateWithoutDdu_client_contract_propertiesInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutDdu_client_contract_propertiesInput
    upsert?: ClientContractUpsertWithoutDdu_client_contract_propertiesInput
    disconnect?: ClientContractWhereInput | boolean
    delete?: ClientContractWhereInput | boolean
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutDdu_client_contract_propertiesInput, ClientContractUpdateWithoutDdu_client_contract_propertiesInput>, ClientContractUncheckedUpdateWithoutDdu_client_contract_propertiesInput>
  }

  export type ClientContractCreateNestedOneWithoutAgency_contractsInput = {
    create?: XOR<ClientContractCreateWithoutAgency_contractsInput, ClientContractUncheckedCreateWithoutAgency_contractsInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutAgency_contractsInput
    connect?: ClientContractWhereUniqueInput
  }

  export type AgencyContractCreateNestedOneWithoutClient_contractsInput = {
    create?: XOR<AgencyContractCreateWithoutClient_contractsInput, AgencyContractUncheckedCreateWithoutClient_contractsInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutClient_contractsInput
    connect?: AgencyContractWhereUniqueInput
  }

  export type ClientContractUpdateOneRequiredWithoutAgency_contractsNestedInput = {
    create?: XOR<ClientContractCreateWithoutAgency_contractsInput, ClientContractUncheckedCreateWithoutAgency_contractsInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutAgency_contractsInput
    upsert?: ClientContractUpsertWithoutAgency_contractsInput
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutAgency_contractsInput, ClientContractUpdateWithoutAgency_contractsInput>, ClientContractUncheckedUpdateWithoutAgency_contractsInput>
  }

  export type AgencyContractUpdateOneRequiredWithoutClient_contractsNestedInput = {
    create?: XOR<AgencyContractCreateWithoutClient_contractsInput, AgencyContractUncheckedCreateWithoutClient_contractsInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutClient_contractsInput
    upsert?: AgencyContractUpsertWithoutClient_contractsInput
    connect?: AgencyContractWhereUniqueInput
    update?: XOR<XOR<AgencyContractUpdateToOneWithWhereWithoutClient_contractsInput, AgencyContractUpdateWithoutClient_contractsInput>, AgencyContractUncheckedUpdateWithoutClient_contractsInput>
  }

  export type ClientContractCreateNestedOneWithoutClientsInput = {
    create?: XOR<ClientContractCreateWithoutClientsInput, ClientContractUncheckedCreateWithoutClientsInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutClientsInput
    connect?: ClientContractWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutClient_contractsInput = {
    create?: XOR<ClientCreateWithoutClient_contractsInput, ClientUncheckedCreateWithoutClient_contractsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClient_contractsInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientContractUpdateOneRequiredWithoutClientsNestedInput = {
    create?: XOR<ClientContractCreateWithoutClientsInput, ClientContractUncheckedCreateWithoutClientsInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutClientsInput
    upsert?: ClientContractUpsertWithoutClientsInput
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutClientsInput, ClientContractUpdateWithoutClientsInput>, ClientContractUncheckedUpdateWithoutClientsInput>
  }

  export type ClientUpdateOneRequiredWithoutClient_contractsNestedInput = {
    create?: XOR<ClientCreateWithoutClient_contractsInput, ClientUncheckedCreateWithoutClient_contractsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClient_contractsInput
    upsert?: ClientUpsertWithoutClient_contractsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClient_contractsInput, ClientUpdateWithoutClient_contractsInput>, ClientUncheckedUpdateWithoutClient_contractsInput>
  }

  export type ClientContractCreateNestedOneWithoutScheduled_paymentsInput = {
    create?: XOR<ClientContractCreateWithoutScheduled_paymentsInput, ClientContractUncheckedCreateWithoutScheduled_paymentsInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutScheduled_paymentsInput
    connect?: ClientContractWhereUniqueInput
  }

  export type EnumScheduledPaymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ScheduledPaymentType
  }

  export type ClientContractUpdateOneRequiredWithoutScheduled_paymentsNestedInput = {
    create?: XOR<ClientContractCreateWithoutScheduled_paymentsInput, ClientContractUncheckedCreateWithoutScheduled_paymentsInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutScheduled_paymentsInput
    upsert?: ClientContractUpsertWithoutScheduled_paymentsInput
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutScheduled_paymentsInput, ClientContractUpdateWithoutScheduled_paymentsInput>, ClientContractUncheckedUpdateWithoutScheduled_paymentsInput>
  }

  export type ClientContractCreateNestedOneWithoutActual_paymentInput = {
    create?: XOR<ClientContractCreateWithoutActual_paymentInput, ClientContractUncheckedCreateWithoutActual_paymentInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutActual_paymentInput
    connect?: ClientContractWhereUniqueInput
  }

  export type ClientContractUpdateOneRequiredWithoutActual_paymentNestedInput = {
    create?: XOR<ClientContractCreateWithoutActual_paymentInput, ClientContractUncheckedCreateWithoutActual_paymentInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutActual_paymentInput
    upsert?: ClientContractUpsertWithoutActual_paymentInput
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutActual_paymentInput, ClientContractUpdateWithoutActual_paymentInput>, ClientContractUncheckedUpdateWithoutActual_paymentInput>
  }

  export type EntityCreateNestedOneWithoutObjectsInput = {
    create?: XOR<EntityCreateWithoutObjectsInput, EntityUncheckedCreateWithoutObjectsInput>
    connectOrCreate?: EntityCreateOrConnectWithoutObjectsInput
    connect?: EntityWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutObjectInput = {
    create?: XOR<ProductCreateWithoutObjectInput, ProductUncheckedCreateWithoutObjectInput> | ProductCreateWithoutObjectInput[] | ProductUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutObjectInput | ProductCreateOrConnectWithoutObjectInput[]
    createMany?: ProductCreateManyObjectInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ClientContractCreateNestedManyWithoutObjectInput = {
    create?: XOR<ClientContractCreateWithoutObjectInput, ClientContractUncheckedCreateWithoutObjectInput> | ClientContractCreateWithoutObjectInput[] | ClientContractUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutObjectInput | ClientContractCreateOrConnectWithoutObjectInput[]
    createMany?: ClientContractCreateManyObjectInputEnvelope
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
  }

  export type AgencyContractCreateNestedManyWithoutObjectInput = {
    create?: XOR<AgencyContractCreateWithoutObjectInput, AgencyContractUncheckedCreateWithoutObjectInput> | AgencyContractCreateWithoutObjectInput[] | AgencyContractUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutObjectInput | AgencyContractCreateOrConnectWithoutObjectInput[]
    createMany?: AgencyContractCreateManyObjectInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutObjectInput = {
    create?: XOR<ProductCreateWithoutObjectInput, ProductUncheckedCreateWithoutObjectInput> | ProductCreateWithoutObjectInput[] | ProductUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutObjectInput | ProductCreateOrConnectWithoutObjectInput[]
    createMany?: ProductCreateManyObjectInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ClientContractUncheckedCreateNestedManyWithoutObjectInput = {
    create?: XOR<ClientContractCreateWithoutObjectInput, ClientContractUncheckedCreateWithoutObjectInput> | ClientContractCreateWithoutObjectInput[] | ClientContractUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutObjectInput | ClientContractCreateOrConnectWithoutObjectInput[]
    createMany?: ClientContractCreateManyObjectInputEnvelope
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
  }

  export type AgencyContractUncheckedCreateNestedManyWithoutObjectInput = {
    create?: XOR<AgencyContractCreateWithoutObjectInput, AgencyContractUncheckedCreateWithoutObjectInput> | AgencyContractCreateWithoutObjectInput[] | AgencyContractUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutObjectInput | AgencyContractCreateOrConnectWithoutObjectInput[]
    createMany?: AgencyContractCreateManyObjectInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type EntityUpdateOneRequiredWithoutObjectsNestedInput = {
    create?: XOR<EntityCreateWithoutObjectsInput, EntityUncheckedCreateWithoutObjectsInput>
    connectOrCreate?: EntityCreateOrConnectWithoutObjectsInput
    upsert?: EntityUpsertWithoutObjectsInput
    connect?: EntityWhereUniqueInput
    update?: XOR<XOR<EntityUpdateToOneWithWhereWithoutObjectsInput, EntityUpdateWithoutObjectsInput>, EntityUncheckedUpdateWithoutObjectsInput>
  }

  export type ProductUpdateManyWithoutObjectNestedInput = {
    create?: XOR<ProductCreateWithoutObjectInput, ProductUncheckedCreateWithoutObjectInput> | ProductCreateWithoutObjectInput[] | ProductUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutObjectInput | ProductCreateOrConnectWithoutObjectInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutObjectInput | ProductUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: ProductCreateManyObjectInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutObjectInput | ProductUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutObjectInput | ProductUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ClientContractUpdateManyWithoutObjectNestedInput = {
    create?: XOR<ClientContractCreateWithoutObjectInput, ClientContractUncheckedCreateWithoutObjectInput> | ClientContractCreateWithoutObjectInput[] | ClientContractUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutObjectInput | ClientContractCreateOrConnectWithoutObjectInput[]
    upsert?: ClientContractUpsertWithWhereUniqueWithoutObjectInput | ClientContractUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: ClientContractCreateManyObjectInputEnvelope
    set?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    disconnect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    delete?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    update?: ClientContractUpdateWithWhereUniqueWithoutObjectInput | ClientContractUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: ClientContractUpdateManyWithWhereWithoutObjectInput | ClientContractUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
  }

  export type AgencyContractUpdateManyWithoutObjectNestedInput = {
    create?: XOR<AgencyContractCreateWithoutObjectInput, AgencyContractUncheckedCreateWithoutObjectInput> | AgencyContractCreateWithoutObjectInput[] | AgencyContractUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutObjectInput | AgencyContractCreateOrConnectWithoutObjectInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutObjectInput | AgencyContractUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: AgencyContractCreateManyObjectInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutObjectInput | AgencyContractUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutObjectInput | AgencyContractUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutObjectNestedInput = {
    create?: XOR<ProductCreateWithoutObjectInput, ProductUncheckedCreateWithoutObjectInput> | ProductCreateWithoutObjectInput[] | ProductUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutObjectInput | ProductCreateOrConnectWithoutObjectInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutObjectInput | ProductUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: ProductCreateManyObjectInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutObjectInput | ProductUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutObjectInput | ProductUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ClientContractUncheckedUpdateManyWithoutObjectNestedInput = {
    create?: XOR<ClientContractCreateWithoutObjectInput, ClientContractUncheckedCreateWithoutObjectInput> | ClientContractCreateWithoutObjectInput[] | ClientContractUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutObjectInput | ClientContractCreateOrConnectWithoutObjectInput[]
    upsert?: ClientContractUpsertWithWhereUniqueWithoutObjectInput | ClientContractUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: ClientContractCreateManyObjectInputEnvelope
    set?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    disconnect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    delete?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    update?: ClientContractUpdateWithWhereUniqueWithoutObjectInput | ClientContractUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: ClientContractUpdateManyWithWhereWithoutObjectInput | ClientContractUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
  }

  export type AgencyContractUncheckedUpdateManyWithoutObjectNestedInput = {
    create?: XOR<AgencyContractCreateWithoutObjectInput, AgencyContractUncheckedCreateWithoutObjectInput> | AgencyContractCreateWithoutObjectInput[] | AgencyContractUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutObjectInput | AgencyContractCreateOrConnectWithoutObjectInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutObjectInput | AgencyContractUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: AgencyContractCreateManyObjectInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutObjectInput | AgencyContractUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutObjectInput | AgencyContractUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type ClientContractCreateNestedOneWithoutProductInput = {
    create?: XOR<ClientContractCreateWithoutProductInput, ClientContractUncheckedCreateWithoutProductInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutProductInput
    connect?: ClientContractWhereUniqueInput
  }

  export type ObjectCreateNestedOneWithoutProductsInput = {
    create?: XOR<ObjectCreateWithoutProductsInput, ObjectUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutProductsInput
    connect?: ObjectWhereUniqueInput
  }

  export type ClientContractUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<ClientContractCreateWithoutProductInput, ClientContractUncheckedCreateWithoutProductInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutProductInput
    connect?: ClientContractWhereUniqueInput
  }

  export type EnumProductCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ProductCategory
  }

  export type ClientContractUpdateOneWithoutProductNestedInput = {
    create?: XOR<ClientContractCreateWithoutProductInput, ClientContractUncheckedCreateWithoutProductInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutProductInput
    upsert?: ClientContractUpsertWithoutProductInput
    disconnect?: ClientContractWhereInput | boolean
    delete?: ClientContractWhereInput | boolean
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutProductInput, ClientContractUpdateWithoutProductInput>, ClientContractUncheckedUpdateWithoutProductInput>
  }

  export type ObjectUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<ObjectCreateWithoutProductsInput, ObjectUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutProductsInput
    upsert?: ObjectUpsertWithoutProductsInput
    connect?: ObjectWhereUniqueInput
    update?: XOR<XOR<ObjectUpdateToOneWithWhereWithoutProductsInput, ObjectUpdateWithoutProductsInput>, ObjectUncheckedUpdateWithoutProductsInput>
  }

  export type ClientContractUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<ClientContractCreateWithoutProductInput, ClientContractUncheckedCreateWithoutProductInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutProductInput
    upsert?: ClientContractUpsertWithoutProductInput
    disconnect?: ClientContractWhereInput | boolean
    delete?: ClientContractWhereInput | boolean
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutProductInput, ClientContractUpdateWithoutProductInput>, ClientContractUncheckedUpdateWithoutProductInput>
  }

  export type AgencyContractCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyContractCreateWithoutAgencyInput, AgencyContractUncheckedCreateWithoutAgencyInput> | AgencyContractCreateWithoutAgencyInput[] | AgencyContractUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutAgencyInput | AgencyContractCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyContractCreateManyAgencyInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type AgencyToRealEstateAgentCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyToRealEstateAgentCreateWithoutAgencyInput, AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput> | AgencyToRealEstateAgentCreateWithoutAgencyInput[] | AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyToRealEstateAgentCreateOrConnectWithoutAgencyInput | AgencyToRealEstateAgentCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyToRealEstateAgentCreateManyAgencyInputEnvelope
    connect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
  }

  export type AgencyContractSignatoryCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyContractSignatoryCreateWithoutAgencyInput, AgencyContractSignatoryUncheckedCreateWithoutAgencyInput> | AgencyContractSignatoryCreateWithoutAgencyInput[] | AgencyContractSignatoryUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyContractSignatoryCreateOrConnectWithoutAgencyInput | AgencyContractSignatoryCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyContractSignatoryCreateManyAgencyInputEnvelope
    connect?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
  }

  export type AgencyContractUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyContractCreateWithoutAgencyInput, AgencyContractUncheckedCreateWithoutAgencyInput> | AgencyContractCreateWithoutAgencyInput[] | AgencyContractUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutAgencyInput | AgencyContractCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyContractCreateManyAgencyInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type AgencyToRealEstateAgentUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyToRealEstateAgentCreateWithoutAgencyInput, AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput> | AgencyToRealEstateAgentCreateWithoutAgencyInput[] | AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyToRealEstateAgentCreateOrConnectWithoutAgencyInput | AgencyToRealEstateAgentCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyToRealEstateAgentCreateManyAgencyInputEnvelope
    connect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
  }

  export type AgencyContractSignatoryUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyContractSignatoryCreateWithoutAgencyInput, AgencyContractSignatoryUncheckedCreateWithoutAgencyInput> | AgencyContractSignatoryCreateWithoutAgencyInput[] | AgencyContractSignatoryUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyContractSignatoryCreateOrConnectWithoutAgencyInput | AgencyContractSignatoryCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyContractSignatoryCreateManyAgencyInputEnvelope
    connect?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
  }

  export type AgencyContractUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyContractCreateWithoutAgencyInput, AgencyContractUncheckedCreateWithoutAgencyInput> | AgencyContractCreateWithoutAgencyInput[] | AgencyContractUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutAgencyInput | AgencyContractCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutAgencyInput | AgencyContractUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyContractCreateManyAgencyInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutAgencyInput | AgencyContractUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutAgencyInput | AgencyContractUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type AgencyToRealEstateAgentUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyToRealEstateAgentCreateWithoutAgencyInput, AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput> | AgencyToRealEstateAgentCreateWithoutAgencyInput[] | AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyToRealEstateAgentCreateOrConnectWithoutAgencyInput | AgencyToRealEstateAgentCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutAgencyInput | AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyToRealEstateAgentCreateManyAgencyInputEnvelope
    set?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    disconnect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    delete?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    connect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    update?: AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutAgencyInput | AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyToRealEstateAgentUpdateManyWithWhereWithoutAgencyInput | AgencyToRealEstateAgentUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyToRealEstateAgentScalarWhereInput | AgencyToRealEstateAgentScalarWhereInput[]
  }

  export type AgencyContractSignatoryUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyContractSignatoryCreateWithoutAgencyInput, AgencyContractSignatoryUncheckedCreateWithoutAgencyInput> | AgencyContractSignatoryCreateWithoutAgencyInput[] | AgencyContractSignatoryUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyContractSignatoryCreateOrConnectWithoutAgencyInput | AgencyContractSignatoryCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyContractSignatoryUpsertWithWhereUniqueWithoutAgencyInput | AgencyContractSignatoryUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyContractSignatoryCreateManyAgencyInputEnvelope
    set?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
    disconnect?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
    delete?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
    connect?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
    update?: AgencyContractSignatoryUpdateWithWhereUniqueWithoutAgencyInput | AgencyContractSignatoryUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyContractSignatoryUpdateManyWithWhereWithoutAgencyInput | AgencyContractSignatoryUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyContractSignatoryScalarWhereInput | AgencyContractSignatoryScalarWhereInput[]
  }

  export type AgencyContractUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyContractCreateWithoutAgencyInput, AgencyContractUncheckedCreateWithoutAgencyInput> | AgencyContractCreateWithoutAgencyInput[] | AgencyContractUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutAgencyInput | AgencyContractCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutAgencyInput | AgencyContractUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyContractCreateManyAgencyInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutAgencyInput | AgencyContractUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutAgencyInput | AgencyContractUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type AgencyToRealEstateAgentUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyToRealEstateAgentCreateWithoutAgencyInput, AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput> | AgencyToRealEstateAgentCreateWithoutAgencyInput[] | AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyToRealEstateAgentCreateOrConnectWithoutAgencyInput | AgencyToRealEstateAgentCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutAgencyInput | AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyToRealEstateAgentCreateManyAgencyInputEnvelope
    set?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    disconnect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    delete?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    connect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    update?: AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutAgencyInput | AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyToRealEstateAgentUpdateManyWithWhereWithoutAgencyInput | AgencyToRealEstateAgentUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyToRealEstateAgentScalarWhereInput | AgencyToRealEstateAgentScalarWhereInput[]
  }

  export type AgencyContractSignatoryUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyContractSignatoryCreateWithoutAgencyInput, AgencyContractSignatoryUncheckedCreateWithoutAgencyInput> | AgencyContractSignatoryCreateWithoutAgencyInput[] | AgencyContractSignatoryUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyContractSignatoryCreateOrConnectWithoutAgencyInput | AgencyContractSignatoryCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyContractSignatoryUpsertWithWhereUniqueWithoutAgencyInput | AgencyContractSignatoryUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyContractSignatoryCreateManyAgencyInputEnvelope
    set?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
    disconnect?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
    delete?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
    connect?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
    update?: AgencyContractSignatoryUpdateWithWhereUniqueWithoutAgencyInput | AgencyContractSignatoryUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyContractSignatoryUpdateManyWithWhereWithoutAgencyInput | AgencyContractSignatoryUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyContractSignatoryScalarWhereInput | AgencyContractSignatoryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAgency_contractsInput = {
    create?: XOR<UserCreateWithoutAgency_contractsInput, UserUncheckedCreateWithoutAgency_contractsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgency_contractsInput
    connect?: UserWhereUniqueInput
  }

  export type EntityCreateNestedOneWithoutAgency_contractsInput = {
    create?: XOR<EntityCreateWithoutAgency_contractsInput, EntityUncheckedCreateWithoutAgency_contractsInput>
    connectOrCreate?: EntityCreateOrConnectWithoutAgency_contractsInput
    connect?: EntityWhereUniqueInput
  }

  export type ObjectCreateNestedOneWithoutAgency_contractsInput = {
    create?: XOR<ObjectCreateWithoutAgency_contractsInput, ObjectUncheckedCreateWithoutAgency_contractsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutAgency_contractsInput
    connect?: ObjectWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutAgency_contractsInput = {
    create?: XOR<AgencyCreateWithoutAgency_contractsInput, AgencyUncheckedCreateWithoutAgency_contractsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgency_contractsInput
    connect?: AgencyWhereUniqueInput
  }

  export type AgencyContractSignatoryCreateNestedOneWithoutAgency_contractInput = {
    create?: XOR<AgencyContractSignatoryCreateWithoutAgency_contractInput, AgencyContractSignatoryUncheckedCreateWithoutAgency_contractInput>
    connectOrCreate?: AgencyContractSignatoryCreateOrConnectWithoutAgency_contractInput
    connect?: AgencyContractSignatoryWhereUniqueInput
  }

  export type RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgency_contractInput = {
    create?: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgency_contractInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgency_contractInput>
    connectOrCreate?: RealEstateAgencyContractPropertiesCreateOrConnectWithoutAgency_contractInput
    connect?: RealEstateAgencyContractPropertiesWhereUniqueInput
  }

  export type MIPAgencyContractPropertiesCreateNestedOneWithoutAgency_contractInput = {
    create?: XOR<MIPAgencyContractPropertiesCreateWithoutAgency_contractInput, MIPAgencyContractPropertiesUncheckedCreateWithoutAgency_contractInput>
    connectOrCreate?: MIPAgencyContractPropertiesCreateOrConnectWithoutAgency_contractInput
    connect?: MIPAgencyContractPropertiesWhereUniqueInput
  }

  export type ClientContractToAgencyContractCreateNestedManyWithoutAgency_contractInput = {
    create?: XOR<ClientContractToAgencyContractCreateWithoutAgency_contractInput, ClientContractToAgencyContractUncheckedCreateWithoutAgency_contractInput> | ClientContractToAgencyContractCreateWithoutAgency_contractInput[] | ClientContractToAgencyContractUncheckedCreateWithoutAgency_contractInput[]
    connectOrCreate?: ClientContractToAgencyContractCreateOrConnectWithoutAgency_contractInput | ClientContractToAgencyContractCreateOrConnectWithoutAgency_contractInput[]
    createMany?: ClientContractToAgencyContractCreateManyAgency_contractInputEnvelope
    connect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
  }

  export type ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgency_contractInput = {
    create?: XOR<ClientContractToAgencyContractCreateWithoutAgency_contractInput, ClientContractToAgencyContractUncheckedCreateWithoutAgency_contractInput> | ClientContractToAgencyContractCreateWithoutAgency_contractInput[] | ClientContractToAgencyContractUncheckedCreateWithoutAgency_contractInput[]
    connectOrCreate?: ClientContractToAgencyContractCreateOrConnectWithoutAgency_contractInput | ClientContractToAgencyContractCreateOrConnectWithoutAgency_contractInput[]
    createMany?: ClientContractToAgencyContractCreateManyAgency_contractInputEnvelope
    connect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
  }

  export type EnumAgencyContractTypeFieldUpdateOperationsInput = {
    set?: $Enums.AgencyContractType
  }

  export type UserUpdateOneWithoutAgency_contractsNestedInput = {
    create?: XOR<UserCreateWithoutAgency_contractsInput, UserUncheckedCreateWithoutAgency_contractsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgency_contractsInput
    upsert?: UserUpsertWithoutAgency_contractsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgency_contractsInput, UserUpdateWithoutAgency_contractsInput>, UserUncheckedUpdateWithoutAgency_contractsInput>
  }

  export type EntityUpdateOneRequiredWithoutAgency_contractsNestedInput = {
    create?: XOR<EntityCreateWithoutAgency_contractsInput, EntityUncheckedCreateWithoutAgency_contractsInput>
    connectOrCreate?: EntityCreateOrConnectWithoutAgency_contractsInput
    upsert?: EntityUpsertWithoutAgency_contractsInput
    connect?: EntityWhereUniqueInput
    update?: XOR<XOR<EntityUpdateToOneWithWhereWithoutAgency_contractsInput, EntityUpdateWithoutAgency_contractsInput>, EntityUncheckedUpdateWithoutAgency_contractsInput>
  }

  export type ObjectUpdateOneRequiredWithoutAgency_contractsNestedInput = {
    create?: XOR<ObjectCreateWithoutAgency_contractsInput, ObjectUncheckedCreateWithoutAgency_contractsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutAgency_contractsInput
    upsert?: ObjectUpsertWithoutAgency_contractsInput
    connect?: ObjectWhereUniqueInput
    update?: XOR<XOR<ObjectUpdateToOneWithWhereWithoutAgency_contractsInput, ObjectUpdateWithoutAgency_contractsInput>, ObjectUncheckedUpdateWithoutAgency_contractsInput>
  }

  export type AgencyUpdateOneRequiredWithoutAgency_contractsNestedInput = {
    create?: XOR<AgencyCreateWithoutAgency_contractsInput, AgencyUncheckedCreateWithoutAgency_contractsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgency_contractsInput
    upsert?: AgencyUpsertWithoutAgency_contractsInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAgency_contractsInput, AgencyUpdateWithoutAgency_contractsInput>, AgencyUncheckedUpdateWithoutAgency_contractsInput>
  }

  export type AgencyContractSignatoryUpdateOneWithoutAgency_contractNestedInput = {
    create?: XOR<AgencyContractSignatoryCreateWithoutAgency_contractInput, AgencyContractSignatoryUncheckedCreateWithoutAgency_contractInput>
    connectOrCreate?: AgencyContractSignatoryCreateOrConnectWithoutAgency_contractInput
    upsert?: AgencyContractSignatoryUpsertWithoutAgency_contractInput
    disconnect?: AgencyContractSignatoryWhereInput | boolean
    delete?: AgencyContractSignatoryWhereInput | boolean
    connect?: AgencyContractSignatoryWhereUniqueInput
    update?: XOR<XOR<AgencyContractSignatoryUpdateToOneWithWhereWithoutAgency_contractInput, AgencyContractSignatoryUpdateWithoutAgency_contractInput>, AgencyContractSignatoryUncheckedUpdateWithoutAgency_contractInput>
  }

  export type RealEstateAgencyContractPropertiesUpdateOneWithoutAgency_contractNestedInput = {
    create?: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgency_contractInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgency_contractInput>
    connectOrCreate?: RealEstateAgencyContractPropertiesCreateOrConnectWithoutAgency_contractInput
    upsert?: RealEstateAgencyContractPropertiesUpsertWithoutAgency_contractInput
    disconnect?: RealEstateAgencyContractPropertiesWhereInput | boolean
    delete?: RealEstateAgencyContractPropertiesWhereInput | boolean
    connect?: RealEstateAgencyContractPropertiesWhereUniqueInput
    update?: XOR<XOR<RealEstateAgencyContractPropertiesUpdateToOneWithWhereWithoutAgency_contractInput, RealEstateAgencyContractPropertiesUpdateWithoutAgency_contractInput>, RealEstateAgencyContractPropertiesUncheckedUpdateWithoutAgency_contractInput>
  }

  export type MIPAgencyContractPropertiesUpdateOneWithoutAgency_contractNestedInput = {
    create?: XOR<MIPAgencyContractPropertiesCreateWithoutAgency_contractInput, MIPAgencyContractPropertiesUncheckedCreateWithoutAgency_contractInput>
    connectOrCreate?: MIPAgencyContractPropertiesCreateOrConnectWithoutAgency_contractInput
    upsert?: MIPAgencyContractPropertiesUpsertWithoutAgency_contractInput
    disconnect?: MIPAgencyContractPropertiesWhereInput | boolean
    delete?: MIPAgencyContractPropertiesWhereInput | boolean
    connect?: MIPAgencyContractPropertiesWhereUniqueInput
    update?: XOR<XOR<MIPAgencyContractPropertiesUpdateToOneWithWhereWithoutAgency_contractInput, MIPAgencyContractPropertiesUpdateWithoutAgency_contractInput>, MIPAgencyContractPropertiesUncheckedUpdateWithoutAgency_contractInput>
  }

  export type ClientContractToAgencyContractUpdateManyWithoutAgency_contractNestedInput = {
    create?: XOR<ClientContractToAgencyContractCreateWithoutAgency_contractInput, ClientContractToAgencyContractUncheckedCreateWithoutAgency_contractInput> | ClientContractToAgencyContractCreateWithoutAgency_contractInput[] | ClientContractToAgencyContractUncheckedCreateWithoutAgency_contractInput[]
    connectOrCreate?: ClientContractToAgencyContractCreateOrConnectWithoutAgency_contractInput | ClientContractToAgencyContractCreateOrConnectWithoutAgency_contractInput[]
    upsert?: ClientContractToAgencyContractUpsertWithWhereUniqueWithoutAgency_contractInput | ClientContractToAgencyContractUpsertWithWhereUniqueWithoutAgency_contractInput[]
    createMany?: ClientContractToAgencyContractCreateManyAgency_contractInputEnvelope
    set?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    disconnect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    delete?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    connect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    update?: ClientContractToAgencyContractUpdateWithWhereUniqueWithoutAgency_contractInput | ClientContractToAgencyContractUpdateWithWhereUniqueWithoutAgency_contractInput[]
    updateMany?: ClientContractToAgencyContractUpdateManyWithWhereWithoutAgency_contractInput | ClientContractToAgencyContractUpdateManyWithWhereWithoutAgency_contractInput[]
    deleteMany?: ClientContractToAgencyContractScalarWhereInput | ClientContractToAgencyContractScalarWhereInput[]
  }

  export type ClientContractToAgencyContractUncheckedUpdateManyWithoutAgency_contractNestedInput = {
    create?: XOR<ClientContractToAgencyContractCreateWithoutAgency_contractInput, ClientContractToAgencyContractUncheckedCreateWithoutAgency_contractInput> | ClientContractToAgencyContractCreateWithoutAgency_contractInput[] | ClientContractToAgencyContractUncheckedCreateWithoutAgency_contractInput[]
    connectOrCreate?: ClientContractToAgencyContractCreateOrConnectWithoutAgency_contractInput | ClientContractToAgencyContractCreateOrConnectWithoutAgency_contractInput[]
    upsert?: ClientContractToAgencyContractUpsertWithWhereUniqueWithoutAgency_contractInput | ClientContractToAgencyContractUpsertWithWhereUniqueWithoutAgency_contractInput[]
    createMany?: ClientContractToAgencyContractCreateManyAgency_contractInputEnvelope
    set?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    disconnect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    delete?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    connect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    update?: ClientContractToAgencyContractUpdateWithWhereUniqueWithoutAgency_contractInput | ClientContractToAgencyContractUpdateWithWhereUniqueWithoutAgency_contractInput[]
    updateMany?: ClientContractToAgencyContractUpdateManyWithWhereWithoutAgency_contractInput | ClientContractToAgencyContractUpdateManyWithWhereWithoutAgency_contractInput[]
    deleteMany?: ClientContractToAgencyContractScalarWhereInput | ClientContractToAgencyContractScalarWhereInput[]
  }

  export type AgencyCreateNestedOneWithoutAgency_contract_signatoryInput = {
    create?: XOR<AgencyCreateWithoutAgency_contract_signatoryInput, AgencyUncheckedCreateWithoutAgency_contract_signatoryInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgency_contract_signatoryInput
    connect?: AgencyWhereUniqueInput
  }

  export type AgencyContractCreateNestedManyWithoutAgency_contract_signatoryInput = {
    create?: XOR<AgencyContractCreateWithoutAgency_contract_signatoryInput, AgencyContractUncheckedCreateWithoutAgency_contract_signatoryInput> | AgencyContractCreateWithoutAgency_contract_signatoryInput[] | AgencyContractUncheckedCreateWithoutAgency_contract_signatoryInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutAgency_contract_signatoryInput | AgencyContractCreateOrConnectWithoutAgency_contract_signatoryInput[]
    createMany?: AgencyContractCreateManyAgency_contract_signatoryInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type AgencyContractUncheckedCreateNestedManyWithoutAgency_contract_signatoryInput = {
    create?: XOR<AgencyContractCreateWithoutAgency_contract_signatoryInput, AgencyContractUncheckedCreateWithoutAgency_contract_signatoryInput> | AgencyContractCreateWithoutAgency_contract_signatoryInput[] | AgencyContractUncheckedCreateWithoutAgency_contract_signatoryInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutAgency_contract_signatoryInput | AgencyContractCreateOrConnectWithoutAgency_contract_signatoryInput[]
    createMany?: AgencyContractCreateManyAgency_contract_signatoryInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type AgencyUpdateOneRequiredWithoutAgency_contract_signatoryNestedInput = {
    create?: XOR<AgencyCreateWithoutAgency_contract_signatoryInput, AgencyUncheckedCreateWithoutAgency_contract_signatoryInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgency_contract_signatoryInput
    upsert?: AgencyUpsertWithoutAgency_contract_signatoryInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAgency_contract_signatoryInput, AgencyUpdateWithoutAgency_contract_signatoryInput>, AgencyUncheckedUpdateWithoutAgency_contract_signatoryInput>
  }

  export type AgencyContractUpdateManyWithoutAgency_contract_signatoryNestedInput = {
    create?: XOR<AgencyContractCreateWithoutAgency_contract_signatoryInput, AgencyContractUncheckedCreateWithoutAgency_contract_signatoryInput> | AgencyContractCreateWithoutAgency_contract_signatoryInput[] | AgencyContractUncheckedCreateWithoutAgency_contract_signatoryInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutAgency_contract_signatoryInput | AgencyContractCreateOrConnectWithoutAgency_contract_signatoryInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutAgency_contract_signatoryInput | AgencyContractUpsertWithWhereUniqueWithoutAgency_contract_signatoryInput[]
    createMany?: AgencyContractCreateManyAgency_contract_signatoryInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutAgency_contract_signatoryInput | AgencyContractUpdateWithWhereUniqueWithoutAgency_contract_signatoryInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutAgency_contract_signatoryInput | AgencyContractUpdateManyWithWhereWithoutAgency_contract_signatoryInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type AgencyContractUncheckedUpdateManyWithoutAgency_contract_signatoryNestedInput = {
    create?: XOR<AgencyContractCreateWithoutAgency_contract_signatoryInput, AgencyContractUncheckedCreateWithoutAgency_contract_signatoryInput> | AgencyContractCreateWithoutAgency_contract_signatoryInput[] | AgencyContractUncheckedCreateWithoutAgency_contract_signatoryInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutAgency_contract_signatoryInput | AgencyContractCreateOrConnectWithoutAgency_contract_signatoryInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutAgency_contract_signatoryInput | AgencyContractUpsertWithWhereUniqueWithoutAgency_contract_signatoryInput[]
    createMany?: AgencyContractCreateManyAgency_contract_signatoryInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutAgency_contract_signatoryInput | AgencyContractUpdateWithWhereUniqueWithoutAgency_contract_signatoryInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutAgency_contract_signatoryInput | AgencyContractUpdateManyWithWhereWithoutAgency_contract_signatoryInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type AgencyContractCreateNestedOneWithoutReal_estate_agency_contract_propertiesInput = {
    create?: XOR<AgencyContractCreateWithoutReal_estate_agency_contract_propertiesInput, AgencyContractUncheckedCreateWithoutReal_estate_agency_contract_propertiesInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutReal_estate_agency_contract_propertiesInput
    connect?: AgencyContractWhereUniqueInput
  }

  export type AgencyContractCommissionCreateNestedOneWithoutReal_estate_agency_contract_propertiesInput = {
    create?: XOR<AgencyContractCommissionCreateWithoutReal_estate_agency_contract_propertiesInput, AgencyContractCommissionUncheckedCreateWithoutReal_estate_agency_contract_propertiesInput>
    connectOrCreate?: AgencyContractCommissionCreateOrConnectWithoutReal_estate_agency_contract_propertiesInput
    connect?: AgencyContractCommissionWhereUniqueInput
  }

  export type AgencyContractUncheckedCreateNestedOneWithoutReal_estate_agency_contract_propertiesInput = {
    create?: XOR<AgencyContractCreateWithoutReal_estate_agency_contract_propertiesInput, AgencyContractUncheckedCreateWithoutReal_estate_agency_contract_propertiesInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutReal_estate_agency_contract_propertiesInput
    connect?: AgencyContractWhereUniqueInput
  }

  export type AgencyContractUpdateOneWithoutReal_estate_agency_contract_propertiesNestedInput = {
    create?: XOR<AgencyContractCreateWithoutReal_estate_agency_contract_propertiesInput, AgencyContractUncheckedCreateWithoutReal_estate_agency_contract_propertiesInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutReal_estate_agency_contract_propertiesInput
    upsert?: AgencyContractUpsertWithoutReal_estate_agency_contract_propertiesInput
    disconnect?: AgencyContractWhereInput | boolean
    delete?: AgencyContractWhereInput | boolean
    connect?: AgencyContractWhereUniqueInput
    update?: XOR<XOR<AgencyContractUpdateToOneWithWhereWithoutReal_estate_agency_contract_propertiesInput, AgencyContractUpdateWithoutReal_estate_agency_contract_propertiesInput>, AgencyContractUncheckedUpdateWithoutReal_estate_agency_contract_propertiesInput>
  }

  export type AgencyContractCommissionUpdateOneRequiredWithoutReal_estate_agency_contract_propertiesNestedInput = {
    create?: XOR<AgencyContractCommissionCreateWithoutReal_estate_agency_contract_propertiesInput, AgencyContractCommissionUncheckedCreateWithoutReal_estate_agency_contract_propertiesInput>
    connectOrCreate?: AgencyContractCommissionCreateOrConnectWithoutReal_estate_agency_contract_propertiesInput
    upsert?: AgencyContractCommissionUpsertWithoutReal_estate_agency_contract_propertiesInput
    connect?: AgencyContractCommissionWhereUniqueInput
    update?: XOR<XOR<AgencyContractCommissionUpdateToOneWithWhereWithoutReal_estate_agency_contract_propertiesInput, AgencyContractCommissionUpdateWithoutReal_estate_agency_contract_propertiesInput>, AgencyContractCommissionUncheckedUpdateWithoutReal_estate_agency_contract_propertiesInput>
  }

  export type AgencyContractUncheckedUpdateOneWithoutReal_estate_agency_contract_propertiesNestedInput = {
    create?: XOR<AgencyContractCreateWithoutReal_estate_agency_contract_propertiesInput, AgencyContractUncheckedCreateWithoutReal_estate_agency_contract_propertiesInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutReal_estate_agency_contract_propertiesInput
    upsert?: AgencyContractUpsertWithoutReal_estate_agency_contract_propertiesInput
    disconnect?: AgencyContractWhereInput | boolean
    delete?: AgencyContractWhereInput | boolean
    connect?: AgencyContractWhereUniqueInput
    update?: XOR<XOR<AgencyContractUpdateToOneWithWhereWithoutReal_estate_agency_contract_propertiesInput, AgencyContractUpdateWithoutReal_estate_agency_contract_propertiesInput>, AgencyContractUncheckedUpdateWithoutReal_estate_agency_contract_propertiesInput>
  }

  export type AgencyContractCreateNestedOneWithoutMip_agency_contract_propertiesInput = {
    create?: XOR<AgencyContractCreateWithoutMip_agency_contract_propertiesInput, AgencyContractUncheckedCreateWithoutMip_agency_contract_propertiesInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutMip_agency_contract_propertiesInput
    connect?: AgencyContractWhereUniqueInput
  }

  export type AgencyContractCommissionCreateNestedOneWithoutMip_agency_contract_propertiesInput = {
    create?: XOR<AgencyContractCommissionCreateWithoutMip_agency_contract_propertiesInput, AgencyContractCommissionUncheckedCreateWithoutMip_agency_contract_propertiesInput>
    connectOrCreate?: AgencyContractCommissionCreateOrConnectWithoutMip_agency_contract_propertiesInput
    connect?: AgencyContractCommissionWhereUniqueInput
  }

  export type AgencyContractUncheckedCreateNestedOneWithoutMip_agency_contract_propertiesInput = {
    create?: XOR<AgencyContractCreateWithoutMip_agency_contract_propertiesInput, AgencyContractUncheckedCreateWithoutMip_agency_contract_propertiesInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutMip_agency_contract_propertiesInput
    connect?: AgencyContractWhereUniqueInput
  }

  export type AgencyContractUpdateOneWithoutMip_agency_contract_propertiesNestedInput = {
    create?: XOR<AgencyContractCreateWithoutMip_agency_contract_propertiesInput, AgencyContractUncheckedCreateWithoutMip_agency_contract_propertiesInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutMip_agency_contract_propertiesInput
    upsert?: AgencyContractUpsertWithoutMip_agency_contract_propertiesInput
    disconnect?: AgencyContractWhereInput | boolean
    delete?: AgencyContractWhereInput | boolean
    connect?: AgencyContractWhereUniqueInput
    update?: XOR<XOR<AgencyContractUpdateToOneWithWhereWithoutMip_agency_contract_propertiesInput, AgencyContractUpdateWithoutMip_agency_contract_propertiesInput>, AgencyContractUncheckedUpdateWithoutMip_agency_contract_propertiesInput>
  }

  export type AgencyContractCommissionUpdateOneRequiredWithoutMip_agency_contract_propertiesNestedInput = {
    create?: XOR<AgencyContractCommissionCreateWithoutMip_agency_contract_propertiesInput, AgencyContractCommissionUncheckedCreateWithoutMip_agency_contract_propertiesInput>
    connectOrCreate?: AgencyContractCommissionCreateOrConnectWithoutMip_agency_contract_propertiesInput
    upsert?: AgencyContractCommissionUpsertWithoutMip_agency_contract_propertiesInput
    connect?: AgencyContractCommissionWhereUniqueInput
    update?: XOR<XOR<AgencyContractCommissionUpdateToOneWithWhereWithoutMip_agency_contract_propertiesInput, AgencyContractCommissionUpdateWithoutMip_agency_contract_propertiesInput>, AgencyContractCommissionUncheckedUpdateWithoutMip_agency_contract_propertiesInput>
  }

  export type AgencyContractUncheckedUpdateOneWithoutMip_agency_contract_propertiesNestedInput = {
    create?: XOR<AgencyContractCreateWithoutMip_agency_contract_propertiesInput, AgencyContractUncheckedCreateWithoutMip_agency_contract_propertiesInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutMip_agency_contract_propertiesInput
    upsert?: AgencyContractUpsertWithoutMip_agency_contract_propertiesInput
    disconnect?: AgencyContractWhereInput | boolean
    delete?: AgencyContractWhereInput | boolean
    connect?: AgencyContractWhereUniqueInput
    update?: XOR<XOR<AgencyContractUpdateToOneWithWhereWithoutMip_agency_contract_propertiesInput, AgencyContractUpdateWithoutMip_agency_contract_propertiesInput>, AgencyContractUncheckedUpdateWithoutMip_agency_contract_propertiesInput>
  }

  export type RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgency_contract_commissionInput = {
    create?: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgency_contract_commissionInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgency_contract_commissionInput>
    connectOrCreate?: RealEstateAgencyContractPropertiesCreateOrConnectWithoutAgency_contract_commissionInput
    connect?: RealEstateAgencyContractPropertiesWhereUniqueInput
  }

  export type MIPAgencyContractPropertiesCreateNestedOneWithoutAgency_contract_commissionInput = {
    create?: XOR<MIPAgencyContractPropertiesCreateWithoutAgency_contract_commissionInput, MIPAgencyContractPropertiesUncheckedCreateWithoutAgency_contract_commissionInput>
    connectOrCreate?: MIPAgencyContractPropertiesCreateOrConnectWithoutAgency_contract_commissionInput
    connect?: MIPAgencyContractPropertiesWhereUniqueInput
  }

  export type RealEstateAgencyContractPropertiesUncheckedCreateNestedOneWithoutAgency_contract_commissionInput = {
    create?: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgency_contract_commissionInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgency_contract_commissionInput>
    connectOrCreate?: RealEstateAgencyContractPropertiesCreateOrConnectWithoutAgency_contract_commissionInput
    connect?: RealEstateAgencyContractPropertiesWhereUniqueInput
  }

  export type MIPAgencyContractPropertiesUncheckedCreateNestedOneWithoutAgency_contract_commissionInput = {
    create?: XOR<MIPAgencyContractPropertiesCreateWithoutAgency_contract_commissionInput, MIPAgencyContractPropertiesUncheckedCreateWithoutAgency_contract_commissionInput>
    connectOrCreate?: MIPAgencyContractPropertiesCreateOrConnectWithoutAgency_contract_commissionInput
    connect?: MIPAgencyContractPropertiesWhereUniqueInput
  }

  export type RealEstateAgencyContractPropertiesUpdateOneWithoutAgency_contract_commissionNestedInput = {
    create?: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgency_contract_commissionInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgency_contract_commissionInput>
    connectOrCreate?: RealEstateAgencyContractPropertiesCreateOrConnectWithoutAgency_contract_commissionInput
    upsert?: RealEstateAgencyContractPropertiesUpsertWithoutAgency_contract_commissionInput
    disconnect?: RealEstateAgencyContractPropertiesWhereInput | boolean
    delete?: RealEstateAgencyContractPropertiesWhereInput | boolean
    connect?: RealEstateAgencyContractPropertiesWhereUniqueInput
    update?: XOR<XOR<RealEstateAgencyContractPropertiesUpdateToOneWithWhereWithoutAgency_contract_commissionInput, RealEstateAgencyContractPropertiesUpdateWithoutAgency_contract_commissionInput>, RealEstateAgencyContractPropertiesUncheckedUpdateWithoutAgency_contract_commissionInput>
  }

  export type MIPAgencyContractPropertiesUpdateOneWithoutAgency_contract_commissionNestedInput = {
    create?: XOR<MIPAgencyContractPropertiesCreateWithoutAgency_contract_commissionInput, MIPAgencyContractPropertiesUncheckedCreateWithoutAgency_contract_commissionInput>
    connectOrCreate?: MIPAgencyContractPropertiesCreateOrConnectWithoutAgency_contract_commissionInput
    upsert?: MIPAgencyContractPropertiesUpsertWithoutAgency_contract_commissionInput
    disconnect?: MIPAgencyContractPropertiesWhereInput | boolean
    delete?: MIPAgencyContractPropertiesWhereInput | boolean
    connect?: MIPAgencyContractPropertiesWhereUniqueInput
    update?: XOR<XOR<MIPAgencyContractPropertiesUpdateToOneWithWhereWithoutAgency_contract_commissionInput, MIPAgencyContractPropertiesUpdateWithoutAgency_contract_commissionInput>, MIPAgencyContractPropertiesUncheckedUpdateWithoutAgency_contract_commissionInput>
  }

  export type RealEstateAgencyContractPropertiesUncheckedUpdateOneWithoutAgency_contract_commissionNestedInput = {
    create?: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgency_contract_commissionInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgency_contract_commissionInput>
    connectOrCreate?: RealEstateAgencyContractPropertiesCreateOrConnectWithoutAgency_contract_commissionInput
    upsert?: RealEstateAgencyContractPropertiesUpsertWithoutAgency_contract_commissionInput
    disconnect?: RealEstateAgencyContractPropertiesWhereInput | boolean
    delete?: RealEstateAgencyContractPropertiesWhereInput | boolean
    connect?: RealEstateAgencyContractPropertiesWhereUniqueInput
    update?: XOR<XOR<RealEstateAgencyContractPropertiesUpdateToOneWithWhereWithoutAgency_contract_commissionInput, RealEstateAgencyContractPropertiesUpdateWithoutAgency_contract_commissionInput>, RealEstateAgencyContractPropertiesUncheckedUpdateWithoutAgency_contract_commissionInput>
  }

  export type MIPAgencyContractPropertiesUncheckedUpdateOneWithoutAgency_contract_commissionNestedInput = {
    create?: XOR<MIPAgencyContractPropertiesCreateWithoutAgency_contract_commissionInput, MIPAgencyContractPropertiesUncheckedCreateWithoutAgency_contract_commissionInput>
    connectOrCreate?: MIPAgencyContractPropertiesCreateOrConnectWithoutAgency_contract_commissionInput
    upsert?: MIPAgencyContractPropertiesUpsertWithoutAgency_contract_commissionInput
    disconnect?: MIPAgencyContractPropertiesWhereInput | boolean
    delete?: MIPAgencyContractPropertiesWhereInput | boolean
    connect?: MIPAgencyContractPropertiesWhereUniqueInput
    update?: XOR<XOR<MIPAgencyContractPropertiesUpdateToOneWithWhereWithoutAgency_contract_commissionInput, MIPAgencyContractPropertiesUpdateWithoutAgency_contract_commissionInput>, MIPAgencyContractPropertiesUncheckedUpdateWithoutAgency_contract_commissionInput>
  }

  export type ClientContractCreateNestedManyWithoutReal_estate_agentInput = {
    create?: XOR<ClientContractCreateWithoutReal_estate_agentInput, ClientContractUncheckedCreateWithoutReal_estate_agentInput> | ClientContractCreateWithoutReal_estate_agentInput[] | ClientContractUncheckedCreateWithoutReal_estate_agentInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutReal_estate_agentInput | ClientContractCreateOrConnectWithoutReal_estate_agentInput[]
    createMany?: ClientContractCreateManyReal_estate_agentInputEnvelope
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
  }

  export type AgencyToRealEstateAgentCreateNestedManyWithoutReal_estate_agentInput = {
    create?: XOR<AgencyToRealEstateAgentCreateWithoutReal_estate_agentInput, AgencyToRealEstateAgentUncheckedCreateWithoutReal_estate_agentInput> | AgencyToRealEstateAgentCreateWithoutReal_estate_agentInput[] | AgencyToRealEstateAgentUncheckedCreateWithoutReal_estate_agentInput[]
    connectOrCreate?: AgencyToRealEstateAgentCreateOrConnectWithoutReal_estate_agentInput | AgencyToRealEstateAgentCreateOrConnectWithoutReal_estate_agentInput[]
    createMany?: AgencyToRealEstateAgentCreateManyReal_estate_agentInputEnvelope
    connect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
  }

  export type ClientContractUncheckedCreateNestedManyWithoutReal_estate_agentInput = {
    create?: XOR<ClientContractCreateWithoutReal_estate_agentInput, ClientContractUncheckedCreateWithoutReal_estate_agentInput> | ClientContractCreateWithoutReal_estate_agentInput[] | ClientContractUncheckedCreateWithoutReal_estate_agentInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutReal_estate_agentInput | ClientContractCreateOrConnectWithoutReal_estate_agentInput[]
    createMany?: ClientContractCreateManyReal_estate_agentInputEnvelope
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
  }

  export type AgencyToRealEstateAgentUncheckedCreateNestedManyWithoutReal_estate_agentInput = {
    create?: XOR<AgencyToRealEstateAgentCreateWithoutReal_estate_agentInput, AgencyToRealEstateAgentUncheckedCreateWithoutReal_estate_agentInput> | AgencyToRealEstateAgentCreateWithoutReal_estate_agentInput[] | AgencyToRealEstateAgentUncheckedCreateWithoutReal_estate_agentInput[]
    connectOrCreate?: AgencyToRealEstateAgentCreateOrConnectWithoutReal_estate_agentInput | AgencyToRealEstateAgentCreateOrConnectWithoutReal_estate_agentInput[]
    createMany?: AgencyToRealEstateAgentCreateManyReal_estate_agentInputEnvelope
    connect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
  }

  export type ClientContractUpdateManyWithoutReal_estate_agentNestedInput = {
    create?: XOR<ClientContractCreateWithoutReal_estate_agentInput, ClientContractUncheckedCreateWithoutReal_estate_agentInput> | ClientContractCreateWithoutReal_estate_agentInput[] | ClientContractUncheckedCreateWithoutReal_estate_agentInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutReal_estate_agentInput | ClientContractCreateOrConnectWithoutReal_estate_agentInput[]
    upsert?: ClientContractUpsertWithWhereUniqueWithoutReal_estate_agentInput | ClientContractUpsertWithWhereUniqueWithoutReal_estate_agentInput[]
    createMany?: ClientContractCreateManyReal_estate_agentInputEnvelope
    set?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    disconnect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    delete?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    update?: ClientContractUpdateWithWhereUniqueWithoutReal_estate_agentInput | ClientContractUpdateWithWhereUniqueWithoutReal_estate_agentInput[]
    updateMany?: ClientContractUpdateManyWithWhereWithoutReal_estate_agentInput | ClientContractUpdateManyWithWhereWithoutReal_estate_agentInput[]
    deleteMany?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
  }

  export type AgencyToRealEstateAgentUpdateManyWithoutReal_estate_agentNestedInput = {
    create?: XOR<AgencyToRealEstateAgentCreateWithoutReal_estate_agentInput, AgencyToRealEstateAgentUncheckedCreateWithoutReal_estate_agentInput> | AgencyToRealEstateAgentCreateWithoutReal_estate_agentInput[] | AgencyToRealEstateAgentUncheckedCreateWithoutReal_estate_agentInput[]
    connectOrCreate?: AgencyToRealEstateAgentCreateOrConnectWithoutReal_estate_agentInput | AgencyToRealEstateAgentCreateOrConnectWithoutReal_estate_agentInput[]
    upsert?: AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutReal_estate_agentInput | AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutReal_estate_agentInput[]
    createMany?: AgencyToRealEstateAgentCreateManyReal_estate_agentInputEnvelope
    set?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    disconnect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    delete?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    connect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    update?: AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutReal_estate_agentInput | AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutReal_estate_agentInput[]
    updateMany?: AgencyToRealEstateAgentUpdateManyWithWhereWithoutReal_estate_agentInput | AgencyToRealEstateAgentUpdateManyWithWhereWithoutReal_estate_agentInput[]
    deleteMany?: AgencyToRealEstateAgentScalarWhereInput | AgencyToRealEstateAgentScalarWhereInput[]
  }

  export type ClientContractUncheckedUpdateManyWithoutReal_estate_agentNestedInput = {
    create?: XOR<ClientContractCreateWithoutReal_estate_agentInput, ClientContractUncheckedCreateWithoutReal_estate_agentInput> | ClientContractCreateWithoutReal_estate_agentInput[] | ClientContractUncheckedCreateWithoutReal_estate_agentInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutReal_estate_agentInput | ClientContractCreateOrConnectWithoutReal_estate_agentInput[]
    upsert?: ClientContractUpsertWithWhereUniqueWithoutReal_estate_agentInput | ClientContractUpsertWithWhereUniqueWithoutReal_estate_agentInput[]
    createMany?: ClientContractCreateManyReal_estate_agentInputEnvelope
    set?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    disconnect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    delete?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    update?: ClientContractUpdateWithWhereUniqueWithoutReal_estate_agentInput | ClientContractUpdateWithWhereUniqueWithoutReal_estate_agentInput[]
    updateMany?: ClientContractUpdateManyWithWhereWithoutReal_estate_agentInput | ClientContractUpdateManyWithWhereWithoutReal_estate_agentInput[]
    deleteMany?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
  }

  export type AgencyToRealEstateAgentUncheckedUpdateManyWithoutReal_estate_agentNestedInput = {
    create?: XOR<AgencyToRealEstateAgentCreateWithoutReal_estate_agentInput, AgencyToRealEstateAgentUncheckedCreateWithoutReal_estate_agentInput> | AgencyToRealEstateAgentCreateWithoutReal_estate_agentInput[] | AgencyToRealEstateAgentUncheckedCreateWithoutReal_estate_agentInput[]
    connectOrCreate?: AgencyToRealEstateAgentCreateOrConnectWithoutReal_estate_agentInput | AgencyToRealEstateAgentCreateOrConnectWithoutReal_estate_agentInput[]
    upsert?: AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutReal_estate_agentInput | AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutReal_estate_agentInput[]
    createMany?: AgencyToRealEstateAgentCreateManyReal_estate_agentInputEnvelope
    set?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    disconnect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    delete?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    connect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    update?: AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutReal_estate_agentInput | AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutReal_estate_agentInput[]
    updateMany?: AgencyToRealEstateAgentUpdateManyWithWhereWithoutReal_estate_agentInput | AgencyToRealEstateAgentUpdateManyWithWhereWithoutReal_estate_agentInput[]
    deleteMany?: AgencyToRealEstateAgentScalarWhereInput | AgencyToRealEstateAgentScalarWhereInput[]
  }

  export type AgencyCreateNestedOneWithoutReal_estate_agentsInput = {
    create?: XOR<AgencyCreateWithoutReal_estate_agentsInput, AgencyUncheckedCreateWithoutReal_estate_agentsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutReal_estate_agentsInput
    connect?: AgencyWhereUniqueInput
  }

  export type RealEstateAgentCreateNestedOneWithoutAgenciesInput = {
    create?: XOR<RealEstateAgentCreateWithoutAgenciesInput, RealEstateAgentUncheckedCreateWithoutAgenciesInput>
    connectOrCreate?: RealEstateAgentCreateOrConnectWithoutAgenciesInput
    connect?: RealEstateAgentWhereUniqueInput
  }

  export type AgencyUpdateOneRequiredWithoutReal_estate_agentsNestedInput = {
    create?: XOR<AgencyCreateWithoutReal_estate_agentsInput, AgencyUncheckedCreateWithoutReal_estate_agentsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutReal_estate_agentsInput
    upsert?: AgencyUpsertWithoutReal_estate_agentsInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutReal_estate_agentsInput, AgencyUpdateWithoutReal_estate_agentsInput>, AgencyUncheckedUpdateWithoutReal_estate_agentsInput>
  }

  export type RealEstateAgentUpdateOneRequiredWithoutAgenciesNestedInput = {
    create?: XOR<RealEstateAgentCreateWithoutAgenciesInput, RealEstateAgentUncheckedCreateWithoutAgenciesInput>
    connectOrCreate?: RealEstateAgentCreateOrConnectWithoutAgenciesInput
    upsert?: RealEstateAgentUpsertWithoutAgenciesInput
    connect?: RealEstateAgentWhereUniqueInput
    update?: XOR<XOR<RealEstateAgentUpdateToOneWithWhereWithoutAgenciesInput, RealEstateAgentUpdateWithoutAgenciesInput>, RealEstateAgentUncheckedUpdateWithoutAgenciesInput>
  }

  export type AgencyContractCreateNestedManyWithoutEntityInput = {
    create?: XOR<AgencyContractCreateWithoutEntityInput, AgencyContractUncheckedCreateWithoutEntityInput> | AgencyContractCreateWithoutEntityInput[] | AgencyContractUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutEntityInput | AgencyContractCreateOrConnectWithoutEntityInput[]
    createMany?: AgencyContractCreateManyEntityInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type ObjectCreateNestedManyWithoutEntityInput = {
    create?: XOR<ObjectCreateWithoutEntityInput, ObjectUncheckedCreateWithoutEntityInput> | ObjectCreateWithoutEntityInput[] | ObjectUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutEntityInput | ObjectCreateOrConnectWithoutEntityInput[]
    createMany?: ObjectCreateManyEntityInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type EntityForbiddenWebsiteCreateNestedManyWithoutEntityInput = {
    create?: XOR<EntityForbiddenWebsiteCreateWithoutEntityInput, EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput> | EntityForbiddenWebsiteCreateWithoutEntityInput[] | EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: EntityForbiddenWebsiteCreateOrConnectWithoutEntityInput | EntityForbiddenWebsiteCreateOrConnectWithoutEntityInput[]
    createMany?: EntityForbiddenWebsiteCreateManyEntityInputEnvelope
    connect?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
  }

  export type EntityForbiddenBrandCreateNestedManyWithoutEntityInput = {
    create?: XOR<EntityForbiddenBrandCreateWithoutEntityInput, EntityForbiddenBrandUncheckedCreateWithoutEntityInput> | EntityForbiddenBrandCreateWithoutEntityInput[] | EntityForbiddenBrandUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: EntityForbiddenBrandCreateOrConnectWithoutEntityInput | EntityForbiddenBrandCreateOrConnectWithoutEntityInput[]
    createMany?: EntityForbiddenBrandCreateManyEntityInputEnvelope
    connect?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
  }

  export type AgencyContractUncheckedCreateNestedManyWithoutEntityInput = {
    create?: XOR<AgencyContractCreateWithoutEntityInput, AgencyContractUncheckedCreateWithoutEntityInput> | AgencyContractCreateWithoutEntityInput[] | AgencyContractUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutEntityInput | AgencyContractCreateOrConnectWithoutEntityInput[]
    createMany?: AgencyContractCreateManyEntityInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type ObjectUncheckedCreateNestedManyWithoutEntityInput = {
    create?: XOR<ObjectCreateWithoutEntityInput, ObjectUncheckedCreateWithoutEntityInput> | ObjectCreateWithoutEntityInput[] | ObjectUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutEntityInput | ObjectCreateOrConnectWithoutEntityInput[]
    createMany?: ObjectCreateManyEntityInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type EntityForbiddenWebsiteUncheckedCreateNestedManyWithoutEntityInput = {
    create?: XOR<EntityForbiddenWebsiteCreateWithoutEntityInput, EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput> | EntityForbiddenWebsiteCreateWithoutEntityInput[] | EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: EntityForbiddenWebsiteCreateOrConnectWithoutEntityInput | EntityForbiddenWebsiteCreateOrConnectWithoutEntityInput[]
    createMany?: EntityForbiddenWebsiteCreateManyEntityInputEnvelope
    connect?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
  }

  export type EntityForbiddenBrandUncheckedCreateNestedManyWithoutEntityInput = {
    create?: XOR<EntityForbiddenBrandCreateWithoutEntityInput, EntityForbiddenBrandUncheckedCreateWithoutEntityInput> | EntityForbiddenBrandCreateWithoutEntityInput[] | EntityForbiddenBrandUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: EntityForbiddenBrandCreateOrConnectWithoutEntityInput | EntityForbiddenBrandCreateOrConnectWithoutEntityInput[]
    createMany?: EntityForbiddenBrandCreateManyEntityInputEnvelope
    connect?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
  }

  export type AgencyContractUpdateManyWithoutEntityNestedInput = {
    create?: XOR<AgencyContractCreateWithoutEntityInput, AgencyContractUncheckedCreateWithoutEntityInput> | AgencyContractCreateWithoutEntityInput[] | AgencyContractUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutEntityInput | AgencyContractCreateOrConnectWithoutEntityInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutEntityInput | AgencyContractUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: AgencyContractCreateManyEntityInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutEntityInput | AgencyContractUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutEntityInput | AgencyContractUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type ObjectUpdateManyWithoutEntityNestedInput = {
    create?: XOR<ObjectCreateWithoutEntityInput, ObjectUncheckedCreateWithoutEntityInput> | ObjectCreateWithoutEntityInput[] | ObjectUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutEntityInput | ObjectCreateOrConnectWithoutEntityInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutEntityInput | ObjectUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: ObjectCreateManyEntityInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutEntityInput | ObjectUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutEntityInput | ObjectUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type EntityForbiddenWebsiteUpdateManyWithoutEntityNestedInput = {
    create?: XOR<EntityForbiddenWebsiteCreateWithoutEntityInput, EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput> | EntityForbiddenWebsiteCreateWithoutEntityInput[] | EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: EntityForbiddenWebsiteCreateOrConnectWithoutEntityInput | EntityForbiddenWebsiteCreateOrConnectWithoutEntityInput[]
    upsert?: EntityForbiddenWebsiteUpsertWithWhereUniqueWithoutEntityInput | EntityForbiddenWebsiteUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: EntityForbiddenWebsiteCreateManyEntityInputEnvelope
    set?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
    disconnect?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
    delete?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
    connect?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
    update?: EntityForbiddenWebsiteUpdateWithWhereUniqueWithoutEntityInput | EntityForbiddenWebsiteUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: EntityForbiddenWebsiteUpdateManyWithWhereWithoutEntityInput | EntityForbiddenWebsiteUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: EntityForbiddenWebsiteScalarWhereInput | EntityForbiddenWebsiteScalarWhereInput[]
  }

  export type EntityForbiddenBrandUpdateManyWithoutEntityNestedInput = {
    create?: XOR<EntityForbiddenBrandCreateWithoutEntityInput, EntityForbiddenBrandUncheckedCreateWithoutEntityInput> | EntityForbiddenBrandCreateWithoutEntityInput[] | EntityForbiddenBrandUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: EntityForbiddenBrandCreateOrConnectWithoutEntityInput | EntityForbiddenBrandCreateOrConnectWithoutEntityInput[]
    upsert?: EntityForbiddenBrandUpsertWithWhereUniqueWithoutEntityInput | EntityForbiddenBrandUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: EntityForbiddenBrandCreateManyEntityInputEnvelope
    set?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
    disconnect?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
    delete?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
    connect?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
    update?: EntityForbiddenBrandUpdateWithWhereUniqueWithoutEntityInput | EntityForbiddenBrandUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: EntityForbiddenBrandUpdateManyWithWhereWithoutEntityInput | EntityForbiddenBrandUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: EntityForbiddenBrandScalarWhereInput | EntityForbiddenBrandScalarWhereInput[]
  }

  export type AgencyContractUncheckedUpdateManyWithoutEntityNestedInput = {
    create?: XOR<AgencyContractCreateWithoutEntityInput, AgencyContractUncheckedCreateWithoutEntityInput> | AgencyContractCreateWithoutEntityInput[] | AgencyContractUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutEntityInput | AgencyContractCreateOrConnectWithoutEntityInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutEntityInput | AgencyContractUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: AgencyContractCreateManyEntityInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutEntityInput | AgencyContractUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutEntityInput | AgencyContractUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type ObjectUncheckedUpdateManyWithoutEntityNestedInput = {
    create?: XOR<ObjectCreateWithoutEntityInput, ObjectUncheckedCreateWithoutEntityInput> | ObjectCreateWithoutEntityInput[] | ObjectUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutEntityInput | ObjectCreateOrConnectWithoutEntityInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutEntityInput | ObjectUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: ObjectCreateManyEntityInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutEntityInput | ObjectUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutEntityInput | ObjectUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type EntityForbiddenWebsiteUncheckedUpdateManyWithoutEntityNestedInput = {
    create?: XOR<EntityForbiddenWebsiteCreateWithoutEntityInput, EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput> | EntityForbiddenWebsiteCreateWithoutEntityInput[] | EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: EntityForbiddenWebsiteCreateOrConnectWithoutEntityInput | EntityForbiddenWebsiteCreateOrConnectWithoutEntityInput[]
    upsert?: EntityForbiddenWebsiteUpsertWithWhereUniqueWithoutEntityInput | EntityForbiddenWebsiteUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: EntityForbiddenWebsiteCreateManyEntityInputEnvelope
    set?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
    disconnect?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
    delete?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
    connect?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
    update?: EntityForbiddenWebsiteUpdateWithWhereUniqueWithoutEntityInput | EntityForbiddenWebsiteUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: EntityForbiddenWebsiteUpdateManyWithWhereWithoutEntityInput | EntityForbiddenWebsiteUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: EntityForbiddenWebsiteScalarWhereInput | EntityForbiddenWebsiteScalarWhereInput[]
  }

  export type EntityForbiddenBrandUncheckedUpdateManyWithoutEntityNestedInput = {
    create?: XOR<EntityForbiddenBrandCreateWithoutEntityInput, EntityForbiddenBrandUncheckedCreateWithoutEntityInput> | EntityForbiddenBrandCreateWithoutEntityInput[] | EntityForbiddenBrandUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: EntityForbiddenBrandCreateOrConnectWithoutEntityInput | EntityForbiddenBrandCreateOrConnectWithoutEntityInput[]
    upsert?: EntityForbiddenBrandUpsertWithWhereUniqueWithoutEntityInput | EntityForbiddenBrandUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: EntityForbiddenBrandCreateManyEntityInputEnvelope
    set?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
    disconnect?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
    delete?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
    connect?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
    update?: EntityForbiddenBrandUpdateWithWhereUniqueWithoutEntityInput | EntityForbiddenBrandUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: EntityForbiddenBrandUpdateManyWithWhereWithoutEntityInput | EntityForbiddenBrandUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: EntityForbiddenBrandScalarWhereInput | EntityForbiddenBrandScalarWhereInput[]
  }

  export type EntityCreateNestedOneWithoutEntity_forbidden_websitesInput = {
    create?: XOR<EntityCreateWithoutEntity_forbidden_websitesInput, EntityUncheckedCreateWithoutEntity_forbidden_websitesInput>
    connectOrCreate?: EntityCreateOrConnectWithoutEntity_forbidden_websitesInput
    connect?: EntityWhereUniqueInput
  }

  export type EntityUpdateOneRequiredWithoutEntity_forbidden_websitesNestedInput = {
    create?: XOR<EntityCreateWithoutEntity_forbidden_websitesInput, EntityUncheckedCreateWithoutEntity_forbidden_websitesInput>
    connectOrCreate?: EntityCreateOrConnectWithoutEntity_forbidden_websitesInput
    upsert?: EntityUpsertWithoutEntity_forbidden_websitesInput
    connect?: EntityWhereUniqueInput
    update?: XOR<XOR<EntityUpdateToOneWithWhereWithoutEntity_forbidden_websitesInput, EntityUpdateWithoutEntity_forbidden_websitesInput>, EntityUncheckedUpdateWithoutEntity_forbidden_websitesInput>
  }

  export type EntityCreateNestedOneWithoutEntity_forbidden_brandsInput = {
    create?: XOR<EntityCreateWithoutEntity_forbidden_brandsInput, EntityUncheckedCreateWithoutEntity_forbidden_brandsInput>
    connectOrCreate?: EntityCreateOrConnectWithoutEntity_forbidden_brandsInput
    connect?: EntityWhereUniqueInput
  }

  export type EntityUpdateOneRequiredWithoutEntity_forbidden_brandsNestedInput = {
    create?: XOR<EntityCreateWithoutEntity_forbidden_brandsInput, EntityUncheckedCreateWithoutEntity_forbidden_brandsInput>
    connectOrCreate?: EntityCreateOrConnectWithoutEntity_forbidden_brandsInput
    upsert?: EntityUpsertWithoutEntity_forbidden_brandsInput
    connect?: EntityWhereUniqueInput
    update?: XOR<XOR<EntityUpdateToOneWithWhereWithoutEntity_forbidden_brandsInput, EntityUpdateWithoutEntity_forbidden_brandsInput>, EntityUncheckedUpdateWithoutEntity_forbidden_brandsInput>
  }

  export type ClientContractCreateNestedManyWithoutBankInput = {
    create?: XOR<ClientContractCreateWithoutBankInput, ClientContractUncheckedCreateWithoutBankInput> | ClientContractCreateWithoutBankInput[] | ClientContractUncheckedCreateWithoutBankInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutBankInput | ClientContractCreateOrConnectWithoutBankInput[]
    createMany?: ClientContractCreateManyBankInputEnvelope
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
  }

  export type ClientContractUncheckedCreateNestedManyWithoutBankInput = {
    create?: XOR<ClientContractCreateWithoutBankInput, ClientContractUncheckedCreateWithoutBankInput> | ClientContractCreateWithoutBankInput[] | ClientContractUncheckedCreateWithoutBankInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutBankInput | ClientContractCreateOrConnectWithoutBankInput[]
    createMany?: ClientContractCreateManyBankInputEnvelope
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
  }

  export type ClientContractUpdateManyWithoutBankNestedInput = {
    create?: XOR<ClientContractCreateWithoutBankInput, ClientContractUncheckedCreateWithoutBankInput> | ClientContractCreateWithoutBankInput[] | ClientContractUncheckedCreateWithoutBankInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutBankInput | ClientContractCreateOrConnectWithoutBankInput[]
    upsert?: ClientContractUpsertWithWhereUniqueWithoutBankInput | ClientContractUpsertWithWhereUniqueWithoutBankInput[]
    createMany?: ClientContractCreateManyBankInputEnvelope
    set?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    disconnect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    delete?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    update?: ClientContractUpdateWithWhereUniqueWithoutBankInput | ClientContractUpdateWithWhereUniqueWithoutBankInput[]
    updateMany?: ClientContractUpdateManyWithWhereWithoutBankInput | ClientContractUpdateManyWithWhereWithoutBankInput[]
    deleteMany?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
  }

  export type ClientContractUncheckedUpdateManyWithoutBankNestedInput = {
    create?: XOR<ClientContractCreateWithoutBankInput, ClientContractUncheckedCreateWithoutBankInput> | ClientContractCreateWithoutBankInput[] | ClientContractUncheckedCreateWithoutBankInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutBankInput | ClientContractCreateOrConnectWithoutBankInput[]
    upsert?: ClientContractUpsertWithWhereUniqueWithoutBankInput | ClientContractUpsertWithWhereUniqueWithoutBankInput[]
    createMany?: ClientContractCreateManyBankInputEnvelope
    set?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    disconnect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    delete?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    update?: ClientContractUpdateWithWhereUniqueWithoutBankInput | ClientContractUpdateWithWhereUniqueWithoutBankInput[]
    updateMany?: ClientContractUpdateManyWithWhereWithoutBankInput | ClientContractUpdateManyWithWhereWithoutBankInput[]
    deleteMany?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumClientCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientCategory | EnumClientCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ClientCategory[]
    notIn?: $Enums.ClientCategory[]
    not?: NestedEnumClientCategoryFilter<$PrismaModel> | $Enums.ClientCategory
  }

  export type NestedEnumClientCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientCategory | EnumClientCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ClientCategory[]
    notIn?: $Enums.ClientCategory[]
    not?: NestedEnumClientCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ClientCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientCategoryFilter<$PrismaModel>
    _max?: NestedEnumClientCategoryFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumClientContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientContractType | EnumClientContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientContractType[]
    notIn?: $Enums.ClientContractType[]
    not?: NestedEnumClientContractTypeFilter<$PrismaModel> | $Enums.ClientContractType
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumClientContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientContractType | EnumClientContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientContractType[]
    notIn?: $Enums.ClientContractType[]
    not?: NestedEnumClientContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientContractTypeFilter<$PrismaModel>
    _max?: NestedEnumClientContractTypeFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumScheduledPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledPaymentType | EnumScheduledPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledPaymentType[]
    notIn?: $Enums.ScheduledPaymentType[]
    not?: NestedEnumScheduledPaymentTypeFilter<$PrismaModel> | $Enums.ScheduledPaymentType
  }

  export type NestedEnumScheduledPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledPaymentType | EnumScheduledPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledPaymentType[]
    notIn?: $Enums.ScheduledPaymentType[]
    not?: NestedEnumScheduledPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScheduledPaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduledPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumScheduledPaymentTypeFilter<$PrismaModel>
  }

  export type NestedEnumProductCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCategory | EnumProductCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCategory[]
    notIn?: $Enums.ProductCategory[]
    not?: NestedEnumProductCategoryFilter<$PrismaModel> | $Enums.ProductCategory
  }

  export type NestedEnumProductCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCategory | EnumProductCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCategory[]
    notIn?: $Enums.ProductCategory[]
    not?: NestedEnumProductCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ProductCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductCategoryFilter<$PrismaModel>
    _max?: NestedEnumProductCategoryFilter<$PrismaModel>
  }

  export type NestedEnumAgencyContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyContractType | EnumAgencyContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyContractType[]
    notIn?: $Enums.AgencyContractType[]
    not?: NestedEnumAgencyContractTypeFilter<$PrismaModel> | $Enums.AgencyContractType
  }

  export type NestedEnumAgencyContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyContractType | EnumAgencyContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyContractType[]
    notIn?: $Enums.AgencyContractType[]
    not?: NestedEnumAgencyContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.AgencyContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgencyContractTypeFilter<$PrismaModel>
    _max?: NestedEnumAgencyContractTypeFilter<$PrismaModel>
  }

  export type ClientContractCreateWithoutManagerInput = {
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object: ObjectCreateNestedOneWithoutClient_contractsInput
    product: ProductCreateNestedOneWithoutClient_contractInput
    real_estate_agent?: RealEstateAgentCreateNestedOneWithoutClient_contractsInput
    bank?: BankCreateNestedOneWithoutClient_contractsInput
    ddu_client_contract_properties?: DDUClientContractPropertiesCreateNestedOneWithoutClient_contractInput
    clients?: ClientContractToClientCreateNestedManyWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractUncheckedCreateWithoutManagerInput = {
    id?: number
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object_id: number
    product_id: number
    real_estate_agent_id?: number | null
    bank_id?: number | null
    ddu_client_contract_properties_id?: number | null
    clients?: ClientContractToClientUncheckedCreateNestedManyWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentUncheckedCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractCreateOrConnectWithoutManagerInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutManagerInput, ClientContractUncheckedCreateWithoutManagerInput>
  }

  export type ClientContractCreateManyManagerInputEnvelope = {
    data: ClientContractCreateManyManagerInput | ClientContractCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type AgencyContractCreateWithoutResponsible_userInput = {
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    entity: EntityCreateNestedOneWithoutAgency_contractsInput
    object: ObjectCreateNestedOneWithoutAgency_contractsInput
    agency: AgencyCreateNestedOneWithoutAgency_contractsInput
    agency_contract_signatory?: AgencyContractSignatoryCreateNestedOneWithoutAgency_contractInput
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgency_contractInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesCreateNestedOneWithoutAgency_contractInput
    client_contracts?: ClientContractToAgencyContractCreateNestedManyWithoutAgency_contractInput
  }

  export type AgencyContractUncheckedCreateWithoutResponsible_userInput = {
    id?: number
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    entity_id: number
    object_id: number
    agency_id: number
    agency_contract_signatory_id?: number | null
    real_estate_agency_contract_properties_id?: number | null
    mip_agency_contract_properties_id?: number | null
    client_contracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgency_contractInput
  }

  export type AgencyContractCreateOrConnectWithoutResponsible_userInput = {
    where: AgencyContractWhereUniqueInput
    create: XOR<AgencyContractCreateWithoutResponsible_userInput, AgencyContractUncheckedCreateWithoutResponsible_userInput>
  }

  export type AgencyContractCreateManyResponsible_userInputEnvelope = {
    data: AgencyContractCreateManyResponsible_userInput | AgencyContractCreateManyResponsible_userInput[]
    skipDuplicates?: boolean
  }

  export type ClientContractUpsertWithWhereUniqueWithoutManagerInput = {
    where: ClientContractWhereUniqueInput
    update: XOR<ClientContractUpdateWithoutManagerInput, ClientContractUncheckedUpdateWithoutManagerInput>
    create: XOR<ClientContractCreateWithoutManagerInput, ClientContractUncheckedCreateWithoutManagerInput>
  }

  export type ClientContractUpdateWithWhereUniqueWithoutManagerInput = {
    where: ClientContractWhereUniqueInput
    data: XOR<ClientContractUpdateWithoutManagerInput, ClientContractUncheckedUpdateWithoutManagerInput>
  }

  export type ClientContractUpdateManyWithWhereWithoutManagerInput = {
    where: ClientContractScalarWhereInput
    data: XOR<ClientContractUpdateManyMutationInput, ClientContractUncheckedUpdateManyWithoutManagerInput>
  }

  export type ClientContractScalarWhereInput = {
    AND?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
    OR?: ClientContractScalarWhereInput[]
    NOT?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
    id?: IntFilter<"ClientContract"> | number
    number?: StringFilter<"ClientContract"> | string
    date?: DateTimeFilter<"ClientContract"> | Date | string
    registration_date?: DateTimeNullableFilter<"ClientContract"> | Date | string | null
    price?: DecimalFilter<"ClientContract"> | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFilter<"ClientContract"> | $Enums.ClientContractType
    created_at?: DateTimeFilter<"ClientContract"> | Date | string
    updated_at?: DateTimeFilter<"ClientContract"> | Date | string
    object_id?: IntFilter<"ClientContract"> | number
    product_id?: IntFilter<"ClientContract"> | number
    real_estate_agent_id?: IntNullableFilter<"ClientContract"> | number | null
    manager_id?: IntNullableFilter<"ClientContract"> | number | null
    bank_id?: IntNullableFilter<"ClientContract"> | number | null
    ddu_client_contract_properties_id?: IntNullableFilter<"ClientContract"> | number | null
  }

  export type AgencyContractUpsertWithWhereUniqueWithoutResponsible_userInput = {
    where: AgencyContractWhereUniqueInput
    update: XOR<AgencyContractUpdateWithoutResponsible_userInput, AgencyContractUncheckedUpdateWithoutResponsible_userInput>
    create: XOR<AgencyContractCreateWithoutResponsible_userInput, AgencyContractUncheckedCreateWithoutResponsible_userInput>
  }

  export type AgencyContractUpdateWithWhereUniqueWithoutResponsible_userInput = {
    where: AgencyContractWhereUniqueInput
    data: XOR<AgencyContractUpdateWithoutResponsible_userInput, AgencyContractUncheckedUpdateWithoutResponsible_userInput>
  }

  export type AgencyContractUpdateManyWithWhereWithoutResponsible_userInput = {
    where: AgencyContractScalarWhereInput
    data: XOR<AgencyContractUpdateManyMutationInput, AgencyContractUncheckedUpdateManyWithoutResponsible_userInput>
  }

  export type AgencyContractScalarWhereInput = {
    AND?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
    OR?: AgencyContractScalarWhereInput[]
    NOT?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
    id?: IntFilter<"AgencyContract"> | number
    number?: StringFilter<"AgencyContract"> | string
    date?: DateTimeFilter<"AgencyContract"> | Date | string
    agency_contract_type?: EnumAgencyContractTypeFilter<"AgencyContract"> | $Enums.AgencyContractType
    created_at?: DateTimeFilter<"AgencyContract"> | Date | string
    updated_at?: DateTimeFilter<"AgencyContract"> | Date | string
    responsible_user_id?: IntNullableFilter<"AgencyContract"> | number | null
    entity_id?: IntFilter<"AgencyContract"> | number
    object_id?: IntFilter<"AgencyContract"> | number
    agency_id?: IntFilter<"AgencyContract"> | number
    agency_contract_signatory_id?: IntNullableFilter<"AgencyContract"> | number | null
    real_estate_agency_contract_properties_id?: IntNullableFilter<"AgencyContract"> | number | null
    mip_agency_contract_properties_id?: IntNullableFilter<"AgencyContract"> | number | null
  }

  export type ClientIndividualPropertiesCreateWithoutClientInput = {
    dob?: Date | string | null
    snils?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_passport?: ClientPassportCreateNestedOneWithoutClient_individual_propertiesInput
  }

  export type ClientIndividualPropertiesUncheckedCreateWithoutClientInput = {
    id?: number
    dob?: Date | string | null
    snils?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_passport_id?: number | null
  }

  export type ClientIndividualPropertiesCreateOrConnectWithoutClientInput = {
    where: ClientIndividualPropertiesWhereUniqueInput
    create: XOR<ClientIndividualPropertiesCreateWithoutClientInput, ClientIndividualPropertiesUncheckedCreateWithoutClientInput>
  }

  export type ClientIndividualMinorPropertiesCreateWithoutClientInput = {
    dob?: Date | string | null
    snils?: string | null
    birth_certificate?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_passport?: ClientPassportCreateNestedOneWithoutClient_individual_minor_propertiesInput
    representatives?: ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClient_individual_minor_propertiesInput
  }

  export type ClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput = {
    id?: number
    dob?: Date | string | null
    snils?: string | null
    birth_certificate?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_passport_id?: number | null
    representatives?: ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClient_individual_minor_propertiesInput
  }

  export type ClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput = {
    where: ClientIndividualMinorPropertiesWhereUniqueInput
    create: XOR<ClientIndividualMinorPropertiesCreateWithoutClientInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput>
  }

  export type ClientEntityPropertiesCreateWithoutClientInput = {
    kpp?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientEntityPropertiesUncheckedCreateWithoutClientInput = {
    id?: number
    kpp?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientEntityPropertiesCreateOrConnectWithoutClientInput = {
    where: ClientEntityPropertiesWhereUniqueInput
    create: XOR<ClientEntityPropertiesCreateWithoutClientInput, ClientEntityPropertiesUncheckedCreateWithoutClientInput>
  }

  export type ClientContractToClientCreateWithoutClientInput = {
    is_main: boolean
    share: number
    created_at?: Date | string
    updated_at?: Date | string
    client_contract: ClientContractCreateNestedOneWithoutClientsInput
  }

  export type ClientContractToClientUncheckedCreateWithoutClientInput = {
    is_main: boolean
    share: number
    created_at?: Date | string
    updated_at?: Date | string
    client_contract_id: number
  }

  export type ClientContractToClientCreateOrConnectWithoutClientInput = {
    where: ClientContractToClientWhereUniqueInput
    create: XOR<ClientContractToClientCreateWithoutClientInput, ClientContractToClientUncheckedCreateWithoutClientInput>
  }

  export type ClientContractToClientCreateManyClientInputEnvelope = {
    data: ClientContractToClientCreateManyClientInput | ClientContractToClientCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientToClientIndividualMinorPropertiesCreateWithoutClientInput = {
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_minor_properties: ClientIndividualMinorPropertiesCreateNestedOneWithoutRepresentativesInput
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput = {
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_minor_properties_id: number
  }

  export type ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput = {
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    create: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClientInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput>
  }

  export type ClientToClientIndividualMinorPropertiesCreateManyClientInputEnvelope = {
    data: ClientToClientIndividualMinorPropertiesCreateManyClientInput | ClientToClientIndividualMinorPropertiesCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientIndividualPropertiesUpsertWithoutClientInput = {
    update: XOR<ClientIndividualPropertiesUpdateWithoutClientInput, ClientIndividualPropertiesUncheckedUpdateWithoutClientInput>
    create: XOR<ClientIndividualPropertiesCreateWithoutClientInput, ClientIndividualPropertiesUncheckedCreateWithoutClientInput>
    where?: ClientIndividualPropertiesWhereInput
  }

  export type ClientIndividualPropertiesUpdateToOneWithWhereWithoutClientInput = {
    where?: ClientIndividualPropertiesWhereInput
    data: XOR<ClientIndividualPropertiesUpdateWithoutClientInput, ClientIndividualPropertiesUncheckedUpdateWithoutClientInput>
  }

  export type ClientIndividualPropertiesUpdateWithoutClientInput = {
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_passport?: ClientPassportUpdateOneWithoutClient_individual_propertiesNestedInput
  }

  export type ClientIndividualPropertiesUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_passport_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClientIndividualMinorPropertiesUpsertWithoutClientInput = {
    update: XOR<ClientIndividualMinorPropertiesUpdateWithoutClientInput, ClientIndividualMinorPropertiesUncheckedUpdateWithoutClientInput>
    create: XOR<ClientIndividualMinorPropertiesCreateWithoutClientInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput>
    where?: ClientIndividualMinorPropertiesWhereInput
  }

  export type ClientIndividualMinorPropertiesUpdateToOneWithWhereWithoutClientInput = {
    where?: ClientIndividualMinorPropertiesWhereInput
    data: XOR<ClientIndividualMinorPropertiesUpdateWithoutClientInput, ClientIndividualMinorPropertiesUncheckedUpdateWithoutClientInput>
  }

  export type ClientIndividualMinorPropertiesUpdateWithoutClientInput = {
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birth_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_passport?: ClientPassportUpdateOneWithoutClient_individual_minor_propertiesNestedInput
    representatives?: ClientToClientIndividualMinorPropertiesUpdateManyWithoutClient_individual_minor_propertiesNestedInput
  }

  export type ClientIndividualMinorPropertiesUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birth_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_passport_id?: NullableIntFieldUpdateOperationsInput | number | null
    representatives?: ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClient_individual_minor_propertiesNestedInput
  }

  export type ClientEntityPropertiesUpsertWithoutClientInput = {
    update: XOR<ClientEntityPropertiesUpdateWithoutClientInput, ClientEntityPropertiesUncheckedUpdateWithoutClientInput>
    create: XOR<ClientEntityPropertiesCreateWithoutClientInput, ClientEntityPropertiesUncheckedCreateWithoutClientInput>
    where?: ClientEntityPropertiesWhereInput
  }

  export type ClientEntityPropertiesUpdateToOneWithWhereWithoutClientInput = {
    where?: ClientEntityPropertiesWhereInput
    data: XOR<ClientEntityPropertiesUpdateWithoutClientInput, ClientEntityPropertiesUncheckedUpdateWithoutClientInput>
  }

  export type ClientEntityPropertiesUpdateWithoutClientInput = {
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEntityPropertiesUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToClientUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientContractToClientWhereUniqueInput
    update: XOR<ClientContractToClientUpdateWithoutClientInput, ClientContractToClientUncheckedUpdateWithoutClientInput>
    create: XOR<ClientContractToClientCreateWithoutClientInput, ClientContractToClientUncheckedCreateWithoutClientInput>
  }

  export type ClientContractToClientUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientContractToClientWhereUniqueInput
    data: XOR<ClientContractToClientUpdateWithoutClientInput, ClientContractToClientUncheckedUpdateWithoutClientInput>
  }

  export type ClientContractToClientUpdateManyWithWhereWithoutClientInput = {
    where: ClientContractToClientScalarWhereInput
    data: XOR<ClientContractToClientUpdateManyMutationInput, ClientContractToClientUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientContractToClientScalarWhereInput = {
    AND?: ClientContractToClientScalarWhereInput | ClientContractToClientScalarWhereInput[]
    OR?: ClientContractToClientScalarWhereInput[]
    NOT?: ClientContractToClientScalarWhereInput | ClientContractToClientScalarWhereInput[]
    is_main?: BoolFilter<"ClientContractToClient"> | boolean
    share?: IntFilter<"ClientContractToClient"> | number
    created_at?: DateTimeFilter<"ClientContractToClient"> | Date | string
    updated_at?: DateTimeFilter<"ClientContractToClient"> | Date | string
    client_contract_id?: IntFilter<"ClientContractToClient"> | number
    client_id?: IntFilter<"ClientContractToClient"> | number
  }

  export type ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    update: XOR<ClientToClientIndividualMinorPropertiesUpdateWithoutClientInput, ClientToClientIndividualMinorPropertiesUncheckedUpdateWithoutClientInput>
    create: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClientInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput>
  }

  export type ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    data: XOR<ClientToClientIndividualMinorPropertiesUpdateWithoutClientInput, ClientToClientIndividualMinorPropertiesUncheckedUpdateWithoutClientInput>
  }

  export type ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClientInput = {
    where: ClientToClientIndividualMinorPropertiesScalarWhereInput
    data: XOR<ClientToClientIndividualMinorPropertiesUpdateManyMutationInput, ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientToClientIndividualMinorPropertiesScalarWhereInput = {
    AND?: ClientToClientIndividualMinorPropertiesScalarWhereInput | ClientToClientIndividualMinorPropertiesScalarWhereInput[]
    OR?: ClientToClientIndividualMinorPropertiesScalarWhereInput[]
    NOT?: ClientToClientIndividualMinorPropertiesScalarWhereInput | ClientToClientIndividualMinorPropertiesScalarWhereInput[]
    created_at?: DateTimeFilter<"ClientToClientIndividualMinorProperties"> | Date | string
    updated_at?: DateTimeFilter<"ClientToClientIndividualMinorProperties"> | Date | string
    client_id?: IntFilter<"ClientToClientIndividualMinorProperties"> | number
    client_individual_minor_properties_id?: IntFilter<"ClientToClientIndividualMinorProperties"> | number
  }

  export type ClientCreateWithoutClient_individual_propertiesInput = {
    full_name: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    client_category: $Enums.ClientCategory
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_minor_properties?: ClientIndividualMinorPropertiesCreateNestedOneWithoutClientInput
    client_entity_properties?: ClientEntityPropertiesCreateNestedOneWithoutClientInput
    client_contracts?: ClientContractToClientCreateNestedManyWithoutClientInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutClient_individual_propertiesInput = {
    id?: number
    full_name: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    client_category: $Enums.ClientCategory
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_minor_properties_id?: number | null
    client_entity_properties_id?: number | null
    client_contracts?: ClientContractToClientUncheckedCreateNestedManyWithoutClientInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutClient_individual_propertiesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutClient_individual_propertiesInput, ClientUncheckedCreateWithoutClient_individual_propertiesInput>
  }

  export type ClientPassportCreateWithoutClient_individual_propertiesInput = {
    number?: string | null
    issued?: string | null
    code?: string | null
    place_of_birth?: string | null
    registration_address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_minor_properties?: ClientIndividualMinorPropertiesCreateNestedOneWithoutClient_passportInput
  }

  export type ClientPassportUncheckedCreateWithoutClient_individual_propertiesInput = {
    id?: number
    number?: string | null
    issued?: string | null
    code?: string | null
    place_of_birth?: string | null
    registration_address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_minor_properties?: ClientIndividualMinorPropertiesUncheckedCreateNestedOneWithoutClient_passportInput
  }

  export type ClientPassportCreateOrConnectWithoutClient_individual_propertiesInput = {
    where: ClientPassportWhereUniqueInput
    create: XOR<ClientPassportCreateWithoutClient_individual_propertiesInput, ClientPassportUncheckedCreateWithoutClient_individual_propertiesInput>
  }

  export type ClientUpsertWithoutClient_individual_propertiesInput = {
    update: XOR<ClientUpdateWithoutClient_individual_propertiesInput, ClientUncheckedUpdateWithoutClient_individual_propertiesInput>
    create: XOR<ClientCreateWithoutClient_individual_propertiesInput, ClientUncheckedCreateWithoutClient_individual_propertiesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutClient_individual_propertiesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutClient_individual_propertiesInput, ClientUncheckedUpdateWithoutClient_individual_propertiesInput>
  }

  export type ClientUpdateWithoutClient_individual_propertiesInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    client_category?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_minor_properties?: ClientIndividualMinorPropertiesUpdateOneWithoutClientNestedInput
    client_entity_properties?: ClientEntityPropertiesUpdateOneWithoutClientNestedInput
    client_contracts?: ClientContractToClientUpdateManyWithoutClientNestedInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutClient_individual_propertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    client_category?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_minor_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_entity_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_contracts?: ClientContractToClientUncheckedUpdateManyWithoutClientNestedInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientPassportUpsertWithoutClient_individual_propertiesInput = {
    update: XOR<ClientPassportUpdateWithoutClient_individual_propertiesInput, ClientPassportUncheckedUpdateWithoutClient_individual_propertiesInput>
    create: XOR<ClientPassportCreateWithoutClient_individual_propertiesInput, ClientPassportUncheckedCreateWithoutClient_individual_propertiesInput>
    where?: ClientPassportWhereInput
  }

  export type ClientPassportUpdateToOneWithWhereWithoutClient_individual_propertiesInput = {
    where?: ClientPassportWhereInput
    data: XOR<ClientPassportUpdateWithoutClient_individual_propertiesInput, ClientPassportUncheckedUpdateWithoutClient_individual_propertiesInput>
  }

  export type ClientPassportUpdateWithoutClient_individual_propertiesInput = {
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issued?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    registration_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_minor_properties?: ClientIndividualMinorPropertiesUpdateOneWithoutClient_passportNestedInput
  }

  export type ClientPassportUncheckedUpdateWithoutClient_individual_propertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issued?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    registration_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_minor_properties?: ClientIndividualMinorPropertiesUncheckedUpdateOneWithoutClient_passportNestedInput
  }

  export type ClientCreateWithoutClient_individual_minor_propertiesInput = {
    full_name: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    client_category: $Enums.ClientCategory
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_properties?: ClientIndividualPropertiesCreateNestedOneWithoutClientInput
    client_entity_properties?: ClientEntityPropertiesCreateNestedOneWithoutClientInput
    client_contracts?: ClientContractToClientCreateNestedManyWithoutClientInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutClient_individual_minor_propertiesInput = {
    id?: number
    full_name: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    client_category: $Enums.ClientCategory
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_properties_id?: number | null
    client_entity_properties_id?: number | null
    client_contracts?: ClientContractToClientUncheckedCreateNestedManyWithoutClientInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutClient_individual_minor_propertiesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutClient_individual_minor_propertiesInput, ClientUncheckedCreateWithoutClient_individual_minor_propertiesInput>
  }

  export type ClientPassportCreateWithoutClient_individual_minor_propertiesInput = {
    number?: string | null
    issued?: string | null
    code?: string | null
    place_of_birth?: string | null
    registration_address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_properties?: ClientIndividualPropertiesCreateNestedOneWithoutClient_passportInput
  }

  export type ClientPassportUncheckedCreateWithoutClient_individual_minor_propertiesInput = {
    id?: number
    number?: string | null
    issued?: string | null
    code?: string | null
    place_of_birth?: string | null
    registration_address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_properties?: ClientIndividualPropertiesUncheckedCreateNestedOneWithoutClient_passportInput
  }

  export type ClientPassportCreateOrConnectWithoutClient_individual_minor_propertiesInput = {
    where: ClientPassportWhereUniqueInput
    create: XOR<ClientPassportCreateWithoutClient_individual_minor_propertiesInput, ClientPassportUncheckedCreateWithoutClient_individual_minor_propertiesInput>
  }

  export type ClientToClientIndividualMinorPropertiesCreateWithoutClient_individual_minor_propertiesInput = {
    created_at?: Date | string
    updated_at?: Date | string
    client: ClientCreateNestedOneWithoutClients_to_client_individual_minor_propertiesInput
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClient_individual_minor_propertiesInput = {
    created_at?: Date | string
    updated_at?: Date | string
    client_id: number
  }

  export type ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClient_individual_minor_propertiesInput = {
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    create: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClient_individual_minor_propertiesInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClient_individual_minor_propertiesInput>
  }

  export type ClientToClientIndividualMinorPropertiesCreateManyClient_individual_minor_propertiesInputEnvelope = {
    data: ClientToClientIndividualMinorPropertiesCreateManyClient_individual_minor_propertiesInput | ClientToClientIndividualMinorPropertiesCreateManyClient_individual_minor_propertiesInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutClient_individual_minor_propertiesInput = {
    update: XOR<ClientUpdateWithoutClient_individual_minor_propertiesInput, ClientUncheckedUpdateWithoutClient_individual_minor_propertiesInput>
    create: XOR<ClientCreateWithoutClient_individual_minor_propertiesInput, ClientUncheckedCreateWithoutClient_individual_minor_propertiesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutClient_individual_minor_propertiesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutClient_individual_minor_propertiesInput, ClientUncheckedUpdateWithoutClient_individual_minor_propertiesInput>
  }

  export type ClientUpdateWithoutClient_individual_minor_propertiesInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    client_category?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_properties?: ClientIndividualPropertiesUpdateOneWithoutClientNestedInput
    client_entity_properties?: ClientEntityPropertiesUpdateOneWithoutClientNestedInput
    client_contracts?: ClientContractToClientUpdateManyWithoutClientNestedInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutClient_individual_minor_propertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    client_category?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_entity_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_contracts?: ClientContractToClientUncheckedUpdateManyWithoutClientNestedInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientPassportUpsertWithoutClient_individual_minor_propertiesInput = {
    update: XOR<ClientPassportUpdateWithoutClient_individual_minor_propertiesInput, ClientPassportUncheckedUpdateWithoutClient_individual_minor_propertiesInput>
    create: XOR<ClientPassportCreateWithoutClient_individual_minor_propertiesInput, ClientPassportUncheckedCreateWithoutClient_individual_minor_propertiesInput>
    where?: ClientPassportWhereInput
  }

  export type ClientPassportUpdateToOneWithWhereWithoutClient_individual_minor_propertiesInput = {
    where?: ClientPassportWhereInput
    data: XOR<ClientPassportUpdateWithoutClient_individual_minor_propertiesInput, ClientPassportUncheckedUpdateWithoutClient_individual_minor_propertiesInput>
  }

  export type ClientPassportUpdateWithoutClient_individual_minor_propertiesInput = {
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issued?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    registration_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_properties?: ClientIndividualPropertiesUpdateOneWithoutClient_passportNestedInput
  }

  export type ClientPassportUncheckedUpdateWithoutClient_individual_minor_propertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issued?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    registration_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_properties?: ClientIndividualPropertiesUncheckedUpdateOneWithoutClient_passportNestedInput
  }

  export type ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClient_individual_minor_propertiesInput = {
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    update: XOR<ClientToClientIndividualMinorPropertiesUpdateWithoutClient_individual_minor_propertiesInput, ClientToClientIndividualMinorPropertiesUncheckedUpdateWithoutClient_individual_minor_propertiesInput>
    create: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClient_individual_minor_propertiesInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClient_individual_minor_propertiesInput>
  }

  export type ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClient_individual_minor_propertiesInput = {
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    data: XOR<ClientToClientIndividualMinorPropertiesUpdateWithoutClient_individual_minor_propertiesInput, ClientToClientIndividualMinorPropertiesUncheckedUpdateWithoutClient_individual_minor_propertiesInput>
  }

  export type ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClient_individual_minor_propertiesInput = {
    where: ClientToClientIndividualMinorPropertiesScalarWhereInput
    data: XOR<ClientToClientIndividualMinorPropertiesUpdateManyMutationInput, ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClient_individual_minor_propertiesInput>
  }

  export type ClientCreateWithoutClient_entity_propertiesInput = {
    full_name: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    client_category: $Enums.ClientCategory
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_properties?: ClientIndividualPropertiesCreateNestedOneWithoutClientInput
    client_individual_minor_properties?: ClientIndividualMinorPropertiesCreateNestedOneWithoutClientInput
    client_contracts?: ClientContractToClientCreateNestedManyWithoutClientInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutClient_entity_propertiesInput = {
    id?: number
    full_name: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    client_category: $Enums.ClientCategory
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_properties_id?: number | null
    client_individual_minor_properties_id?: number | null
    client_contracts?: ClientContractToClientUncheckedCreateNestedManyWithoutClientInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutClient_entity_propertiesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutClient_entity_propertiesInput, ClientUncheckedCreateWithoutClient_entity_propertiesInput>
  }

  export type ClientUpsertWithoutClient_entity_propertiesInput = {
    update: XOR<ClientUpdateWithoutClient_entity_propertiesInput, ClientUncheckedUpdateWithoutClient_entity_propertiesInput>
    create: XOR<ClientCreateWithoutClient_entity_propertiesInput, ClientUncheckedCreateWithoutClient_entity_propertiesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutClient_entity_propertiesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutClient_entity_propertiesInput, ClientUncheckedUpdateWithoutClient_entity_propertiesInput>
  }

  export type ClientUpdateWithoutClient_entity_propertiesInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    client_category?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_properties?: ClientIndividualPropertiesUpdateOneWithoutClientNestedInput
    client_individual_minor_properties?: ClientIndividualMinorPropertiesUpdateOneWithoutClientNestedInput
    client_contracts?: ClientContractToClientUpdateManyWithoutClientNestedInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutClient_entity_propertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    client_category?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_individual_minor_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_contracts?: ClientContractToClientUncheckedUpdateManyWithoutClientNestedInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutClients_to_client_individual_minor_propertiesInput = {
    full_name: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    client_category: $Enums.ClientCategory
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_properties?: ClientIndividualPropertiesCreateNestedOneWithoutClientInput
    client_individual_minor_properties?: ClientIndividualMinorPropertiesCreateNestedOneWithoutClientInput
    client_entity_properties?: ClientEntityPropertiesCreateNestedOneWithoutClientInput
    client_contracts?: ClientContractToClientCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutClients_to_client_individual_minor_propertiesInput = {
    id?: number
    full_name: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    client_category: $Enums.ClientCategory
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_properties_id?: number | null
    client_individual_minor_properties_id?: number | null
    client_entity_properties_id?: number | null
    client_contracts?: ClientContractToClientUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutClients_to_client_individual_minor_propertiesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutClients_to_client_individual_minor_propertiesInput, ClientUncheckedCreateWithoutClients_to_client_individual_minor_propertiesInput>
  }

  export type ClientIndividualMinorPropertiesCreateWithoutRepresentativesInput = {
    dob?: Date | string | null
    snils?: string | null
    birth_certificate?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client?: ClientCreateNestedOneWithoutClient_individual_minor_propertiesInput
    client_passport?: ClientPassportCreateNestedOneWithoutClient_individual_minor_propertiesInput
  }

  export type ClientIndividualMinorPropertiesUncheckedCreateWithoutRepresentativesInput = {
    id?: number
    dob?: Date | string | null
    snils?: string | null
    birth_certificate?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_passport_id?: number | null
    client?: ClientUncheckedCreateNestedOneWithoutClient_individual_minor_propertiesInput
  }

  export type ClientIndividualMinorPropertiesCreateOrConnectWithoutRepresentativesInput = {
    where: ClientIndividualMinorPropertiesWhereUniqueInput
    create: XOR<ClientIndividualMinorPropertiesCreateWithoutRepresentativesInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutRepresentativesInput>
  }

  export type ClientUpsertWithoutClients_to_client_individual_minor_propertiesInput = {
    update: XOR<ClientUpdateWithoutClients_to_client_individual_minor_propertiesInput, ClientUncheckedUpdateWithoutClients_to_client_individual_minor_propertiesInput>
    create: XOR<ClientCreateWithoutClients_to_client_individual_minor_propertiesInput, ClientUncheckedCreateWithoutClients_to_client_individual_minor_propertiesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutClients_to_client_individual_minor_propertiesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutClients_to_client_individual_minor_propertiesInput, ClientUncheckedUpdateWithoutClients_to_client_individual_minor_propertiesInput>
  }

  export type ClientUpdateWithoutClients_to_client_individual_minor_propertiesInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    client_category?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_properties?: ClientIndividualPropertiesUpdateOneWithoutClientNestedInput
    client_individual_minor_properties?: ClientIndividualMinorPropertiesUpdateOneWithoutClientNestedInput
    client_entity_properties?: ClientEntityPropertiesUpdateOneWithoutClientNestedInput
    client_contracts?: ClientContractToClientUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutClients_to_client_individual_minor_propertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    client_category?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_individual_minor_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_entity_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_contracts?: ClientContractToClientUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientIndividualMinorPropertiesUpsertWithoutRepresentativesInput = {
    update: XOR<ClientIndividualMinorPropertiesUpdateWithoutRepresentativesInput, ClientIndividualMinorPropertiesUncheckedUpdateWithoutRepresentativesInput>
    create: XOR<ClientIndividualMinorPropertiesCreateWithoutRepresentativesInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutRepresentativesInput>
    where?: ClientIndividualMinorPropertiesWhereInput
  }

  export type ClientIndividualMinorPropertiesUpdateToOneWithWhereWithoutRepresentativesInput = {
    where?: ClientIndividualMinorPropertiesWhereInput
    data: XOR<ClientIndividualMinorPropertiesUpdateWithoutRepresentativesInput, ClientIndividualMinorPropertiesUncheckedUpdateWithoutRepresentativesInput>
  }

  export type ClientIndividualMinorPropertiesUpdateWithoutRepresentativesInput = {
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birth_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutClient_individual_minor_propertiesNestedInput
    client_passport?: ClientPassportUpdateOneWithoutClient_individual_minor_propertiesNestedInput
  }

  export type ClientIndividualMinorPropertiesUncheckedUpdateWithoutRepresentativesInput = {
    id?: IntFieldUpdateOperationsInput | number
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birth_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_passport_id?: NullableIntFieldUpdateOperationsInput | number | null
    client?: ClientUncheckedUpdateOneWithoutClient_individual_minor_propertiesNestedInput
  }

  export type ClientIndividualPropertiesCreateWithoutClient_passportInput = {
    dob?: Date | string | null
    snils?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client?: ClientCreateNestedOneWithoutClient_individual_propertiesInput
  }

  export type ClientIndividualPropertiesUncheckedCreateWithoutClient_passportInput = {
    id?: number
    dob?: Date | string | null
    snils?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client?: ClientUncheckedCreateNestedOneWithoutClient_individual_propertiesInput
  }

  export type ClientIndividualPropertiesCreateOrConnectWithoutClient_passportInput = {
    where: ClientIndividualPropertiesWhereUniqueInput
    create: XOR<ClientIndividualPropertiesCreateWithoutClient_passportInput, ClientIndividualPropertiesUncheckedCreateWithoutClient_passportInput>
  }

  export type ClientIndividualMinorPropertiesCreateWithoutClient_passportInput = {
    dob?: Date | string | null
    snils?: string | null
    birth_certificate?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client?: ClientCreateNestedOneWithoutClient_individual_minor_propertiesInput
    representatives?: ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClient_individual_minor_propertiesInput
  }

  export type ClientIndividualMinorPropertiesUncheckedCreateWithoutClient_passportInput = {
    id?: number
    dob?: Date | string | null
    snils?: string | null
    birth_certificate?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client?: ClientUncheckedCreateNestedOneWithoutClient_individual_minor_propertiesInput
    representatives?: ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClient_individual_minor_propertiesInput
  }

  export type ClientIndividualMinorPropertiesCreateOrConnectWithoutClient_passportInput = {
    where: ClientIndividualMinorPropertiesWhereUniqueInput
    create: XOR<ClientIndividualMinorPropertiesCreateWithoutClient_passportInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClient_passportInput>
  }

  export type ClientIndividualPropertiesUpsertWithoutClient_passportInput = {
    update: XOR<ClientIndividualPropertiesUpdateWithoutClient_passportInput, ClientIndividualPropertiesUncheckedUpdateWithoutClient_passportInput>
    create: XOR<ClientIndividualPropertiesCreateWithoutClient_passportInput, ClientIndividualPropertiesUncheckedCreateWithoutClient_passportInput>
    where?: ClientIndividualPropertiesWhereInput
  }

  export type ClientIndividualPropertiesUpdateToOneWithWhereWithoutClient_passportInput = {
    where?: ClientIndividualPropertiesWhereInput
    data: XOR<ClientIndividualPropertiesUpdateWithoutClient_passportInput, ClientIndividualPropertiesUncheckedUpdateWithoutClient_passportInput>
  }

  export type ClientIndividualPropertiesUpdateWithoutClient_passportInput = {
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutClient_individual_propertiesNestedInput
  }

  export type ClientIndividualPropertiesUncheckedUpdateWithoutClient_passportInput = {
    id?: IntFieldUpdateOperationsInput | number
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUncheckedUpdateOneWithoutClient_individual_propertiesNestedInput
  }

  export type ClientIndividualMinorPropertiesUpsertWithoutClient_passportInput = {
    update: XOR<ClientIndividualMinorPropertiesUpdateWithoutClient_passportInput, ClientIndividualMinorPropertiesUncheckedUpdateWithoutClient_passportInput>
    create: XOR<ClientIndividualMinorPropertiesCreateWithoutClient_passportInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClient_passportInput>
    where?: ClientIndividualMinorPropertiesWhereInput
  }

  export type ClientIndividualMinorPropertiesUpdateToOneWithWhereWithoutClient_passportInput = {
    where?: ClientIndividualMinorPropertiesWhereInput
    data: XOR<ClientIndividualMinorPropertiesUpdateWithoutClient_passportInput, ClientIndividualMinorPropertiesUncheckedUpdateWithoutClient_passportInput>
  }

  export type ClientIndividualMinorPropertiesUpdateWithoutClient_passportInput = {
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birth_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutClient_individual_minor_propertiesNestedInput
    representatives?: ClientToClientIndividualMinorPropertiesUpdateManyWithoutClient_individual_minor_propertiesNestedInput
  }

  export type ClientIndividualMinorPropertiesUncheckedUpdateWithoutClient_passportInput = {
    id?: IntFieldUpdateOperationsInput | number
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birth_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUncheckedUpdateOneWithoutClient_individual_minor_propertiesNestedInput
    representatives?: ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClient_individual_minor_propertiesNestedInput
  }

  export type ObjectCreateWithoutClient_contractsInput = {
    common_db_objects_id: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entity: EntityCreateNestedOneWithoutObjectsInput
    products?: ProductCreateNestedManyWithoutObjectInput
    agency_contracts?: AgencyContractCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutClient_contractsInput = {
    id?: number
    common_db_objects_id: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entity_id: number
    products?: ProductUncheckedCreateNestedManyWithoutObjectInput
    agency_contracts?: AgencyContractUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutClient_contractsInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutClient_contractsInput, ObjectUncheckedCreateWithoutClient_contractsInput>
  }

  export type ProductCreateWithoutClient_contractInput = {
    pricing_products_id: number
    number: string
    product_category: $Enums.ProductCategory
    created_at?: Date | string
    updated_at?: Date | string
    object: ObjectCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutClient_contractInput = {
    id?: number
    pricing_products_id: number
    number: string
    product_category: $Enums.ProductCategory
    created_at?: Date | string
    updated_at?: Date | string
    object_id: number
  }

  export type ProductCreateOrConnectWithoutClient_contractInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutClient_contractInput, ProductUncheckedCreateWithoutClient_contractInput>
  }

  export type RealEstateAgentCreateWithoutClient_contractsInput = {
    full_name: string
    phone?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agencies?: AgencyToRealEstateAgentCreateNestedManyWithoutReal_estate_agentInput
  }

  export type RealEstateAgentUncheckedCreateWithoutClient_contractsInput = {
    id?: number
    full_name: string
    phone?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agencies?: AgencyToRealEstateAgentUncheckedCreateNestedManyWithoutReal_estate_agentInput
  }

  export type RealEstateAgentCreateOrConnectWithoutClient_contractsInput = {
    where: RealEstateAgentWhereUniqueInput
    create: XOR<RealEstateAgentCreateWithoutClient_contractsInput, RealEstateAgentUncheckedCreateWithoutClient_contractsInput>
  }

  export type UserCreateWithoutClient_contractsInput = {
    full_name: string
    email: string
    phone?: string | null
    is_manager: boolean
    user_role: $Enums.UserRole
    created_at?: Date | string
    updated_at?: Date | string
    agency_contracts?: AgencyContractCreateNestedManyWithoutResponsible_userInput
  }

  export type UserUncheckedCreateWithoutClient_contractsInput = {
    id?: number
    full_name: string
    email: string
    phone?: string | null
    is_manager: boolean
    user_role: $Enums.UserRole
    created_at?: Date | string
    updated_at?: Date | string
    agency_contracts?: AgencyContractUncheckedCreateNestedManyWithoutResponsible_userInput
  }

  export type UserCreateOrConnectWithoutClient_contractsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClient_contractsInput, UserUncheckedCreateWithoutClient_contractsInput>
  }

  export type BankCreateWithoutClient_contractsInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BankUncheckedCreateWithoutClient_contractsInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BankCreateOrConnectWithoutClient_contractsInput = {
    where: BankWhereUniqueInput
    create: XOR<BankCreateWithoutClient_contractsInput, BankUncheckedCreateWithoutClient_contractsInput>
  }

  export type DDUClientContractPropertiesCreateWithoutClient_contractInput = {
    ddu_link?: string | null
    return_account?: string | null
    escrow_account_opening_date?: Date | string | null
    escrow_period?: Date | string | null
    escrow_account_number?: string | null
    is_escrow_discount?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DDUClientContractPropertiesUncheckedCreateWithoutClient_contractInput = {
    id?: number
    ddu_link?: string | null
    return_account?: string | null
    escrow_account_opening_date?: Date | string | null
    escrow_period?: Date | string | null
    escrow_account_number?: string | null
    is_escrow_discount?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DDUClientContractPropertiesCreateOrConnectWithoutClient_contractInput = {
    where: DDUClientContractPropertiesWhereUniqueInput
    create: XOR<DDUClientContractPropertiesCreateWithoutClient_contractInput, DDUClientContractPropertiesUncheckedCreateWithoutClient_contractInput>
  }

  export type ClientContractToClientCreateWithoutClient_contractInput = {
    is_main: boolean
    share: number
    created_at?: Date | string
    updated_at?: Date | string
    client: ClientCreateNestedOneWithoutClient_contractsInput
  }

  export type ClientContractToClientUncheckedCreateWithoutClient_contractInput = {
    is_main: boolean
    share: number
    created_at?: Date | string
    updated_at?: Date | string
    client_id: number
  }

  export type ClientContractToClientCreateOrConnectWithoutClient_contractInput = {
    where: ClientContractToClientWhereUniqueInput
    create: XOR<ClientContractToClientCreateWithoutClient_contractInput, ClientContractToClientUncheckedCreateWithoutClient_contractInput>
  }

  export type ClientContractToClientCreateManyClient_contractInputEnvelope = {
    data: ClientContractToClientCreateManyClient_contractInput | ClientContractToClientCreateManyClient_contractInput[]
    skipDuplicates?: boolean
  }

  export type ClientContractToAgencyContractCreateWithoutClient_contractInput = {
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract: AgencyContractCreateNestedOneWithoutClient_contractsInput
  }

  export type ClientContractToAgencyContractUncheckedCreateWithoutClient_contractInput = {
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract_id: number
  }

  export type ClientContractToAgencyContractCreateOrConnectWithoutClient_contractInput = {
    where: ClientContractToAgencyContractWhereUniqueInput
    create: XOR<ClientContractToAgencyContractCreateWithoutClient_contractInput, ClientContractToAgencyContractUncheckedCreateWithoutClient_contractInput>
  }

  export type ClientContractToAgencyContractCreateManyClient_contractInputEnvelope = {
    data: ClientContractToAgencyContractCreateManyClient_contractInput | ClientContractToAgencyContractCreateManyClient_contractInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledPaymentCreateWithoutClient_contractInput = {
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    scheduled_payment_type: $Enums.ScheduledPaymentType
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ScheduledPaymentUncheckedCreateWithoutClient_contractInput = {
    id?: number
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    scheduled_payment_type: $Enums.ScheduledPaymentType
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ScheduledPaymentCreateOrConnectWithoutClient_contractInput = {
    where: ScheduledPaymentWhereUniqueInput
    create: XOR<ScheduledPaymentCreateWithoutClient_contractInput, ScheduledPaymentUncheckedCreateWithoutClient_contractInput>
  }

  export type ScheduledPaymentCreateManyClient_contractInputEnvelope = {
    data: ScheduledPaymentCreateManyClient_contractInput | ScheduledPaymentCreateManyClient_contractInput[]
    skipDuplicates?: boolean
  }

  export type ActualPaymentCreateWithoutClient_contractInput = {
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActualPaymentUncheckedCreateWithoutClient_contractInput = {
    id?: number
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActualPaymentCreateOrConnectWithoutClient_contractInput = {
    where: ActualPaymentWhereUniqueInput
    create: XOR<ActualPaymentCreateWithoutClient_contractInput, ActualPaymentUncheckedCreateWithoutClient_contractInput>
  }

  export type ActualPaymentCreateManyClient_contractInputEnvelope = {
    data: ActualPaymentCreateManyClient_contractInput | ActualPaymentCreateManyClient_contractInput[]
    skipDuplicates?: boolean
  }

  export type ObjectUpsertWithoutClient_contractsInput = {
    update: XOR<ObjectUpdateWithoutClient_contractsInput, ObjectUncheckedUpdateWithoutClient_contractsInput>
    create: XOR<ObjectCreateWithoutClient_contractsInput, ObjectUncheckedCreateWithoutClient_contractsInput>
    where?: ObjectWhereInput
  }

  export type ObjectUpdateToOneWithWhereWithoutClient_contractsInput = {
    where?: ObjectWhereInput
    data: XOR<ObjectUpdateWithoutClient_contractsInput, ObjectUncheckedUpdateWithoutClient_contractsInput>
  }

  export type ObjectUpdateWithoutClient_contractsInput = {
    common_db_objects_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: EntityUpdateOneRequiredWithoutObjectsNestedInput
    products?: ProductUpdateManyWithoutObjectNestedInput
    agency_contracts?: AgencyContractUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutClient_contractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    common_db_objects_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entity_id?: IntFieldUpdateOperationsInput | number
    products?: ProductUncheckedUpdateManyWithoutObjectNestedInput
    agency_contracts?: AgencyContractUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type ProductUpsertWithoutClient_contractInput = {
    update: XOR<ProductUpdateWithoutClient_contractInput, ProductUncheckedUpdateWithoutClient_contractInput>
    create: XOR<ProductCreateWithoutClient_contractInput, ProductUncheckedCreateWithoutClient_contractInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutClient_contractInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutClient_contractInput, ProductUncheckedUpdateWithoutClient_contractInput>
  }

  export type ProductUpdateWithoutClient_contractInput = {
    pricing_products_id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    product_category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object?: ObjectUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutClient_contractInput = {
    id?: IntFieldUpdateOperationsInput | number
    pricing_products_id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    product_category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: IntFieldUpdateOperationsInput | number
  }

  export type RealEstateAgentUpsertWithoutClient_contractsInput = {
    update: XOR<RealEstateAgentUpdateWithoutClient_contractsInput, RealEstateAgentUncheckedUpdateWithoutClient_contractsInput>
    create: XOR<RealEstateAgentCreateWithoutClient_contractsInput, RealEstateAgentUncheckedCreateWithoutClient_contractsInput>
    where?: RealEstateAgentWhereInput
  }

  export type RealEstateAgentUpdateToOneWithWhereWithoutClient_contractsInput = {
    where?: RealEstateAgentWhereInput
    data: XOR<RealEstateAgentUpdateWithoutClient_contractsInput, RealEstateAgentUncheckedUpdateWithoutClient_contractsInput>
  }

  export type RealEstateAgentUpdateWithoutClient_contractsInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agencies?: AgencyToRealEstateAgentUpdateManyWithoutReal_estate_agentNestedInput
  }

  export type RealEstateAgentUncheckedUpdateWithoutClient_contractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agencies?: AgencyToRealEstateAgentUncheckedUpdateManyWithoutReal_estate_agentNestedInput
  }

  export type UserUpsertWithoutClient_contractsInput = {
    update: XOR<UserUpdateWithoutClient_contractsInput, UserUncheckedUpdateWithoutClient_contractsInput>
    create: XOR<UserCreateWithoutClient_contractsInput, UserUncheckedCreateWithoutClient_contractsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClient_contractsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClient_contractsInput, UserUncheckedUpdateWithoutClient_contractsInput>
  }

  export type UserUpdateWithoutClient_contractsInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_manager?: BoolFieldUpdateOperationsInput | boolean
    user_role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contracts?: AgencyContractUpdateManyWithoutResponsible_userNestedInput
  }

  export type UserUncheckedUpdateWithoutClient_contractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_manager?: BoolFieldUpdateOperationsInput | boolean
    user_role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contracts?: AgencyContractUncheckedUpdateManyWithoutResponsible_userNestedInput
  }

  export type BankUpsertWithoutClient_contractsInput = {
    update: XOR<BankUpdateWithoutClient_contractsInput, BankUncheckedUpdateWithoutClient_contractsInput>
    create: XOR<BankCreateWithoutClient_contractsInput, BankUncheckedCreateWithoutClient_contractsInput>
    where?: BankWhereInput
  }

  export type BankUpdateToOneWithWhereWithoutClient_contractsInput = {
    where?: BankWhereInput
    data: XOR<BankUpdateWithoutClient_contractsInput, BankUncheckedUpdateWithoutClient_contractsInput>
  }

  export type BankUpdateWithoutClient_contractsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankUncheckedUpdateWithoutClient_contractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DDUClientContractPropertiesUpsertWithoutClient_contractInput = {
    update: XOR<DDUClientContractPropertiesUpdateWithoutClient_contractInput, DDUClientContractPropertiesUncheckedUpdateWithoutClient_contractInput>
    create: XOR<DDUClientContractPropertiesCreateWithoutClient_contractInput, DDUClientContractPropertiesUncheckedCreateWithoutClient_contractInput>
    where?: DDUClientContractPropertiesWhereInput
  }

  export type DDUClientContractPropertiesUpdateToOneWithWhereWithoutClient_contractInput = {
    where?: DDUClientContractPropertiesWhereInput
    data: XOR<DDUClientContractPropertiesUpdateWithoutClient_contractInput, DDUClientContractPropertiesUncheckedUpdateWithoutClient_contractInput>
  }

  export type DDUClientContractPropertiesUpdateWithoutClient_contractInput = {
    ddu_link?: NullableStringFieldUpdateOperationsInput | string | null
    return_account?: NullableStringFieldUpdateOperationsInput | string | null
    escrow_account_opening_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrow_period?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrow_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_escrow_discount?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DDUClientContractPropertiesUncheckedUpdateWithoutClient_contractInput = {
    id?: IntFieldUpdateOperationsInput | number
    ddu_link?: NullableStringFieldUpdateOperationsInput | string | null
    return_account?: NullableStringFieldUpdateOperationsInput | string | null
    escrow_account_opening_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrow_period?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrow_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_escrow_discount?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToClientUpsertWithWhereUniqueWithoutClient_contractInput = {
    where: ClientContractToClientWhereUniqueInput
    update: XOR<ClientContractToClientUpdateWithoutClient_contractInput, ClientContractToClientUncheckedUpdateWithoutClient_contractInput>
    create: XOR<ClientContractToClientCreateWithoutClient_contractInput, ClientContractToClientUncheckedCreateWithoutClient_contractInput>
  }

  export type ClientContractToClientUpdateWithWhereUniqueWithoutClient_contractInput = {
    where: ClientContractToClientWhereUniqueInput
    data: XOR<ClientContractToClientUpdateWithoutClient_contractInput, ClientContractToClientUncheckedUpdateWithoutClient_contractInput>
  }

  export type ClientContractToClientUpdateManyWithWhereWithoutClient_contractInput = {
    where: ClientContractToClientScalarWhereInput
    data: XOR<ClientContractToClientUpdateManyMutationInput, ClientContractToClientUncheckedUpdateManyWithoutClient_contractInput>
  }

  export type ClientContractToAgencyContractUpsertWithWhereUniqueWithoutClient_contractInput = {
    where: ClientContractToAgencyContractWhereUniqueInput
    update: XOR<ClientContractToAgencyContractUpdateWithoutClient_contractInput, ClientContractToAgencyContractUncheckedUpdateWithoutClient_contractInput>
    create: XOR<ClientContractToAgencyContractCreateWithoutClient_contractInput, ClientContractToAgencyContractUncheckedCreateWithoutClient_contractInput>
  }

  export type ClientContractToAgencyContractUpdateWithWhereUniqueWithoutClient_contractInput = {
    where: ClientContractToAgencyContractWhereUniqueInput
    data: XOR<ClientContractToAgencyContractUpdateWithoutClient_contractInput, ClientContractToAgencyContractUncheckedUpdateWithoutClient_contractInput>
  }

  export type ClientContractToAgencyContractUpdateManyWithWhereWithoutClient_contractInput = {
    where: ClientContractToAgencyContractScalarWhereInput
    data: XOR<ClientContractToAgencyContractUpdateManyMutationInput, ClientContractToAgencyContractUncheckedUpdateManyWithoutClient_contractInput>
  }

  export type ClientContractToAgencyContractScalarWhereInput = {
    AND?: ClientContractToAgencyContractScalarWhereInput | ClientContractToAgencyContractScalarWhereInput[]
    OR?: ClientContractToAgencyContractScalarWhereInput[]
    NOT?: ClientContractToAgencyContractScalarWhereInput | ClientContractToAgencyContractScalarWhereInput[]
    created_at?: DateTimeFilter<"ClientContractToAgencyContract"> | Date | string
    updated_at?: DateTimeFilter<"ClientContractToAgencyContract"> | Date | string
    client_contract_id?: IntFilter<"ClientContractToAgencyContract"> | number
    agency_contract_id?: IntFilter<"ClientContractToAgencyContract"> | number
  }

  export type ScheduledPaymentUpsertWithWhereUniqueWithoutClient_contractInput = {
    where: ScheduledPaymentWhereUniqueInput
    update: XOR<ScheduledPaymentUpdateWithoutClient_contractInput, ScheduledPaymentUncheckedUpdateWithoutClient_contractInput>
    create: XOR<ScheduledPaymentCreateWithoutClient_contractInput, ScheduledPaymentUncheckedCreateWithoutClient_contractInput>
  }

  export type ScheduledPaymentUpdateWithWhereUniqueWithoutClient_contractInput = {
    where: ScheduledPaymentWhereUniqueInput
    data: XOR<ScheduledPaymentUpdateWithoutClient_contractInput, ScheduledPaymentUncheckedUpdateWithoutClient_contractInput>
  }

  export type ScheduledPaymentUpdateManyWithWhereWithoutClient_contractInput = {
    where: ScheduledPaymentScalarWhereInput
    data: XOR<ScheduledPaymentUpdateManyMutationInput, ScheduledPaymentUncheckedUpdateManyWithoutClient_contractInput>
  }

  export type ScheduledPaymentScalarWhereInput = {
    AND?: ScheduledPaymentScalarWhereInput | ScheduledPaymentScalarWhereInput[]
    OR?: ScheduledPaymentScalarWhereInput[]
    NOT?: ScheduledPaymentScalarWhereInput | ScheduledPaymentScalarWhereInput[]
    id?: IntFilter<"ScheduledPayment"> | number
    payment?: DecimalFilter<"ScheduledPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"ScheduledPayment"> | Date | string
    scheduled_payment_type?: EnumScheduledPaymentTypeFilter<"ScheduledPayment"> | $Enums.ScheduledPaymentType
    created_at?: DateTimeFilter<"ScheduledPayment"> | Date | string
    updated_at?: DateTimeFilter<"ScheduledPayment"> | Date | string
    client_contract_id?: IntFilter<"ScheduledPayment"> | number
  }

  export type ActualPaymentUpsertWithWhereUniqueWithoutClient_contractInput = {
    where: ActualPaymentWhereUniqueInput
    update: XOR<ActualPaymentUpdateWithoutClient_contractInput, ActualPaymentUncheckedUpdateWithoutClient_contractInput>
    create: XOR<ActualPaymentCreateWithoutClient_contractInput, ActualPaymentUncheckedCreateWithoutClient_contractInput>
  }

  export type ActualPaymentUpdateWithWhereUniqueWithoutClient_contractInput = {
    where: ActualPaymentWhereUniqueInput
    data: XOR<ActualPaymentUpdateWithoutClient_contractInput, ActualPaymentUncheckedUpdateWithoutClient_contractInput>
  }

  export type ActualPaymentUpdateManyWithWhereWithoutClient_contractInput = {
    where: ActualPaymentScalarWhereInput
    data: XOR<ActualPaymentUpdateManyMutationInput, ActualPaymentUncheckedUpdateManyWithoutClient_contractInput>
  }

  export type ActualPaymentScalarWhereInput = {
    AND?: ActualPaymentScalarWhereInput | ActualPaymentScalarWhereInput[]
    OR?: ActualPaymentScalarWhereInput[]
    NOT?: ActualPaymentScalarWhereInput | ActualPaymentScalarWhereInput[]
    id?: IntFilter<"ActualPayment"> | number
    payment?: DecimalFilter<"ActualPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"ActualPayment"> | Date | string
    created_at?: DateTimeFilter<"ActualPayment"> | Date | string
    updated_at?: DateTimeFilter<"ActualPayment"> | Date | string
    client_contract_id?: IntFilter<"ActualPayment"> | number
  }

  export type ClientContractCreateWithoutDdu_client_contract_propertiesInput = {
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object: ObjectCreateNestedOneWithoutClient_contractsInput
    product: ProductCreateNestedOneWithoutClient_contractInput
    real_estate_agent?: RealEstateAgentCreateNestedOneWithoutClient_contractsInput
    manager?: UserCreateNestedOneWithoutClient_contractsInput
    bank?: BankCreateNestedOneWithoutClient_contractsInput
    clients?: ClientContractToClientCreateNestedManyWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractUncheckedCreateWithoutDdu_client_contract_propertiesInput = {
    id?: number
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object_id: number
    product_id: number
    real_estate_agent_id?: number | null
    manager_id?: number | null
    bank_id?: number | null
    clients?: ClientContractToClientUncheckedCreateNestedManyWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentUncheckedCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractCreateOrConnectWithoutDdu_client_contract_propertiesInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutDdu_client_contract_propertiesInput, ClientContractUncheckedCreateWithoutDdu_client_contract_propertiesInput>
  }

  export type ClientContractUpsertWithoutDdu_client_contract_propertiesInput = {
    update: XOR<ClientContractUpdateWithoutDdu_client_contract_propertiesInput, ClientContractUncheckedUpdateWithoutDdu_client_contract_propertiesInput>
    create: XOR<ClientContractCreateWithoutDdu_client_contract_propertiesInput, ClientContractUncheckedCreateWithoutDdu_client_contract_propertiesInput>
    where?: ClientContractWhereInput
  }

  export type ClientContractUpdateToOneWithWhereWithoutDdu_client_contract_propertiesInput = {
    where?: ClientContractWhereInput
    data: XOR<ClientContractUpdateWithoutDdu_client_contract_propertiesInput, ClientContractUncheckedUpdateWithoutDdu_client_contract_propertiesInput>
  }

  export type ClientContractUpdateWithoutDdu_client_contract_propertiesInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object?: ObjectUpdateOneRequiredWithoutClient_contractsNestedInput
    product?: ProductUpdateOneRequiredWithoutClient_contractNestedInput
    real_estate_agent?: RealEstateAgentUpdateOneWithoutClient_contractsNestedInput
    manager?: UserUpdateOneWithoutClient_contractsNestedInput
    bank?: BankUpdateOneWithoutClient_contractsNestedInput
    clients?: ClientContractToClientUpdateManyWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutDdu_client_contract_propertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    real_estate_agent_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    bank_id?: NullableIntFieldUpdateOperationsInput | number | null
    clients?: ClientContractToClientUncheckedUpdateManyWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientContractCreateWithoutAgency_contractsInput = {
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object: ObjectCreateNestedOneWithoutClient_contractsInput
    product: ProductCreateNestedOneWithoutClient_contractInput
    real_estate_agent?: RealEstateAgentCreateNestedOneWithoutClient_contractsInput
    manager?: UserCreateNestedOneWithoutClient_contractsInput
    bank?: BankCreateNestedOneWithoutClient_contractsInput
    ddu_client_contract_properties?: DDUClientContractPropertiesCreateNestedOneWithoutClient_contractInput
    clients?: ClientContractToClientCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractUncheckedCreateWithoutAgency_contractsInput = {
    id?: number
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object_id: number
    product_id: number
    real_estate_agent_id?: number | null
    manager_id?: number | null
    bank_id?: number | null
    ddu_client_contract_properties_id?: number | null
    clients?: ClientContractToClientUncheckedCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentUncheckedCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractCreateOrConnectWithoutAgency_contractsInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutAgency_contractsInput, ClientContractUncheckedCreateWithoutAgency_contractsInput>
  }

  export type AgencyContractCreateWithoutClient_contractsInput = {
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user?: UserCreateNestedOneWithoutAgency_contractsInput
    entity: EntityCreateNestedOneWithoutAgency_contractsInput
    object: ObjectCreateNestedOneWithoutAgency_contractsInput
    agency: AgencyCreateNestedOneWithoutAgency_contractsInput
    agency_contract_signatory?: AgencyContractSignatoryCreateNestedOneWithoutAgency_contractInput
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgency_contractInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesCreateNestedOneWithoutAgency_contractInput
  }

  export type AgencyContractUncheckedCreateWithoutClient_contractsInput = {
    id?: number
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user_id?: number | null
    entity_id: number
    object_id: number
    agency_id: number
    agency_contract_signatory_id?: number | null
    real_estate_agency_contract_properties_id?: number | null
    mip_agency_contract_properties_id?: number | null
  }

  export type AgencyContractCreateOrConnectWithoutClient_contractsInput = {
    where: AgencyContractWhereUniqueInput
    create: XOR<AgencyContractCreateWithoutClient_contractsInput, AgencyContractUncheckedCreateWithoutClient_contractsInput>
  }

  export type ClientContractUpsertWithoutAgency_contractsInput = {
    update: XOR<ClientContractUpdateWithoutAgency_contractsInput, ClientContractUncheckedUpdateWithoutAgency_contractsInput>
    create: XOR<ClientContractCreateWithoutAgency_contractsInput, ClientContractUncheckedCreateWithoutAgency_contractsInput>
    where?: ClientContractWhereInput
  }

  export type ClientContractUpdateToOneWithWhereWithoutAgency_contractsInput = {
    where?: ClientContractWhereInput
    data: XOR<ClientContractUpdateWithoutAgency_contractsInput, ClientContractUncheckedUpdateWithoutAgency_contractsInput>
  }

  export type ClientContractUpdateWithoutAgency_contractsInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object?: ObjectUpdateOneRequiredWithoutClient_contractsNestedInput
    product?: ProductUpdateOneRequiredWithoutClient_contractNestedInput
    real_estate_agent?: RealEstateAgentUpdateOneWithoutClient_contractsNestedInput
    manager?: UserUpdateOneWithoutClient_contractsNestedInput
    bank?: BankUpdateOneWithoutClient_contractsNestedInput
    ddu_client_contract_properties?: DDUClientContractPropertiesUpdateOneWithoutClient_contractNestedInput
    clients?: ClientContractToClientUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutAgency_contractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    real_estate_agent_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    bank_id?: NullableIntFieldUpdateOperationsInput | number | null
    ddu_client_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    clients?: ClientContractToClientUncheckedUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
  }

  export type AgencyContractUpsertWithoutClient_contractsInput = {
    update: XOR<AgencyContractUpdateWithoutClient_contractsInput, AgencyContractUncheckedUpdateWithoutClient_contractsInput>
    create: XOR<AgencyContractCreateWithoutClient_contractsInput, AgencyContractUncheckedCreateWithoutClient_contractsInput>
    where?: AgencyContractWhereInput
  }

  export type AgencyContractUpdateToOneWithWhereWithoutClient_contractsInput = {
    where?: AgencyContractWhereInput
    data: XOR<AgencyContractUpdateWithoutClient_contractsInput, AgencyContractUncheckedUpdateWithoutClient_contractsInput>
  }

  export type AgencyContractUpdateWithoutClient_contractsInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user?: UserUpdateOneWithoutAgency_contractsNestedInput
    entity?: EntityUpdateOneRequiredWithoutAgency_contractsNestedInput
    object?: ObjectUpdateOneRequiredWithoutAgency_contractsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgency_contractsNestedInput
    agency_contract_signatory?: AgencyContractSignatoryUpdateOneWithoutAgency_contractNestedInput
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgency_contractNestedInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesUpdateOneWithoutAgency_contractNestedInput
  }

  export type AgencyContractUncheckedUpdateWithoutClient_contractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_id?: IntFieldUpdateOperationsInput | number
    object_id?: IntFieldUpdateOperationsInput | number
    agency_id?: IntFieldUpdateOperationsInput | number
    agency_contract_signatory_id?: NullableIntFieldUpdateOperationsInput | number | null
    real_estate_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    mip_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClientContractCreateWithoutClientsInput = {
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object: ObjectCreateNestedOneWithoutClient_contractsInput
    product: ProductCreateNestedOneWithoutClient_contractInput
    real_estate_agent?: RealEstateAgentCreateNestedOneWithoutClient_contractsInput
    manager?: UserCreateNestedOneWithoutClient_contractsInput
    bank?: BankCreateNestedOneWithoutClient_contractsInput
    ddu_client_contract_properties?: DDUClientContractPropertiesCreateNestedOneWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractUncheckedCreateWithoutClientsInput = {
    id?: number
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object_id: number
    product_id: number
    real_estate_agent_id?: number | null
    manager_id?: number | null
    bank_id?: number | null
    ddu_client_contract_properties_id?: number | null
    agency_contracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentUncheckedCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractCreateOrConnectWithoutClientsInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutClientsInput, ClientContractUncheckedCreateWithoutClientsInput>
  }

  export type ClientCreateWithoutClient_contractsInput = {
    full_name: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    client_category: $Enums.ClientCategory
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_properties?: ClientIndividualPropertiesCreateNestedOneWithoutClientInput
    client_individual_minor_properties?: ClientIndividualMinorPropertiesCreateNestedOneWithoutClientInput
    client_entity_properties?: ClientEntityPropertiesCreateNestedOneWithoutClientInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutClient_contractsInput = {
    id?: number
    full_name: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    client_category: $Enums.ClientCategory
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_properties_id?: number | null
    client_individual_minor_properties_id?: number | null
    client_entity_properties_id?: number | null
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutClient_contractsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutClient_contractsInput, ClientUncheckedCreateWithoutClient_contractsInput>
  }

  export type ClientContractUpsertWithoutClientsInput = {
    update: XOR<ClientContractUpdateWithoutClientsInput, ClientContractUncheckedUpdateWithoutClientsInput>
    create: XOR<ClientContractCreateWithoutClientsInput, ClientContractUncheckedCreateWithoutClientsInput>
    where?: ClientContractWhereInput
  }

  export type ClientContractUpdateToOneWithWhereWithoutClientsInput = {
    where?: ClientContractWhereInput
    data: XOR<ClientContractUpdateWithoutClientsInput, ClientContractUncheckedUpdateWithoutClientsInput>
  }

  export type ClientContractUpdateWithoutClientsInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object?: ObjectUpdateOneRequiredWithoutClient_contractsNestedInput
    product?: ProductUpdateOneRequiredWithoutClient_contractNestedInput
    real_estate_agent?: RealEstateAgentUpdateOneWithoutClient_contractsNestedInput
    manager?: UserUpdateOneWithoutClient_contractsNestedInput
    bank?: BankUpdateOneWithoutClient_contractsNestedInput
    ddu_client_contract_properties?: DDUClientContractPropertiesUpdateOneWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutClientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    real_estate_agent_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    bank_id?: NullableIntFieldUpdateOperationsInput | number | null
    ddu_client_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    agency_contracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientUpsertWithoutClient_contractsInput = {
    update: XOR<ClientUpdateWithoutClient_contractsInput, ClientUncheckedUpdateWithoutClient_contractsInput>
    create: XOR<ClientCreateWithoutClient_contractsInput, ClientUncheckedCreateWithoutClient_contractsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutClient_contractsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutClient_contractsInput, ClientUncheckedUpdateWithoutClient_contractsInput>
  }

  export type ClientUpdateWithoutClient_contractsInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    client_category?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_properties?: ClientIndividualPropertiesUpdateOneWithoutClientNestedInput
    client_individual_minor_properties?: ClientIndividualMinorPropertiesUpdateOneWithoutClientNestedInput
    client_entity_properties?: ClientEntityPropertiesUpdateOneWithoutClientNestedInput
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutClient_contractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    client_category?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_individual_minor_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_entity_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    clients_to_client_individual_minor_properties?: ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientContractCreateWithoutScheduled_paymentsInput = {
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object: ObjectCreateNestedOneWithoutClient_contractsInput
    product: ProductCreateNestedOneWithoutClient_contractInput
    real_estate_agent?: RealEstateAgentCreateNestedOneWithoutClient_contractsInput
    manager?: UserCreateNestedOneWithoutClient_contractsInput
    bank?: BankCreateNestedOneWithoutClient_contractsInput
    ddu_client_contract_properties?: DDUClientContractPropertiesCreateNestedOneWithoutClient_contractInput
    clients?: ClientContractToClientCreateNestedManyWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractUncheckedCreateWithoutScheduled_paymentsInput = {
    id?: number
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object_id: number
    product_id: number
    real_estate_agent_id?: number | null
    manager_id?: number | null
    bank_id?: number | null
    ddu_client_contract_properties_id?: number | null
    clients?: ClientContractToClientUncheckedCreateNestedManyWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentUncheckedCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractCreateOrConnectWithoutScheduled_paymentsInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutScheduled_paymentsInput, ClientContractUncheckedCreateWithoutScheduled_paymentsInput>
  }

  export type ClientContractUpsertWithoutScheduled_paymentsInput = {
    update: XOR<ClientContractUpdateWithoutScheduled_paymentsInput, ClientContractUncheckedUpdateWithoutScheduled_paymentsInput>
    create: XOR<ClientContractCreateWithoutScheduled_paymentsInput, ClientContractUncheckedCreateWithoutScheduled_paymentsInput>
    where?: ClientContractWhereInput
  }

  export type ClientContractUpdateToOneWithWhereWithoutScheduled_paymentsInput = {
    where?: ClientContractWhereInput
    data: XOR<ClientContractUpdateWithoutScheduled_paymentsInput, ClientContractUncheckedUpdateWithoutScheduled_paymentsInput>
  }

  export type ClientContractUpdateWithoutScheduled_paymentsInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object?: ObjectUpdateOneRequiredWithoutClient_contractsNestedInput
    product?: ProductUpdateOneRequiredWithoutClient_contractNestedInput
    real_estate_agent?: RealEstateAgentUpdateOneWithoutClient_contractsNestedInput
    manager?: UserUpdateOneWithoutClient_contractsNestedInput
    bank?: BankUpdateOneWithoutClient_contractsNestedInput
    ddu_client_contract_properties?: DDUClientContractPropertiesUpdateOneWithoutClient_contractNestedInput
    clients?: ClientContractToClientUpdateManyWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutScheduled_paymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    real_estate_agent_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    bank_id?: NullableIntFieldUpdateOperationsInput | number | null
    ddu_client_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    clients?: ClientContractToClientUncheckedUpdateManyWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientContractCreateWithoutActual_paymentInput = {
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object: ObjectCreateNestedOneWithoutClient_contractsInput
    product: ProductCreateNestedOneWithoutClient_contractInput
    real_estate_agent?: RealEstateAgentCreateNestedOneWithoutClient_contractsInput
    manager?: UserCreateNestedOneWithoutClient_contractsInput
    bank?: BankCreateNestedOneWithoutClient_contractsInput
    ddu_client_contract_properties?: DDUClientContractPropertiesCreateNestedOneWithoutClient_contractInput
    clients?: ClientContractToClientCreateNestedManyWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractUncheckedCreateWithoutActual_paymentInput = {
    id?: number
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object_id: number
    product_id: number
    real_estate_agent_id?: number | null
    manager_id?: number | null
    bank_id?: number | null
    ddu_client_contract_properties_id?: number | null
    clients?: ClientContractToClientUncheckedCreateNestedManyWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractCreateOrConnectWithoutActual_paymentInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutActual_paymentInput, ClientContractUncheckedCreateWithoutActual_paymentInput>
  }

  export type ClientContractUpsertWithoutActual_paymentInput = {
    update: XOR<ClientContractUpdateWithoutActual_paymentInput, ClientContractUncheckedUpdateWithoutActual_paymentInput>
    create: XOR<ClientContractCreateWithoutActual_paymentInput, ClientContractUncheckedCreateWithoutActual_paymentInput>
    where?: ClientContractWhereInput
  }

  export type ClientContractUpdateToOneWithWhereWithoutActual_paymentInput = {
    where?: ClientContractWhereInput
    data: XOR<ClientContractUpdateWithoutActual_paymentInput, ClientContractUncheckedUpdateWithoutActual_paymentInput>
  }

  export type ClientContractUpdateWithoutActual_paymentInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object?: ObjectUpdateOneRequiredWithoutClient_contractsNestedInput
    product?: ProductUpdateOneRequiredWithoutClient_contractNestedInput
    real_estate_agent?: RealEstateAgentUpdateOneWithoutClient_contractsNestedInput
    manager?: UserUpdateOneWithoutClient_contractsNestedInput
    bank?: BankUpdateOneWithoutClient_contractsNestedInput
    ddu_client_contract_properties?: DDUClientContractPropertiesUpdateOneWithoutClient_contractNestedInput
    clients?: ClientContractToClientUpdateManyWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutActual_paymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    real_estate_agent_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    bank_id?: NullableIntFieldUpdateOperationsInput | number | null
    ddu_client_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    clients?: ClientContractToClientUncheckedUpdateManyWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
  }

  export type EntityCreateWithoutObjectsInput = {
    common_db_entities_id: number
    name: string
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agency_contracts?: AgencyContractCreateNestedManyWithoutEntityInput
    entity_forbidden_websites?: EntityForbiddenWebsiteCreateNestedManyWithoutEntityInput
    entity_forbidden_brands?: EntityForbiddenBrandCreateNestedManyWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutObjectsInput = {
    id?: number
    common_db_entities_id: number
    name: string
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agency_contracts?: AgencyContractUncheckedCreateNestedManyWithoutEntityInput
    entity_forbidden_websites?: EntityForbiddenWebsiteUncheckedCreateNestedManyWithoutEntityInput
    entity_forbidden_brands?: EntityForbiddenBrandUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutObjectsInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutObjectsInput, EntityUncheckedCreateWithoutObjectsInput>
  }

  export type ProductCreateWithoutObjectInput = {
    pricing_products_id: number
    number: string
    product_category: $Enums.ProductCategory
    created_at?: Date | string
    updated_at?: Date | string
    client_contract?: ClientContractCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutObjectInput = {
    id?: number
    pricing_products_id: number
    number: string
    product_category: $Enums.ProductCategory
    created_at?: Date | string
    updated_at?: Date | string
    client_contract?: ClientContractUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutObjectInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutObjectInput, ProductUncheckedCreateWithoutObjectInput>
  }

  export type ProductCreateManyObjectInputEnvelope = {
    data: ProductCreateManyObjectInput | ProductCreateManyObjectInput[]
    skipDuplicates?: boolean
  }

  export type ClientContractCreateWithoutObjectInput = {
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    product: ProductCreateNestedOneWithoutClient_contractInput
    real_estate_agent?: RealEstateAgentCreateNestedOneWithoutClient_contractsInput
    manager?: UserCreateNestedOneWithoutClient_contractsInput
    bank?: BankCreateNestedOneWithoutClient_contractsInput
    ddu_client_contract_properties?: DDUClientContractPropertiesCreateNestedOneWithoutClient_contractInput
    clients?: ClientContractToClientCreateNestedManyWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractUncheckedCreateWithoutObjectInput = {
    id?: number
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    product_id: number
    real_estate_agent_id?: number | null
    manager_id?: number | null
    bank_id?: number | null
    ddu_client_contract_properties_id?: number | null
    clients?: ClientContractToClientUncheckedCreateNestedManyWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentUncheckedCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractCreateOrConnectWithoutObjectInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutObjectInput, ClientContractUncheckedCreateWithoutObjectInput>
  }

  export type ClientContractCreateManyObjectInputEnvelope = {
    data: ClientContractCreateManyObjectInput | ClientContractCreateManyObjectInput[]
    skipDuplicates?: boolean
  }

  export type AgencyContractCreateWithoutObjectInput = {
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user?: UserCreateNestedOneWithoutAgency_contractsInput
    entity: EntityCreateNestedOneWithoutAgency_contractsInput
    agency: AgencyCreateNestedOneWithoutAgency_contractsInput
    agency_contract_signatory?: AgencyContractSignatoryCreateNestedOneWithoutAgency_contractInput
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgency_contractInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesCreateNestedOneWithoutAgency_contractInput
    client_contracts?: ClientContractToAgencyContractCreateNestedManyWithoutAgency_contractInput
  }

  export type AgencyContractUncheckedCreateWithoutObjectInput = {
    id?: number
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user_id?: number | null
    entity_id: number
    agency_id: number
    agency_contract_signatory_id?: number | null
    real_estate_agency_contract_properties_id?: number | null
    mip_agency_contract_properties_id?: number | null
    client_contracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgency_contractInput
  }

  export type AgencyContractCreateOrConnectWithoutObjectInput = {
    where: AgencyContractWhereUniqueInput
    create: XOR<AgencyContractCreateWithoutObjectInput, AgencyContractUncheckedCreateWithoutObjectInput>
  }

  export type AgencyContractCreateManyObjectInputEnvelope = {
    data: AgencyContractCreateManyObjectInput | AgencyContractCreateManyObjectInput[]
    skipDuplicates?: boolean
  }

  export type EntityUpsertWithoutObjectsInput = {
    update: XOR<EntityUpdateWithoutObjectsInput, EntityUncheckedUpdateWithoutObjectsInput>
    create: XOR<EntityCreateWithoutObjectsInput, EntityUncheckedCreateWithoutObjectsInput>
    where?: EntityWhereInput
  }

  export type EntityUpdateToOneWithWhereWithoutObjectsInput = {
    where?: EntityWhereInput
    data: XOR<EntityUpdateWithoutObjectsInput, EntityUncheckedUpdateWithoutObjectsInput>
  }

  export type EntityUpdateWithoutObjectsInput = {
    common_db_entities_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contracts?: AgencyContractUpdateManyWithoutEntityNestedInput
    entity_forbidden_websites?: EntityForbiddenWebsiteUpdateManyWithoutEntityNestedInput
    entity_forbidden_brands?: EntityForbiddenBrandUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutObjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    common_db_entities_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contracts?: AgencyContractUncheckedUpdateManyWithoutEntityNestedInput
    entity_forbidden_websites?: EntityForbiddenWebsiteUncheckedUpdateManyWithoutEntityNestedInput
    entity_forbidden_brands?: EntityForbiddenBrandUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutObjectInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutObjectInput, ProductUncheckedUpdateWithoutObjectInput>
    create: XOR<ProductCreateWithoutObjectInput, ProductUncheckedCreateWithoutObjectInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutObjectInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutObjectInput, ProductUncheckedUpdateWithoutObjectInput>
  }

  export type ProductUpdateManyWithWhereWithoutObjectInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutObjectInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    pricing_products_id?: IntFilter<"Product"> | number
    number?: StringFilter<"Product"> | string
    product_category?: EnumProductCategoryFilter<"Product"> | $Enums.ProductCategory
    created_at?: DateTimeFilter<"Product"> | Date | string
    updated_at?: DateTimeFilter<"Product"> | Date | string
    object_id?: IntFilter<"Product"> | number
  }

  export type ClientContractUpsertWithWhereUniqueWithoutObjectInput = {
    where: ClientContractWhereUniqueInput
    update: XOR<ClientContractUpdateWithoutObjectInput, ClientContractUncheckedUpdateWithoutObjectInput>
    create: XOR<ClientContractCreateWithoutObjectInput, ClientContractUncheckedCreateWithoutObjectInput>
  }

  export type ClientContractUpdateWithWhereUniqueWithoutObjectInput = {
    where: ClientContractWhereUniqueInput
    data: XOR<ClientContractUpdateWithoutObjectInput, ClientContractUncheckedUpdateWithoutObjectInput>
  }

  export type ClientContractUpdateManyWithWhereWithoutObjectInput = {
    where: ClientContractScalarWhereInput
    data: XOR<ClientContractUpdateManyMutationInput, ClientContractUncheckedUpdateManyWithoutObjectInput>
  }

  export type AgencyContractUpsertWithWhereUniqueWithoutObjectInput = {
    where: AgencyContractWhereUniqueInput
    update: XOR<AgencyContractUpdateWithoutObjectInput, AgencyContractUncheckedUpdateWithoutObjectInput>
    create: XOR<AgencyContractCreateWithoutObjectInput, AgencyContractUncheckedCreateWithoutObjectInput>
  }

  export type AgencyContractUpdateWithWhereUniqueWithoutObjectInput = {
    where: AgencyContractWhereUniqueInput
    data: XOR<AgencyContractUpdateWithoutObjectInput, AgencyContractUncheckedUpdateWithoutObjectInput>
  }

  export type AgencyContractUpdateManyWithWhereWithoutObjectInput = {
    where: AgencyContractScalarWhereInput
    data: XOR<AgencyContractUpdateManyMutationInput, AgencyContractUncheckedUpdateManyWithoutObjectInput>
  }

  export type ClientContractCreateWithoutProductInput = {
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object: ObjectCreateNestedOneWithoutClient_contractsInput
    real_estate_agent?: RealEstateAgentCreateNestedOneWithoutClient_contractsInput
    manager?: UserCreateNestedOneWithoutClient_contractsInput
    bank?: BankCreateNestedOneWithoutClient_contractsInput
    ddu_client_contract_properties?: DDUClientContractPropertiesCreateNestedOneWithoutClient_contractInput
    clients?: ClientContractToClientCreateNestedManyWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractUncheckedCreateWithoutProductInput = {
    id?: number
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object_id: number
    real_estate_agent_id?: number | null
    manager_id?: number | null
    bank_id?: number | null
    ddu_client_contract_properties_id?: number | null
    clients?: ClientContractToClientUncheckedCreateNestedManyWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentUncheckedCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractCreateOrConnectWithoutProductInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutProductInput, ClientContractUncheckedCreateWithoutProductInput>
  }

  export type ObjectCreateWithoutProductsInput = {
    common_db_objects_id: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entity: EntityCreateNestedOneWithoutObjectsInput
    client_contracts?: ClientContractCreateNestedManyWithoutObjectInput
    agency_contracts?: AgencyContractCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutProductsInput = {
    id?: number
    common_db_objects_id: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entity_id: number
    client_contracts?: ClientContractUncheckedCreateNestedManyWithoutObjectInput
    agency_contracts?: AgencyContractUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutProductsInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutProductsInput, ObjectUncheckedCreateWithoutProductsInput>
  }

  export type ClientContractUpsertWithoutProductInput = {
    update: XOR<ClientContractUpdateWithoutProductInput, ClientContractUncheckedUpdateWithoutProductInput>
    create: XOR<ClientContractCreateWithoutProductInput, ClientContractUncheckedCreateWithoutProductInput>
    where?: ClientContractWhereInput
  }

  export type ClientContractUpdateToOneWithWhereWithoutProductInput = {
    where?: ClientContractWhereInput
    data: XOR<ClientContractUpdateWithoutProductInput, ClientContractUncheckedUpdateWithoutProductInput>
  }

  export type ClientContractUpdateWithoutProductInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object?: ObjectUpdateOneRequiredWithoutClient_contractsNestedInput
    real_estate_agent?: RealEstateAgentUpdateOneWithoutClient_contractsNestedInput
    manager?: UserUpdateOneWithoutClient_contractsNestedInput
    bank?: BankUpdateOneWithoutClient_contractsNestedInput
    ddu_client_contract_properties?: DDUClientContractPropertiesUpdateOneWithoutClient_contractNestedInput
    clients?: ClientContractToClientUpdateManyWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: IntFieldUpdateOperationsInput | number
    real_estate_agent_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    bank_id?: NullableIntFieldUpdateOperationsInput | number | null
    ddu_client_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    clients?: ClientContractToClientUncheckedUpdateManyWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
  }

  export type ObjectUpsertWithoutProductsInput = {
    update: XOR<ObjectUpdateWithoutProductsInput, ObjectUncheckedUpdateWithoutProductsInput>
    create: XOR<ObjectCreateWithoutProductsInput, ObjectUncheckedCreateWithoutProductsInput>
    where?: ObjectWhereInput
  }

  export type ObjectUpdateToOneWithWhereWithoutProductsInput = {
    where?: ObjectWhereInput
    data: XOR<ObjectUpdateWithoutProductsInput, ObjectUncheckedUpdateWithoutProductsInput>
  }

  export type ObjectUpdateWithoutProductsInput = {
    common_db_objects_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: EntityUpdateOneRequiredWithoutObjectsNestedInput
    client_contracts?: ClientContractUpdateManyWithoutObjectNestedInput
    agency_contracts?: AgencyContractUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    common_db_objects_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entity_id?: IntFieldUpdateOperationsInput | number
    client_contracts?: ClientContractUncheckedUpdateManyWithoutObjectNestedInput
    agency_contracts?: AgencyContractUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type AgencyContractCreateWithoutAgencyInput = {
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user?: UserCreateNestedOneWithoutAgency_contractsInput
    entity: EntityCreateNestedOneWithoutAgency_contractsInput
    object: ObjectCreateNestedOneWithoutAgency_contractsInput
    agency_contract_signatory?: AgencyContractSignatoryCreateNestedOneWithoutAgency_contractInput
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgency_contractInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesCreateNestedOneWithoutAgency_contractInput
    client_contracts?: ClientContractToAgencyContractCreateNestedManyWithoutAgency_contractInput
  }

  export type AgencyContractUncheckedCreateWithoutAgencyInput = {
    id?: number
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user_id?: number | null
    entity_id: number
    object_id: number
    agency_contract_signatory_id?: number | null
    real_estate_agency_contract_properties_id?: number | null
    mip_agency_contract_properties_id?: number | null
    client_contracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgency_contractInput
  }

  export type AgencyContractCreateOrConnectWithoutAgencyInput = {
    where: AgencyContractWhereUniqueInput
    create: XOR<AgencyContractCreateWithoutAgencyInput, AgencyContractUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyContractCreateManyAgencyInputEnvelope = {
    data: AgencyContractCreateManyAgencyInput | AgencyContractCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type AgencyToRealEstateAgentCreateWithoutAgencyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    real_estate_agent: RealEstateAgentCreateNestedOneWithoutAgenciesInput
  }

  export type AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    real_estate_agent_id: number
  }

  export type AgencyToRealEstateAgentCreateOrConnectWithoutAgencyInput = {
    where: AgencyToRealEstateAgentWhereUniqueInput
    create: XOR<AgencyToRealEstateAgentCreateWithoutAgencyInput, AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyToRealEstateAgentCreateManyAgencyInputEnvelope = {
    data: AgencyToRealEstateAgentCreateManyAgencyInput | AgencyToRealEstateAgentCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type AgencyContractSignatoryCreateWithoutAgencyInput = {
    full_name: string
    email: string
    phone: string
    title: string
    based_on: string
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract?: AgencyContractCreateNestedManyWithoutAgency_contract_signatoryInput
  }

  export type AgencyContractSignatoryUncheckedCreateWithoutAgencyInput = {
    id?: number
    full_name: string
    email: string
    phone: string
    title: string
    based_on: string
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract?: AgencyContractUncheckedCreateNestedManyWithoutAgency_contract_signatoryInput
  }

  export type AgencyContractSignatoryCreateOrConnectWithoutAgencyInput = {
    where: AgencyContractSignatoryWhereUniqueInput
    create: XOR<AgencyContractSignatoryCreateWithoutAgencyInput, AgencyContractSignatoryUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyContractSignatoryCreateManyAgencyInputEnvelope = {
    data: AgencyContractSignatoryCreateManyAgencyInput | AgencyContractSignatoryCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type AgencyContractUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AgencyContractWhereUniqueInput
    update: XOR<AgencyContractUpdateWithoutAgencyInput, AgencyContractUncheckedUpdateWithoutAgencyInput>
    create: XOR<AgencyContractCreateWithoutAgencyInput, AgencyContractUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyContractUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AgencyContractWhereUniqueInput
    data: XOR<AgencyContractUpdateWithoutAgencyInput, AgencyContractUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencyContractUpdateManyWithWhereWithoutAgencyInput = {
    where: AgencyContractScalarWhereInput
    data: XOR<AgencyContractUpdateManyMutationInput, AgencyContractUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AgencyToRealEstateAgentWhereUniqueInput
    update: XOR<AgencyToRealEstateAgentUpdateWithoutAgencyInput, AgencyToRealEstateAgentUncheckedUpdateWithoutAgencyInput>
    create: XOR<AgencyToRealEstateAgentCreateWithoutAgencyInput, AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AgencyToRealEstateAgentWhereUniqueInput
    data: XOR<AgencyToRealEstateAgentUpdateWithoutAgencyInput, AgencyToRealEstateAgentUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencyToRealEstateAgentUpdateManyWithWhereWithoutAgencyInput = {
    where: AgencyToRealEstateAgentScalarWhereInput
    data: XOR<AgencyToRealEstateAgentUpdateManyMutationInput, AgencyToRealEstateAgentUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AgencyToRealEstateAgentScalarWhereInput = {
    AND?: AgencyToRealEstateAgentScalarWhereInput | AgencyToRealEstateAgentScalarWhereInput[]
    OR?: AgencyToRealEstateAgentScalarWhereInput[]
    NOT?: AgencyToRealEstateAgentScalarWhereInput | AgencyToRealEstateAgentScalarWhereInput[]
    created_at?: DateTimeFilter<"AgencyToRealEstateAgent"> | Date | string
    updated_at?: DateTimeFilter<"AgencyToRealEstateAgent"> | Date | string
    agency_id?: IntFilter<"AgencyToRealEstateAgent"> | number
    real_estate_agent_id?: IntFilter<"AgencyToRealEstateAgent"> | number
  }

  export type AgencyContractSignatoryUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AgencyContractSignatoryWhereUniqueInput
    update: XOR<AgencyContractSignatoryUpdateWithoutAgencyInput, AgencyContractSignatoryUncheckedUpdateWithoutAgencyInput>
    create: XOR<AgencyContractSignatoryCreateWithoutAgencyInput, AgencyContractSignatoryUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyContractSignatoryUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AgencyContractSignatoryWhereUniqueInput
    data: XOR<AgencyContractSignatoryUpdateWithoutAgencyInput, AgencyContractSignatoryUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencyContractSignatoryUpdateManyWithWhereWithoutAgencyInput = {
    where: AgencyContractSignatoryScalarWhereInput
    data: XOR<AgencyContractSignatoryUpdateManyMutationInput, AgencyContractSignatoryUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AgencyContractSignatoryScalarWhereInput = {
    AND?: AgencyContractSignatoryScalarWhereInput | AgencyContractSignatoryScalarWhereInput[]
    OR?: AgencyContractSignatoryScalarWhereInput[]
    NOT?: AgencyContractSignatoryScalarWhereInput | AgencyContractSignatoryScalarWhereInput[]
    id?: IntFilter<"AgencyContractSignatory"> | number
    full_name?: StringFilter<"AgencyContractSignatory"> | string
    email?: StringFilter<"AgencyContractSignatory"> | string
    phone?: StringFilter<"AgencyContractSignatory"> | string
    title?: StringFilter<"AgencyContractSignatory"> | string
    based_on?: StringFilter<"AgencyContractSignatory"> | string
    created_at?: DateTimeFilter<"AgencyContractSignatory"> | Date | string
    updated_at?: DateTimeFilter<"AgencyContractSignatory"> | Date | string
    agency_id?: IntFilter<"AgencyContractSignatory"> | number
  }

  export type UserCreateWithoutAgency_contractsInput = {
    full_name: string
    email: string
    phone?: string | null
    is_manager: boolean
    user_role: $Enums.UserRole
    created_at?: Date | string
    updated_at?: Date | string
    client_contracts?: ClientContractCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutAgency_contractsInput = {
    id?: number
    full_name: string
    email: string
    phone?: string | null
    is_manager: boolean
    user_role: $Enums.UserRole
    created_at?: Date | string
    updated_at?: Date | string
    client_contracts?: ClientContractUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutAgency_contractsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgency_contractsInput, UserUncheckedCreateWithoutAgency_contractsInput>
  }

  export type EntityCreateWithoutAgency_contractsInput = {
    common_db_entities_id: number
    name: string
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    objects?: ObjectCreateNestedManyWithoutEntityInput
    entity_forbidden_websites?: EntityForbiddenWebsiteCreateNestedManyWithoutEntityInput
    entity_forbidden_brands?: EntityForbiddenBrandCreateNestedManyWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutAgency_contractsInput = {
    id?: number
    common_db_entities_id: number
    name: string
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    objects?: ObjectUncheckedCreateNestedManyWithoutEntityInput
    entity_forbidden_websites?: EntityForbiddenWebsiteUncheckedCreateNestedManyWithoutEntityInput
    entity_forbidden_brands?: EntityForbiddenBrandUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutAgency_contractsInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutAgency_contractsInput, EntityUncheckedCreateWithoutAgency_contractsInput>
  }

  export type ObjectCreateWithoutAgency_contractsInput = {
    common_db_objects_id: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entity: EntityCreateNestedOneWithoutObjectsInput
    products?: ProductCreateNestedManyWithoutObjectInput
    client_contracts?: ClientContractCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutAgency_contractsInput = {
    id?: number
    common_db_objects_id: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entity_id: number
    products?: ProductUncheckedCreateNestedManyWithoutObjectInput
    client_contracts?: ClientContractUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutAgency_contractsInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutAgency_contractsInput, ObjectUncheckedCreateWithoutAgency_contractsInput>
  }

  export type AgencyCreateWithoutAgency_contractsInput = {
    common_db_contractors_id: number
    name: string
    inn?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    real_estate_agents?: AgencyToRealEstateAgentCreateNestedManyWithoutAgencyInput
    agency_contract_signatory?: AgencyContractSignatoryCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutAgency_contractsInput = {
    id?: number
    common_db_contractors_id: number
    name: string
    inn?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    real_estate_agents?: AgencyToRealEstateAgentUncheckedCreateNestedManyWithoutAgencyInput
    agency_contract_signatory?: AgencyContractSignatoryUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutAgency_contractsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutAgency_contractsInput, AgencyUncheckedCreateWithoutAgency_contractsInput>
  }

  export type AgencyContractSignatoryCreateWithoutAgency_contractInput = {
    full_name: string
    email: string
    phone: string
    title: string
    based_on: string
    created_at?: Date | string
    updated_at?: Date | string
    agency: AgencyCreateNestedOneWithoutAgency_contract_signatoryInput
  }

  export type AgencyContractSignatoryUncheckedCreateWithoutAgency_contractInput = {
    id?: number
    full_name: string
    email: string
    phone: string
    title: string
    based_on: string
    created_at?: Date | string
    updated_at?: Date | string
    agency_id: number
  }

  export type AgencyContractSignatoryCreateOrConnectWithoutAgency_contractInput = {
    where: AgencyContractSignatoryWhereUniqueInput
    create: XOR<AgencyContractSignatoryCreateWithoutAgency_contractInput, AgencyContractSignatoryUncheckedCreateWithoutAgency_contractInput>
  }

  export type RealEstateAgencyContractPropertiesCreateWithoutAgency_contractInput = {
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract_commission: AgencyContractCommissionCreateNestedOneWithoutReal_estate_agency_contract_propertiesInput
  }

  export type RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgency_contractInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract_commission_id: number
  }

  export type RealEstateAgencyContractPropertiesCreateOrConnectWithoutAgency_contractInput = {
    where: RealEstateAgencyContractPropertiesWhereUniqueInput
    create: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgency_contractInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgency_contractInput>
  }

  export type MIPAgencyContractPropertiesCreateWithoutAgency_contractInput = {
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract_commission: AgencyContractCommissionCreateNestedOneWithoutMip_agency_contract_propertiesInput
  }

  export type MIPAgencyContractPropertiesUncheckedCreateWithoutAgency_contractInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract_commission_id: number
  }

  export type MIPAgencyContractPropertiesCreateOrConnectWithoutAgency_contractInput = {
    where: MIPAgencyContractPropertiesWhereUniqueInput
    create: XOR<MIPAgencyContractPropertiesCreateWithoutAgency_contractInput, MIPAgencyContractPropertiesUncheckedCreateWithoutAgency_contractInput>
  }

  export type ClientContractToAgencyContractCreateWithoutAgency_contractInput = {
    created_at?: Date | string
    updated_at?: Date | string
    client_contract: ClientContractCreateNestedOneWithoutAgency_contractsInput
  }

  export type ClientContractToAgencyContractUncheckedCreateWithoutAgency_contractInput = {
    created_at?: Date | string
    updated_at?: Date | string
    client_contract_id: number
  }

  export type ClientContractToAgencyContractCreateOrConnectWithoutAgency_contractInput = {
    where: ClientContractToAgencyContractWhereUniqueInput
    create: XOR<ClientContractToAgencyContractCreateWithoutAgency_contractInput, ClientContractToAgencyContractUncheckedCreateWithoutAgency_contractInput>
  }

  export type ClientContractToAgencyContractCreateManyAgency_contractInputEnvelope = {
    data: ClientContractToAgencyContractCreateManyAgency_contractInput | ClientContractToAgencyContractCreateManyAgency_contractInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAgency_contractsInput = {
    update: XOR<UserUpdateWithoutAgency_contractsInput, UserUncheckedUpdateWithoutAgency_contractsInput>
    create: XOR<UserCreateWithoutAgency_contractsInput, UserUncheckedCreateWithoutAgency_contractsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgency_contractsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgency_contractsInput, UserUncheckedUpdateWithoutAgency_contractsInput>
  }

  export type UserUpdateWithoutAgency_contractsInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_manager?: BoolFieldUpdateOperationsInput | boolean
    user_role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contracts?: ClientContractUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutAgency_contractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_manager?: BoolFieldUpdateOperationsInput | boolean
    user_role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contracts?: ClientContractUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type EntityUpsertWithoutAgency_contractsInput = {
    update: XOR<EntityUpdateWithoutAgency_contractsInput, EntityUncheckedUpdateWithoutAgency_contractsInput>
    create: XOR<EntityCreateWithoutAgency_contractsInput, EntityUncheckedCreateWithoutAgency_contractsInput>
    where?: EntityWhereInput
  }

  export type EntityUpdateToOneWithWhereWithoutAgency_contractsInput = {
    where?: EntityWhereInput
    data: XOR<EntityUpdateWithoutAgency_contractsInput, EntityUncheckedUpdateWithoutAgency_contractsInput>
  }

  export type EntityUpdateWithoutAgency_contractsInput = {
    common_db_entities_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    objects?: ObjectUpdateManyWithoutEntityNestedInput
    entity_forbidden_websites?: EntityForbiddenWebsiteUpdateManyWithoutEntityNestedInput
    entity_forbidden_brands?: EntityForbiddenBrandUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutAgency_contractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    common_db_entities_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    objects?: ObjectUncheckedUpdateManyWithoutEntityNestedInput
    entity_forbidden_websites?: EntityForbiddenWebsiteUncheckedUpdateManyWithoutEntityNestedInput
    entity_forbidden_brands?: EntityForbiddenBrandUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type ObjectUpsertWithoutAgency_contractsInput = {
    update: XOR<ObjectUpdateWithoutAgency_contractsInput, ObjectUncheckedUpdateWithoutAgency_contractsInput>
    create: XOR<ObjectCreateWithoutAgency_contractsInput, ObjectUncheckedCreateWithoutAgency_contractsInput>
    where?: ObjectWhereInput
  }

  export type ObjectUpdateToOneWithWhereWithoutAgency_contractsInput = {
    where?: ObjectWhereInput
    data: XOR<ObjectUpdateWithoutAgency_contractsInput, ObjectUncheckedUpdateWithoutAgency_contractsInput>
  }

  export type ObjectUpdateWithoutAgency_contractsInput = {
    common_db_objects_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: EntityUpdateOneRequiredWithoutObjectsNestedInput
    products?: ProductUpdateManyWithoutObjectNestedInput
    client_contracts?: ClientContractUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutAgency_contractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    common_db_objects_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entity_id?: IntFieldUpdateOperationsInput | number
    products?: ProductUncheckedUpdateManyWithoutObjectNestedInput
    client_contracts?: ClientContractUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type AgencyUpsertWithoutAgency_contractsInput = {
    update: XOR<AgencyUpdateWithoutAgency_contractsInput, AgencyUncheckedUpdateWithoutAgency_contractsInput>
    create: XOR<AgencyCreateWithoutAgency_contractsInput, AgencyUncheckedCreateWithoutAgency_contractsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutAgency_contractsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutAgency_contractsInput, AgencyUncheckedUpdateWithoutAgency_contractsInput>
  }

  export type AgencyUpdateWithoutAgency_contractsInput = {
    common_db_contractors_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    real_estate_agents?: AgencyToRealEstateAgentUpdateManyWithoutAgencyNestedInput
    agency_contract_signatory?: AgencyContractSignatoryUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutAgency_contractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    common_db_contractors_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    real_estate_agents?: AgencyToRealEstateAgentUncheckedUpdateManyWithoutAgencyNestedInput
    agency_contract_signatory?: AgencyContractSignatoryUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyContractSignatoryUpsertWithoutAgency_contractInput = {
    update: XOR<AgencyContractSignatoryUpdateWithoutAgency_contractInput, AgencyContractSignatoryUncheckedUpdateWithoutAgency_contractInput>
    create: XOR<AgencyContractSignatoryCreateWithoutAgency_contractInput, AgencyContractSignatoryUncheckedCreateWithoutAgency_contractInput>
    where?: AgencyContractSignatoryWhereInput
  }

  export type AgencyContractSignatoryUpdateToOneWithWhereWithoutAgency_contractInput = {
    where?: AgencyContractSignatoryWhereInput
    data: XOR<AgencyContractSignatoryUpdateWithoutAgency_contractInput, AgencyContractSignatoryUncheckedUpdateWithoutAgency_contractInput>
  }

  export type AgencyContractSignatoryUpdateWithoutAgency_contractInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    based_on?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutAgency_contract_signatoryNestedInput
  }

  export type AgencyContractSignatoryUncheckedUpdateWithoutAgency_contractInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    based_on?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_id?: IntFieldUpdateOperationsInput | number
  }

  export type RealEstateAgencyContractPropertiesUpsertWithoutAgency_contractInput = {
    update: XOR<RealEstateAgencyContractPropertiesUpdateWithoutAgency_contractInput, RealEstateAgencyContractPropertiesUncheckedUpdateWithoutAgency_contractInput>
    create: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgency_contractInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgency_contractInput>
    where?: RealEstateAgencyContractPropertiesWhereInput
  }

  export type RealEstateAgencyContractPropertiesUpdateToOneWithWhereWithoutAgency_contractInput = {
    where?: RealEstateAgencyContractPropertiesWhereInput
    data: XOR<RealEstateAgencyContractPropertiesUpdateWithoutAgency_contractInput, RealEstateAgencyContractPropertiesUncheckedUpdateWithoutAgency_contractInput>
  }

  export type RealEstateAgencyContractPropertiesUpdateWithoutAgency_contractInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_commission?: AgencyContractCommissionUpdateOneRequiredWithoutReal_estate_agency_contract_propertiesNestedInput
  }

  export type RealEstateAgencyContractPropertiesUncheckedUpdateWithoutAgency_contractInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_commission_id?: IntFieldUpdateOperationsInput | number
  }

  export type MIPAgencyContractPropertiesUpsertWithoutAgency_contractInput = {
    update: XOR<MIPAgencyContractPropertiesUpdateWithoutAgency_contractInput, MIPAgencyContractPropertiesUncheckedUpdateWithoutAgency_contractInput>
    create: XOR<MIPAgencyContractPropertiesCreateWithoutAgency_contractInput, MIPAgencyContractPropertiesUncheckedCreateWithoutAgency_contractInput>
    where?: MIPAgencyContractPropertiesWhereInput
  }

  export type MIPAgencyContractPropertiesUpdateToOneWithWhereWithoutAgency_contractInput = {
    where?: MIPAgencyContractPropertiesWhereInput
    data: XOR<MIPAgencyContractPropertiesUpdateWithoutAgency_contractInput, MIPAgencyContractPropertiesUncheckedUpdateWithoutAgency_contractInput>
  }

  export type MIPAgencyContractPropertiesUpdateWithoutAgency_contractInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_commission?: AgencyContractCommissionUpdateOneRequiredWithoutMip_agency_contract_propertiesNestedInput
  }

  export type MIPAgencyContractPropertiesUncheckedUpdateWithoutAgency_contractInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_commission_id?: IntFieldUpdateOperationsInput | number
  }

  export type ClientContractToAgencyContractUpsertWithWhereUniqueWithoutAgency_contractInput = {
    where: ClientContractToAgencyContractWhereUniqueInput
    update: XOR<ClientContractToAgencyContractUpdateWithoutAgency_contractInput, ClientContractToAgencyContractUncheckedUpdateWithoutAgency_contractInput>
    create: XOR<ClientContractToAgencyContractCreateWithoutAgency_contractInput, ClientContractToAgencyContractUncheckedCreateWithoutAgency_contractInput>
  }

  export type ClientContractToAgencyContractUpdateWithWhereUniqueWithoutAgency_contractInput = {
    where: ClientContractToAgencyContractWhereUniqueInput
    data: XOR<ClientContractToAgencyContractUpdateWithoutAgency_contractInput, ClientContractToAgencyContractUncheckedUpdateWithoutAgency_contractInput>
  }

  export type ClientContractToAgencyContractUpdateManyWithWhereWithoutAgency_contractInput = {
    where: ClientContractToAgencyContractScalarWhereInput
    data: XOR<ClientContractToAgencyContractUpdateManyMutationInput, ClientContractToAgencyContractUncheckedUpdateManyWithoutAgency_contractInput>
  }

  export type AgencyCreateWithoutAgency_contract_signatoryInput = {
    common_db_contractors_id: number
    name: string
    inn?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agency_contracts?: AgencyContractCreateNestedManyWithoutAgencyInput
    real_estate_agents?: AgencyToRealEstateAgentCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutAgency_contract_signatoryInput = {
    id?: number
    common_db_contractors_id: number
    name: string
    inn?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agency_contracts?: AgencyContractUncheckedCreateNestedManyWithoutAgencyInput
    real_estate_agents?: AgencyToRealEstateAgentUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutAgency_contract_signatoryInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutAgency_contract_signatoryInput, AgencyUncheckedCreateWithoutAgency_contract_signatoryInput>
  }

  export type AgencyContractCreateWithoutAgency_contract_signatoryInput = {
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user?: UserCreateNestedOneWithoutAgency_contractsInput
    entity: EntityCreateNestedOneWithoutAgency_contractsInput
    object: ObjectCreateNestedOneWithoutAgency_contractsInput
    agency: AgencyCreateNestedOneWithoutAgency_contractsInput
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgency_contractInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesCreateNestedOneWithoutAgency_contractInput
    client_contracts?: ClientContractToAgencyContractCreateNestedManyWithoutAgency_contractInput
  }

  export type AgencyContractUncheckedCreateWithoutAgency_contract_signatoryInput = {
    id?: number
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user_id?: number | null
    entity_id: number
    object_id: number
    agency_id: number
    real_estate_agency_contract_properties_id?: number | null
    mip_agency_contract_properties_id?: number | null
    client_contracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgency_contractInput
  }

  export type AgencyContractCreateOrConnectWithoutAgency_contract_signatoryInput = {
    where: AgencyContractWhereUniqueInput
    create: XOR<AgencyContractCreateWithoutAgency_contract_signatoryInput, AgencyContractUncheckedCreateWithoutAgency_contract_signatoryInput>
  }

  export type AgencyContractCreateManyAgency_contract_signatoryInputEnvelope = {
    data: AgencyContractCreateManyAgency_contract_signatoryInput | AgencyContractCreateManyAgency_contract_signatoryInput[]
    skipDuplicates?: boolean
  }

  export type AgencyUpsertWithoutAgency_contract_signatoryInput = {
    update: XOR<AgencyUpdateWithoutAgency_contract_signatoryInput, AgencyUncheckedUpdateWithoutAgency_contract_signatoryInput>
    create: XOR<AgencyCreateWithoutAgency_contract_signatoryInput, AgencyUncheckedCreateWithoutAgency_contract_signatoryInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutAgency_contract_signatoryInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutAgency_contract_signatoryInput, AgencyUncheckedUpdateWithoutAgency_contract_signatoryInput>
  }

  export type AgencyUpdateWithoutAgency_contract_signatoryInput = {
    common_db_contractors_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contracts?: AgencyContractUpdateManyWithoutAgencyNestedInput
    real_estate_agents?: AgencyToRealEstateAgentUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutAgency_contract_signatoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    common_db_contractors_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contracts?: AgencyContractUncheckedUpdateManyWithoutAgencyNestedInput
    real_estate_agents?: AgencyToRealEstateAgentUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyContractUpsertWithWhereUniqueWithoutAgency_contract_signatoryInput = {
    where: AgencyContractWhereUniqueInput
    update: XOR<AgencyContractUpdateWithoutAgency_contract_signatoryInput, AgencyContractUncheckedUpdateWithoutAgency_contract_signatoryInput>
    create: XOR<AgencyContractCreateWithoutAgency_contract_signatoryInput, AgencyContractUncheckedCreateWithoutAgency_contract_signatoryInput>
  }

  export type AgencyContractUpdateWithWhereUniqueWithoutAgency_contract_signatoryInput = {
    where: AgencyContractWhereUniqueInput
    data: XOR<AgencyContractUpdateWithoutAgency_contract_signatoryInput, AgencyContractUncheckedUpdateWithoutAgency_contract_signatoryInput>
  }

  export type AgencyContractUpdateManyWithWhereWithoutAgency_contract_signatoryInput = {
    where: AgencyContractScalarWhereInput
    data: XOR<AgencyContractUpdateManyMutationInput, AgencyContractUncheckedUpdateManyWithoutAgency_contract_signatoryInput>
  }

  export type AgencyContractCreateWithoutReal_estate_agency_contract_propertiesInput = {
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user?: UserCreateNestedOneWithoutAgency_contractsInput
    entity: EntityCreateNestedOneWithoutAgency_contractsInput
    object: ObjectCreateNestedOneWithoutAgency_contractsInput
    agency: AgencyCreateNestedOneWithoutAgency_contractsInput
    agency_contract_signatory?: AgencyContractSignatoryCreateNestedOneWithoutAgency_contractInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesCreateNestedOneWithoutAgency_contractInput
    client_contracts?: ClientContractToAgencyContractCreateNestedManyWithoutAgency_contractInput
  }

  export type AgencyContractUncheckedCreateWithoutReal_estate_agency_contract_propertiesInput = {
    id?: number
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user_id?: number | null
    entity_id: number
    object_id: number
    agency_id: number
    agency_contract_signatory_id?: number | null
    mip_agency_contract_properties_id?: number | null
    client_contracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgency_contractInput
  }

  export type AgencyContractCreateOrConnectWithoutReal_estate_agency_contract_propertiesInput = {
    where: AgencyContractWhereUniqueInput
    create: XOR<AgencyContractCreateWithoutReal_estate_agency_contract_propertiesInput, AgencyContractUncheckedCreateWithoutReal_estate_agency_contract_propertiesInput>
  }

  export type AgencyContractCommissionCreateWithoutReal_estate_agency_contract_propertiesInput = {
    percent: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    max_days: number
    created_at?: Date | string
    updated_at?: Date | string
    mip_agency_contract_properties?: MIPAgencyContractPropertiesCreateNestedOneWithoutAgency_contract_commissionInput
  }

  export type AgencyContractCommissionUncheckedCreateWithoutReal_estate_agency_contract_propertiesInput = {
    id?: number
    percent: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    max_days: number
    created_at?: Date | string
    updated_at?: Date | string
    mip_agency_contract_properties?: MIPAgencyContractPropertiesUncheckedCreateNestedOneWithoutAgency_contract_commissionInput
  }

  export type AgencyContractCommissionCreateOrConnectWithoutReal_estate_agency_contract_propertiesInput = {
    where: AgencyContractCommissionWhereUniqueInput
    create: XOR<AgencyContractCommissionCreateWithoutReal_estate_agency_contract_propertiesInput, AgencyContractCommissionUncheckedCreateWithoutReal_estate_agency_contract_propertiesInput>
  }

  export type AgencyContractUpsertWithoutReal_estate_agency_contract_propertiesInput = {
    update: XOR<AgencyContractUpdateWithoutReal_estate_agency_contract_propertiesInput, AgencyContractUncheckedUpdateWithoutReal_estate_agency_contract_propertiesInput>
    create: XOR<AgencyContractCreateWithoutReal_estate_agency_contract_propertiesInput, AgencyContractUncheckedCreateWithoutReal_estate_agency_contract_propertiesInput>
    where?: AgencyContractWhereInput
  }

  export type AgencyContractUpdateToOneWithWhereWithoutReal_estate_agency_contract_propertiesInput = {
    where?: AgencyContractWhereInput
    data: XOR<AgencyContractUpdateWithoutReal_estate_agency_contract_propertiesInput, AgencyContractUncheckedUpdateWithoutReal_estate_agency_contract_propertiesInput>
  }

  export type AgencyContractUpdateWithoutReal_estate_agency_contract_propertiesInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user?: UserUpdateOneWithoutAgency_contractsNestedInput
    entity?: EntityUpdateOneRequiredWithoutAgency_contractsNestedInput
    object?: ObjectUpdateOneRequiredWithoutAgency_contractsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgency_contractsNestedInput
    agency_contract_signatory?: AgencyContractSignatoryUpdateOneWithoutAgency_contractNestedInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesUpdateOneWithoutAgency_contractNestedInput
    client_contracts?: ClientContractToAgencyContractUpdateManyWithoutAgency_contractNestedInput
  }

  export type AgencyContractUncheckedUpdateWithoutReal_estate_agency_contract_propertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_id?: IntFieldUpdateOperationsInput | number
    object_id?: IntFieldUpdateOperationsInput | number
    agency_id?: IntFieldUpdateOperationsInput | number
    agency_contract_signatory_id?: NullableIntFieldUpdateOperationsInput | number | null
    mip_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_contracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutAgency_contractNestedInput
  }

  export type AgencyContractCommissionUpsertWithoutReal_estate_agency_contract_propertiesInput = {
    update: XOR<AgencyContractCommissionUpdateWithoutReal_estate_agency_contract_propertiesInput, AgencyContractCommissionUncheckedUpdateWithoutReal_estate_agency_contract_propertiesInput>
    create: XOR<AgencyContractCommissionCreateWithoutReal_estate_agency_contract_propertiesInput, AgencyContractCommissionUncheckedCreateWithoutReal_estate_agency_contract_propertiesInput>
    where?: AgencyContractCommissionWhereInput
  }

  export type AgencyContractCommissionUpdateToOneWithWhereWithoutReal_estate_agency_contract_propertiesInput = {
    where?: AgencyContractCommissionWhereInput
    data: XOR<AgencyContractCommissionUpdateWithoutReal_estate_agency_contract_propertiesInput, AgencyContractCommissionUncheckedUpdateWithoutReal_estate_agency_contract_propertiesInput>
  }

  export type AgencyContractCommissionUpdateWithoutReal_estate_agency_contract_propertiesInput = {
    percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mip_agency_contract_properties?: MIPAgencyContractPropertiesUpdateOneWithoutAgency_contract_commissionNestedInput
  }

  export type AgencyContractCommissionUncheckedUpdateWithoutReal_estate_agency_contract_propertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mip_agency_contract_properties?: MIPAgencyContractPropertiesUncheckedUpdateOneWithoutAgency_contract_commissionNestedInput
  }

  export type AgencyContractCreateWithoutMip_agency_contract_propertiesInput = {
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user?: UserCreateNestedOneWithoutAgency_contractsInput
    entity: EntityCreateNestedOneWithoutAgency_contractsInput
    object: ObjectCreateNestedOneWithoutAgency_contractsInput
    agency: AgencyCreateNestedOneWithoutAgency_contractsInput
    agency_contract_signatory?: AgencyContractSignatoryCreateNestedOneWithoutAgency_contractInput
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgency_contractInput
    client_contracts?: ClientContractToAgencyContractCreateNestedManyWithoutAgency_contractInput
  }

  export type AgencyContractUncheckedCreateWithoutMip_agency_contract_propertiesInput = {
    id?: number
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user_id?: number | null
    entity_id: number
    object_id: number
    agency_id: number
    agency_contract_signatory_id?: number | null
    real_estate_agency_contract_properties_id?: number | null
    client_contracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgency_contractInput
  }

  export type AgencyContractCreateOrConnectWithoutMip_agency_contract_propertiesInput = {
    where: AgencyContractWhereUniqueInput
    create: XOR<AgencyContractCreateWithoutMip_agency_contract_propertiesInput, AgencyContractUncheckedCreateWithoutMip_agency_contract_propertiesInput>
  }

  export type AgencyContractCommissionCreateWithoutMip_agency_contract_propertiesInput = {
    percent: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    max_days: number
    created_at?: Date | string
    updated_at?: Date | string
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgency_contract_commissionInput
  }

  export type AgencyContractCommissionUncheckedCreateWithoutMip_agency_contract_propertiesInput = {
    id?: number
    percent: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    max_days: number
    created_at?: Date | string
    updated_at?: Date | string
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesUncheckedCreateNestedOneWithoutAgency_contract_commissionInput
  }

  export type AgencyContractCommissionCreateOrConnectWithoutMip_agency_contract_propertiesInput = {
    where: AgencyContractCommissionWhereUniqueInput
    create: XOR<AgencyContractCommissionCreateWithoutMip_agency_contract_propertiesInput, AgencyContractCommissionUncheckedCreateWithoutMip_agency_contract_propertiesInput>
  }

  export type AgencyContractUpsertWithoutMip_agency_contract_propertiesInput = {
    update: XOR<AgencyContractUpdateWithoutMip_agency_contract_propertiesInput, AgencyContractUncheckedUpdateWithoutMip_agency_contract_propertiesInput>
    create: XOR<AgencyContractCreateWithoutMip_agency_contract_propertiesInput, AgencyContractUncheckedCreateWithoutMip_agency_contract_propertiesInput>
    where?: AgencyContractWhereInput
  }

  export type AgencyContractUpdateToOneWithWhereWithoutMip_agency_contract_propertiesInput = {
    where?: AgencyContractWhereInput
    data: XOR<AgencyContractUpdateWithoutMip_agency_contract_propertiesInput, AgencyContractUncheckedUpdateWithoutMip_agency_contract_propertiesInput>
  }

  export type AgencyContractUpdateWithoutMip_agency_contract_propertiesInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user?: UserUpdateOneWithoutAgency_contractsNestedInput
    entity?: EntityUpdateOneRequiredWithoutAgency_contractsNestedInput
    object?: ObjectUpdateOneRequiredWithoutAgency_contractsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgency_contractsNestedInput
    agency_contract_signatory?: AgencyContractSignatoryUpdateOneWithoutAgency_contractNestedInput
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgency_contractNestedInput
    client_contracts?: ClientContractToAgencyContractUpdateManyWithoutAgency_contractNestedInput
  }

  export type AgencyContractUncheckedUpdateWithoutMip_agency_contract_propertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_id?: IntFieldUpdateOperationsInput | number
    object_id?: IntFieldUpdateOperationsInput | number
    agency_id?: IntFieldUpdateOperationsInput | number
    agency_contract_signatory_id?: NullableIntFieldUpdateOperationsInput | number | null
    real_estate_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_contracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutAgency_contractNestedInput
  }

  export type AgencyContractCommissionUpsertWithoutMip_agency_contract_propertiesInput = {
    update: XOR<AgencyContractCommissionUpdateWithoutMip_agency_contract_propertiesInput, AgencyContractCommissionUncheckedUpdateWithoutMip_agency_contract_propertiesInput>
    create: XOR<AgencyContractCommissionCreateWithoutMip_agency_contract_propertiesInput, AgencyContractCommissionUncheckedCreateWithoutMip_agency_contract_propertiesInput>
    where?: AgencyContractCommissionWhereInput
  }

  export type AgencyContractCommissionUpdateToOneWithWhereWithoutMip_agency_contract_propertiesInput = {
    where?: AgencyContractCommissionWhereInput
    data: XOR<AgencyContractCommissionUpdateWithoutMip_agency_contract_propertiesInput, AgencyContractCommissionUncheckedUpdateWithoutMip_agency_contract_propertiesInput>
  }

  export type AgencyContractCommissionUpdateWithoutMip_agency_contract_propertiesInput = {
    percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgency_contract_commissionNestedInput
  }

  export type AgencyContractCommissionUncheckedUpdateWithoutMip_agency_contract_propertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesUncheckedUpdateOneWithoutAgency_contract_commissionNestedInput
  }

  export type RealEstateAgencyContractPropertiesCreateWithoutAgency_contract_commissionInput = {
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract?: AgencyContractCreateNestedOneWithoutReal_estate_agency_contract_propertiesInput
  }

  export type RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgency_contract_commissionInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract?: AgencyContractUncheckedCreateNestedOneWithoutReal_estate_agency_contract_propertiesInput
  }

  export type RealEstateAgencyContractPropertiesCreateOrConnectWithoutAgency_contract_commissionInput = {
    where: RealEstateAgencyContractPropertiesWhereUniqueInput
    create: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgency_contract_commissionInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgency_contract_commissionInput>
  }

  export type MIPAgencyContractPropertiesCreateWithoutAgency_contract_commissionInput = {
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract?: AgencyContractCreateNestedOneWithoutMip_agency_contract_propertiesInput
  }

  export type MIPAgencyContractPropertiesUncheckedCreateWithoutAgency_contract_commissionInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract?: AgencyContractUncheckedCreateNestedOneWithoutMip_agency_contract_propertiesInput
  }

  export type MIPAgencyContractPropertiesCreateOrConnectWithoutAgency_contract_commissionInput = {
    where: MIPAgencyContractPropertiesWhereUniqueInput
    create: XOR<MIPAgencyContractPropertiesCreateWithoutAgency_contract_commissionInput, MIPAgencyContractPropertiesUncheckedCreateWithoutAgency_contract_commissionInput>
  }

  export type RealEstateAgencyContractPropertiesUpsertWithoutAgency_contract_commissionInput = {
    update: XOR<RealEstateAgencyContractPropertiesUpdateWithoutAgency_contract_commissionInput, RealEstateAgencyContractPropertiesUncheckedUpdateWithoutAgency_contract_commissionInput>
    create: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgency_contract_commissionInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgency_contract_commissionInput>
    where?: RealEstateAgencyContractPropertiesWhereInput
  }

  export type RealEstateAgencyContractPropertiesUpdateToOneWithWhereWithoutAgency_contract_commissionInput = {
    where?: RealEstateAgencyContractPropertiesWhereInput
    data: XOR<RealEstateAgencyContractPropertiesUpdateWithoutAgency_contract_commissionInput, RealEstateAgencyContractPropertiesUncheckedUpdateWithoutAgency_contract_commissionInput>
  }

  export type RealEstateAgencyContractPropertiesUpdateWithoutAgency_contract_commissionInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract?: AgencyContractUpdateOneWithoutReal_estate_agency_contract_propertiesNestedInput
  }

  export type RealEstateAgencyContractPropertiesUncheckedUpdateWithoutAgency_contract_commissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract?: AgencyContractUncheckedUpdateOneWithoutReal_estate_agency_contract_propertiesNestedInput
  }

  export type MIPAgencyContractPropertiesUpsertWithoutAgency_contract_commissionInput = {
    update: XOR<MIPAgencyContractPropertiesUpdateWithoutAgency_contract_commissionInput, MIPAgencyContractPropertiesUncheckedUpdateWithoutAgency_contract_commissionInput>
    create: XOR<MIPAgencyContractPropertiesCreateWithoutAgency_contract_commissionInput, MIPAgencyContractPropertiesUncheckedCreateWithoutAgency_contract_commissionInput>
    where?: MIPAgencyContractPropertiesWhereInput
  }

  export type MIPAgencyContractPropertiesUpdateToOneWithWhereWithoutAgency_contract_commissionInput = {
    where?: MIPAgencyContractPropertiesWhereInput
    data: XOR<MIPAgencyContractPropertiesUpdateWithoutAgency_contract_commissionInput, MIPAgencyContractPropertiesUncheckedUpdateWithoutAgency_contract_commissionInput>
  }

  export type MIPAgencyContractPropertiesUpdateWithoutAgency_contract_commissionInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract?: AgencyContractUpdateOneWithoutMip_agency_contract_propertiesNestedInput
  }

  export type MIPAgencyContractPropertiesUncheckedUpdateWithoutAgency_contract_commissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract?: AgencyContractUncheckedUpdateOneWithoutMip_agency_contract_propertiesNestedInput
  }

  export type ClientContractCreateWithoutReal_estate_agentInput = {
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object: ObjectCreateNestedOneWithoutClient_contractsInput
    product: ProductCreateNestedOneWithoutClient_contractInput
    manager?: UserCreateNestedOneWithoutClient_contractsInput
    bank?: BankCreateNestedOneWithoutClient_contractsInput
    ddu_client_contract_properties?: DDUClientContractPropertiesCreateNestedOneWithoutClient_contractInput
    clients?: ClientContractToClientCreateNestedManyWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractUncheckedCreateWithoutReal_estate_agentInput = {
    id?: number
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object_id: number
    product_id: number
    manager_id?: number | null
    bank_id?: number | null
    ddu_client_contract_properties_id?: number | null
    clients?: ClientContractToClientUncheckedCreateNestedManyWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentUncheckedCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractCreateOrConnectWithoutReal_estate_agentInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutReal_estate_agentInput, ClientContractUncheckedCreateWithoutReal_estate_agentInput>
  }

  export type ClientContractCreateManyReal_estate_agentInputEnvelope = {
    data: ClientContractCreateManyReal_estate_agentInput | ClientContractCreateManyReal_estate_agentInput[]
    skipDuplicates?: boolean
  }

  export type AgencyToRealEstateAgentCreateWithoutReal_estate_agentInput = {
    created_at?: Date | string
    updated_at?: Date | string
    agency: AgencyCreateNestedOneWithoutReal_estate_agentsInput
  }

  export type AgencyToRealEstateAgentUncheckedCreateWithoutReal_estate_agentInput = {
    created_at?: Date | string
    updated_at?: Date | string
    agency_id: number
  }

  export type AgencyToRealEstateAgentCreateOrConnectWithoutReal_estate_agentInput = {
    where: AgencyToRealEstateAgentWhereUniqueInput
    create: XOR<AgencyToRealEstateAgentCreateWithoutReal_estate_agentInput, AgencyToRealEstateAgentUncheckedCreateWithoutReal_estate_agentInput>
  }

  export type AgencyToRealEstateAgentCreateManyReal_estate_agentInputEnvelope = {
    data: AgencyToRealEstateAgentCreateManyReal_estate_agentInput | AgencyToRealEstateAgentCreateManyReal_estate_agentInput[]
    skipDuplicates?: boolean
  }

  export type ClientContractUpsertWithWhereUniqueWithoutReal_estate_agentInput = {
    where: ClientContractWhereUniqueInput
    update: XOR<ClientContractUpdateWithoutReal_estate_agentInput, ClientContractUncheckedUpdateWithoutReal_estate_agentInput>
    create: XOR<ClientContractCreateWithoutReal_estate_agentInput, ClientContractUncheckedCreateWithoutReal_estate_agentInput>
  }

  export type ClientContractUpdateWithWhereUniqueWithoutReal_estate_agentInput = {
    where: ClientContractWhereUniqueInput
    data: XOR<ClientContractUpdateWithoutReal_estate_agentInput, ClientContractUncheckedUpdateWithoutReal_estate_agentInput>
  }

  export type ClientContractUpdateManyWithWhereWithoutReal_estate_agentInput = {
    where: ClientContractScalarWhereInput
    data: XOR<ClientContractUpdateManyMutationInput, ClientContractUncheckedUpdateManyWithoutReal_estate_agentInput>
  }

  export type AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutReal_estate_agentInput = {
    where: AgencyToRealEstateAgentWhereUniqueInput
    update: XOR<AgencyToRealEstateAgentUpdateWithoutReal_estate_agentInput, AgencyToRealEstateAgentUncheckedUpdateWithoutReal_estate_agentInput>
    create: XOR<AgencyToRealEstateAgentCreateWithoutReal_estate_agentInput, AgencyToRealEstateAgentUncheckedCreateWithoutReal_estate_agentInput>
  }

  export type AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutReal_estate_agentInput = {
    where: AgencyToRealEstateAgentWhereUniqueInput
    data: XOR<AgencyToRealEstateAgentUpdateWithoutReal_estate_agentInput, AgencyToRealEstateAgentUncheckedUpdateWithoutReal_estate_agentInput>
  }

  export type AgencyToRealEstateAgentUpdateManyWithWhereWithoutReal_estate_agentInput = {
    where: AgencyToRealEstateAgentScalarWhereInput
    data: XOR<AgencyToRealEstateAgentUpdateManyMutationInput, AgencyToRealEstateAgentUncheckedUpdateManyWithoutReal_estate_agentInput>
  }

  export type AgencyCreateWithoutReal_estate_agentsInput = {
    common_db_contractors_id: number
    name: string
    inn?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agency_contracts?: AgencyContractCreateNestedManyWithoutAgencyInput
    agency_contract_signatory?: AgencyContractSignatoryCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutReal_estate_agentsInput = {
    id?: number
    common_db_contractors_id: number
    name: string
    inn?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agency_contracts?: AgencyContractUncheckedCreateNestedManyWithoutAgencyInput
    agency_contract_signatory?: AgencyContractSignatoryUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutReal_estate_agentsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutReal_estate_agentsInput, AgencyUncheckedCreateWithoutReal_estate_agentsInput>
  }

  export type RealEstateAgentCreateWithoutAgenciesInput = {
    full_name: string
    phone?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_contracts?: ClientContractCreateNestedManyWithoutReal_estate_agentInput
  }

  export type RealEstateAgentUncheckedCreateWithoutAgenciesInput = {
    id?: number
    full_name: string
    phone?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client_contracts?: ClientContractUncheckedCreateNestedManyWithoutReal_estate_agentInput
  }

  export type RealEstateAgentCreateOrConnectWithoutAgenciesInput = {
    where: RealEstateAgentWhereUniqueInput
    create: XOR<RealEstateAgentCreateWithoutAgenciesInput, RealEstateAgentUncheckedCreateWithoutAgenciesInput>
  }

  export type AgencyUpsertWithoutReal_estate_agentsInput = {
    update: XOR<AgencyUpdateWithoutReal_estate_agentsInput, AgencyUncheckedUpdateWithoutReal_estate_agentsInput>
    create: XOR<AgencyCreateWithoutReal_estate_agentsInput, AgencyUncheckedCreateWithoutReal_estate_agentsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutReal_estate_agentsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutReal_estate_agentsInput, AgencyUncheckedUpdateWithoutReal_estate_agentsInput>
  }

  export type AgencyUpdateWithoutReal_estate_agentsInput = {
    common_db_contractors_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contracts?: AgencyContractUpdateManyWithoutAgencyNestedInput
    agency_contract_signatory?: AgencyContractSignatoryUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutReal_estate_agentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    common_db_contractors_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contracts?: AgencyContractUncheckedUpdateManyWithoutAgencyNestedInput
    agency_contract_signatory?: AgencyContractSignatoryUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type RealEstateAgentUpsertWithoutAgenciesInput = {
    update: XOR<RealEstateAgentUpdateWithoutAgenciesInput, RealEstateAgentUncheckedUpdateWithoutAgenciesInput>
    create: XOR<RealEstateAgentCreateWithoutAgenciesInput, RealEstateAgentUncheckedCreateWithoutAgenciesInput>
    where?: RealEstateAgentWhereInput
  }

  export type RealEstateAgentUpdateToOneWithWhereWithoutAgenciesInput = {
    where?: RealEstateAgentWhereInput
    data: XOR<RealEstateAgentUpdateWithoutAgenciesInput, RealEstateAgentUncheckedUpdateWithoutAgenciesInput>
  }

  export type RealEstateAgentUpdateWithoutAgenciesInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contracts?: ClientContractUpdateManyWithoutReal_estate_agentNestedInput
  }

  export type RealEstateAgentUncheckedUpdateWithoutAgenciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contracts?: ClientContractUncheckedUpdateManyWithoutReal_estate_agentNestedInput
  }

  export type AgencyContractCreateWithoutEntityInput = {
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user?: UserCreateNestedOneWithoutAgency_contractsInput
    object: ObjectCreateNestedOneWithoutAgency_contractsInput
    agency: AgencyCreateNestedOneWithoutAgency_contractsInput
    agency_contract_signatory?: AgencyContractSignatoryCreateNestedOneWithoutAgency_contractInput
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgency_contractInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesCreateNestedOneWithoutAgency_contractInput
    client_contracts?: ClientContractToAgencyContractCreateNestedManyWithoutAgency_contractInput
  }

  export type AgencyContractUncheckedCreateWithoutEntityInput = {
    id?: number
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user_id?: number | null
    object_id: number
    agency_id: number
    agency_contract_signatory_id?: number | null
    real_estate_agency_contract_properties_id?: number | null
    mip_agency_contract_properties_id?: number | null
    client_contracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgency_contractInput
  }

  export type AgencyContractCreateOrConnectWithoutEntityInput = {
    where: AgencyContractWhereUniqueInput
    create: XOR<AgencyContractCreateWithoutEntityInput, AgencyContractUncheckedCreateWithoutEntityInput>
  }

  export type AgencyContractCreateManyEntityInputEnvelope = {
    data: AgencyContractCreateManyEntityInput | AgencyContractCreateManyEntityInput[]
    skipDuplicates?: boolean
  }

  export type ObjectCreateWithoutEntityInput = {
    common_db_objects_id: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    products?: ProductCreateNestedManyWithoutObjectInput
    client_contracts?: ClientContractCreateNestedManyWithoutObjectInput
    agency_contracts?: AgencyContractCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutEntityInput = {
    id?: number
    common_db_objects_id: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutObjectInput
    client_contracts?: ClientContractUncheckedCreateNestedManyWithoutObjectInput
    agency_contracts?: AgencyContractUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutEntityInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutEntityInput, ObjectUncheckedCreateWithoutEntityInput>
  }

  export type ObjectCreateManyEntityInputEnvelope = {
    data: ObjectCreateManyEntityInput | ObjectCreateManyEntityInput[]
    skipDuplicates?: boolean
  }

  export type EntityForbiddenWebsiteCreateWithoutEntityInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EntityForbiddenWebsiteCreateOrConnectWithoutEntityInput = {
    where: EntityForbiddenWebsiteWhereUniqueInput
    create: XOR<EntityForbiddenWebsiteCreateWithoutEntityInput, EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput>
  }

  export type EntityForbiddenWebsiteCreateManyEntityInputEnvelope = {
    data: EntityForbiddenWebsiteCreateManyEntityInput | EntityForbiddenWebsiteCreateManyEntityInput[]
    skipDuplicates?: boolean
  }

  export type EntityForbiddenBrandCreateWithoutEntityInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EntityForbiddenBrandUncheckedCreateWithoutEntityInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EntityForbiddenBrandCreateOrConnectWithoutEntityInput = {
    where: EntityForbiddenBrandWhereUniqueInput
    create: XOR<EntityForbiddenBrandCreateWithoutEntityInput, EntityForbiddenBrandUncheckedCreateWithoutEntityInput>
  }

  export type EntityForbiddenBrandCreateManyEntityInputEnvelope = {
    data: EntityForbiddenBrandCreateManyEntityInput | EntityForbiddenBrandCreateManyEntityInput[]
    skipDuplicates?: boolean
  }

  export type AgencyContractUpsertWithWhereUniqueWithoutEntityInput = {
    where: AgencyContractWhereUniqueInput
    update: XOR<AgencyContractUpdateWithoutEntityInput, AgencyContractUncheckedUpdateWithoutEntityInput>
    create: XOR<AgencyContractCreateWithoutEntityInput, AgencyContractUncheckedCreateWithoutEntityInput>
  }

  export type AgencyContractUpdateWithWhereUniqueWithoutEntityInput = {
    where: AgencyContractWhereUniqueInput
    data: XOR<AgencyContractUpdateWithoutEntityInput, AgencyContractUncheckedUpdateWithoutEntityInput>
  }

  export type AgencyContractUpdateManyWithWhereWithoutEntityInput = {
    where: AgencyContractScalarWhereInput
    data: XOR<AgencyContractUpdateManyMutationInput, AgencyContractUncheckedUpdateManyWithoutEntityInput>
  }

  export type ObjectUpsertWithWhereUniqueWithoutEntityInput = {
    where: ObjectWhereUniqueInput
    update: XOR<ObjectUpdateWithoutEntityInput, ObjectUncheckedUpdateWithoutEntityInput>
    create: XOR<ObjectCreateWithoutEntityInput, ObjectUncheckedCreateWithoutEntityInput>
  }

  export type ObjectUpdateWithWhereUniqueWithoutEntityInput = {
    where: ObjectWhereUniqueInput
    data: XOR<ObjectUpdateWithoutEntityInput, ObjectUncheckedUpdateWithoutEntityInput>
  }

  export type ObjectUpdateManyWithWhereWithoutEntityInput = {
    where: ObjectScalarWhereInput
    data: XOR<ObjectUpdateManyMutationInput, ObjectUncheckedUpdateManyWithoutEntityInput>
  }

  export type ObjectScalarWhereInput = {
    AND?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
    OR?: ObjectScalarWhereInput[]
    NOT?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
    id?: IntFilter<"Object"> | number
    common_db_objects_id?: IntFilter<"Object"> | number
    name?: StringFilter<"Object"> | string
    created_at?: DateTimeFilter<"Object"> | Date | string
    updated_at?: DateTimeFilter<"Object"> | Date | string
    entity_id?: IntFilter<"Object"> | number
  }

  export type EntityForbiddenWebsiteUpsertWithWhereUniqueWithoutEntityInput = {
    where: EntityForbiddenWebsiteWhereUniqueInput
    update: XOR<EntityForbiddenWebsiteUpdateWithoutEntityInput, EntityForbiddenWebsiteUncheckedUpdateWithoutEntityInput>
    create: XOR<EntityForbiddenWebsiteCreateWithoutEntityInput, EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput>
  }

  export type EntityForbiddenWebsiteUpdateWithWhereUniqueWithoutEntityInput = {
    where: EntityForbiddenWebsiteWhereUniqueInput
    data: XOR<EntityForbiddenWebsiteUpdateWithoutEntityInput, EntityForbiddenWebsiteUncheckedUpdateWithoutEntityInput>
  }

  export type EntityForbiddenWebsiteUpdateManyWithWhereWithoutEntityInput = {
    where: EntityForbiddenWebsiteScalarWhereInput
    data: XOR<EntityForbiddenWebsiteUpdateManyMutationInput, EntityForbiddenWebsiteUncheckedUpdateManyWithoutEntityInput>
  }

  export type EntityForbiddenWebsiteScalarWhereInput = {
    AND?: EntityForbiddenWebsiteScalarWhereInput | EntityForbiddenWebsiteScalarWhereInput[]
    OR?: EntityForbiddenWebsiteScalarWhereInput[]
    NOT?: EntityForbiddenWebsiteScalarWhereInput | EntityForbiddenWebsiteScalarWhereInput[]
    id?: IntFilter<"EntityForbiddenWebsite"> | number
    name?: StringFilter<"EntityForbiddenWebsite"> | string
    created_at?: DateTimeFilter<"EntityForbiddenWebsite"> | Date | string
    updated_at?: DateTimeFilter<"EntityForbiddenWebsite"> | Date | string
    entity_id?: IntFilter<"EntityForbiddenWebsite"> | number
  }

  export type EntityForbiddenBrandUpsertWithWhereUniqueWithoutEntityInput = {
    where: EntityForbiddenBrandWhereUniqueInput
    update: XOR<EntityForbiddenBrandUpdateWithoutEntityInput, EntityForbiddenBrandUncheckedUpdateWithoutEntityInput>
    create: XOR<EntityForbiddenBrandCreateWithoutEntityInput, EntityForbiddenBrandUncheckedCreateWithoutEntityInput>
  }

  export type EntityForbiddenBrandUpdateWithWhereUniqueWithoutEntityInput = {
    where: EntityForbiddenBrandWhereUniqueInput
    data: XOR<EntityForbiddenBrandUpdateWithoutEntityInput, EntityForbiddenBrandUncheckedUpdateWithoutEntityInput>
  }

  export type EntityForbiddenBrandUpdateManyWithWhereWithoutEntityInput = {
    where: EntityForbiddenBrandScalarWhereInput
    data: XOR<EntityForbiddenBrandUpdateManyMutationInput, EntityForbiddenBrandUncheckedUpdateManyWithoutEntityInput>
  }

  export type EntityForbiddenBrandScalarWhereInput = {
    AND?: EntityForbiddenBrandScalarWhereInput | EntityForbiddenBrandScalarWhereInput[]
    OR?: EntityForbiddenBrandScalarWhereInput[]
    NOT?: EntityForbiddenBrandScalarWhereInput | EntityForbiddenBrandScalarWhereInput[]
    id?: IntFilter<"EntityForbiddenBrand"> | number
    name?: StringFilter<"EntityForbiddenBrand"> | string
    created_at?: DateTimeFilter<"EntityForbiddenBrand"> | Date | string
    updated_at?: DateTimeFilter<"EntityForbiddenBrand"> | Date | string
    entity_id?: IntFilter<"EntityForbiddenBrand"> | number
  }

  export type EntityCreateWithoutEntity_forbidden_websitesInput = {
    common_db_entities_id: number
    name: string
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agency_contracts?: AgencyContractCreateNestedManyWithoutEntityInput
    objects?: ObjectCreateNestedManyWithoutEntityInput
    entity_forbidden_brands?: EntityForbiddenBrandCreateNestedManyWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutEntity_forbidden_websitesInput = {
    id?: number
    common_db_entities_id: number
    name: string
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agency_contracts?: AgencyContractUncheckedCreateNestedManyWithoutEntityInput
    objects?: ObjectUncheckedCreateNestedManyWithoutEntityInput
    entity_forbidden_brands?: EntityForbiddenBrandUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutEntity_forbidden_websitesInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutEntity_forbidden_websitesInput, EntityUncheckedCreateWithoutEntity_forbidden_websitesInput>
  }

  export type EntityUpsertWithoutEntity_forbidden_websitesInput = {
    update: XOR<EntityUpdateWithoutEntity_forbidden_websitesInput, EntityUncheckedUpdateWithoutEntity_forbidden_websitesInput>
    create: XOR<EntityCreateWithoutEntity_forbidden_websitesInput, EntityUncheckedCreateWithoutEntity_forbidden_websitesInput>
    where?: EntityWhereInput
  }

  export type EntityUpdateToOneWithWhereWithoutEntity_forbidden_websitesInput = {
    where?: EntityWhereInput
    data: XOR<EntityUpdateWithoutEntity_forbidden_websitesInput, EntityUncheckedUpdateWithoutEntity_forbidden_websitesInput>
  }

  export type EntityUpdateWithoutEntity_forbidden_websitesInput = {
    common_db_entities_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contracts?: AgencyContractUpdateManyWithoutEntityNestedInput
    objects?: ObjectUpdateManyWithoutEntityNestedInput
    entity_forbidden_brands?: EntityForbiddenBrandUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutEntity_forbidden_websitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    common_db_entities_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contracts?: AgencyContractUncheckedUpdateManyWithoutEntityNestedInput
    objects?: ObjectUncheckedUpdateManyWithoutEntityNestedInput
    entity_forbidden_brands?: EntityForbiddenBrandUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type EntityCreateWithoutEntity_forbidden_brandsInput = {
    common_db_entities_id: number
    name: string
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agency_contracts?: AgencyContractCreateNestedManyWithoutEntityInput
    objects?: ObjectCreateNestedManyWithoutEntityInput
    entity_forbidden_websites?: EntityForbiddenWebsiteCreateNestedManyWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutEntity_forbidden_brandsInput = {
    id?: number
    common_db_entities_id: number
    name: string
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agency_contracts?: AgencyContractUncheckedCreateNestedManyWithoutEntityInput
    objects?: ObjectUncheckedCreateNestedManyWithoutEntityInput
    entity_forbidden_websites?: EntityForbiddenWebsiteUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutEntity_forbidden_brandsInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutEntity_forbidden_brandsInput, EntityUncheckedCreateWithoutEntity_forbidden_brandsInput>
  }

  export type EntityUpsertWithoutEntity_forbidden_brandsInput = {
    update: XOR<EntityUpdateWithoutEntity_forbidden_brandsInput, EntityUncheckedUpdateWithoutEntity_forbidden_brandsInput>
    create: XOR<EntityCreateWithoutEntity_forbidden_brandsInput, EntityUncheckedCreateWithoutEntity_forbidden_brandsInput>
    where?: EntityWhereInput
  }

  export type EntityUpdateToOneWithWhereWithoutEntity_forbidden_brandsInput = {
    where?: EntityWhereInput
    data: XOR<EntityUpdateWithoutEntity_forbidden_brandsInput, EntityUncheckedUpdateWithoutEntity_forbidden_brandsInput>
  }

  export type EntityUpdateWithoutEntity_forbidden_brandsInput = {
    common_db_entities_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contracts?: AgencyContractUpdateManyWithoutEntityNestedInput
    objects?: ObjectUpdateManyWithoutEntityNestedInput
    entity_forbidden_websites?: EntityForbiddenWebsiteUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutEntity_forbidden_brandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    common_db_entities_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contracts?: AgencyContractUncheckedUpdateManyWithoutEntityNestedInput
    objects?: ObjectUncheckedUpdateManyWithoutEntityNestedInput
    entity_forbidden_websites?: EntityForbiddenWebsiteUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type ClientContractCreateWithoutBankInput = {
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object: ObjectCreateNestedOneWithoutClient_contractsInput
    product: ProductCreateNestedOneWithoutClient_contractInput
    real_estate_agent?: RealEstateAgentCreateNestedOneWithoutClient_contractsInput
    manager?: UserCreateNestedOneWithoutClient_contractsInput
    ddu_client_contract_properties?: DDUClientContractPropertiesCreateNestedOneWithoutClient_contractInput
    clients?: ClientContractToClientCreateNestedManyWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractUncheckedCreateWithoutBankInput = {
    id?: number
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object_id: number
    product_id: number
    real_estate_agent_id?: number | null
    manager_id?: number | null
    ddu_client_contract_properties_id?: number | null
    clients?: ClientContractToClientUncheckedCreateNestedManyWithoutClient_contractInput
    agency_contracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClient_contractInput
    scheduled_payments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClient_contractInput
    actual_payment?: ActualPaymentUncheckedCreateNestedManyWithoutClient_contractInput
  }

  export type ClientContractCreateOrConnectWithoutBankInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutBankInput, ClientContractUncheckedCreateWithoutBankInput>
  }

  export type ClientContractCreateManyBankInputEnvelope = {
    data: ClientContractCreateManyBankInput | ClientContractCreateManyBankInput[]
    skipDuplicates?: boolean
  }

  export type ClientContractUpsertWithWhereUniqueWithoutBankInput = {
    where: ClientContractWhereUniqueInput
    update: XOR<ClientContractUpdateWithoutBankInput, ClientContractUncheckedUpdateWithoutBankInput>
    create: XOR<ClientContractCreateWithoutBankInput, ClientContractUncheckedCreateWithoutBankInput>
  }

  export type ClientContractUpdateWithWhereUniqueWithoutBankInput = {
    where: ClientContractWhereUniqueInput
    data: XOR<ClientContractUpdateWithoutBankInput, ClientContractUncheckedUpdateWithoutBankInput>
  }

  export type ClientContractUpdateManyWithWhereWithoutBankInput = {
    where: ClientContractScalarWhereInput
    data: XOR<ClientContractUpdateManyMutationInput, ClientContractUncheckedUpdateManyWithoutBankInput>
  }

  export type ClientContractCreateManyManagerInput = {
    id?: number
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object_id: number
    product_id: number
    real_estate_agent_id?: number | null
    bank_id?: number | null
    ddu_client_contract_properties_id?: number | null
  }

  export type AgencyContractCreateManyResponsible_userInput = {
    id?: number
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    entity_id: number
    object_id: number
    agency_id: number
    agency_contract_signatory_id?: number | null
    real_estate_agency_contract_properties_id?: number | null
    mip_agency_contract_properties_id?: number | null
  }

  export type ClientContractUpdateWithoutManagerInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object?: ObjectUpdateOneRequiredWithoutClient_contractsNestedInput
    product?: ProductUpdateOneRequiredWithoutClient_contractNestedInput
    real_estate_agent?: RealEstateAgentUpdateOneWithoutClient_contractsNestedInput
    bank?: BankUpdateOneWithoutClient_contractsNestedInput
    ddu_client_contract_properties?: DDUClientContractPropertiesUpdateOneWithoutClient_contractNestedInput
    clients?: ClientContractToClientUpdateManyWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    real_estate_agent_id?: NullableIntFieldUpdateOperationsInput | number | null
    bank_id?: NullableIntFieldUpdateOperationsInput | number | null
    ddu_client_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    clients?: ClientContractToClientUncheckedUpdateManyWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientContractUncheckedUpdateManyWithoutManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    real_estate_agent_id?: NullableIntFieldUpdateOperationsInput | number | null
    bank_id?: NullableIntFieldUpdateOperationsInput | number | null
    ddu_client_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AgencyContractUpdateWithoutResponsible_userInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: EntityUpdateOneRequiredWithoutAgency_contractsNestedInput
    object?: ObjectUpdateOneRequiredWithoutAgency_contractsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgency_contractsNestedInput
    agency_contract_signatory?: AgencyContractSignatoryUpdateOneWithoutAgency_contractNestedInput
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgency_contractNestedInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesUpdateOneWithoutAgency_contractNestedInput
    client_contracts?: ClientContractToAgencyContractUpdateManyWithoutAgency_contractNestedInput
  }

  export type AgencyContractUncheckedUpdateWithoutResponsible_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entity_id?: IntFieldUpdateOperationsInput | number
    object_id?: IntFieldUpdateOperationsInput | number
    agency_id?: IntFieldUpdateOperationsInput | number
    agency_contract_signatory_id?: NullableIntFieldUpdateOperationsInput | number | null
    real_estate_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    mip_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_contracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutAgency_contractNestedInput
  }

  export type AgencyContractUncheckedUpdateManyWithoutResponsible_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entity_id?: IntFieldUpdateOperationsInput | number
    object_id?: IntFieldUpdateOperationsInput | number
    agency_id?: IntFieldUpdateOperationsInput | number
    agency_contract_signatory_id?: NullableIntFieldUpdateOperationsInput | number | null
    real_estate_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    mip_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClientContractToClientCreateManyClientInput = {
    is_main: boolean
    share: number
    created_at?: Date | string
    updated_at?: Date | string
    client_contract_id: number
  }

  export type ClientToClientIndividualMinorPropertiesCreateManyClientInput = {
    created_at?: Date | string
    updated_at?: Date | string
    client_individual_minor_properties_id: number
  }

  export type ClientContractToClientUpdateWithoutClientInput = {
    is_main?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract?: ClientContractUpdateOneRequiredWithoutClientsNestedInput
  }

  export type ClientContractToClientUncheckedUpdateWithoutClientInput = {
    is_main?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract_id?: IntFieldUpdateOperationsInput | number
  }

  export type ClientContractToClientUncheckedUpdateManyWithoutClientInput = {
    is_main?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract_id?: IntFieldUpdateOperationsInput | number
  }

  export type ClientToClientIndividualMinorPropertiesUpdateWithoutClientInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_minor_properties?: ClientIndividualMinorPropertiesUpdateOneRequiredWithoutRepresentativesNestedInput
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedUpdateWithoutClientInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_minor_properties_id?: IntFieldUpdateOperationsInput | number
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_individual_minor_properties_id?: IntFieldUpdateOperationsInput | number
  }

  export type ClientToClientIndividualMinorPropertiesCreateManyClient_individual_minor_propertiesInput = {
    created_at?: Date | string
    updated_at?: Date | string
    client_id: number
  }

  export type ClientToClientIndividualMinorPropertiesUpdateWithoutClient_individual_minor_propertiesInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutClients_to_client_individual_minor_propertiesNestedInput
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedUpdateWithoutClient_individual_minor_propertiesInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: IntFieldUpdateOperationsInput | number
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClient_individual_minor_propertiesInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: IntFieldUpdateOperationsInput | number
  }

  export type ClientContractToClientCreateManyClient_contractInput = {
    is_main: boolean
    share: number
    created_at?: Date | string
    updated_at?: Date | string
    client_id: number
  }

  export type ClientContractToAgencyContractCreateManyClient_contractInput = {
    created_at?: Date | string
    updated_at?: Date | string
    agency_contract_id: number
  }

  export type ScheduledPaymentCreateManyClient_contractInput = {
    id?: number
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    scheduled_payment_type: $Enums.ScheduledPaymentType
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActualPaymentCreateManyClient_contractInput = {
    id?: number
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientContractToClientUpdateWithoutClient_contractInput = {
    is_main?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutClient_contractsNestedInput
  }

  export type ClientContractToClientUncheckedUpdateWithoutClient_contractInput = {
    is_main?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: IntFieldUpdateOperationsInput | number
  }

  export type ClientContractToClientUncheckedUpdateManyWithoutClient_contractInput = {
    is_main?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: IntFieldUpdateOperationsInput | number
  }

  export type ClientContractToAgencyContractUpdateWithoutClient_contractInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract?: AgencyContractUpdateOneRequiredWithoutClient_contractsNestedInput
  }

  export type ClientContractToAgencyContractUncheckedUpdateWithoutClient_contractInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_id?: IntFieldUpdateOperationsInput | number
  }

  export type ClientContractToAgencyContractUncheckedUpdateManyWithoutClient_contractInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_id?: IntFieldUpdateOperationsInput | number
  }

  export type ScheduledPaymentUpdateWithoutClient_contractInput = {
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduled_payment_type?: EnumScheduledPaymentTypeFieldUpdateOperationsInput | $Enums.ScheduledPaymentType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPaymentUncheckedUpdateWithoutClient_contractInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduled_payment_type?: EnumScheduledPaymentTypeFieldUpdateOperationsInput | $Enums.ScheduledPaymentType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPaymentUncheckedUpdateManyWithoutClient_contractInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduled_payment_type?: EnumScheduledPaymentTypeFieldUpdateOperationsInput | $Enums.ScheduledPaymentType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActualPaymentUpdateWithoutClient_contractInput = {
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActualPaymentUncheckedUpdateWithoutClient_contractInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActualPaymentUncheckedUpdateManyWithoutClient_contractInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyObjectInput = {
    id?: number
    pricing_products_id: number
    number: string
    product_category: $Enums.ProductCategory
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientContractCreateManyObjectInput = {
    id?: number
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    product_id: number
    real_estate_agent_id?: number | null
    manager_id?: number | null
    bank_id?: number | null
    ddu_client_contract_properties_id?: number | null
  }

  export type AgencyContractCreateManyObjectInput = {
    id?: number
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user_id?: number | null
    entity_id: number
    agency_id: number
    agency_contract_signatory_id?: number | null
    real_estate_agency_contract_properties_id?: number | null
    mip_agency_contract_properties_id?: number | null
  }

  export type ProductUpdateWithoutObjectInput = {
    pricing_products_id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    product_category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract?: ClientContractUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    pricing_products_id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    product_category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract?: ClientContractUncheckedUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    pricing_products_id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    product_category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractUpdateWithoutObjectInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutClient_contractNestedInput
    real_estate_agent?: RealEstateAgentUpdateOneWithoutClient_contractsNestedInput
    manager?: UserUpdateOneWithoutClient_contractsNestedInput
    bank?: BankUpdateOneWithoutClient_contractsNestedInput
    ddu_client_contract_properties?: DDUClientContractPropertiesUpdateOneWithoutClient_contractNestedInput
    clients?: ClientContractToClientUpdateManyWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product_id?: IntFieldUpdateOperationsInput | number
    real_estate_agent_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    bank_id?: NullableIntFieldUpdateOperationsInput | number | null
    ddu_client_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    clients?: ClientContractToClientUncheckedUpdateManyWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientContractUncheckedUpdateManyWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product_id?: IntFieldUpdateOperationsInput | number
    real_estate_agent_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    bank_id?: NullableIntFieldUpdateOperationsInput | number | null
    ddu_client_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AgencyContractUpdateWithoutObjectInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user?: UserUpdateOneWithoutAgency_contractsNestedInput
    entity?: EntityUpdateOneRequiredWithoutAgency_contractsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgency_contractsNestedInput
    agency_contract_signatory?: AgencyContractSignatoryUpdateOneWithoutAgency_contractNestedInput
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgency_contractNestedInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesUpdateOneWithoutAgency_contractNestedInput
    client_contracts?: ClientContractToAgencyContractUpdateManyWithoutAgency_contractNestedInput
  }

  export type AgencyContractUncheckedUpdateWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_id?: IntFieldUpdateOperationsInput | number
    agency_id?: IntFieldUpdateOperationsInput | number
    agency_contract_signatory_id?: NullableIntFieldUpdateOperationsInput | number | null
    real_estate_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    mip_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_contracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutAgency_contractNestedInput
  }

  export type AgencyContractUncheckedUpdateManyWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_id?: IntFieldUpdateOperationsInput | number
    agency_id?: IntFieldUpdateOperationsInput | number
    agency_contract_signatory_id?: NullableIntFieldUpdateOperationsInput | number | null
    real_estate_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    mip_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AgencyContractCreateManyAgencyInput = {
    id?: number
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user_id?: number | null
    entity_id: number
    object_id: number
    agency_contract_signatory_id?: number | null
    real_estate_agency_contract_properties_id?: number | null
    mip_agency_contract_properties_id?: number | null
  }

  export type AgencyToRealEstateAgentCreateManyAgencyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    real_estate_agent_id: number
  }

  export type AgencyContractSignatoryCreateManyAgencyInput = {
    id?: number
    full_name: string
    email: string
    phone: string
    title: string
    based_on: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AgencyContractUpdateWithoutAgencyInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user?: UserUpdateOneWithoutAgency_contractsNestedInput
    entity?: EntityUpdateOneRequiredWithoutAgency_contractsNestedInput
    object?: ObjectUpdateOneRequiredWithoutAgency_contractsNestedInput
    agency_contract_signatory?: AgencyContractSignatoryUpdateOneWithoutAgency_contractNestedInput
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgency_contractNestedInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesUpdateOneWithoutAgency_contractNestedInput
    client_contracts?: ClientContractToAgencyContractUpdateManyWithoutAgency_contractNestedInput
  }

  export type AgencyContractUncheckedUpdateWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_id?: IntFieldUpdateOperationsInput | number
    object_id?: IntFieldUpdateOperationsInput | number
    agency_contract_signatory_id?: NullableIntFieldUpdateOperationsInput | number | null
    real_estate_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    mip_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_contracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutAgency_contractNestedInput
  }

  export type AgencyContractUncheckedUpdateManyWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_id?: IntFieldUpdateOperationsInput | number
    object_id?: IntFieldUpdateOperationsInput | number
    agency_contract_signatory_id?: NullableIntFieldUpdateOperationsInput | number | null
    real_estate_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    mip_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AgencyToRealEstateAgentUpdateWithoutAgencyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    real_estate_agent?: RealEstateAgentUpdateOneRequiredWithoutAgenciesNestedInput
  }

  export type AgencyToRealEstateAgentUncheckedUpdateWithoutAgencyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    real_estate_agent_id?: IntFieldUpdateOperationsInput | number
  }

  export type AgencyToRealEstateAgentUncheckedUpdateManyWithoutAgencyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    real_estate_agent_id?: IntFieldUpdateOperationsInput | number
  }

  export type AgencyContractSignatoryUpdateWithoutAgencyInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    based_on?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract?: AgencyContractUpdateManyWithoutAgency_contract_signatoryNestedInput
  }

  export type AgencyContractSignatoryUncheckedUpdateWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    based_on?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract?: AgencyContractUncheckedUpdateManyWithoutAgency_contract_signatoryNestedInput
  }

  export type AgencyContractSignatoryUncheckedUpdateManyWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    based_on?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToAgencyContractCreateManyAgency_contractInput = {
    created_at?: Date | string
    updated_at?: Date | string
    client_contract_id: number
  }

  export type ClientContractToAgencyContractUpdateWithoutAgency_contractInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract?: ClientContractUpdateOneRequiredWithoutAgency_contractsNestedInput
  }

  export type ClientContractToAgencyContractUncheckedUpdateWithoutAgency_contractInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract_id?: IntFieldUpdateOperationsInput | number
  }

  export type ClientContractToAgencyContractUncheckedUpdateManyWithoutAgency_contractInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_contract_id?: IntFieldUpdateOperationsInput | number
  }

  export type AgencyContractCreateManyAgency_contract_signatoryInput = {
    id?: number
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user_id?: number | null
    entity_id: number
    object_id: number
    agency_id: number
    real_estate_agency_contract_properties_id?: number | null
    mip_agency_contract_properties_id?: number | null
  }

  export type AgencyContractUpdateWithoutAgency_contract_signatoryInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user?: UserUpdateOneWithoutAgency_contractsNestedInput
    entity?: EntityUpdateOneRequiredWithoutAgency_contractsNestedInput
    object?: ObjectUpdateOneRequiredWithoutAgency_contractsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgency_contractsNestedInput
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgency_contractNestedInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesUpdateOneWithoutAgency_contractNestedInput
    client_contracts?: ClientContractToAgencyContractUpdateManyWithoutAgency_contractNestedInput
  }

  export type AgencyContractUncheckedUpdateWithoutAgency_contract_signatoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_id?: IntFieldUpdateOperationsInput | number
    object_id?: IntFieldUpdateOperationsInput | number
    agency_id?: IntFieldUpdateOperationsInput | number
    real_estate_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    mip_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_contracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutAgency_contractNestedInput
  }

  export type AgencyContractUncheckedUpdateManyWithoutAgency_contract_signatoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_id?: IntFieldUpdateOperationsInput | number
    object_id?: IntFieldUpdateOperationsInput | number
    agency_id?: IntFieldUpdateOperationsInput | number
    real_estate_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    mip_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClientContractCreateManyReal_estate_agentInput = {
    id?: number
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object_id: number
    product_id: number
    manager_id?: number | null
    bank_id?: number | null
    ddu_client_contract_properties_id?: number | null
  }

  export type AgencyToRealEstateAgentCreateManyReal_estate_agentInput = {
    created_at?: Date | string
    updated_at?: Date | string
    agency_id: number
  }

  export type ClientContractUpdateWithoutReal_estate_agentInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object?: ObjectUpdateOneRequiredWithoutClient_contractsNestedInput
    product?: ProductUpdateOneRequiredWithoutClient_contractNestedInput
    manager?: UserUpdateOneWithoutClient_contractsNestedInput
    bank?: BankUpdateOneWithoutClient_contractsNestedInput
    ddu_client_contract_properties?: DDUClientContractPropertiesUpdateOneWithoutClient_contractNestedInput
    clients?: ClientContractToClientUpdateManyWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutReal_estate_agentInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    bank_id?: NullableIntFieldUpdateOperationsInput | number | null
    ddu_client_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    clients?: ClientContractToClientUncheckedUpdateManyWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientContractUncheckedUpdateManyWithoutReal_estate_agentInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    bank_id?: NullableIntFieldUpdateOperationsInput | number | null
    ddu_client_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AgencyToRealEstateAgentUpdateWithoutReal_estate_agentInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutReal_estate_agentsNestedInput
  }

  export type AgencyToRealEstateAgentUncheckedUpdateWithoutReal_estate_agentInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_id?: IntFieldUpdateOperationsInput | number
  }

  export type AgencyToRealEstateAgentUncheckedUpdateManyWithoutReal_estate_agentInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_id?: IntFieldUpdateOperationsInput | number
  }

  export type AgencyContractCreateManyEntityInput = {
    id?: number
    number: string
    date: Date | string
    agency_contract_type: $Enums.AgencyContractType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_user_id?: number | null
    object_id: number
    agency_id: number
    agency_contract_signatory_id?: number | null
    real_estate_agency_contract_properties_id?: number | null
    mip_agency_contract_properties_id?: number | null
  }

  export type ObjectCreateManyEntityInput = {
    id?: number
    common_db_objects_id: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EntityForbiddenWebsiteCreateManyEntityInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EntityForbiddenBrandCreateManyEntityInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AgencyContractUpdateWithoutEntityInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user?: UserUpdateOneWithoutAgency_contractsNestedInput
    object?: ObjectUpdateOneRequiredWithoutAgency_contractsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgency_contractsNestedInput
    agency_contract_signatory?: AgencyContractSignatoryUpdateOneWithoutAgency_contractNestedInput
    real_estate_agency_contract_properties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgency_contractNestedInput
    mip_agency_contract_properties?: MIPAgencyContractPropertiesUpdateOneWithoutAgency_contractNestedInput
    client_contracts?: ClientContractToAgencyContractUpdateManyWithoutAgency_contractNestedInput
  }

  export type AgencyContractUncheckedUpdateWithoutEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    object_id?: IntFieldUpdateOperationsInput | number
    agency_id?: IntFieldUpdateOperationsInput | number
    agency_contract_signatory_id?: NullableIntFieldUpdateOperationsInput | number | null
    real_estate_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    mip_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_contracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutAgency_contractNestedInput
  }

  export type AgencyContractUncheckedUpdateManyWithoutEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agency_contract_type?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    object_id?: IntFieldUpdateOperationsInput | number
    agency_id?: IntFieldUpdateOperationsInput | number
    agency_contract_signatory_id?: NullableIntFieldUpdateOperationsInput | number | null
    real_estate_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    mip_agency_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ObjectUpdateWithoutEntityInput = {
    common_db_objects_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutObjectNestedInput
    client_contracts?: ClientContractUpdateManyWithoutObjectNestedInput
    agency_contracts?: AgencyContractUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    common_db_objects_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutObjectNestedInput
    client_contracts?: ClientContractUncheckedUpdateManyWithoutObjectNestedInput
    agency_contracts?: AgencyContractUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateManyWithoutEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    common_db_objects_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenWebsiteUpdateWithoutEntityInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenWebsiteUncheckedUpdateWithoutEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenWebsiteUncheckedUpdateManyWithoutEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenBrandUpdateWithoutEntityInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenBrandUncheckedUpdateWithoutEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenBrandUncheckedUpdateManyWithoutEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractCreateManyBankInput = {
    id?: number
    number: string
    date: Date | string
    registration_date?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    client_contract_type: $Enums.ClientContractType
    created_at?: Date | string
    updated_at?: Date | string
    object_id: number
    product_id: number
    real_estate_agent_id?: number | null
    manager_id?: number | null
    ddu_client_contract_properties_id?: number | null
  }

  export type ClientContractUpdateWithoutBankInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object?: ObjectUpdateOneRequiredWithoutClient_contractsNestedInput
    product?: ProductUpdateOneRequiredWithoutClient_contractNestedInput
    real_estate_agent?: RealEstateAgentUpdateOneWithoutClient_contractsNestedInput
    manager?: UserUpdateOneWithoutClient_contractsNestedInput
    ddu_client_contract_properties?: DDUClientContractPropertiesUpdateOneWithoutClient_contractNestedInput
    clients?: ClientContractToClientUpdateManyWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutBankInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    real_estate_agent_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    ddu_client_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
    clients?: ClientContractToClientUncheckedUpdateManyWithoutClient_contractNestedInput
    agency_contracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClient_contractNestedInput
    scheduled_payments?: ScheduledPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
    actual_payment?: ActualPaymentUncheckedUpdateManyWithoutClient_contractNestedInput
  }

  export type ClientContractUncheckedUpdateManyWithoutBankInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client_contract_type?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    real_estate_agent_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    ddu_client_contract_properties_id?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientCountOutputTypeDefaultArgs instead
     */
    export type ClientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientIndividualMinorPropertiesCountOutputTypeDefaultArgs instead
     */
    export type ClientIndividualMinorPropertiesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientIndividualMinorPropertiesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientContractCountOutputTypeDefaultArgs instead
     */
    export type ClientContractCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientContractCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectCountOutputTypeDefaultArgs instead
     */
    export type ObjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgencyCountOutputTypeDefaultArgs instead
     */
    export type AgencyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgencyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgencyContractCountOutputTypeDefaultArgs instead
     */
    export type AgencyContractCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgencyContractCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgencyContractSignatoryCountOutputTypeDefaultArgs instead
     */
    export type AgencyContractSignatoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgencyContractSignatoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RealEstateAgentCountOutputTypeDefaultArgs instead
     */
    export type RealEstateAgentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RealEstateAgentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntityCountOutputTypeDefaultArgs instead
     */
    export type EntityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BankCountOutputTypeDefaultArgs instead
     */
    export type BankCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BankCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientDefaultArgs instead
     */
    export type ClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientIndividualPropertiesDefaultArgs instead
     */
    export type ClientIndividualPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientIndividualPropertiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientIndividualMinorPropertiesDefaultArgs instead
     */
    export type ClientIndividualMinorPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientIndividualMinorPropertiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientEntityPropertiesDefaultArgs instead
     */
    export type ClientEntityPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientEntityPropertiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientToClientIndividualMinorPropertiesDefaultArgs instead
     */
    export type ClientToClientIndividualMinorPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientToClientIndividualMinorPropertiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientPassportDefaultArgs instead
     */
    export type ClientPassportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientPassportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientContractDefaultArgs instead
     */
    export type ClientContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientContractDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DDUClientContractPropertiesDefaultArgs instead
     */
    export type DDUClientContractPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DDUClientContractPropertiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientContractToAgencyContractDefaultArgs instead
     */
    export type ClientContractToAgencyContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientContractToAgencyContractDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientContractToClientDefaultArgs instead
     */
    export type ClientContractToClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientContractToClientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduledPaymentDefaultArgs instead
     */
    export type ScheduledPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduledPaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActualPaymentDefaultArgs instead
     */
    export type ActualPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActualPaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectDefaultArgs instead
     */
    export type ObjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgencyDefaultArgs instead
     */
    export type AgencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgencyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgencyContractDefaultArgs instead
     */
    export type AgencyContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgencyContractDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgencyContractSignatoryDefaultArgs instead
     */
    export type AgencyContractSignatoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgencyContractSignatoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RealEstateAgencyContractPropertiesDefaultArgs instead
     */
    export type RealEstateAgencyContractPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RealEstateAgencyContractPropertiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MIPAgencyContractPropertiesDefaultArgs instead
     */
    export type MIPAgencyContractPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MIPAgencyContractPropertiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgencyContractCommissionDefaultArgs instead
     */
    export type AgencyContractCommissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgencyContractCommissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RealEstateAgentDefaultArgs instead
     */
    export type RealEstateAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RealEstateAgentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgencyToRealEstateAgentDefaultArgs instead
     */
    export type AgencyToRealEstateAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgencyToRealEstateAgentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntityDefaultArgs instead
     */
    export type EntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntityForbiddenWebsiteDefaultArgs instead
     */
    export type EntityForbiddenWebsiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntityForbiddenWebsiteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntityForbiddenBrandDefaultArgs instead
     */
    export type EntityForbiddenBrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntityForbiddenBrandDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BankDefaultArgs instead
     */
    export type BankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BankDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}