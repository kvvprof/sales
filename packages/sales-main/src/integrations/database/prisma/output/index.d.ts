
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model ClientIndividualProperties
 * 
 */
export type ClientIndividualProperties = $Result.DefaultSelection<Prisma.$ClientIndividualPropertiesPayload>
/**
 * Model ClientIndividualMinorProperties
 * 
 */
export type ClientIndividualMinorProperties = $Result.DefaultSelection<Prisma.$ClientIndividualMinorPropertiesPayload>
/**
 * Model ClientEntityProperties
 * 
 */
export type ClientEntityProperties = $Result.DefaultSelection<Prisma.$ClientEntityPropertiesPayload>
/**
 * Model ClientToClientIndividualMinorProperties
 * 
 */
export type ClientToClientIndividualMinorProperties = $Result.DefaultSelection<Prisma.$ClientToClientIndividualMinorPropertiesPayload>
/**
 * Model ClientPassport
 * 
 */
export type ClientPassport = $Result.DefaultSelection<Prisma.$ClientPassportPayload>
/**
 * Model ClientContract
 * 
 */
export type ClientContract = $Result.DefaultSelection<Prisma.$ClientContractPayload>
/**
 * Model DduClientContractProperties
 * 
 */
export type DduClientContractProperties = $Result.DefaultSelection<Prisma.$DduClientContractPropertiesPayload>
/**
 * Model DkpClientContractProperties
 * 
 */
export type DkpClientContractProperties = $Result.DefaultSelection<Prisma.$DkpClientContractPropertiesPayload>
/**
 * Model ClientContractToAgencyContract
 * 
 */
export type ClientContractToAgencyContract = $Result.DefaultSelection<Prisma.$ClientContractToAgencyContractPayload>
/**
 * Model ClientContractToClient
 * 
 */
export type ClientContractToClient = $Result.DefaultSelection<Prisma.$ClientContractToClientPayload>
/**
 * Model ScheduledPayment
 * 
 */
export type ScheduledPayment = $Result.DefaultSelection<Prisma.$ScheduledPaymentPayload>
/**
 * Model ActualPayment
 * 
 */
export type ActualPayment = $Result.DefaultSelection<Prisma.$ActualPaymentPayload>
/**
 * Model Object
 * 
 */
export type Object = $Result.DefaultSelection<Prisma.$ObjectPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Agency
 * 
 */
export type Agency = $Result.DefaultSelection<Prisma.$AgencyPayload>
/**
 * Model AgencyContract
 * 
 */
export type AgencyContract = $Result.DefaultSelection<Prisma.$AgencyContractPayload>
/**
 * Model AgencyContractSignatory
 * 
 */
export type AgencyContractSignatory = $Result.DefaultSelection<Prisma.$AgencyContractSignatoryPayload>
/**
 * Model RealEstateAgencyContractProperties
 * 
 */
export type RealEstateAgencyContractProperties = $Result.DefaultSelection<Prisma.$RealEstateAgencyContractPropertiesPayload>
/**
 * Model MipAgencyContractProperties
 * 
 */
export type MipAgencyContractProperties = $Result.DefaultSelection<Prisma.$MipAgencyContractPropertiesPayload>
/**
 * Model AgencyContractCommission
 * 
 */
export type AgencyContractCommission = $Result.DefaultSelection<Prisma.$AgencyContractCommissionPayload>
/**
 * Model RealEstateAgent
 * 
 */
export type RealEstateAgent = $Result.DefaultSelection<Prisma.$RealEstateAgentPayload>
/**
 * Model AgencyToRealEstateAgent
 * 
 */
export type AgencyToRealEstateAgent = $Result.DefaultSelection<Prisma.$AgencyToRealEstateAgentPayload>
/**
 * Model Entity
 * 
 */
export type Entity = $Result.DefaultSelection<Prisma.$EntityPayload>
/**
 * Model EntityForbiddenWebsite
 * 
 */
export type EntityForbiddenWebsite = $Result.DefaultSelection<Prisma.$EntityForbiddenWebsitePayload>
/**
 * Model EntityForbiddenBrand
 * 
 */
export type EntityForbiddenBrand = $Result.DefaultSelection<Prisma.$EntityForbiddenBrandPayload>
/**
 * Model Bank
 * 
 */
export type Bank = $Result.DefaultSelection<Prisma.$BankPayload>
/**
 * Model EscrowAccountHistory
 * 
 */
export type EscrowAccountHistory = $Result.DefaultSelection<Prisma.$EscrowAccountHistoryPayload>
/**
 * Model RealEstateAgencyAct
 * 
 */
export type RealEstateAgencyAct = $Result.DefaultSelection<Prisma.$RealEstateAgencyActPayload>
/**
 * Model Subsidy
 * 
 */
export type Subsidy = $Result.DefaultSelection<Prisma.$SubsidyPayload>
/**
 * Model Assignment
 * 
 */
export type Assignment = $Result.DefaultSelection<Prisma.$AssignmentPayload>
/**
 * Model TransferAct
 * 
 */
export type TransferAct = $Result.DefaultSelection<Prisma.$TransferActPayload>
/**
 * Model Representative
 * 
 */
export type Representative = $Result.DefaultSelection<Prisma.$RepresentativePayload>
/**
 * Model TransferActToRepresentative
 * 
 */
export type TransferActToRepresentative = $Result.DefaultSelection<Prisma.$TransferActToRepresentativePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMINISTRATOR: 'ADMINISTRATOR',
  DIRECTOR: 'DIRECTOR',
  SALES_EMPLOYEE: 'SALES_EMPLOYEE'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ClientCategory: {
  INDIVIDUAL: 'INDIVIDUAL',
  INDIVIDUAL_MINOR: 'INDIVIDUAL_MINOR',
  ENTITY: 'ENTITY'
};

export type ClientCategory = (typeof ClientCategory)[keyof typeof ClientCategory]


export const ClientContractType: {
  DDU: 'DDU',
  DKP: 'DKP'
};

export type ClientContractType = (typeof ClientContractType)[keyof typeof ClientContractType]


export const ScheduledPaymentType: {
  OWN: 'OWN',
  MORTGAGE: 'MORTGAGE',
  EXCHANGE: 'EXCHANGE',
  MATERNITY_CAPITAL: 'MATERNITY_CAPITAL'
};

export type ScheduledPaymentType = (typeof ScheduledPaymentType)[keyof typeof ScheduledPaymentType]


export const ProductCategory: {
  FLAT: 'FLAT',
  OFFICE: 'OFFICE',
  APARTMENT: 'APARTMENT',
  STORAGE_ROOM: 'STORAGE_ROOM',
  PARKING_SPACE: 'PARKING_SPACE'
};

export type ProductCategory = (typeof ProductCategory)[keyof typeof ProductCategory]


export const AgencyContractType: {
  REAL_ESTATE_AGENCY_CONTRACT: 'REAL_ESTATE_AGENCY_CONTRACT',
  MIP_AGENCY_CONTRACT: 'MIP_AGENCY_CONTRACT'
};

export type AgencyContractType = (typeof AgencyContractType)[keyof typeof AgencyContractType]


export const EscrowAccountStatus: {
  OPENED: 'OPENED',
  CLOSED: 'CLOSED'
};

export type EscrowAccountStatus = (typeof EscrowAccountStatus)[keyof typeof EscrowAccountStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ClientCategory = $Enums.ClientCategory

export const ClientCategory: typeof $Enums.ClientCategory

export type ClientContractType = $Enums.ClientContractType

export const ClientContractType: typeof $Enums.ClientContractType

export type ScheduledPaymentType = $Enums.ScheduledPaymentType

export const ScheduledPaymentType: typeof $Enums.ScheduledPaymentType

export type ProductCategory = $Enums.ProductCategory

export const ProductCategory: typeof $Enums.ProductCategory

export type AgencyContractType = $Enums.AgencyContractType

export const AgencyContractType: typeof $Enums.AgencyContractType

export type EscrowAccountStatus = $Enums.EscrowAccountStatus

export const EscrowAccountStatus: typeof $Enums.EscrowAccountStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs>;

  /**
   * `prisma.clientIndividualProperties`: Exposes CRUD operations for the **ClientIndividualProperties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientIndividualProperties
    * const clientIndividualProperties = await prisma.clientIndividualProperties.findMany()
    * ```
    */
  get clientIndividualProperties(): Prisma.ClientIndividualPropertiesDelegate<ExtArgs>;

  /**
   * `prisma.clientIndividualMinorProperties`: Exposes CRUD operations for the **ClientIndividualMinorProperties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientIndividualMinorProperties
    * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.findMany()
    * ```
    */
  get clientIndividualMinorProperties(): Prisma.ClientIndividualMinorPropertiesDelegate<ExtArgs>;

  /**
   * `prisma.clientEntityProperties`: Exposes CRUD operations for the **ClientEntityProperties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientEntityProperties
    * const clientEntityProperties = await prisma.clientEntityProperties.findMany()
    * ```
    */
  get clientEntityProperties(): Prisma.ClientEntityPropertiesDelegate<ExtArgs>;

  /**
   * `prisma.clientToClientIndividualMinorProperties`: Exposes CRUD operations for the **ClientToClientIndividualMinorProperties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientToClientIndividualMinorProperties
    * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.findMany()
    * ```
    */
  get clientToClientIndividualMinorProperties(): Prisma.ClientToClientIndividualMinorPropertiesDelegate<ExtArgs>;

  /**
   * `prisma.clientPassport`: Exposes CRUD operations for the **ClientPassport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientPassports
    * const clientPassports = await prisma.clientPassport.findMany()
    * ```
    */
  get clientPassport(): Prisma.ClientPassportDelegate<ExtArgs>;

  /**
   * `prisma.clientContract`: Exposes CRUD operations for the **ClientContract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientContracts
    * const clientContracts = await prisma.clientContract.findMany()
    * ```
    */
  get clientContract(): Prisma.ClientContractDelegate<ExtArgs>;

  /**
   * `prisma.dduClientContractProperties`: Exposes CRUD operations for the **DduClientContractProperties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DduClientContractProperties
    * const dduClientContractProperties = await prisma.dduClientContractProperties.findMany()
    * ```
    */
  get dduClientContractProperties(): Prisma.DduClientContractPropertiesDelegate<ExtArgs>;

  /**
   * `prisma.dkpClientContractProperties`: Exposes CRUD operations for the **DkpClientContractProperties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DkpClientContractProperties
    * const dkpClientContractProperties = await prisma.dkpClientContractProperties.findMany()
    * ```
    */
  get dkpClientContractProperties(): Prisma.DkpClientContractPropertiesDelegate<ExtArgs>;

  /**
   * `prisma.clientContractToAgencyContract`: Exposes CRUD operations for the **ClientContractToAgencyContract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientContractToAgencyContracts
    * const clientContractToAgencyContracts = await prisma.clientContractToAgencyContract.findMany()
    * ```
    */
  get clientContractToAgencyContract(): Prisma.ClientContractToAgencyContractDelegate<ExtArgs>;

  /**
   * `prisma.clientContractToClient`: Exposes CRUD operations for the **ClientContractToClient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientContractToClients
    * const clientContractToClients = await prisma.clientContractToClient.findMany()
    * ```
    */
  get clientContractToClient(): Prisma.ClientContractToClientDelegate<ExtArgs>;

  /**
   * `prisma.scheduledPayment`: Exposes CRUD operations for the **ScheduledPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduledPayments
    * const scheduledPayments = await prisma.scheduledPayment.findMany()
    * ```
    */
  get scheduledPayment(): Prisma.ScheduledPaymentDelegate<ExtArgs>;

  /**
   * `prisma.actualPayment`: Exposes CRUD operations for the **ActualPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActualPayments
    * const actualPayments = await prisma.actualPayment.findMany()
    * ```
    */
  get actualPayment(): Prisma.ActualPaymentDelegate<ExtArgs>;

  /**
   * `prisma.object`: Exposes CRUD operations for the **Object** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Objects
    * const objects = await prisma.object.findMany()
    * ```
    */
  get object(): Prisma.ObjectDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.agency`: Exposes CRUD operations for the **Agency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agencies
    * const agencies = await prisma.agency.findMany()
    * ```
    */
  get agency(): Prisma.AgencyDelegate<ExtArgs>;

  /**
   * `prisma.agencyContract`: Exposes CRUD operations for the **AgencyContract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyContracts
    * const agencyContracts = await prisma.agencyContract.findMany()
    * ```
    */
  get agencyContract(): Prisma.AgencyContractDelegate<ExtArgs>;

  /**
   * `prisma.agencyContractSignatory`: Exposes CRUD operations for the **AgencyContractSignatory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyContractSignatories
    * const agencyContractSignatories = await prisma.agencyContractSignatory.findMany()
    * ```
    */
  get agencyContractSignatory(): Prisma.AgencyContractSignatoryDelegate<ExtArgs>;

  /**
   * `prisma.realEstateAgencyContractProperties`: Exposes CRUD operations for the **RealEstateAgencyContractProperties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RealEstateAgencyContractProperties
    * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.findMany()
    * ```
    */
  get realEstateAgencyContractProperties(): Prisma.RealEstateAgencyContractPropertiesDelegate<ExtArgs>;

  /**
   * `prisma.mipAgencyContractProperties`: Exposes CRUD operations for the **MipAgencyContractProperties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MipAgencyContractProperties
    * const mipAgencyContractProperties = await prisma.mipAgencyContractProperties.findMany()
    * ```
    */
  get mipAgencyContractProperties(): Prisma.MipAgencyContractPropertiesDelegate<ExtArgs>;

  /**
   * `prisma.agencyContractCommission`: Exposes CRUD operations for the **AgencyContractCommission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyContractCommissions
    * const agencyContractCommissions = await prisma.agencyContractCommission.findMany()
    * ```
    */
  get agencyContractCommission(): Prisma.AgencyContractCommissionDelegate<ExtArgs>;

  /**
   * `prisma.realEstateAgent`: Exposes CRUD operations for the **RealEstateAgent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RealEstateAgents
    * const realEstateAgents = await prisma.realEstateAgent.findMany()
    * ```
    */
  get realEstateAgent(): Prisma.RealEstateAgentDelegate<ExtArgs>;

  /**
   * `prisma.agencyToRealEstateAgent`: Exposes CRUD operations for the **AgencyToRealEstateAgent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyToRealEstateAgents
    * const agencyToRealEstateAgents = await prisma.agencyToRealEstateAgent.findMany()
    * ```
    */
  get agencyToRealEstateAgent(): Prisma.AgencyToRealEstateAgentDelegate<ExtArgs>;

  /**
   * `prisma.entity`: Exposes CRUD operations for the **Entity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entities
    * const entities = await prisma.entity.findMany()
    * ```
    */
  get entity(): Prisma.EntityDelegate<ExtArgs>;

  /**
   * `prisma.entityForbiddenWebsite`: Exposes CRUD operations for the **EntityForbiddenWebsite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EntityForbiddenWebsites
    * const entityForbiddenWebsites = await prisma.entityForbiddenWebsite.findMany()
    * ```
    */
  get entityForbiddenWebsite(): Prisma.EntityForbiddenWebsiteDelegate<ExtArgs>;

  /**
   * `prisma.entityForbiddenBrand`: Exposes CRUD operations for the **EntityForbiddenBrand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EntityForbiddenBrands
    * const entityForbiddenBrands = await prisma.entityForbiddenBrand.findMany()
    * ```
    */
  get entityForbiddenBrand(): Prisma.EntityForbiddenBrandDelegate<ExtArgs>;

  /**
   * `prisma.bank`: Exposes CRUD operations for the **Bank** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banks
    * const banks = await prisma.bank.findMany()
    * ```
    */
  get bank(): Prisma.BankDelegate<ExtArgs>;

  /**
   * `prisma.escrowAccountHistory`: Exposes CRUD operations for the **EscrowAccountHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EscrowAccountHistories
    * const escrowAccountHistories = await prisma.escrowAccountHistory.findMany()
    * ```
    */
  get escrowAccountHistory(): Prisma.EscrowAccountHistoryDelegate<ExtArgs>;

  /**
   * `prisma.realEstateAgencyAct`: Exposes CRUD operations for the **RealEstateAgencyAct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RealEstateAgencyActs
    * const realEstateAgencyActs = await prisma.realEstateAgencyAct.findMany()
    * ```
    */
  get realEstateAgencyAct(): Prisma.RealEstateAgencyActDelegate<ExtArgs>;

  /**
   * `prisma.subsidy`: Exposes CRUD operations for the **Subsidy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subsidies
    * const subsidies = await prisma.subsidy.findMany()
    * ```
    */
  get subsidy(): Prisma.SubsidyDelegate<ExtArgs>;

  /**
   * `prisma.assignment`: Exposes CRUD operations for the **Assignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignments
    * const assignments = await prisma.assignment.findMany()
    * ```
    */
  get assignment(): Prisma.AssignmentDelegate<ExtArgs>;

  /**
   * `prisma.transferAct`: Exposes CRUD operations for the **TransferAct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransferActs
    * const transferActs = await prisma.transferAct.findMany()
    * ```
    */
  get transferAct(): Prisma.TransferActDelegate<ExtArgs>;

  /**
   * `prisma.representative`: Exposes CRUD operations for the **Representative** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Representatives
    * const representatives = await prisma.representative.findMany()
    * ```
    */
  get representative(): Prisma.RepresentativeDelegate<ExtArgs>;

  /**
   * `prisma.transferActToRepresentative`: Exposes CRUD operations for the **TransferActToRepresentative** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransferActToRepresentatives
    * const transferActToRepresentatives = await prisma.transferActToRepresentative.findMany()
    * ```
    */
  get transferActToRepresentative(): Prisma.TransferActToRepresentativeDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.15.1
   * Query Engine version: 5675a3182f972f1a8f31d16eee6abf4fd54910e3
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Client: 'Client',
    ClientIndividualProperties: 'ClientIndividualProperties',
    ClientIndividualMinorProperties: 'ClientIndividualMinorProperties',
    ClientEntityProperties: 'ClientEntityProperties',
    ClientToClientIndividualMinorProperties: 'ClientToClientIndividualMinorProperties',
    ClientPassport: 'ClientPassport',
    ClientContract: 'ClientContract',
    DduClientContractProperties: 'DduClientContractProperties',
    DkpClientContractProperties: 'DkpClientContractProperties',
    ClientContractToAgencyContract: 'ClientContractToAgencyContract',
    ClientContractToClient: 'ClientContractToClient',
    ScheduledPayment: 'ScheduledPayment',
    ActualPayment: 'ActualPayment',
    Object: 'Object',
    Product: 'Product',
    Agency: 'Agency',
    AgencyContract: 'AgencyContract',
    AgencyContractSignatory: 'AgencyContractSignatory',
    RealEstateAgencyContractProperties: 'RealEstateAgencyContractProperties',
    MipAgencyContractProperties: 'MipAgencyContractProperties',
    AgencyContractCommission: 'AgencyContractCommission',
    RealEstateAgent: 'RealEstateAgent',
    AgencyToRealEstateAgent: 'AgencyToRealEstateAgent',
    Entity: 'Entity',
    EntityForbiddenWebsite: 'EntityForbiddenWebsite',
    EntityForbiddenBrand: 'EntityForbiddenBrand',
    Bank: 'Bank',
    EscrowAccountHistory: 'EscrowAccountHistory',
    RealEstateAgencyAct: 'RealEstateAgencyAct',
    Subsidy: 'Subsidy',
    Assignment: 'Assignment',
    TransferAct: 'TransferAct',
    Representative: 'Representative',
    TransferActToRepresentative: 'TransferActToRepresentative'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'client' | 'clientIndividualProperties' | 'clientIndividualMinorProperties' | 'clientEntityProperties' | 'clientToClientIndividualMinorProperties' | 'clientPassport' | 'clientContract' | 'dduClientContractProperties' | 'dkpClientContractProperties' | 'clientContractToAgencyContract' | 'clientContractToClient' | 'scheduledPayment' | 'actualPayment' | 'object' | 'product' | 'agency' | 'agencyContract' | 'agencyContractSignatory' | 'realEstateAgencyContractProperties' | 'mipAgencyContractProperties' | 'agencyContractCommission' | 'realEstateAgent' | 'agencyToRealEstateAgent' | 'entity' | 'entityForbiddenWebsite' | 'entityForbiddenBrand' | 'bank' | 'escrowAccountHistory' | 'realEstateAgencyAct' | 'subsidy' | 'assignment' | 'transferAct' | 'representative' | 'transferActToRepresentative'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      ClientIndividualProperties: {
        payload: Prisma.$ClientIndividualPropertiesPayload<ExtArgs>
        fields: Prisma.ClientIndividualPropertiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientIndividualPropertiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualPropertiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientIndividualPropertiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualPropertiesPayload>
          }
          findFirst: {
            args: Prisma.ClientIndividualPropertiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualPropertiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientIndividualPropertiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualPropertiesPayload>
          }
          findMany: {
            args: Prisma.ClientIndividualPropertiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualPropertiesPayload>[]
          }
          create: {
            args: Prisma.ClientIndividualPropertiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualPropertiesPayload>
          }
          createMany: {
            args: Prisma.ClientIndividualPropertiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientIndividualPropertiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualPropertiesPayload>
          }
          update: {
            args: Prisma.ClientIndividualPropertiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualPropertiesPayload>
          }
          deleteMany: {
            args: Prisma.ClientIndividualPropertiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientIndividualPropertiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientIndividualPropertiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualPropertiesPayload>
          }
          aggregate: {
            args: Prisma.ClientIndividualPropertiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClientIndividualProperties>
          }
          groupBy: {
            args: Prisma.ClientIndividualPropertiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientIndividualPropertiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientIndividualPropertiesCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientIndividualPropertiesCountAggregateOutputType> | number
          }
        }
      }
      ClientIndividualMinorProperties: {
        payload: Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>
        fields: Prisma.ClientIndividualMinorPropertiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientIndividualMinorPropertiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualMinorPropertiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientIndividualMinorPropertiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualMinorPropertiesPayload>
          }
          findFirst: {
            args: Prisma.ClientIndividualMinorPropertiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualMinorPropertiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientIndividualMinorPropertiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualMinorPropertiesPayload>
          }
          findMany: {
            args: Prisma.ClientIndividualMinorPropertiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualMinorPropertiesPayload>[]
          }
          create: {
            args: Prisma.ClientIndividualMinorPropertiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualMinorPropertiesPayload>
          }
          createMany: {
            args: Prisma.ClientIndividualMinorPropertiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientIndividualMinorPropertiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualMinorPropertiesPayload>
          }
          update: {
            args: Prisma.ClientIndividualMinorPropertiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualMinorPropertiesPayload>
          }
          deleteMany: {
            args: Prisma.ClientIndividualMinorPropertiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientIndividualMinorPropertiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientIndividualMinorPropertiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientIndividualMinorPropertiesPayload>
          }
          aggregate: {
            args: Prisma.ClientIndividualMinorPropertiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClientIndividualMinorProperties>
          }
          groupBy: {
            args: Prisma.ClientIndividualMinorPropertiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientIndividualMinorPropertiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientIndividualMinorPropertiesCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientIndividualMinorPropertiesCountAggregateOutputType> | number
          }
        }
      }
      ClientEntityProperties: {
        payload: Prisma.$ClientEntityPropertiesPayload<ExtArgs>
        fields: Prisma.ClientEntityPropertiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientEntityPropertiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPropertiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientEntityPropertiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPropertiesPayload>
          }
          findFirst: {
            args: Prisma.ClientEntityPropertiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPropertiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientEntityPropertiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPropertiesPayload>
          }
          findMany: {
            args: Prisma.ClientEntityPropertiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPropertiesPayload>[]
          }
          create: {
            args: Prisma.ClientEntityPropertiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPropertiesPayload>
          }
          createMany: {
            args: Prisma.ClientEntityPropertiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientEntityPropertiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPropertiesPayload>
          }
          update: {
            args: Prisma.ClientEntityPropertiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPropertiesPayload>
          }
          deleteMany: {
            args: Prisma.ClientEntityPropertiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientEntityPropertiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientEntityPropertiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPropertiesPayload>
          }
          aggregate: {
            args: Prisma.ClientEntityPropertiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClientEntityProperties>
          }
          groupBy: {
            args: Prisma.ClientEntityPropertiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientEntityPropertiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientEntityPropertiesCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientEntityPropertiesCountAggregateOutputType> | number
          }
        }
      }
      ClientToClientIndividualMinorProperties: {
        payload: Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>
        fields: Prisma.ClientToClientIndividualMinorPropertiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientToClientIndividualMinorPropertiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientToClientIndividualMinorPropertiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload>
          }
          findFirst: {
            args: Prisma.ClientToClientIndividualMinorPropertiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientToClientIndividualMinorPropertiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload>
          }
          findMany: {
            args: Prisma.ClientToClientIndividualMinorPropertiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload>[]
          }
          create: {
            args: Prisma.ClientToClientIndividualMinorPropertiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload>
          }
          createMany: {
            args: Prisma.ClientToClientIndividualMinorPropertiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientToClientIndividualMinorPropertiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload>
          }
          update: {
            args: Prisma.ClientToClientIndividualMinorPropertiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload>
          }
          deleteMany: {
            args: Prisma.ClientToClientIndividualMinorPropertiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientToClientIndividualMinorPropertiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientToClientIndividualMinorPropertiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload>
          }
          aggregate: {
            args: Prisma.ClientToClientIndividualMinorPropertiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClientToClientIndividualMinorProperties>
          }
          groupBy: {
            args: Prisma.ClientToClientIndividualMinorPropertiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientToClientIndividualMinorPropertiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientToClientIndividualMinorPropertiesCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientToClientIndividualMinorPropertiesCountAggregateOutputType> | number
          }
        }
      }
      ClientPassport: {
        payload: Prisma.$ClientPassportPayload<ExtArgs>
        fields: Prisma.ClientPassportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientPassportFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPassportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientPassportFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPassportPayload>
          }
          findFirst: {
            args: Prisma.ClientPassportFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPassportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientPassportFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPassportPayload>
          }
          findMany: {
            args: Prisma.ClientPassportFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPassportPayload>[]
          }
          create: {
            args: Prisma.ClientPassportCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPassportPayload>
          }
          createMany: {
            args: Prisma.ClientPassportCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientPassportDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPassportPayload>
          }
          update: {
            args: Prisma.ClientPassportUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPassportPayload>
          }
          deleteMany: {
            args: Prisma.ClientPassportDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientPassportUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientPassportUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPassportPayload>
          }
          aggregate: {
            args: Prisma.ClientPassportAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClientPassport>
          }
          groupBy: {
            args: Prisma.ClientPassportGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientPassportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientPassportCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientPassportCountAggregateOutputType> | number
          }
        }
      }
      ClientContract: {
        payload: Prisma.$ClientContractPayload<ExtArgs>
        fields: Prisma.ClientContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientContractFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientContractFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractPayload>
          }
          findFirst: {
            args: Prisma.ClientContractFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientContractFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractPayload>
          }
          findMany: {
            args: Prisma.ClientContractFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractPayload>[]
          }
          create: {
            args: Prisma.ClientContractCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractPayload>
          }
          createMany: {
            args: Prisma.ClientContractCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientContractDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractPayload>
          }
          update: {
            args: Prisma.ClientContractUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractPayload>
          }
          deleteMany: {
            args: Prisma.ClientContractDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientContractUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientContractUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractPayload>
          }
          aggregate: {
            args: Prisma.ClientContractAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClientContract>
          }
          groupBy: {
            args: Prisma.ClientContractGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientContractCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientContractCountAggregateOutputType> | number
          }
        }
      }
      DduClientContractProperties: {
        payload: Prisma.$DduClientContractPropertiesPayload<ExtArgs>
        fields: Prisma.DduClientContractPropertiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DduClientContractPropertiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DduClientContractPropertiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DduClientContractPropertiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DduClientContractPropertiesPayload>
          }
          findFirst: {
            args: Prisma.DduClientContractPropertiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DduClientContractPropertiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DduClientContractPropertiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DduClientContractPropertiesPayload>
          }
          findMany: {
            args: Prisma.DduClientContractPropertiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DduClientContractPropertiesPayload>[]
          }
          create: {
            args: Prisma.DduClientContractPropertiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DduClientContractPropertiesPayload>
          }
          createMany: {
            args: Prisma.DduClientContractPropertiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DduClientContractPropertiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DduClientContractPropertiesPayload>
          }
          update: {
            args: Prisma.DduClientContractPropertiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DduClientContractPropertiesPayload>
          }
          deleteMany: {
            args: Prisma.DduClientContractPropertiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DduClientContractPropertiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DduClientContractPropertiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DduClientContractPropertiesPayload>
          }
          aggregate: {
            args: Prisma.DduClientContractPropertiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDduClientContractProperties>
          }
          groupBy: {
            args: Prisma.DduClientContractPropertiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DduClientContractPropertiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.DduClientContractPropertiesCountArgs<ExtArgs>,
            result: $Utils.Optional<DduClientContractPropertiesCountAggregateOutputType> | number
          }
        }
      }
      DkpClientContractProperties: {
        payload: Prisma.$DkpClientContractPropertiesPayload<ExtArgs>
        fields: Prisma.DkpClientContractPropertiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DkpClientContractPropertiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DkpClientContractPropertiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DkpClientContractPropertiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DkpClientContractPropertiesPayload>
          }
          findFirst: {
            args: Prisma.DkpClientContractPropertiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DkpClientContractPropertiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DkpClientContractPropertiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DkpClientContractPropertiesPayload>
          }
          findMany: {
            args: Prisma.DkpClientContractPropertiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DkpClientContractPropertiesPayload>[]
          }
          create: {
            args: Prisma.DkpClientContractPropertiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DkpClientContractPropertiesPayload>
          }
          createMany: {
            args: Prisma.DkpClientContractPropertiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DkpClientContractPropertiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DkpClientContractPropertiesPayload>
          }
          update: {
            args: Prisma.DkpClientContractPropertiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DkpClientContractPropertiesPayload>
          }
          deleteMany: {
            args: Prisma.DkpClientContractPropertiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DkpClientContractPropertiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DkpClientContractPropertiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DkpClientContractPropertiesPayload>
          }
          aggregate: {
            args: Prisma.DkpClientContractPropertiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDkpClientContractProperties>
          }
          groupBy: {
            args: Prisma.DkpClientContractPropertiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DkpClientContractPropertiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.DkpClientContractPropertiesCountArgs<ExtArgs>,
            result: $Utils.Optional<DkpClientContractPropertiesCountAggregateOutputType> | number
          }
        }
      }
      ClientContractToAgencyContract: {
        payload: Prisma.$ClientContractToAgencyContractPayload<ExtArgs>
        fields: Prisma.ClientContractToAgencyContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientContractToAgencyContractFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToAgencyContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientContractToAgencyContractFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToAgencyContractPayload>
          }
          findFirst: {
            args: Prisma.ClientContractToAgencyContractFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToAgencyContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientContractToAgencyContractFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToAgencyContractPayload>
          }
          findMany: {
            args: Prisma.ClientContractToAgencyContractFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToAgencyContractPayload>[]
          }
          create: {
            args: Prisma.ClientContractToAgencyContractCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToAgencyContractPayload>
          }
          createMany: {
            args: Prisma.ClientContractToAgencyContractCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientContractToAgencyContractDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToAgencyContractPayload>
          }
          update: {
            args: Prisma.ClientContractToAgencyContractUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToAgencyContractPayload>
          }
          deleteMany: {
            args: Prisma.ClientContractToAgencyContractDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientContractToAgencyContractUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientContractToAgencyContractUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToAgencyContractPayload>
          }
          aggregate: {
            args: Prisma.ClientContractToAgencyContractAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClientContractToAgencyContract>
          }
          groupBy: {
            args: Prisma.ClientContractToAgencyContractGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientContractToAgencyContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientContractToAgencyContractCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientContractToAgencyContractCountAggregateOutputType> | number
          }
        }
      }
      ClientContractToClient: {
        payload: Prisma.$ClientContractToClientPayload<ExtArgs>
        fields: Prisma.ClientContractToClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientContractToClientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientContractToClientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToClientPayload>
          }
          findFirst: {
            args: Prisma.ClientContractToClientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientContractToClientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToClientPayload>
          }
          findMany: {
            args: Prisma.ClientContractToClientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToClientPayload>[]
          }
          create: {
            args: Prisma.ClientContractToClientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToClientPayload>
          }
          createMany: {
            args: Prisma.ClientContractToClientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientContractToClientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToClientPayload>
          }
          update: {
            args: Prisma.ClientContractToClientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientContractToClientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientContractToClientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientContractToClientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientContractToClientPayload>
          }
          aggregate: {
            args: Prisma.ClientContractToClientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClientContractToClient>
          }
          groupBy: {
            args: Prisma.ClientContractToClientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientContractToClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientContractToClientCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientContractToClientCountAggregateOutputType> | number
          }
        }
      }
      ScheduledPayment: {
        payload: Prisma.$ScheduledPaymentPayload<ExtArgs>
        fields: Prisma.ScheduledPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduledPaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ScheduledPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduledPaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ScheduledPaymentPayload>
          }
          findFirst: {
            args: Prisma.ScheduledPaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ScheduledPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduledPaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ScheduledPaymentPayload>
          }
          findMany: {
            args: Prisma.ScheduledPaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ScheduledPaymentPayload>[]
          }
          create: {
            args: Prisma.ScheduledPaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ScheduledPaymentPayload>
          }
          createMany: {
            args: Prisma.ScheduledPaymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ScheduledPaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ScheduledPaymentPayload>
          }
          update: {
            args: Prisma.ScheduledPaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ScheduledPaymentPayload>
          }
          deleteMany: {
            args: Prisma.ScheduledPaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduledPaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ScheduledPaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ScheduledPaymentPayload>
          }
          aggregate: {
            args: Prisma.ScheduledPaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateScheduledPayment>
          }
          groupBy: {
            args: Prisma.ScheduledPaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ScheduledPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduledPaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<ScheduledPaymentCountAggregateOutputType> | number
          }
        }
      }
      ActualPayment: {
        payload: Prisma.$ActualPaymentPayload<ExtArgs>
        fields: Prisma.ActualPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActualPaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActualPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActualPaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActualPaymentPayload>
          }
          findFirst: {
            args: Prisma.ActualPaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActualPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActualPaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActualPaymentPayload>
          }
          findMany: {
            args: Prisma.ActualPaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActualPaymentPayload>[]
          }
          create: {
            args: Prisma.ActualPaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActualPaymentPayload>
          }
          createMany: {
            args: Prisma.ActualPaymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ActualPaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActualPaymentPayload>
          }
          update: {
            args: Prisma.ActualPaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActualPaymentPayload>
          }
          deleteMany: {
            args: Prisma.ActualPaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ActualPaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ActualPaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActualPaymentPayload>
          }
          aggregate: {
            args: Prisma.ActualPaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateActualPayment>
          }
          groupBy: {
            args: Prisma.ActualPaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ActualPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActualPaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<ActualPaymentCountAggregateOutputType> | number
          }
        }
      }
      Object: {
        payload: Prisma.$ObjectPayload<ExtArgs>
        fields: Prisma.ObjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObjectFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObjectFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          findFirst: {
            args: Prisma.ObjectFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObjectFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          findMany: {
            args: Prisma.ObjectFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>[]
          }
          create: {
            args: Prisma.ObjectCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          createMany: {
            args: Prisma.ObjectCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ObjectDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          update: {
            args: Prisma.ObjectUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          deleteMany: {
            args: Prisma.ObjectDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ObjectUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ObjectUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          aggregate: {
            args: Prisma.ObjectAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateObject>
          }
          groupBy: {
            args: Prisma.ObjectGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ObjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObjectCountArgs<ExtArgs>,
            result: $Utils.Optional<ObjectCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Agency: {
        payload: Prisma.$AgencyPayload<ExtArgs>
        fields: Prisma.AgencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findFirst: {
            args: Prisma.AgencyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findMany: {
            args: Prisma.AgencyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          create: {
            args: Prisma.AgencyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          createMany: {
            args: Prisma.AgencyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AgencyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          update: {
            args: Prisma.AgencyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          deleteMany: {
            args: Prisma.AgencyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AgencyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          aggregate: {
            args: Prisma.AgencyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgency>
          }
          groupBy: {
            args: Prisma.AgencyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyCountArgs<ExtArgs>,
            result: $Utils.Optional<AgencyCountAggregateOutputType> | number
          }
        }
      }
      AgencyContract: {
        payload: Prisma.$AgencyContractPayload<ExtArgs>
        fields: Prisma.AgencyContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyContractFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyContractFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractPayload>
          }
          findFirst: {
            args: Prisma.AgencyContractFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyContractFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractPayload>
          }
          findMany: {
            args: Prisma.AgencyContractFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractPayload>[]
          }
          create: {
            args: Prisma.AgencyContractCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractPayload>
          }
          createMany: {
            args: Prisma.AgencyContractCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AgencyContractDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractPayload>
          }
          update: {
            args: Prisma.AgencyContractUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractPayload>
          }
          deleteMany: {
            args: Prisma.AgencyContractDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyContractUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AgencyContractUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractPayload>
          }
          aggregate: {
            args: Prisma.AgencyContractAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgencyContract>
          }
          groupBy: {
            args: Prisma.AgencyContractGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgencyContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyContractCountArgs<ExtArgs>,
            result: $Utils.Optional<AgencyContractCountAggregateOutputType> | number
          }
        }
      }
      AgencyContractSignatory: {
        payload: Prisma.$AgencyContractSignatoryPayload<ExtArgs>
        fields: Prisma.AgencyContractSignatoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyContractSignatoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractSignatoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyContractSignatoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractSignatoryPayload>
          }
          findFirst: {
            args: Prisma.AgencyContractSignatoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractSignatoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyContractSignatoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractSignatoryPayload>
          }
          findMany: {
            args: Prisma.AgencyContractSignatoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractSignatoryPayload>[]
          }
          create: {
            args: Prisma.AgencyContractSignatoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractSignatoryPayload>
          }
          createMany: {
            args: Prisma.AgencyContractSignatoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AgencyContractSignatoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractSignatoryPayload>
          }
          update: {
            args: Prisma.AgencyContractSignatoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractSignatoryPayload>
          }
          deleteMany: {
            args: Prisma.AgencyContractSignatoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyContractSignatoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AgencyContractSignatoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractSignatoryPayload>
          }
          aggregate: {
            args: Prisma.AgencyContractSignatoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgencyContractSignatory>
          }
          groupBy: {
            args: Prisma.AgencyContractSignatoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgencyContractSignatoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyContractSignatoryCountArgs<ExtArgs>,
            result: $Utils.Optional<AgencyContractSignatoryCountAggregateOutputType> | number
          }
        }
      }
      RealEstateAgencyContractProperties: {
        payload: Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>
        fields: Prisma.RealEstateAgencyContractPropertiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RealEstateAgencyContractPropertiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyContractPropertiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RealEstateAgencyContractPropertiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyContractPropertiesPayload>
          }
          findFirst: {
            args: Prisma.RealEstateAgencyContractPropertiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyContractPropertiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RealEstateAgencyContractPropertiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyContractPropertiesPayload>
          }
          findMany: {
            args: Prisma.RealEstateAgencyContractPropertiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyContractPropertiesPayload>[]
          }
          create: {
            args: Prisma.RealEstateAgencyContractPropertiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyContractPropertiesPayload>
          }
          createMany: {
            args: Prisma.RealEstateAgencyContractPropertiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RealEstateAgencyContractPropertiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyContractPropertiesPayload>
          }
          update: {
            args: Prisma.RealEstateAgencyContractPropertiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyContractPropertiesPayload>
          }
          deleteMany: {
            args: Prisma.RealEstateAgencyContractPropertiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RealEstateAgencyContractPropertiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RealEstateAgencyContractPropertiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyContractPropertiesPayload>
          }
          aggregate: {
            args: Prisma.RealEstateAgencyContractPropertiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRealEstateAgencyContractProperties>
          }
          groupBy: {
            args: Prisma.RealEstateAgencyContractPropertiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RealEstateAgencyContractPropertiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RealEstateAgencyContractPropertiesCountArgs<ExtArgs>,
            result: $Utils.Optional<RealEstateAgencyContractPropertiesCountAggregateOutputType> | number
          }
        }
      }
      MipAgencyContractProperties: {
        payload: Prisma.$MipAgencyContractPropertiesPayload<ExtArgs>
        fields: Prisma.MipAgencyContractPropertiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MipAgencyContractPropertiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MipAgencyContractPropertiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MipAgencyContractPropertiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MipAgencyContractPropertiesPayload>
          }
          findFirst: {
            args: Prisma.MipAgencyContractPropertiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MipAgencyContractPropertiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MipAgencyContractPropertiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MipAgencyContractPropertiesPayload>
          }
          findMany: {
            args: Prisma.MipAgencyContractPropertiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MipAgencyContractPropertiesPayload>[]
          }
          create: {
            args: Prisma.MipAgencyContractPropertiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MipAgencyContractPropertiesPayload>
          }
          createMany: {
            args: Prisma.MipAgencyContractPropertiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MipAgencyContractPropertiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MipAgencyContractPropertiesPayload>
          }
          update: {
            args: Prisma.MipAgencyContractPropertiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MipAgencyContractPropertiesPayload>
          }
          deleteMany: {
            args: Prisma.MipAgencyContractPropertiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MipAgencyContractPropertiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MipAgencyContractPropertiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MipAgencyContractPropertiesPayload>
          }
          aggregate: {
            args: Prisma.MipAgencyContractPropertiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMipAgencyContractProperties>
          }
          groupBy: {
            args: Prisma.MipAgencyContractPropertiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MipAgencyContractPropertiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.MipAgencyContractPropertiesCountArgs<ExtArgs>,
            result: $Utils.Optional<MipAgencyContractPropertiesCountAggregateOutputType> | number
          }
        }
      }
      AgencyContractCommission: {
        payload: Prisma.$AgencyContractCommissionPayload<ExtArgs>
        fields: Prisma.AgencyContractCommissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyContractCommissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractCommissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyContractCommissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractCommissionPayload>
          }
          findFirst: {
            args: Prisma.AgencyContractCommissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractCommissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyContractCommissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractCommissionPayload>
          }
          findMany: {
            args: Prisma.AgencyContractCommissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractCommissionPayload>[]
          }
          create: {
            args: Prisma.AgencyContractCommissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractCommissionPayload>
          }
          createMany: {
            args: Prisma.AgencyContractCommissionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AgencyContractCommissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractCommissionPayload>
          }
          update: {
            args: Prisma.AgencyContractCommissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractCommissionPayload>
          }
          deleteMany: {
            args: Prisma.AgencyContractCommissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyContractCommissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AgencyContractCommissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyContractCommissionPayload>
          }
          aggregate: {
            args: Prisma.AgencyContractCommissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgencyContractCommission>
          }
          groupBy: {
            args: Prisma.AgencyContractCommissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgencyContractCommissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyContractCommissionCountArgs<ExtArgs>,
            result: $Utils.Optional<AgencyContractCommissionCountAggregateOutputType> | number
          }
        }
      }
      RealEstateAgent: {
        payload: Prisma.$RealEstateAgentPayload<ExtArgs>
        fields: Prisma.RealEstateAgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RealEstateAgentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RealEstateAgentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgentPayload>
          }
          findFirst: {
            args: Prisma.RealEstateAgentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RealEstateAgentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgentPayload>
          }
          findMany: {
            args: Prisma.RealEstateAgentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgentPayload>[]
          }
          create: {
            args: Prisma.RealEstateAgentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgentPayload>
          }
          createMany: {
            args: Prisma.RealEstateAgentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RealEstateAgentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgentPayload>
          }
          update: {
            args: Prisma.RealEstateAgentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgentPayload>
          }
          deleteMany: {
            args: Prisma.RealEstateAgentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RealEstateAgentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RealEstateAgentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgentPayload>
          }
          aggregate: {
            args: Prisma.RealEstateAgentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRealEstateAgent>
          }
          groupBy: {
            args: Prisma.RealEstateAgentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RealEstateAgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RealEstateAgentCountArgs<ExtArgs>,
            result: $Utils.Optional<RealEstateAgentCountAggregateOutputType> | number
          }
        }
      }
      AgencyToRealEstateAgent: {
        payload: Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>
        fields: Prisma.AgencyToRealEstateAgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyToRealEstateAgentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyToRealEstateAgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyToRealEstateAgentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyToRealEstateAgentPayload>
          }
          findFirst: {
            args: Prisma.AgencyToRealEstateAgentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyToRealEstateAgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyToRealEstateAgentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyToRealEstateAgentPayload>
          }
          findMany: {
            args: Prisma.AgencyToRealEstateAgentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyToRealEstateAgentPayload>[]
          }
          create: {
            args: Prisma.AgencyToRealEstateAgentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyToRealEstateAgentPayload>
          }
          createMany: {
            args: Prisma.AgencyToRealEstateAgentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AgencyToRealEstateAgentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyToRealEstateAgentPayload>
          }
          update: {
            args: Prisma.AgencyToRealEstateAgentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyToRealEstateAgentPayload>
          }
          deleteMany: {
            args: Prisma.AgencyToRealEstateAgentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyToRealEstateAgentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AgencyToRealEstateAgentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgencyToRealEstateAgentPayload>
          }
          aggregate: {
            args: Prisma.AgencyToRealEstateAgentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgencyToRealEstateAgent>
          }
          groupBy: {
            args: Prisma.AgencyToRealEstateAgentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgencyToRealEstateAgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyToRealEstateAgentCountArgs<ExtArgs>,
            result: $Utils.Optional<AgencyToRealEstateAgentCountAggregateOutputType> | number
          }
        }
      }
      Entity: {
        payload: Prisma.$EntityPayload<ExtArgs>
        fields: Prisma.EntityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>
          }
          findFirst: {
            args: Prisma.EntityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>
          }
          findMany: {
            args: Prisma.EntityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>[]
          }
          create: {
            args: Prisma.EntityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>
          }
          createMany: {
            args: Prisma.EntityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EntityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>
          }
          update: {
            args: Prisma.EntityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>
          }
          deleteMany: {
            args: Prisma.EntityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EntityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EntityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>
          }
          aggregate: {
            args: Prisma.EntityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEntity>
          }
          groupBy: {
            args: Prisma.EntityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EntityGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntityCountArgs<ExtArgs>,
            result: $Utils.Optional<EntityCountAggregateOutputType> | number
          }
        }
      }
      EntityForbiddenWebsite: {
        payload: Prisma.$EntityForbiddenWebsitePayload<ExtArgs>
        fields: Prisma.EntityForbiddenWebsiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntityForbiddenWebsiteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenWebsitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntityForbiddenWebsiteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenWebsitePayload>
          }
          findFirst: {
            args: Prisma.EntityForbiddenWebsiteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenWebsitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntityForbiddenWebsiteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenWebsitePayload>
          }
          findMany: {
            args: Prisma.EntityForbiddenWebsiteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenWebsitePayload>[]
          }
          create: {
            args: Prisma.EntityForbiddenWebsiteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenWebsitePayload>
          }
          createMany: {
            args: Prisma.EntityForbiddenWebsiteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EntityForbiddenWebsiteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenWebsitePayload>
          }
          update: {
            args: Prisma.EntityForbiddenWebsiteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenWebsitePayload>
          }
          deleteMany: {
            args: Prisma.EntityForbiddenWebsiteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EntityForbiddenWebsiteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EntityForbiddenWebsiteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenWebsitePayload>
          }
          aggregate: {
            args: Prisma.EntityForbiddenWebsiteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEntityForbiddenWebsite>
          }
          groupBy: {
            args: Prisma.EntityForbiddenWebsiteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EntityForbiddenWebsiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntityForbiddenWebsiteCountArgs<ExtArgs>,
            result: $Utils.Optional<EntityForbiddenWebsiteCountAggregateOutputType> | number
          }
        }
      }
      EntityForbiddenBrand: {
        payload: Prisma.$EntityForbiddenBrandPayload<ExtArgs>
        fields: Prisma.EntityForbiddenBrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntityForbiddenBrandFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenBrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntityForbiddenBrandFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenBrandPayload>
          }
          findFirst: {
            args: Prisma.EntityForbiddenBrandFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenBrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntityForbiddenBrandFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenBrandPayload>
          }
          findMany: {
            args: Prisma.EntityForbiddenBrandFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenBrandPayload>[]
          }
          create: {
            args: Prisma.EntityForbiddenBrandCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenBrandPayload>
          }
          createMany: {
            args: Prisma.EntityForbiddenBrandCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EntityForbiddenBrandDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenBrandPayload>
          }
          update: {
            args: Prisma.EntityForbiddenBrandUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenBrandPayload>
          }
          deleteMany: {
            args: Prisma.EntityForbiddenBrandDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EntityForbiddenBrandUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EntityForbiddenBrandUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntityForbiddenBrandPayload>
          }
          aggregate: {
            args: Prisma.EntityForbiddenBrandAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEntityForbiddenBrand>
          }
          groupBy: {
            args: Prisma.EntityForbiddenBrandGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EntityForbiddenBrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntityForbiddenBrandCountArgs<ExtArgs>,
            result: $Utils.Optional<EntityForbiddenBrandCountAggregateOutputType> | number
          }
        }
      }
      Bank: {
        payload: Prisma.$BankPayload<ExtArgs>
        fields: Prisma.BankFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankPayload>
          }
          findFirst: {
            args: Prisma.BankFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankPayload>
          }
          findMany: {
            args: Prisma.BankFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankPayload>[]
          }
          create: {
            args: Prisma.BankCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankPayload>
          }
          createMany: {
            args: Prisma.BankCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BankDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankPayload>
          }
          update: {
            args: Prisma.BankUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankPayload>
          }
          deleteMany: {
            args: Prisma.BankDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BankUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BankUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankPayload>
          }
          aggregate: {
            args: Prisma.BankAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBank>
          }
          groupBy: {
            args: Prisma.BankGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BankGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankCountArgs<ExtArgs>,
            result: $Utils.Optional<BankCountAggregateOutputType> | number
          }
        }
      }
      EscrowAccountHistory: {
        payload: Prisma.$EscrowAccountHistoryPayload<ExtArgs>
        fields: Prisma.EscrowAccountHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EscrowAccountHistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EscrowAccountHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EscrowAccountHistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EscrowAccountHistoryPayload>
          }
          findFirst: {
            args: Prisma.EscrowAccountHistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EscrowAccountHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EscrowAccountHistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EscrowAccountHistoryPayload>
          }
          findMany: {
            args: Prisma.EscrowAccountHistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EscrowAccountHistoryPayload>[]
          }
          create: {
            args: Prisma.EscrowAccountHistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EscrowAccountHistoryPayload>
          }
          createMany: {
            args: Prisma.EscrowAccountHistoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EscrowAccountHistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EscrowAccountHistoryPayload>
          }
          update: {
            args: Prisma.EscrowAccountHistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EscrowAccountHistoryPayload>
          }
          deleteMany: {
            args: Prisma.EscrowAccountHistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EscrowAccountHistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EscrowAccountHistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EscrowAccountHistoryPayload>
          }
          aggregate: {
            args: Prisma.EscrowAccountHistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEscrowAccountHistory>
          }
          groupBy: {
            args: Prisma.EscrowAccountHistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EscrowAccountHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.EscrowAccountHistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<EscrowAccountHistoryCountAggregateOutputType> | number
          }
        }
      }
      RealEstateAgencyAct: {
        payload: Prisma.$RealEstateAgencyActPayload<ExtArgs>
        fields: Prisma.RealEstateAgencyActFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RealEstateAgencyActFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyActPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RealEstateAgencyActFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyActPayload>
          }
          findFirst: {
            args: Prisma.RealEstateAgencyActFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyActPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RealEstateAgencyActFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyActPayload>
          }
          findMany: {
            args: Prisma.RealEstateAgencyActFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyActPayload>[]
          }
          create: {
            args: Prisma.RealEstateAgencyActCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyActPayload>
          }
          createMany: {
            args: Prisma.RealEstateAgencyActCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RealEstateAgencyActDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyActPayload>
          }
          update: {
            args: Prisma.RealEstateAgencyActUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyActPayload>
          }
          deleteMany: {
            args: Prisma.RealEstateAgencyActDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RealEstateAgencyActUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RealEstateAgencyActUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealEstateAgencyActPayload>
          }
          aggregate: {
            args: Prisma.RealEstateAgencyActAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRealEstateAgencyAct>
          }
          groupBy: {
            args: Prisma.RealEstateAgencyActGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RealEstateAgencyActGroupByOutputType>[]
          }
          count: {
            args: Prisma.RealEstateAgencyActCountArgs<ExtArgs>,
            result: $Utils.Optional<RealEstateAgencyActCountAggregateOutputType> | number
          }
        }
      }
      Subsidy: {
        payload: Prisma.$SubsidyPayload<ExtArgs>
        fields: Prisma.SubsidyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubsidyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubsidyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubsidyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubsidyPayload>
          }
          findFirst: {
            args: Prisma.SubsidyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubsidyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubsidyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubsidyPayload>
          }
          findMany: {
            args: Prisma.SubsidyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubsidyPayload>[]
          }
          create: {
            args: Prisma.SubsidyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubsidyPayload>
          }
          createMany: {
            args: Prisma.SubsidyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SubsidyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubsidyPayload>
          }
          update: {
            args: Prisma.SubsidyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubsidyPayload>
          }
          deleteMany: {
            args: Prisma.SubsidyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SubsidyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SubsidyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubsidyPayload>
          }
          aggregate: {
            args: Prisma.SubsidyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSubsidy>
          }
          groupBy: {
            args: Prisma.SubsidyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SubsidyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubsidyCountArgs<ExtArgs>,
            result: $Utils.Optional<SubsidyCountAggregateOutputType> | number
          }
        }
      }
      Assignment: {
        payload: Prisma.$AssignmentPayload<ExtArgs>
        fields: Prisma.AssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findFirst: {
            args: Prisma.AssignmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findMany: {
            args: Prisma.AssignmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          create: {
            args: Prisma.AssignmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          createMany: {
            args: Prisma.AssignmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AssignmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          update: {
            args: Prisma.AssignmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AssignmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          aggregate: {
            args: Prisma.AssignmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAssignment>
          }
          groupBy: {
            args: Prisma.AssignmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentCountArgs<ExtArgs>,
            result: $Utils.Optional<AssignmentCountAggregateOutputType> | number
          }
        }
      }
      TransferAct: {
        payload: Prisma.$TransferActPayload<ExtArgs>
        fields: Prisma.TransferActFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferActFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferActPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferActFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferActPayload>
          }
          findFirst: {
            args: Prisma.TransferActFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferActPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferActFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferActPayload>
          }
          findMany: {
            args: Prisma.TransferActFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferActPayload>[]
          }
          create: {
            args: Prisma.TransferActCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferActPayload>
          }
          createMany: {
            args: Prisma.TransferActCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TransferActDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferActPayload>
          }
          update: {
            args: Prisma.TransferActUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferActPayload>
          }
          deleteMany: {
            args: Prisma.TransferActDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TransferActUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TransferActUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferActPayload>
          }
          aggregate: {
            args: Prisma.TransferActAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTransferAct>
          }
          groupBy: {
            args: Prisma.TransferActGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TransferActGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferActCountArgs<ExtArgs>,
            result: $Utils.Optional<TransferActCountAggregateOutputType> | number
          }
        }
      }
      Representative: {
        payload: Prisma.$RepresentativePayload<ExtArgs>
        fields: Prisma.RepresentativeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RepresentativeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RepresentativeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload>
          }
          findFirst: {
            args: Prisma.RepresentativeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RepresentativeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload>
          }
          findMany: {
            args: Prisma.RepresentativeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload>[]
          }
          create: {
            args: Prisma.RepresentativeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload>
          }
          createMany: {
            args: Prisma.RepresentativeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RepresentativeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload>
          }
          update: {
            args: Prisma.RepresentativeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload>
          }
          deleteMany: {
            args: Prisma.RepresentativeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RepresentativeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RepresentativeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RepresentativePayload>
          }
          aggregate: {
            args: Prisma.RepresentativeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRepresentative>
          }
          groupBy: {
            args: Prisma.RepresentativeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RepresentativeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RepresentativeCountArgs<ExtArgs>,
            result: $Utils.Optional<RepresentativeCountAggregateOutputType> | number
          }
        }
      }
      TransferActToRepresentative: {
        payload: Prisma.$TransferActToRepresentativePayload<ExtArgs>
        fields: Prisma.TransferActToRepresentativeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferActToRepresentativeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferActToRepresentativePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferActToRepresentativeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferActToRepresentativePayload>
          }
          findFirst: {
            args: Prisma.TransferActToRepresentativeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferActToRepresentativePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferActToRepresentativeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferActToRepresentativePayload>
          }
          findMany: {
            args: Prisma.TransferActToRepresentativeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferActToRepresentativePayload>[]
          }
          create: {
            args: Prisma.TransferActToRepresentativeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferActToRepresentativePayload>
          }
          createMany: {
            args: Prisma.TransferActToRepresentativeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TransferActToRepresentativeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferActToRepresentativePayload>
          }
          update: {
            args: Prisma.TransferActToRepresentativeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferActToRepresentativePayload>
          }
          deleteMany: {
            args: Prisma.TransferActToRepresentativeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TransferActToRepresentativeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TransferActToRepresentativeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferActToRepresentativePayload>
          }
          aggregate: {
            args: Prisma.TransferActToRepresentativeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTransferActToRepresentative>
          }
          groupBy: {
            args: Prisma.TransferActToRepresentativeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TransferActToRepresentativeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferActToRepresentativeCountArgs<ExtArgs>,
            result: $Utils.Optional<TransferActToRepresentativeCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    clientContracts: number
    agencyContracts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientContracts?: boolean | UserCountOutputTypeCountClientContractsArgs
    agencyContracts?: boolean | UserCountOutputTypeCountAgencyContractsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAgencyContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyContractWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    assignments: number
    clientsToClientIndividualMinorProperties: number
    clientContractsToClients: number
    representatives: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | ClientCountOutputTypeCountAssignmentsArgs
    clientsToClientIndividualMinorProperties?: boolean | ClientCountOutputTypeCountClientsToClientIndividualMinorPropertiesArgs
    clientContractsToClients?: boolean | ClientCountOutputTypeCountClientContractsToClientsArgs
    representatives?: boolean | ClientCountOutputTypeCountRepresentativesArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountClientsToClientIndividualMinorPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientToClientIndividualMinorPropertiesWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountClientContractsToClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractToClientWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountRepresentativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepresentativeWhereInput
  }


  /**
   * Count Type ClientIndividualMinorPropertiesCountOutputType
   */

  export type ClientIndividualMinorPropertiesCountOutputType = {
    clientsToClientIndividualMinorProperties: number
  }

  export type ClientIndividualMinorPropertiesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientsToClientIndividualMinorProperties?: boolean | ClientIndividualMinorPropertiesCountOutputTypeCountClientsToClientIndividualMinorPropertiesArgs
  }

  // Custom InputTypes
  /**
   * ClientIndividualMinorPropertiesCountOutputType without action
   */
  export type ClientIndividualMinorPropertiesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorPropertiesCountOutputType
     */
    select?: ClientIndividualMinorPropertiesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientIndividualMinorPropertiesCountOutputType without action
   */
  export type ClientIndividualMinorPropertiesCountOutputTypeCountClientsToClientIndividualMinorPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientToClientIndividualMinorPropertiesWhereInput
  }


  /**
   * Count Type ClientContractCountOutputType
   */

  export type ClientContractCountOutputType = {
    scheduledPayments: number
    actualPayments: number
    realEstateAgencyActs: number
    assignments: number
    clientContractsToClients: number
    clientContractsToAgencyContracts: number
  }

  export type ClientContractCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduledPayments?: boolean | ClientContractCountOutputTypeCountScheduledPaymentsArgs
    actualPayments?: boolean | ClientContractCountOutputTypeCountActualPaymentsArgs
    realEstateAgencyActs?: boolean | ClientContractCountOutputTypeCountRealEstateAgencyActsArgs
    assignments?: boolean | ClientContractCountOutputTypeCountAssignmentsArgs
    clientContractsToClients?: boolean | ClientContractCountOutputTypeCountClientContractsToClientsArgs
    clientContractsToAgencyContracts?: boolean | ClientContractCountOutputTypeCountClientContractsToAgencyContractsArgs
  }

  // Custom InputTypes
  /**
   * ClientContractCountOutputType without action
   */
  export type ClientContractCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractCountOutputType
     */
    select?: ClientContractCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientContractCountOutputType without action
   */
  export type ClientContractCountOutputTypeCountScheduledPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledPaymentWhereInput
  }

  /**
   * ClientContractCountOutputType without action
   */
  export type ClientContractCountOutputTypeCountActualPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActualPaymentWhereInput
  }

  /**
   * ClientContractCountOutputType without action
   */
  export type ClientContractCountOutputTypeCountRealEstateAgencyActsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RealEstateAgencyActWhereInput
  }

  /**
   * ClientContractCountOutputType without action
   */
  export type ClientContractCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * ClientContractCountOutputType without action
   */
  export type ClientContractCountOutputTypeCountClientContractsToClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractToClientWhereInput
  }

  /**
   * ClientContractCountOutputType without action
   */
  export type ClientContractCountOutputTypeCountClientContractsToAgencyContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractToAgencyContractWhereInput
  }


  /**
   * Count Type ObjectCountOutputType
   */

  export type ObjectCountOutputType = {
    products: number
    clientContracts: number
    agencyContracts: number
    transferActs: number
  }

  export type ObjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ObjectCountOutputTypeCountProductsArgs
    clientContracts?: boolean | ObjectCountOutputTypeCountClientContractsArgs
    agencyContracts?: boolean | ObjectCountOutputTypeCountAgencyContractsArgs
    transferActs?: boolean | ObjectCountOutputTypeCountTransferActsArgs
  }

  // Custom InputTypes
  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectCountOutputType
     */
    select?: ObjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeCountClientContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractWhereInput
  }

  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeCountAgencyContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyContractWhereInput
  }

  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeCountTransferActsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferActWhereInput
  }


  /**
   * Count Type AgencyCountOutputType
   */

  export type AgencyCountOutputType = {
    agencyContracts: number
    agencyContractSignatory: number
    realEstateAgencyActs: number
    agenciesToRealEstateAgents: number
  }

  export type AgencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agencyContracts?: boolean | AgencyCountOutputTypeCountAgencyContractsArgs
    agencyContractSignatory?: boolean | AgencyCountOutputTypeCountAgencyContractSignatoryArgs
    realEstateAgencyActs?: boolean | AgencyCountOutputTypeCountRealEstateAgencyActsArgs
    agenciesToRealEstateAgents?: boolean | AgencyCountOutputTypeCountAgenciesToRealEstateAgentsArgs
  }

  // Custom InputTypes
  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyCountOutputType
     */
    select?: AgencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountAgencyContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyContractWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountAgencyContractSignatoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyContractSignatoryWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountRealEstateAgencyActsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RealEstateAgencyActWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountAgenciesToRealEstateAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyToRealEstateAgentWhereInput
  }


  /**
   * Count Type AgencyContractCountOutputType
   */

  export type AgencyContractCountOutputType = {
    realEstateAgencyAct: number
    clientContractsToAgencyContracts: number
  }

  export type AgencyContractCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    realEstateAgencyAct?: boolean | AgencyContractCountOutputTypeCountRealEstateAgencyActArgs
    clientContractsToAgencyContracts?: boolean | AgencyContractCountOutputTypeCountClientContractsToAgencyContractsArgs
  }

  // Custom InputTypes
  /**
   * AgencyContractCountOutputType without action
   */
  export type AgencyContractCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCountOutputType
     */
    select?: AgencyContractCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgencyContractCountOutputType without action
   */
  export type AgencyContractCountOutputTypeCountRealEstateAgencyActArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RealEstateAgencyActWhereInput
  }

  /**
   * AgencyContractCountOutputType without action
   */
  export type AgencyContractCountOutputTypeCountClientContractsToAgencyContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractToAgencyContractWhereInput
  }


  /**
   * Count Type AgencyContractSignatoryCountOutputType
   */

  export type AgencyContractSignatoryCountOutputType = {
    agencyContracts: number
  }

  export type AgencyContractSignatoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agencyContracts?: boolean | AgencyContractSignatoryCountOutputTypeCountAgencyContractsArgs
  }

  // Custom InputTypes
  /**
   * AgencyContractSignatoryCountOutputType without action
   */
  export type AgencyContractSignatoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatoryCountOutputType
     */
    select?: AgencyContractSignatoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgencyContractSignatoryCountOutputType without action
   */
  export type AgencyContractSignatoryCountOutputTypeCountAgencyContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyContractWhereInput
  }


  /**
   * Count Type RealEstateAgentCountOutputType
   */

  export type RealEstateAgentCountOutputType = {
    clientContracts: number
    agenciesToRealEstateAgents: number
  }

  export type RealEstateAgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientContracts?: boolean | RealEstateAgentCountOutputTypeCountClientContractsArgs
    agenciesToRealEstateAgents?: boolean | RealEstateAgentCountOutputTypeCountAgenciesToRealEstateAgentsArgs
  }

  // Custom InputTypes
  /**
   * RealEstateAgentCountOutputType without action
   */
  export type RealEstateAgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgentCountOutputType
     */
    select?: RealEstateAgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RealEstateAgentCountOutputType without action
   */
  export type RealEstateAgentCountOutputTypeCountClientContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractWhereInput
  }

  /**
   * RealEstateAgentCountOutputType without action
   */
  export type RealEstateAgentCountOutputTypeCountAgenciesToRealEstateAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyToRealEstateAgentWhereInput
  }


  /**
   * Count Type EntityCountOutputType
   */

  export type EntityCountOutputType = {
    agencyContracts: number
    objects: number
    entityForbiddenWebsites: number
    entityForbiddenBrands: number
  }

  export type EntityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agencyContracts?: boolean | EntityCountOutputTypeCountAgencyContractsArgs
    objects?: boolean | EntityCountOutputTypeCountObjectsArgs
    entityForbiddenWebsites?: boolean | EntityCountOutputTypeCountEntityForbiddenWebsitesArgs
    entityForbiddenBrands?: boolean | EntityCountOutputTypeCountEntityForbiddenBrandsArgs
  }

  // Custom InputTypes
  /**
   * EntityCountOutputType without action
   */
  export type EntityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityCountOutputType
     */
    select?: EntityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EntityCountOutputType without action
   */
  export type EntityCountOutputTypeCountAgencyContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyContractWhereInput
  }

  /**
   * EntityCountOutputType without action
   */
  export type EntityCountOutputTypeCountObjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectWhereInput
  }

  /**
   * EntityCountOutputType without action
   */
  export type EntityCountOutputTypeCountEntityForbiddenWebsitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityForbiddenWebsiteWhereInput
  }

  /**
   * EntityCountOutputType without action
   */
  export type EntityCountOutputTypeCountEntityForbiddenBrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityForbiddenBrandWhereInput
  }


  /**
   * Count Type BankCountOutputType
   */

  export type BankCountOutputType = {
    clientContracts: number
  }

  export type BankCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientContracts?: boolean | BankCountOutputTypeCountClientContractsArgs
  }

  // Custom InputTypes
  /**
   * BankCountOutputType without action
   */
  export type BankCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankCountOutputType
     */
    select?: BankCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BankCountOutputType without action
   */
  export type BankCountOutputTypeCountClientContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractWhereInput
  }


  /**
   * Count Type SubsidyCountOutputType
   */

  export type SubsidyCountOutputType = {
    clientContracts: number
  }

  export type SubsidyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientContracts?: boolean | SubsidyCountOutputTypeCountClientContractsArgs
  }

  // Custom InputTypes
  /**
   * SubsidyCountOutputType without action
   */
  export type SubsidyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyCountOutputType
     */
    select?: SubsidyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubsidyCountOutputType without action
   */
  export type SubsidyCountOutputTypeCountClientContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractWhereInput
  }


  /**
   * Count Type TransferActCountOutputType
   */

  export type TransferActCountOutputType = {
    transferActsToRepresentatives: number
  }

  export type TransferActCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transferActsToRepresentatives?: boolean | TransferActCountOutputTypeCountTransferActsToRepresentativesArgs
  }

  // Custom InputTypes
  /**
   * TransferActCountOutputType without action
   */
  export type TransferActCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferActCountOutputType
     */
    select?: TransferActCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransferActCountOutputType without action
   */
  export type TransferActCountOutputTypeCountTransferActsToRepresentativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferActToRepresentativeWhereInput
  }


  /**
   * Count Type RepresentativeCountOutputType
   */

  export type RepresentativeCountOutputType = {
    transferActsToRepresentatives: number
  }

  export type RepresentativeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transferActsToRepresentatives?: boolean | RepresentativeCountOutputTypeCountTransferActsToRepresentativesArgs
  }

  // Custom InputTypes
  /**
   * RepresentativeCountOutputType without action
   */
  export type RepresentativeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepresentativeCountOutputType
     */
    select?: RepresentativeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RepresentativeCountOutputType without action
   */
  export type RepresentativeCountOutputTypeCountTransferActsToRepresentativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferActToRepresentativeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    fullName: string | null
    email: string | null
    phone: string | null
    isManager: boolean | null
    isStaff: boolean | null
    userRole: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    fullName: string | null
    email: string | null
    phone: string | null
    isManager: boolean | null
    isStaff: boolean | null
    userRole: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    fullName: number
    email: number
    phone: number
    isManager: number
    isStaff: number
    userRole: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    fullName?: true
    email?: true
    phone?: true
    isManager?: true
    isStaff?: true
    userRole?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    fullName?: true
    email?: true
    phone?: true
    isManager?: true
    isStaff?: true
    userRole?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    fullName?: true
    email?: true
    phone?: true
    isManager?: true
    isStaff?: true
    userRole?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    fullName: string
    email: string
    phone: string | null
    isManager: boolean
    isStaff: boolean
    userRole: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    isManager?: boolean
    isStaff?: boolean
    userRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientContracts?: boolean | User$clientContractsArgs<ExtArgs>
    agencyContracts?: boolean | User$agencyContractsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    isManager?: boolean
    isStaff?: boolean
    userRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientContracts?: boolean | User$clientContractsArgs<ExtArgs>
    agencyContracts?: boolean | User$agencyContractsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      clientContracts: Prisma.$ClientContractPayload<ExtArgs>[]
      agencyContracts: Prisma.$AgencyContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullName: string
      email: string
      phone: string | null
      isManager: boolean
      isStaff: boolean
      userRole: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    clientContracts<T extends User$clientContractsArgs<ExtArgs> = {}>(args?: Subset<T, User$clientContractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    agencyContracts<T extends User$agencyContractsArgs<ExtArgs> = {}>(args?: Subset<T, User$agencyContractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly isManager: FieldRef<"User", 'Boolean'>
    readonly isStaff: FieldRef<"User", 'Boolean'>
    readonly userRole: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.clientContracts
   */
  export type User$clientContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    where?: ClientContractWhereInput
    orderBy?: ClientContractOrderByWithRelationInput | ClientContractOrderByWithRelationInput[]
    cursor?: ClientContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientContractScalarFieldEnum | ClientContractScalarFieldEnum[]
  }

  /**
   * User.agencyContracts
   */
  export type User$agencyContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    where?: AgencyContractWhereInput
    orderBy?: AgencyContractOrderByWithRelationInput | AgencyContractOrderByWithRelationInput[]
    cursor?: AgencyContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyContractScalarFieldEnum | AgencyContractScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    id: number | null
    clientIndividualPropertiesId: number | null
    clientIndividualMinorPropertiesId: number | null
    clientEntityPropertiesId: number | null
  }

  export type ClientSumAggregateOutputType = {
    id: number | null
    clientIndividualPropertiesId: number | null
    clientIndividualMinorPropertiesId: number | null
    clientEntityPropertiesId: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: number | null
    fullName: string | null
    inn: string | null
    phone: string | null
    email: string | null
    address: string | null
    clientCategory: $Enums.ClientCategory | null
    clientIndividualPropertiesId: number | null
    clientIndividualMinorPropertiesId: number | null
    clientEntityPropertiesId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: number | null
    fullName: string | null
    inn: string | null
    phone: string | null
    email: string | null
    address: string | null
    clientCategory: $Enums.ClientCategory | null
    clientIndividualPropertiesId: number | null
    clientIndividualMinorPropertiesId: number | null
    clientEntityPropertiesId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    fullName: number
    inn: number
    phone: number
    email: number
    address: number
    clientCategory: number
    clientIndividualPropertiesId: number
    clientIndividualMinorPropertiesId: number
    clientEntityPropertiesId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    id?: true
    clientIndividualPropertiesId?: true
    clientIndividualMinorPropertiesId?: true
    clientEntityPropertiesId?: true
  }

  export type ClientSumAggregateInputType = {
    id?: true
    clientIndividualPropertiesId?: true
    clientIndividualMinorPropertiesId?: true
    clientEntityPropertiesId?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    fullName?: true
    inn?: true
    phone?: true
    email?: true
    address?: true
    clientCategory?: true
    clientIndividualPropertiesId?: true
    clientIndividualMinorPropertiesId?: true
    clientEntityPropertiesId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    fullName?: true
    inn?: true
    phone?: true
    email?: true
    address?: true
    clientCategory?: true
    clientIndividualPropertiesId?: true
    clientIndividualMinorPropertiesId?: true
    clientEntityPropertiesId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    fullName?: true
    inn?: true
    phone?: true
    email?: true
    address?: true
    clientCategory?: true
    clientIndividualPropertiesId?: true
    clientIndividualMinorPropertiesId?: true
    clientEntityPropertiesId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: number
    fullName: string
    inn: string | null
    phone: string | null
    email: string | null
    address: string | null
    clientCategory: $Enums.ClientCategory
    clientIndividualPropertiesId: number | null
    clientIndividualMinorPropertiesId: number | null
    clientEntityPropertiesId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    inn?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    clientCategory?: boolean
    clientIndividualPropertiesId?: boolean
    clientIndividualMinorPropertiesId?: boolean
    clientEntityPropertiesId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientIndividualProperties?: boolean | Client$clientIndividualPropertiesArgs<ExtArgs>
    clientIndividualMinorProperties?: boolean | Client$clientIndividualMinorPropertiesArgs<ExtArgs>
    clientEntityProperties?: boolean | Client$clientEntityPropertiesArgs<ExtArgs>
    assignments?: boolean | Client$assignmentsArgs<ExtArgs>
    clientsToClientIndividualMinorProperties?: boolean | Client$clientsToClientIndividualMinorPropertiesArgs<ExtArgs>
    clientContractsToClients?: boolean | Client$clientContractsToClientsArgs<ExtArgs>
    representatives?: boolean | Client$representativesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>


  export type ClientSelectScalar = {
    id?: boolean
    fullName?: boolean
    inn?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    clientCategory?: boolean
    clientIndividualPropertiesId?: boolean
    clientIndividualMinorPropertiesId?: boolean
    clientEntityPropertiesId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientIndividualProperties?: boolean | Client$clientIndividualPropertiesArgs<ExtArgs>
    clientIndividualMinorProperties?: boolean | Client$clientIndividualMinorPropertiesArgs<ExtArgs>
    clientEntityProperties?: boolean | Client$clientEntityPropertiesArgs<ExtArgs>
    assignments?: boolean | Client$assignmentsArgs<ExtArgs>
    clientsToClientIndividualMinorProperties?: boolean | Client$clientsToClientIndividualMinorPropertiesArgs<ExtArgs>
    clientContractsToClients?: boolean | Client$clientContractsToClientsArgs<ExtArgs>
    representatives?: boolean | Client$representativesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      clientIndividualProperties: Prisma.$ClientIndividualPropertiesPayload<ExtArgs> | null
      clientIndividualMinorProperties: Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs> | null
      clientEntityProperties: Prisma.$ClientEntityPropertiesPayload<ExtArgs> | null
      assignments: Prisma.$AssignmentPayload<ExtArgs>[]
      clientsToClientIndividualMinorProperties: Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>[]
      clientContractsToClients: Prisma.$ClientContractToClientPayload<ExtArgs>[]
      representatives: Prisma.$RepresentativePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullName: string
      inn: string | null
      phone: string | null
      email: string | null
      address: string | null
      clientCategory: $Enums.ClientCategory
      clientIndividualPropertiesId: number | null
      clientIndividualMinorPropertiesId: number | null
      clientEntityPropertiesId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
    **/
    create<T extends ClientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientCreateArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
    **/
    delete<T extends ClientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
    **/
    upsert<T extends ClientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    clientIndividualProperties<T extends Client$clientIndividualPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, Client$clientIndividualPropertiesArgs<ExtArgs>>): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    clientIndividualMinorProperties<T extends Client$clientIndividualMinorPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, Client$clientIndividualMinorPropertiesArgs<ExtArgs>>): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    clientEntityProperties<T extends Client$clientEntityPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, Client$clientEntityPropertiesArgs<ExtArgs>>): Prisma__ClientEntityPropertiesClient<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    assignments<T extends Client$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Client$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    clientsToClientIndividualMinorProperties<T extends Client$clientsToClientIndividualMinorPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, Client$clientsToClientIndividualMinorPropertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findMany'> | Null>;

    clientContractsToClients<T extends Client$clientContractsToClientsArgs<ExtArgs> = {}>(args?: Subset<T, Client$clientContractsToClientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'findMany'> | Null>;

    representatives<T extends Client$representativesArgs<ExtArgs> = {}>(args?: Subset<T, Client$representativesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Client model
   */ 
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'Int'>
    readonly fullName: FieldRef<"Client", 'String'>
    readonly inn: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly address: FieldRef<"Client", 'String'>
    readonly clientCategory: FieldRef<"Client", 'ClientCategory'>
    readonly clientIndividualPropertiesId: FieldRef<"Client", 'Int'>
    readonly clientIndividualMinorPropertiesId: FieldRef<"Client", 'Int'>
    readonly clientEntityPropertiesId: FieldRef<"Client", 'Int'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
  }

  /**
   * Client.clientIndividualProperties
   */
  export type Client$clientIndividualPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    where?: ClientIndividualPropertiesWhereInput
  }

  /**
   * Client.clientIndividualMinorProperties
   */
  export type Client$clientIndividualMinorPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    where?: ClientIndividualMinorPropertiesWhereInput
  }

  /**
   * Client.clientEntityProperties
   */
  export type Client$clientEntityPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    where?: ClientEntityPropertiesWhereInput
  }

  /**
   * Client.assignments
   */
  export type Client$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Client.clientsToClientIndividualMinorProperties
   */
  export type Client$clientsToClientIndividualMinorPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    where?: ClientToClientIndividualMinorPropertiesWhereInput
    orderBy?: ClientToClientIndividualMinorPropertiesOrderByWithRelationInput | ClientToClientIndividualMinorPropertiesOrderByWithRelationInput[]
    cursor?: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientToClientIndividualMinorPropertiesScalarFieldEnum | ClientToClientIndividualMinorPropertiesScalarFieldEnum[]
  }

  /**
   * Client.clientContractsToClients
   */
  export type Client$clientContractsToClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    where?: ClientContractToClientWhereInput
    orderBy?: ClientContractToClientOrderByWithRelationInput | ClientContractToClientOrderByWithRelationInput[]
    cursor?: ClientContractToClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientContractToClientScalarFieldEnum | ClientContractToClientScalarFieldEnum[]
  }

  /**
   * Client.representatives
   */
  export type Client$representativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    where?: RepresentativeWhereInput
    orderBy?: RepresentativeOrderByWithRelationInput | RepresentativeOrderByWithRelationInput[]
    cursor?: RepresentativeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RepresentativeScalarFieldEnum | RepresentativeScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model ClientIndividualProperties
   */

  export type AggregateClientIndividualProperties = {
    _count: ClientIndividualPropertiesCountAggregateOutputType | null
    _avg: ClientIndividualPropertiesAvgAggregateOutputType | null
    _sum: ClientIndividualPropertiesSumAggregateOutputType | null
    _min: ClientIndividualPropertiesMinAggregateOutputType | null
    _max: ClientIndividualPropertiesMaxAggregateOutputType | null
  }

  export type ClientIndividualPropertiesAvgAggregateOutputType = {
    id: number | null
    clientPassportId: number | null
  }

  export type ClientIndividualPropertiesSumAggregateOutputType = {
    id: number | null
    clientPassportId: number | null
  }

  export type ClientIndividualPropertiesMinAggregateOutputType = {
    id: number | null
    dob: Date | null
    snils: string | null
    clientPassportId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientIndividualPropertiesMaxAggregateOutputType = {
    id: number | null
    dob: Date | null
    snils: string | null
    clientPassportId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientIndividualPropertiesCountAggregateOutputType = {
    id: number
    dob: number
    snils: number
    clientPassportId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientIndividualPropertiesAvgAggregateInputType = {
    id?: true
    clientPassportId?: true
  }

  export type ClientIndividualPropertiesSumAggregateInputType = {
    id?: true
    clientPassportId?: true
  }

  export type ClientIndividualPropertiesMinAggregateInputType = {
    id?: true
    dob?: true
    snils?: true
    clientPassportId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientIndividualPropertiesMaxAggregateInputType = {
    id?: true
    dob?: true
    snils?: true
    clientPassportId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientIndividualPropertiesCountAggregateInputType = {
    id?: true
    dob?: true
    snils?: true
    clientPassportId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientIndividualPropertiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientIndividualProperties to aggregate.
     */
    where?: ClientIndividualPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientIndividualProperties to fetch.
     */
    orderBy?: ClientIndividualPropertiesOrderByWithRelationInput | ClientIndividualPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientIndividualPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientIndividualProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientIndividualProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientIndividualProperties
    **/
    _count?: true | ClientIndividualPropertiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientIndividualPropertiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientIndividualPropertiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientIndividualPropertiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientIndividualPropertiesMaxAggregateInputType
  }

  export type GetClientIndividualPropertiesAggregateType<T extends ClientIndividualPropertiesAggregateArgs> = {
        [P in keyof T & keyof AggregateClientIndividualProperties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientIndividualProperties[P]>
      : GetScalarType<T[P], AggregateClientIndividualProperties[P]>
  }




  export type ClientIndividualPropertiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientIndividualPropertiesWhereInput
    orderBy?: ClientIndividualPropertiesOrderByWithAggregationInput | ClientIndividualPropertiesOrderByWithAggregationInput[]
    by: ClientIndividualPropertiesScalarFieldEnum[] | ClientIndividualPropertiesScalarFieldEnum
    having?: ClientIndividualPropertiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientIndividualPropertiesCountAggregateInputType | true
    _avg?: ClientIndividualPropertiesAvgAggregateInputType
    _sum?: ClientIndividualPropertiesSumAggregateInputType
    _min?: ClientIndividualPropertiesMinAggregateInputType
    _max?: ClientIndividualPropertiesMaxAggregateInputType
  }

  export type ClientIndividualPropertiesGroupByOutputType = {
    id: number
    dob: Date | null
    snils: string | null
    clientPassportId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ClientIndividualPropertiesCountAggregateOutputType | null
    _avg: ClientIndividualPropertiesAvgAggregateOutputType | null
    _sum: ClientIndividualPropertiesSumAggregateOutputType | null
    _min: ClientIndividualPropertiesMinAggregateOutputType | null
    _max: ClientIndividualPropertiesMaxAggregateOutputType | null
  }

  type GetClientIndividualPropertiesGroupByPayload<T extends ClientIndividualPropertiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientIndividualPropertiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientIndividualPropertiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientIndividualPropertiesGroupByOutputType[P]>
            : GetScalarType<T[P], ClientIndividualPropertiesGroupByOutputType[P]>
        }
      >
    >


  export type ClientIndividualPropertiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dob?: boolean
    snils?: boolean
    clientPassportId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientIndividualProperties$clientArgs<ExtArgs>
    clientPassport?: boolean | ClientIndividualProperties$clientPassportArgs<ExtArgs>
  }, ExtArgs["result"]["clientIndividualProperties"]>


  export type ClientIndividualPropertiesSelectScalar = {
    id?: boolean
    dob?: boolean
    snils?: boolean
    clientPassportId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientIndividualPropertiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientIndividualProperties$clientArgs<ExtArgs>
    clientPassport?: boolean | ClientIndividualProperties$clientPassportArgs<ExtArgs>
  }

  export type $ClientIndividualPropertiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientIndividualProperties"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      clientPassport: Prisma.$ClientPassportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dob: Date | null
      snils: string | null
      clientPassportId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientIndividualProperties"]>
    composites: {}
  }

  type ClientIndividualPropertiesGetPayload<S extends boolean | null | undefined | ClientIndividualPropertiesDefaultArgs> = $Result.GetResult<Prisma.$ClientIndividualPropertiesPayload, S>

  type ClientIndividualPropertiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientIndividualPropertiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientIndividualPropertiesCountAggregateInputType | true
    }

  export interface ClientIndividualPropertiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientIndividualProperties'], meta: { name: 'ClientIndividualProperties' } }
    /**
     * Find zero or one ClientIndividualProperties that matches the filter.
     * @param {ClientIndividualPropertiesFindUniqueArgs} args - Arguments to find a ClientIndividualProperties
     * @example
     * // Get one ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientIndividualPropertiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualPropertiesFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClientIndividualProperties that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientIndividualPropertiesFindUniqueOrThrowArgs} args - Arguments to find a ClientIndividualProperties
     * @example
     * // Get one ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientIndividualPropertiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualPropertiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClientIndividualProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualPropertiesFindFirstArgs} args - Arguments to find a ClientIndividualProperties
     * @example
     * // Get one ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientIndividualPropertiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualPropertiesFindFirstArgs<ExtArgs>>
    ): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClientIndividualProperties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualPropertiesFindFirstOrThrowArgs} args - Arguments to find a ClientIndividualProperties
     * @example
     * // Get one ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientIndividualPropertiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualPropertiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClientIndividualProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualPropertiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.findMany()
     * 
     * // Get first 10 ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientIndividualPropertiesWithIdOnly = await prisma.clientIndividualProperties.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientIndividualPropertiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualPropertiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClientIndividualProperties.
     * @param {ClientIndividualPropertiesCreateArgs} args - Arguments to create a ClientIndividualProperties.
     * @example
     * // Create one ClientIndividualProperties
     * const ClientIndividualProperties = await prisma.clientIndividualProperties.create({
     *   data: {
     *     // ... data to create a ClientIndividualProperties
     *   }
     * })
     * 
    **/
    create<T extends ClientIndividualPropertiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualPropertiesCreateArgs<ExtArgs>>
    ): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClientIndividualProperties.
     * @param {ClientIndividualPropertiesCreateManyArgs} args - Arguments to create many ClientIndividualProperties.
     * @example
     * // Create many ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientIndividualPropertiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualPropertiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientIndividualProperties.
     * @param {ClientIndividualPropertiesDeleteArgs} args - Arguments to delete one ClientIndividualProperties.
     * @example
     * // Delete one ClientIndividualProperties
     * const ClientIndividualProperties = await prisma.clientIndividualProperties.delete({
     *   where: {
     *     // ... filter to delete one ClientIndividualProperties
     *   }
     * })
     * 
    **/
    delete<T extends ClientIndividualPropertiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualPropertiesDeleteArgs<ExtArgs>>
    ): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClientIndividualProperties.
     * @param {ClientIndividualPropertiesUpdateArgs} args - Arguments to update one ClientIndividualProperties.
     * @example
     * // Update one ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientIndividualPropertiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualPropertiesUpdateArgs<ExtArgs>>
    ): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClientIndividualProperties.
     * @param {ClientIndividualPropertiesDeleteManyArgs} args - Arguments to filter ClientIndividualProperties to delete.
     * @example
     * // Delete a few ClientIndividualProperties
     * const { count } = await prisma.clientIndividualProperties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientIndividualPropertiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualPropertiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientIndividualProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualPropertiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientIndividualPropertiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualPropertiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientIndividualProperties.
     * @param {ClientIndividualPropertiesUpsertArgs} args - Arguments to update or create a ClientIndividualProperties.
     * @example
     * // Update or create a ClientIndividualProperties
     * const clientIndividualProperties = await prisma.clientIndividualProperties.upsert({
     *   create: {
     *     // ... data to create a ClientIndividualProperties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientIndividualProperties we want to update
     *   }
     * })
    **/
    upsert<T extends ClientIndividualPropertiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualPropertiesUpsertArgs<ExtArgs>>
    ): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClientIndividualProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualPropertiesCountArgs} args - Arguments to filter ClientIndividualProperties to count.
     * @example
     * // Count the number of ClientIndividualProperties
     * const count = await prisma.clientIndividualProperties.count({
     *   where: {
     *     // ... the filter for the ClientIndividualProperties we want to count
     *   }
     * })
    **/
    count<T extends ClientIndividualPropertiesCountArgs>(
      args?: Subset<T, ClientIndividualPropertiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientIndividualPropertiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientIndividualProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualPropertiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientIndividualPropertiesAggregateArgs>(args: Subset<T, ClientIndividualPropertiesAggregateArgs>): Prisma.PrismaPromise<GetClientIndividualPropertiesAggregateType<T>>

    /**
     * Group by ClientIndividualProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualPropertiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientIndividualPropertiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientIndividualPropertiesGroupByArgs['orderBy'] }
        : { orderBy?: ClientIndividualPropertiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientIndividualPropertiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientIndividualPropertiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientIndividualProperties model
   */
  readonly fields: ClientIndividualPropertiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientIndividualProperties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientIndividualPropertiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client<T extends ClientIndividualProperties$clientArgs<ExtArgs> = {}>(args?: Subset<T, ClientIndividualProperties$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    clientPassport<T extends ClientIndividualProperties$clientPassportArgs<ExtArgs> = {}>(args?: Subset<T, ClientIndividualProperties$clientPassportArgs<ExtArgs>>): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClientIndividualProperties model
   */ 
  interface ClientIndividualPropertiesFieldRefs {
    readonly id: FieldRef<"ClientIndividualProperties", 'Int'>
    readonly dob: FieldRef<"ClientIndividualProperties", 'DateTime'>
    readonly snils: FieldRef<"ClientIndividualProperties", 'String'>
    readonly clientPassportId: FieldRef<"ClientIndividualProperties", 'Int'>
    readonly createdAt: FieldRef<"ClientIndividualProperties", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientIndividualProperties", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientIndividualProperties findUnique
   */
  export type ClientIndividualPropertiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualProperties to fetch.
     */
    where: ClientIndividualPropertiesWhereUniqueInput
  }

  /**
   * ClientIndividualProperties findUniqueOrThrow
   */
  export type ClientIndividualPropertiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualProperties to fetch.
     */
    where: ClientIndividualPropertiesWhereUniqueInput
  }

  /**
   * ClientIndividualProperties findFirst
   */
  export type ClientIndividualPropertiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualProperties to fetch.
     */
    where?: ClientIndividualPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientIndividualProperties to fetch.
     */
    orderBy?: ClientIndividualPropertiesOrderByWithRelationInput | ClientIndividualPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientIndividualProperties.
     */
    cursor?: ClientIndividualPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientIndividualProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientIndividualProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientIndividualProperties.
     */
    distinct?: ClientIndividualPropertiesScalarFieldEnum | ClientIndividualPropertiesScalarFieldEnum[]
  }

  /**
   * ClientIndividualProperties findFirstOrThrow
   */
  export type ClientIndividualPropertiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualProperties to fetch.
     */
    where?: ClientIndividualPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientIndividualProperties to fetch.
     */
    orderBy?: ClientIndividualPropertiesOrderByWithRelationInput | ClientIndividualPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientIndividualProperties.
     */
    cursor?: ClientIndividualPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientIndividualProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientIndividualProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientIndividualProperties.
     */
    distinct?: ClientIndividualPropertiesScalarFieldEnum | ClientIndividualPropertiesScalarFieldEnum[]
  }

  /**
   * ClientIndividualProperties findMany
   */
  export type ClientIndividualPropertiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualProperties to fetch.
     */
    where?: ClientIndividualPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientIndividualProperties to fetch.
     */
    orderBy?: ClientIndividualPropertiesOrderByWithRelationInput | ClientIndividualPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientIndividualProperties.
     */
    cursor?: ClientIndividualPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientIndividualProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientIndividualProperties.
     */
    skip?: number
    distinct?: ClientIndividualPropertiesScalarFieldEnum | ClientIndividualPropertiesScalarFieldEnum[]
  }

  /**
   * ClientIndividualProperties create
   */
  export type ClientIndividualPropertiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientIndividualProperties.
     */
    data: XOR<ClientIndividualPropertiesCreateInput, ClientIndividualPropertiesUncheckedCreateInput>
  }

  /**
   * ClientIndividualProperties createMany
   */
  export type ClientIndividualPropertiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientIndividualProperties.
     */
    data: ClientIndividualPropertiesCreateManyInput | ClientIndividualPropertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientIndividualProperties update
   */
  export type ClientIndividualPropertiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientIndividualProperties.
     */
    data: XOR<ClientIndividualPropertiesUpdateInput, ClientIndividualPropertiesUncheckedUpdateInput>
    /**
     * Choose, which ClientIndividualProperties to update.
     */
    where: ClientIndividualPropertiesWhereUniqueInput
  }

  /**
   * ClientIndividualProperties updateMany
   */
  export type ClientIndividualPropertiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientIndividualProperties.
     */
    data: XOR<ClientIndividualPropertiesUpdateManyMutationInput, ClientIndividualPropertiesUncheckedUpdateManyInput>
    /**
     * Filter which ClientIndividualProperties to update
     */
    where?: ClientIndividualPropertiesWhereInput
  }

  /**
   * ClientIndividualProperties upsert
   */
  export type ClientIndividualPropertiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientIndividualProperties to update in case it exists.
     */
    where: ClientIndividualPropertiesWhereUniqueInput
    /**
     * In case the ClientIndividualProperties found by the `where` argument doesn't exist, create a new ClientIndividualProperties with this data.
     */
    create: XOR<ClientIndividualPropertiesCreateInput, ClientIndividualPropertiesUncheckedCreateInput>
    /**
     * In case the ClientIndividualProperties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientIndividualPropertiesUpdateInput, ClientIndividualPropertiesUncheckedUpdateInput>
  }

  /**
   * ClientIndividualProperties delete
   */
  export type ClientIndividualPropertiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    /**
     * Filter which ClientIndividualProperties to delete.
     */
    where: ClientIndividualPropertiesWhereUniqueInput
  }

  /**
   * ClientIndividualProperties deleteMany
   */
  export type ClientIndividualPropertiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientIndividualProperties to delete
     */
    where?: ClientIndividualPropertiesWhereInput
  }

  /**
   * ClientIndividualProperties.client
   */
  export type ClientIndividualProperties$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * ClientIndividualProperties.clientPassport
   */
  export type ClientIndividualProperties$clientPassportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    where?: ClientPassportWhereInput
  }

  /**
   * ClientIndividualProperties without action
   */
  export type ClientIndividualPropertiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
  }


  /**
   * Model ClientIndividualMinorProperties
   */

  export type AggregateClientIndividualMinorProperties = {
    _count: ClientIndividualMinorPropertiesCountAggregateOutputType | null
    _avg: ClientIndividualMinorPropertiesAvgAggregateOutputType | null
    _sum: ClientIndividualMinorPropertiesSumAggregateOutputType | null
    _min: ClientIndividualMinorPropertiesMinAggregateOutputType | null
    _max: ClientIndividualMinorPropertiesMaxAggregateOutputType | null
  }

  export type ClientIndividualMinorPropertiesAvgAggregateOutputType = {
    id: number | null
    clientPassportId: number | null
  }

  export type ClientIndividualMinorPropertiesSumAggregateOutputType = {
    id: number | null
    clientPassportId: number | null
  }

  export type ClientIndividualMinorPropertiesMinAggregateOutputType = {
    id: number | null
    dob: Date | null
    snils: string | null
    birthCertificate: string | null
    clientPassportId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientIndividualMinorPropertiesMaxAggregateOutputType = {
    id: number | null
    dob: Date | null
    snils: string | null
    birthCertificate: string | null
    clientPassportId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientIndividualMinorPropertiesCountAggregateOutputType = {
    id: number
    dob: number
    snils: number
    birthCertificate: number
    clientPassportId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientIndividualMinorPropertiesAvgAggregateInputType = {
    id?: true
    clientPassportId?: true
  }

  export type ClientIndividualMinorPropertiesSumAggregateInputType = {
    id?: true
    clientPassportId?: true
  }

  export type ClientIndividualMinorPropertiesMinAggregateInputType = {
    id?: true
    dob?: true
    snils?: true
    birthCertificate?: true
    clientPassportId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientIndividualMinorPropertiesMaxAggregateInputType = {
    id?: true
    dob?: true
    snils?: true
    birthCertificate?: true
    clientPassportId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientIndividualMinorPropertiesCountAggregateInputType = {
    id?: true
    dob?: true
    snils?: true
    birthCertificate?: true
    clientPassportId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientIndividualMinorPropertiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientIndividualMinorProperties to aggregate.
     */
    where?: ClientIndividualMinorPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientIndividualMinorProperties to fetch.
     */
    orderBy?: ClientIndividualMinorPropertiesOrderByWithRelationInput | ClientIndividualMinorPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientIndividualMinorProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientIndividualMinorProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientIndividualMinorProperties
    **/
    _count?: true | ClientIndividualMinorPropertiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientIndividualMinorPropertiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientIndividualMinorPropertiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientIndividualMinorPropertiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientIndividualMinorPropertiesMaxAggregateInputType
  }

  export type GetClientIndividualMinorPropertiesAggregateType<T extends ClientIndividualMinorPropertiesAggregateArgs> = {
        [P in keyof T & keyof AggregateClientIndividualMinorProperties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientIndividualMinorProperties[P]>
      : GetScalarType<T[P], AggregateClientIndividualMinorProperties[P]>
  }




  export type ClientIndividualMinorPropertiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientIndividualMinorPropertiesWhereInput
    orderBy?: ClientIndividualMinorPropertiesOrderByWithAggregationInput | ClientIndividualMinorPropertiesOrderByWithAggregationInput[]
    by: ClientIndividualMinorPropertiesScalarFieldEnum[] | ClientIndividualMinorPropertiesScalarFieldEnum
    having?: ClientIndividualMinorPropertiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientIndividualMinorPropertiesCountAggregateInputType | true
    _avg?: ClientIndividualMinorPropertiesAvgAggregateInputType
    _sum?: ClientIndividualMinorPropertiesSumAggregateInputType
    _min?: ClientIndividualMinorPropertiesMinAggregateInputType
    _max?: ClientIndividualMinorPropertiesMaxAggregateInputType
  }

  export type ClientIndividualMinorPropertiesGroupByOutputType = {
    id: number
    dob: Date | null
    snils: string | null
    birthCertificate: string | null
    clientPassportId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ClientIndividualMinorPropertiesCountAggregateOutputType | null
    _avg: ClientIndividualMinorPropertiesAvgAggregateOutputType | null
    _sum: ClientIndividualMinorPropertiesSumAggregateOutputType | null
    _min: ClientIndividualMinorPropertiesMinAggregateOutputType | null
    _max: ClientIndividualMinorPropertiesMaxAggregateOutputType | null
  }

  type GetClientIndividualMinorPropertiesGroupByPayload<T extends ClientIndividualMinorPropertiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientIndividualMinorPropertiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientIndividualMinorPropertiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientIndividualMinorPropertiesGroupByOutputType[P]>
            : GetScalarType<T[P], ClientIndividualMinorPropertiesGroupByOutputType[P]>
        }
      >
    >


  export type ClientIndividualMinorPropertiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dob?: boolean
    snils?: boolean
    birthCertificate?: boolean
    clientPassportId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientIndividualMinorProperties$clientArgs<ExtArgs>
    clientPassport?: boolean | ClientIndividualMinorProperties$clientPassportArgs<ExtArgs>
    clientsToClientIndividualMinorProperties?: boolean | ClientIndividualMinorProperties$clientsToClientIndividualMinorPropertiesArgs<ExtArgs>
    _count?: boolean | ClientIndividualMinorPropertiesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientIndividualMinorProperties"]>


  export type ClientIndividualMinorPropertiesSelectScalar = {
    id?: boolean
    dob?: boolean
    snils?: boolean
    birthCertificate?: boolean
    clientPassportId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientIndividualMinorPropertiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientIndividualMinorProperties$clientArgs<ExtArgs>
    clientPassport?: boolean | ClientIndividualMinorProperties$clientPassportArgs<ExtArgs>
    clientsToClientIndividualMinorProperties?: boolean | ClientIndividualMinorProperties$clientsToClientIndividualMinorPropertiesArgs<ExtArgs>
    _count?: boolean | ClientIndividualMinorPropertiesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClientIndividualMinorPropertiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientIndividualMinorProperties"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      clientPassport: Prisma.$ClientPassportPayload<ExtArgs> | null
      clientsToClientIndividualMinorProperties: Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dob: Date | null
      snils: string | null
      birthCertificate: string | null
      clientPassportId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientIndividualMinorProperties"]>
    composites: {}
  }

  type ClientIndividualMinorPropertiesGetPayload<S extends boolean | null | undefined | ClientIndividualMinorPropertiesDefaultArgs> = $Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload, S>

  type ClientIndividualMinorPropertiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientIndividualMinorPropertiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientIndividualMinorPropertiesCountAggregateInputType | true
    }

  export interface ClientIndividualMinorPropertiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientIndividualMinorProperties'], meta: { name: 'ClientIndividualMinorProperties' } }
    /**
     * Find zero or one ClientIndividualMinorProperties that matches the filter.
     * @param {ClientIndividualMinorPropertiesFindUniqueArgs} args - Arguments to find a ClientIndividualMinorProperties
     * @example
     * // Get one ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientIndividualMinorPropertiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualMinorPropertiesFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClientIndividualMinorProperties that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientIndividualMinorPropertiesFindUniqueOrThrowArgs} args - Arguments to find a ClientIndividualMinorProperties
     * @example
     * // Get one ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientIndividualMinorPropertiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualMinorPropertiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClientIndividualMinorProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualMinorPropertiesFindFirstArgs} args - Arguments to find a ClientIndividualMinorProperties
     * @example
     * // Get one ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientIndividualMinorPropertiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualMinorPropertiesFindFirstArgs<ExtArgs>>
    ): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClientIndividualMinorProperties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualMinorPropertiesFindFirstOrThrowArgs} args - Arguments to find a ClientIndividualMinorProperties
     * @example
     * // Get one ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientIndividualMinorPropertiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualMinorPropertiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClientIndividualMinorProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualMinorPropertiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.findMany()
     * 
     * // Get first 10 ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientIndividualMinorPropertiesWithIdOnly = await prisma.clientIndividualMinorProperties.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientIndividualMinorPropertiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualMinorPropertiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClientIndividualMinorProperties.
     * @param {ClientIndividualMinorPropertiesCreateArgs} args - Arguments to create a ClientIndividualMinorProperties.
     * @example
     * // Create one ClientIndividualMinorProperties
     * const ClientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.create({
     *   data: {
     *     // ... data to create a ClientIndividualMinorProperties
     *   }
     * })
     * 
    **/
    create<T extends ClientIndividualMinorPropertiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualMinorPropertiesCreateArgs<ExtArgs>>
    ): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClientIndividualMinorProperties.
     * @param {ClientIndividualMinorPropertiesCreateManyArgs} args - Arguments to create many ClientIndividualMinorProperties.
     * @example
     * // Create many ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientIndividualMinorPropertiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualMinorPropertiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientIndividualMinorProperties.
     * @param {ClientIndividualMinorPropertiesDeleteArgs} args - Arguments to delete one ClientIndividualMinorProperties.
     * @example
     * // Delete one ClientIndividualMinorProperties
     * const ClientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.delete({
     *   where: {
     *     // ... filter to delete one ClientIndividualMinorProperties
     *   }
     * })
     * 
    **/
    delete<T extends ClientIndividualMinorPropertiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualMinorPropertiesDeleteArgs<ExtArgs>>
    ): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClientIndividualMinorProperties.
     * @param {ClientIndividualMinorPropertiesUpdateArgs} args - Arguments to update one ClientIndividualMinorProperties.
     * @example
     * // Update one ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientIndividualMinorPropertiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualMinorPropertiesUpdateArgs<ExtArgs>>
    ): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClientIndividualMinorProperties.
     * @param {ClientIndividualMinorPropertiesDeleteManyArgs} args - Arguments to filter ClientIndividualMinorProperties to delete.
     * @example
     * // Delete a few ClientIndividualMinorProperties
     * const { count } = await prisma.clientIndividualMinorProperties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientIndividualMinorPropertiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientIndividualMinorPropertiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientIndividualMinorProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualMinorPropertiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientIndividualMinorPropertiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualMinorPropertiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientIndividualMinorProperties.
     * @param {ClientIndividualMinorPropertiesUpsertArgs} args - Arguments to update or create a ClientIndividualMinorProperties.
     * @example
     * // Update or create a ClientIndividualMinorProperties
     * const clientIndividualMinorProperties = await prisma.clientIndividualMinorProperties.upsert({
     *   create: {
     *     // ... data to create a ClientIndividualMinorProperties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientIndividualMinorProperties we want to update
     *   }
     * })
    **/
    upsert<T extends ClientIndividualMinorPropertiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientIndividualMinorPropertiesUpsertArgs<ExtArgs>>
    ): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClientIndividualMinorProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualMinorPropertiesCountArgs} args - Arguments to filter ClientIndividualMinorProperties to count.
     * @example
     * // Count the number of ClientIndividualMinorProperties
     * const count = await prisma.clientIndividualMinorProperties.count({
     *   where: {
     *     // ... the filter for the ClientIndividualMinorProperties we want to count
     *   }
     * })
    **/
    count<T extends ClientIndividualMinorPropertiesCountArgs>(
      args?: Subset<T, ClientIndividualMinorPropertiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientIndividualMinorPropertiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientIndividualMinorProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualMinorPropertiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientIndividualMinorPropertiesAggregateArgs>(args: Subset<T, ClientIndividualMinorPropertiesAggregateArgs>): Prisma.PrismaPromise<GetClientIndividualMinorPropertiesAggregateType<T>>

    /**
     * Group by ClientIndividualMinorProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientIndividualMinorPropertiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientIndividualMinorPropertiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientIndividualMinorPropertiesGroupByArgs['orderBy'] }
        : { orderBy?: ClientIndividualMinorPropertiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientIndividualMinorPropertiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientIndividualMinorPropertiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientIndividualMinorProperties model
   */
  readonly fields: ClientIndividualMinorPropertiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientIndividualMinorProperties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientIndividualMinorPropertiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client<T extends ClientIndividualMinorProperties$clientArgs<ExtArgs> = {}>(args?: Subset<T, ClientIndividualMinorProperties$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    clientPassport<T extends ClientIndividualMinorProperties$clientPassportArgs<ExtArgs> = {}>(args?: Subset<T, ClientIndividualMinorProperties$clientPassportArgs<ExtArgs>>): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    clientsToClientIndividualMinorProperties<T extends ClientIndividualMinorProperties$clientsToClientIndividualMinorPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, ClientIndividualMinorProperties$clientsToClientIndividualMinorPropertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClientIndividualMinorProperties model
   */ 
  interface ClientIndividualMinorPropertiesFieldRefs {
    readonly id: FieldRef<"ClientIndividualMinorProperties", 'Int'>
    readonly dob: FieldRef<"ClientIndividualMinorProperties", 'DateTime'>
    readonly snils: FieldRef<"ClientIndividualMinorProperties", 'String'>
    readonly birthCertificate: FieldRef<"ClientIndividualMinorProperties", 'String'>
    readonly clientPassportId: FieldRef<"ClientIndividualMinorProperties", 'Int'>
    readonly createdAt: FieldRef<"ClientIndividualMinorProperties", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientIndividualMinorProperties", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientIndividualMinorProperties findUnique
   */
  export type ClientIndividualMinorPropertiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualMinorProperties to fetch.
     */
    where: ClientIndividualMinorPropertiesWhereUniqueInput
  }

  /**
   * ClientIndividualMinorProperties findUniqueOrThrow
   */
  export type ClientIndividualMinorPropertiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualMinorProperties to fetch.
     */
    where: ClientIndividualMinorPropertiesWhereUniqueInput
  }

  /**
   * ClientIndividualMinorProperties findFirst
   */
  export type ClientIndividualMinorPropertiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualMinorProperties to fetch.
     */
    where?: ClientIndividualMinorPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientIndividualMinorProperties to fetch.
     */
    orderBy?: ClientIndividualMinorPropertiesOrderByWithRelationInput | ClientIndividualMinorPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientIndividualMinorProperties.
     */
    cursor?: ClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientIndividualMinorProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientIndividualMinorProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientIndividualMinorProperties.
     */
    distinct?: ClientIndividualMinorPropertiesScalarFieldEnum | ClientIndividualMinorPropertiesScalarFieldEnum[]
  }

  /**
   * ClientIndividualMinorProperties findFirstOrThrow
   */
  export type ClientIndividualMinorPropertiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualMinorProperties to fetch.
     */
    where?: ClientIndividualMinorPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientIndividualMinorProperties to fetch.
     */
    orderBy?: ClientIndividualMinorPropertiesOrderByWithRelationInput | ClientIndividualMinorPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientIndividualMinorProperties.
     */
    cursor?: ClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientIndividualMinorProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientIndividualMinorProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientIndividualMinorProperties.
     */
    distinct?: ClientIndividualMinorPropertiesScalarFieldEnum | ClientIndividualMinorPropertiesScalarFieldEnum[]
  }

  /**
   * ClientIndividualMinorProperties findMany
   */
  export type ClientIndividualMinorPropertiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientIndividualMinorProperties to fetch.
     */
    where?: ClientIndividualMinorPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientIndividualMinorProperties to fetch.
     */
    orderBy?: ClientIndividualMinorPropertiesOrderByWithRelationInput | ClientIndividualMinorPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientIndividualMinorProperties.
     */
    cursor?: ClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientIndividualMinorProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientIndividualMinorProperties.
     */
    skip?: number
    distinct?: ClientIndividualMinorPropertiesScalarFieldEnum | ClientIndividualMinorPropertiesScalarFieldEnum[]
  }

  /**
   * ClientIndividualMinorProperties create
   */
  export type ClientIndividualMinorPropertiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientIndividualMinorProperties.
     */
    data: XOR<ClientIndividualMinorPropertiesCreateInput, ClientIndividualMinorPropertiesUncheckedCreateInput>
  }

  /**
   * ClientIndividualMinorProperties createMany
   */
  export type ClientIndividualMinorPropertiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientIndividualMinorProperties.
     */
    data: ClientIndividualMinorPropertiesCreateManyInput | ClientIndividualMinorPropertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientIndividualMinorProperties update
   */
  export type ClientIndividualMinorPropertiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientIndividualMinorProperties.
     */
    data: XOR<ClientIndividualMinorPropertiesUpdateInput, ClientIndividualMinorPropertiesUncheckedUpdateInput>
    /**
     * Choose, which ClientIndividualMinorProperties to update.
     */
    where: ClientIndividualMinorPropertiesWhereUniqueInput
  }

  /**
   * ClientIndividualMinorProperties updateMany
   */
  export type ClientIndividualMinorPropertiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientIndividualMinorProperties.
     */
    data: XOR<ClientIndividualMinorPropertiesUpdateManyMutationInput, ClientIndividualMinorPropertiesUncheckedUpdateManyInput>
    /**
     * Filter which ClientIndividualMinorProperties to update
     */
    where?: ClientIndividualMinorPropertiesWhereInput
  }

  /**
   * ClientIndividualMinorProperties upsert
   */
  export type ClientIndividualMinorPropertiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientIndividualMinorProperties to update in case it exists.
     */
    where: ClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * In case the ClientIndividualMinorProperties found by the `where` argument doesn't exist, create a new ClientIndividualMinorProperties with this data.
     */
    create: XOR<ClientIndividualMinorPropertiesCreateInput, ClientIndividualMinorPropertiesUncheckedCreateInput>
    /**
     * In case the ClientIndividualMinorProperties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientIndividualMinorPropertiesUpdateInput, ClientIndividualMinorPropertiesUncheckedUpdateInput>
  }

  /**
   * ClientIndividualMinorProperties delete
   */
  export type ClientIndividualMinorPropertiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter which ClientIndividualMinorProperties to delete.
     */
    where: ClientIndividualMinorPropertiesWhereUniqueInput
  }

  /**
   * ClientIndividualMinorProperties deleteMany
   */
  export type ClientIndividualMinorPropertiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientIndividualMinorProperties to delete
     */
    where?: ClientIndividualMinorPropertiesWhereInput
  }

  /**
   * ClientIndividualMinorProperties.client
   */
  export type ClientIndividualMinorProperties$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * ClientIndividualMinorProperties.clientPassport
   */
  export type ClientIndividualMinorProperties$clientPassportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    where?: ClientPassportWhereInput
  }

  /**
   * ClientIndividualMinorProperties.clientsToClientIndividualMinorProperties
   */
  export type ClientIndividualMinorProperties$clientsToClientIndividualMinorPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    where?: ClientToClientIndividualMinorPropertiesWhereInput
    orderBy?: ClientToClientIndividualMinorPropertiesOrderByWithRelationInput | ClientToClientIndividualMinorPropertiesOrderByWithRelationInput[]
    cursor?: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientToClientIndividualMinorPropertiesScalarFieldEnum | ClientToClientIndividualMinorPropertiesScalarFieldEnum[]
  }

  /**
   * ClientIndividualMinorProperties without action
   */
  export type ClientIndividualMinorPropertiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
  }


  /**
   * Model ClientEntityProperties
   */

  export type AggregateClientEntityProperties = {
    _count: ClientEntityPropertiesCountAggregateOutputType | null
    _avg: ClientEntityPropertiesAvgAggregateOutputType | null
    _sum: ClientEntityPropertiesSumAggregateOutputType | null
    _min: ClientEntityPropertiesMinAggregateOutputType | null
    _max: ClientEntityPropertiesMaxAggregateOutputType | null
  }

  export type ClientEntityPropertiesAvgAggregateOutputType = {
    id: number | null
  }

  export type ClientEntityPropertiesSumAggregateOutputType = {
    id: number | null
  }

  export type ClientEntityPropertiesMinAggregateOutputType = {
    id: number | null
    kpp: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientEntityPropertiesMaxAggregateOutputType = {
    id: number | null
    kpp: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientEntityPropertiesCountAggregateOutputType = {
    id: number
    kpp: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientEntityPropertiesAvgAggregateInputType = {
    id?: true
  }

  export type ClientEntityPropertiesSumAggregateInputType = {
    id?: true
  }

  export type ClientEntityPropertiesMinAggregateInputType = {
    id?: true
    kpp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientEntityPropertiesMaxAggregateInputType = {
    id?: true
    kpp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientEntityPropertiesCountAggregateInputType = {
    id?: true
    kpp?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientEntityPropertiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientEntityProperties to aggregate.
     */
    where?: ClientEntityPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEntityProperties to fetch.
     */
    orderBy?: ClientEntityPropertiesOrderByWithRelationInput | ClientEntityPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientEntityPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEntityProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEntityProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientEntityProperties
    **/
    _count?: true | ClientEntityPropertiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientEntityPropertiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientEntityPropertiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientEntityPropertiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientEntityPropertiesMaxAggregateInputType
  }

  export type GetClientEntityPropertiesAggregateType<T extends ClientEntityPropertiesAggregateArgs> = {
        [P in keyof T & keyof AggregateClientEntityProperties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientEntityProperties[P]>
      : GetScalarType<T[P], AggregateClientEntityProperties[P]>
  }




  export type ClientEntityPropertiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientEntityPropertiesWhereInput
    orderBy?: ClientEntityPropertiesOrderByWithAggregationInput | ClientEntityPropertiesOrderByWithAggregationInput[]
    by: ClientEntityPropertiesScalarFieldEnum[] | ClientEntityPropertiesScalarFieldEnum
    having?: ClientEntityPropertiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientEntityPropertiesCountAggregateInputType | true
    _avg?: ClientEntityPropertiesAvgAggregateInputType
    _sum?: ClientEntityPropertiesSumAggregateInputType
    _min?: ClientEntityPropertiesMinAggregateInputType
    _max?: ClientEntityPropertiesMaxAggregateInputType
  }

  export type ClientEntityPropertiesGroupByOutputType = {
    id: number
    kpp: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClientEntityPropertiesCountAggregateOutputType | null
    _avg: ClientEntityPropertiesAvgAggregateOutputType | null
    _sum: ClientEntityPropertiesSumAggregateOutputType | null
    _min: ClientEntityPropertiesMinAggregateOutputType | null
    _max: ClientEntityPropertiesMaxAggregateOutputType | null
  }

  type GetClientEntityPropertiesGroupByPayload<T extends ClientEntityPropertiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientEntityPropertiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientEntityPropertiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientEntityPropertiesGroupByOutputType[P]>
            : GetScalarType<T[P], ClientEntityPropertiesGroupByOutputType[P]>
        }
      >
    >


  export type ClientEntityPropertiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kpp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientEntityProperties$clientArgs<ExtArgs>
  }, ExtArgs["result"]["clientEntityProperties"]>


  export type ClientEntityPropertiesSelectScalar = {
    id?: boolean
    kpp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientEntityPropertiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientEntityProperties$clientArgs<ExtArgs>
  }

  export type $ClientEntityPropertiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientEntityProperties"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kpp: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientEntityProperties"]>
    composites: {}
  }

  type ClientEntityPropertiesGetPayload<S extends boolean | null | undefined | ClientEntityPropertiesDefaultArgs> = $Result.GetResult<Prisma.$ClientEntityPropertiesPayload, S>

  type ClientEntityPropertiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientEntityPropertiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientEntityPropertiesCountAggregateInputType | true
    }

  export interface ClientEntityPropertiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientEntityProperties'], meta: { name: 'ClientEntityProperties' } }
    /**
     * Find zero or one ClientEntityProperties that matches the filter.
     * @param {ClientEntityPropertiesFindUniqueArgs} args - Arguments to find a ClientEntityProperties
     * @example
     * // Get one ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientEntityPropertiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientEntityPropertiesFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientEntityPropertiesClient<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClientEntityProperties that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientEntityPropertiesFindUniqueOrThrowArgs} args - Arguments to find a ClientEntityProperties
     * @example
     * // Get one ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientEntityPropertiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientEntityPropertiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientEntityPropertiesClient<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClientEntityProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityPropertiesFindFirstArgs} args - Arguments to find a ClientEntityProperties
     * @example
     * // Get one ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientEntityPropertiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientEntityPropertiesFindFirstArgs<ExtArgs>>
    ): Prisma__ClientEntityPropertiesClient<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClientEntityProperties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityPropertiesFindFirstOrThrowArgs} args - Arguments to find a ClientEntityProperties
     * @example
     * // Get one ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientEntityPropertiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientEntityPropertiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientEntityPropertiesClient<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClientEntityProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityPropertiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.findMany()
     * 
     * // Get first 10 ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientEntityPropertiesWithIdOnly = await prisma.clientEntityProperties.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientEntityPropertiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientEntityPropertiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClientEntityProperties.
     * @param {ClientEntityPropertiesCreateArgs} args - Arguments to create a ClientEntityProperties.
     * @example
     * // Create one ClientEntityProperties
     * const ClientEntityProperties = await prisma.clientEntityProperties.create({
     *   data: {
     *     // ... data to create a ClientEntityProperties
     *   }
     * })
     * 
    **/
    create<T extends ClientEntityPropertiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientEntityPropertiesCreateArgs<ExtArgs>>
    ): Prisma__ClientEntityPropertiesClient<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClientEntityProperties.
     * @param {ClientEntityPropertiesCreateManyArgs} args - Arguments to create many ClientEntityProperties.
     * @example
     * // Create many ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientEntityPropertiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientEntityPropertiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientEntityProperties.
     * @param {ClientEntityPropertiesDeleteArgs} args - Arguments to delete one ClientEntityProperties.
     * @example
     * // Delete one ClientEntityProperties
     * const ClientEntityProperties = await prisma.clientEntityProperties.delete({
     *   where: {
     *     // ... filter to delete one ClientEntityProperties
     *   }
     * })
     * 
    **/
    delete<T extends ClientEntityPropertiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientEntityPropertiesDeleteArgs<ExtArgs>>
    ): Prisma__ClientEntityPropertiesClient<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClientEntityProperties.
     * @param {ClientEntityPropertiesUpdateArgs} args - Arguments to update one ClientEntityProperties.
     * @example
     * // Update one ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientEntityPropertiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientEntityPropertiesUpdateArgs<ExtArgs>>
    ): Prisma__ClientEntityPropertiesClient<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClientEntityProperties.
     * @param {ClientEntityPropertiesDeleteManyArgs} args - Arguments to filter ClientEntityProperties to delete.
     * @example
     * // Delete a few ClientEntityProperties
     * const { count } = await prisma.clientEntityProperties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientEntityPropertiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientEntityPropertiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientEntityProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityPropertiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientEntityPropertiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientEntityPropertiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientEntityProperties.
     * @param {ClientEntityPropertiesUpsertArgs} args - Arguments to update or create a ClientEntityProperties.
     * @example
     * // Update or create a ClientEntityProperties
     * const clientEntityProperties = await prisma.clientEntityProperties.upsert({
     *   create: {
     *     // ... data to create a ClientEntityProperties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientEntityProperties we want to update
     *   }
     * })
    **/
    upsert<T extends ClientEntityPropertiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientEntityPropertiesUpsertArgs<ExtArgs>>
    ): Prisma__ClientEntityPropertiesClient<$Result.GetResult<Prisma.$ClientEntityPropertiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClientEntityProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityPropertiesCountArgs} args - Arguments to filter ClientEntityProperties to count.
     * @example
     * // Count the number of ClientEntityProperties
     * const count = await prisma.clientEntityProperties.count({
     *   where: {
     *     // ... the filter for the ClientEntityProperties we want to count
     *   }
     * })
    **/
    count<T extends ClientEntityPropertiesCountArgs>(
      args?: Subset<T, ClientEntityPropertiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientEntityPropertiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientEntityProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityPropertiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientEntityPropertiesAggregateArgs>(args: Subset<T, ClientEntityPropertiesAggregateArgs>): Prisma.PrismaPromise<GetClientEntityPropertiesAggregateType<T>>

    /**
     * Group by ClientEntityProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityPropertiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientEntityPropertiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientEntityPropertiesGroupByArgs['orderBy'] }
        : { orderBy?: ClientEntityPropertiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientEntityPropertiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientEntityPropertiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientEntityProperties model
   */
  readonly fields: ClientEntityPropertiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientEntityProperties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientEntityPropertiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client<T extends ClientEntityProperties$clientArgs<ExtArgs> = {}>(args?: Subset<T, ClientEntityProperties$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClientEntityProperties model
   */ 
  interface ClientEntityPropertiesFieldRefs {
    readonly id: FieldRef<"ClientEntityProperties", 'Int'>
    readonly kpp: FieldRef<"ClientEntityProperties", 'String'>
    readonly createdAt: FieldRef<"ClientEntityProperties", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientEntityProperties", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientEntityProperties findUnique
   */
  export type ClientEntityPropertiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientEntityProperties to fetch.
     */
    where: ClientEntityPropertiesWhereUniqueInput
  }

  /**
   * ClientEntityProperties findUniqueOrThrow
   */
  export type ClientEntityPropertiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientEntityProperties to fetch.
     */
    where: ClientEntityPropertiesWhereUniqueInput
  }

  /**
   * ClientEntityProperties findFirst
   */
  export type ClientEntityPropertiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientEntityProperties to fetch.
     */
    where?: ClientEntityPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEntityProperties to fetch.
     */
    orderBy?: ClientEntityPropertiesOrderByWithRelationInput | ClientEntityPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientEntityProperties.
     */
    cursor?: ClientEntityPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEntityProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEntityProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientEntityProperties.
     */
    distinct?: ClientEntityPropertiesScalarFieldEnum | ClientEntityPropertiesScalarFieldEnum[]
  }

  /**
   * ClientEntityProperties findFirstOrThrow
   */
  export type ClientEntityPropertiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientEntityProperties to fetch.
     */
    where?: ClientEntityPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEntityProperties to fetch.
     */
    orderBy?: ClientEntityPropertiesOrderByWithRelationInput | ClientEntityPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientEntityProperties.
     */
    cursor?: ClientEntityPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEntityProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEntityProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientEntityProperties.
     */
    distinct?: ClientEntityPropertiesScalarFieldEnum | ClientEntityPropertiesScalarFieldEnum[]
  }

  /**
   * ClientEntityProperties findMany
   */
  export type ClientEntityPropertiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientEntityProperties to fetch.
     */
    where?: ClientEntityPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEntityProperties to fetch.
     */
    orderBy?: ClientEntityPropertiesOrderByWithRelationInput | ClientEntityPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientEntityProperties.
     */
    cursor?: ClientEntityPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEntityProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEntityProperties.
     */
    skip?: number
    distinct?: ClientEntityPropertiesScalarFieldEnum | ClientEntityPropertiesScalarFieldEnum[]
  }

  /**
   * ClientEntityProperties create
   */
  export type ClientEntityPropertiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientEntityProperties.
     */
    data: XOR<ClientEntityPropertiesCreateInput, ClientEntityPropertiesUncheckedCreateInput>
  }

  /**
   * ClientEntityProperties createMany
   */
  export type ClientEntityPropertiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientEntityProperties.
     */
    data: ClientEntityPropertiesCreateManyInput | ClientEntityPropertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientEntityProperties update
   */
  export type ClientEntityPropertiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientEntityProperties.
     */
    data: XOR<ClientEntityPropertiesUpdateInput, ClientEntityPropertiesUncheckedUpdateInput>
    /**
     * Choose, which ClientEntityProperties to update.
     */
    where: ClientEntityPropertiesWhereUniqueInput
  }

  /**
   * ClientEntityProperties updateMany
   */
  export type ClientEntityPropertiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientEntityProperties.
     */
    data: XOR<ClientEntityPropertiesUpdateManyMutationInput, ClientEntityPropertiesUncheckedUpdateManyInput>
    /**
     * Filter which ClientEntityProperties to update
     */
    where?: ClientEntityPropertiesWhereInput
  }

  /**
   * ClientEntityProperties upsert
   */
  export type ClientEntityPropertiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientEntityProperties to update in case it exists.
     */
    where: ClientEntityPropertiesWhereUniqueInput
    /**
     * In case the ClientEntityProperties found by the `where` argument doesn't exist, create a new ClientEntityProperties with this data.
     */
    create: XOR<ClientEntityPropertiesCreateInput, ClientEntityPropertiesUncheckedCreateInput>
    /**
     * In case the ClientEntityProperties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientEntityPropertiesUpdateInput, ClientEntityPropertiesUncheckedUpdateInput>
  }

  /**
   * ClientEntityProperties delete
   */
  export type ClientEntityPropertiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
    /**
     * Filter which ClientEntityProperties to delete.
     */
    where: ClientEntityPropertiesWhereUniqueInput
  }

  /**
   * ClientEntityProperties deleteMany
   */
  export type ClientEntityPropertiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientEntityProperties to delete
     */
    where?: ClientEntityPropertiesWhereInput
  }

  /**
   * ClientEntityProperties.client
   */
  export type ClientEntityProperties$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * ClientEntityProperties without action
   */
  export type ClientEntityPropertiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityProperties
     */
    select?: ClientEntityPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityPropertiesInclude<ExtArgs> | null
  }


  /**
   * Model ClientToClientIndividualMinorProperties
   */

  export type AggregateClientToClientIndividualMinorProperties = {
    _count: ClientToClientIndividualMinorPropertiesCountAggregateOutputType | null
    _avg: ClientToClientIndividualMinorPropertiesAvgAggregateOutputType | null
    _sum: ClientToClientIndividualMinorPropertiesSumAggregateOutputType | null
    _min: ClientToClientIndividualMinorPropertiesMinAggregateOutputType | null
    _max: ClientToClientIndividualMinorPropertiesMaxAggregateOutputType | null
  }

  export type ClientToClientIndividualMinorPropertiesAvgAggregateOutputType = {
    clientId: number | null
    clientIndividualMinorPropertiesId: number | null
  }

  export type ClientToClientIndividualMinorPropertiesSumAggregateOutputType = {
    clientId: number | null
    clientIndividualMinorPropertiesId: number | null
  }

  export type ClientToClientIndividualMinorPropertiesMinAggregateOutputType = {
    clientId: number | null
    clientIndividualMinorPropertiesId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientToClientIndividualMinorPropertiesMaxAggregateOutputType = {
    clientId: number | null
    clientIndividualMinorPropertiesId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientToClientIndividualMinorPropertiesCountAggregateOutputType = {
    clientId: number
    clientIndividualMinorPropertiesId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientToClientIndividualMinorPropertiesAvgAggregateInputType = {
    clientId?: true
    clientIndividualMinorPropertiesId?: true
  }

  export type ClientToClientIndividualMinorPropertiesSumAggregateInputType = {
    clientId?: true
    clientIndividualMinorPropertiesId?: true
  }

  export type ClientToClientIndividualMinorPropertiesMinAggregateInputType = {
    clientId?: true
    clientIndividualMinorPropertiesId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientToClientIndividualMinorPropertiesMaxAggregateInputType = {
    clientId?: true
    clientIndividualMinorPropertiesId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientToClientIndividualMinorPropertiesCountAggregateInputType = {
    clientId?: true
    clientIndividualMinorPropertiesId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientToClientIndividualMinorPropertiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientToClientIndividualMinorProperties to aggregate.
     */
    where?: ClientToClientIndividualMinorPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientToClientIndividualMinorProperties to fetch.
     */
    orderBy?: ClientToClientIndividualMinorPropertiesOrderByWithRelationInput | ClientToClientIndividualMinorPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientToClientIndividualMinorProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientToClientIndividualMinorProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientToClientIndividualMinorProperties
    **/
    _count?: true | ClientToClientIndividualMinorPropertiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientToClientIndividualMinorPropertiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientToClientIndividualMinorPropertiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientToClientIndividualMinorPropertiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientToClientIndividualMinorPropertiesMaxAggregateInputType
  }

  export type GetClientToClientIndividualMinorPropertiesAggregateType<T extends ClientToClientIndividualMinorPropertiesAggregateArgs> = {
        [P in keyof T & keyof AggregateClientToClientIndividualMinorProperties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientToClientIndividualMinorProperties[P]>
      : GetScalarType<T[P], AggregateClientToClientIndividualMinorProperties[P]>
  }




  export type ClientToClientIndividualMinorPropertiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientToClientIndividualMinorPropertiesWhereInput
    orderBy?: ClientToClientIndividualMinorPropertiesOrderByWithAggregationInput | ClientToClientIndividualMinorPropertiesOrderByWithAggregationInput[]
    by: ClientToClientIndividualMinorPropertiesScalarFieldEnum[] | ClientToClientIndividualMinorPropertiesScalarFieldEnum
    having?: ClientToClientIndividualMinorPropertiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientToClientIndividualMinorPropertiesCountAggregateInputType | true
    _avg?: ClientToClientIndividualMinorPropertiesAvgAggregateInputType
    _sum?: ClientToClientIndividualMinorPropertiesSumAggregateInputType
    _min?: ClientToClientIndividualMinorPropertiesMinAggregateInputType
    _max?: ClientToClientIndividualMinorPropertiesMaxAggregateInputType
  }

  export type ClientToClientIndividualMinorPropertiesGroupByOutputType = {
    clientId: number
    clientIndividualMinorPropertiesId: number
    createdAt: Date
    updatedAt: Date
    _count: ClientToClientIndividualMinorPropertiesCountAggregateOutputType | null
    _avg: ClientToClientIndividualMinorPropertiesAvgAggregateOutputType | null
    _sum: ClientToClientIndividualMinorPropertiesSumAggregateOutputType | null
    _min: ClientToClientIndividualMinorPropertiesMinAggregateOutputType | null
    _max: ClientToClientIndividualMinorPropertiesMaxAggregateOutputType | null
  }

  type GetClientToClientIndividualMinorPropertiesGroupByPayload<T extends ClientToClientIndividualMinorPropertiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientToClientIndividualMinorPropertiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientToClientIndividualMinorPropertiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientToClientIndividualMinorPropertiesGroupByOutputType[P]>
            : GetScalarType<T[P], ClientToClientIndividualMinorPropertiesGroupByOutputType[P]>
        }
      >
    >


  export type ClientToClientIndividualMinorPropertiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clientId?: boolean
    clientIndividualMinorPropertiesId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    clientIndividualMinorProperties?: boolean | ClientIndividualMinorPropertiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientToClientIndividualMinorProperties"]>


  export type ClientToClientIndividualMinorPropertiesSelectScalar = {
    clientId?: boolean
    clientIndividualMinorPropertiesId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientToClientIndividualMinorPropertiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    clientIndividualMinorProperties?: boolean | ClientIndividualMinorPropertiesDefaultArgs<ExtArgs>
  }

  export type $ClientToClientIndividualMinorPropertiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientToClientIndividualMinorProperties"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      clientIndividualMinorProperties: Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      clientId: number
      clientIndividualMinorPropertiesId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientToClientIndividualMinorProperties"]>
    composites: {}
  }

  type ClientToClientIndividualMinorPropertiesGetPayload<S extends boolean | null | undefined | ClientToClientIndividualMinorPropertiesDefaultArgs> = $Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload, S>

  type ClientToClientIndividualMinorPropertiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientToClientIndividualMinorPropertiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientToClientIndividualMinorPropertiesCountAggregateInputType | true
    }

  export interface ClientToClientIndividualMinorPropertiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientToClientIndividualMinorProperties'], meta: { name: 'ClientToClientIndividualMinorProperties' } }
    /**
     * Find zero or one ClientToClientIndividualMinorProperties that matches the filter.
     * @param {ClientToClientIndividualMinorPropertiesFindUniqueArgs} args - Arguments to find a ClientToClientIndividualMinorProperties
     * @example
     * // Get one ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientToClientIndividualMinorPropertiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientToClientIndividualMinorPropertiesFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientToClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClientToClientIndividualMinorProperties that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientToClientIndividualMinorPropertiesFindUniqueOrThrowArgs} args - Arguments to find a ClientToClientIndividualMinorProperties
     * @example
     * // Get one ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientToClientIndividualMinorPropertiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientToClientIndividualMinorPropertiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientToClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClientToClientIndividualMinorProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientToClientIndividualMinorPropertiesFindFirstArgs} args - Arguments to find a ClientToClientIndividualMinorProperties
     * @example
     * // Get one ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientToClientIndividualMinorPropertiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientToClientIndividualMinorPropertiesFindFirstArgs<ExtArgs>>
    ): Prisma__ClientToClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClientToClientIndividualMinorProperties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientToClientIndividualMinorPropertiesFindFirstOrThrowArgs} args - Arguments to find a ClientToClientIndividualMinorProperties
     * @example
     * // Get one ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientToClientIndividualMinorPropertiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientToClientIndividualMinorPropertiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientToClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClientToClientIndividualMinorProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientToClientIndividualMinorPropertiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.findMany()
     * 
     * // Get first 10 ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.findMany({ take: 10 })
     * 
     * // Only select the `clientId`
     * const clientToClientIndividualMinorPropertiesWithClientIdOnly = await prisma.clientToClientIndividualMinorProperties.findMany({ select: { clientId: true } })
     * 
    **/
    findMany<T extends ClientToClientIndividualMinorPropertiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientToClientIndividualMinorPropertiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClientToClientIndividualMinorProperties.
     * @param {ClientToClientIndividualMinorPropertiesCreateArgs} args - Arguments to create a ClientToClientIndividualMinorProperties.
     * @example
     * // Create one ClientToClientIndividualMinorProperties
     * const ClientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.create({
     *   data: {
     *     // ... data to create a ClientToClientIndividualMinorProperties
     *   }
     * })
     * 
    **/
    create<T extends ClientToClientIndividualMinorPropertiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientToClientIndividualMinorPropertiesCreateArgs<ExtArgs>>
    ): Prisma__ClientToClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClientToClientIndividualMinorProperties.
     * @param {ClientToClientIndividualMinorPropertiesCreateManyArgs} args - Arguments to create many ClientToClientIndividualMinorProperties.
     * @example
     * // Create many ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientToClientIndividualMinorPropertiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientToClientIndividualMinorPropertiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientToClientIndividualMinorProperties.
     * @param {ClientToClientIndividualMinorPropertiesDeleteArgs} args - Arguments to delete one ClientToClientIndividualMinorProperties.
     * @example
     * // Delete one ClientToClientIndividualMinorProperties
     * const ClientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.delete({
     *   where: {
     *     // ... filter to delete one ClientToClientIndividualMinorProperties
     *   }
     * })
     * 
    **/
    delete<T extends ClientToClientIndividualMinorPropertiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientToClientIndividualMinorPropertiesDeleteArgs<ExtArgs>>
    ): Prisma__ClientToClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClientToClientIndividualMinorProperties.
     * @param {ClientToClientIndividualMinorPropertiesUpdateArgs} args - Arguments to update one ClientToClientIndividualMinorProperties.
     * @example
     * // Update one ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientToClientIndividualMinorPropertiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientToClientIndividualMinorPropertiesUpdateArgs<ExtArgs>>
    ): Prisma__ClientToClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClientToClientIndividualMinorProperties.
     * @param {ClientToClientIndividualMinorPropertiesDeleteManyArgs} args - Arguments to filter ClientToClientIndividualMinorProperties to delete.
     * @example
     * // Delete a few ClientToClientIndividualMinorProperties
     * const { count } = await prisma.clientToClientIndividualMinorProperties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientToClientIndividualMinorPropertiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientToClientIndividualMinorPropertiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientToClientIndividualMinorProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientToClientIndividualMinorPropertiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientToClientIndividualMinorPropertiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientToClientIndividualMinorPropertiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientToClientIndividualMinorProperties.
     * @param {ClientToClientIndividualMinorPropertiesUpsertArgs} args - Arguments to update or create a ClientToClientIndividualMinorProperties.
     * @example
     * // Update or create a ClientToClientIndividualMinorProperties
     * const clientToClientIndividualMinorProperties = await prisma.clientToClientIndividualMinorProperties.upsert({
     *   create: {
     *     // ... data to create a ClientToClientIndividualMinorProperties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientToClientIndividualMinorProperties we want to update
     *   }
     * })
    **/
    upsert<T extends ClientToClientIndividualMinorPropertiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientToClientIndividualMinorPropertiesUpsertArgs<ExtArgs>>
    ): Prisma__ClientToClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientToClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClientToClientIndividualMinorProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientToClientIndividualMinorPropertiesCountArgs} args - Arguments to filter ClientToClientIndividualMinorProperties to count.
     * @example
     * // Count the number of ClientToClientIndividualMinorProperties
     * const count = await prisma.clientToClientIndividualMinorProperties.count({
     *   where: {
     *     // ... the filter for the ClientToClientIndividualMinorProperties we want to count
     *   }
     * })
    **/
    count<T extends ClientToClientIndividualMinorPropertiesCountArgs>(
      args?: Subset<T, ClientToClientIndividualMinorPropertiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientToClientIndividualMinorPropertiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientToClientIndividualMinorProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientToClientIndividualMinorPropertiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientToClientIndividualMinorPropertiesAggregateArgs>(args: Subset<T, ClientToClientIndividualMinorPropertiesAggregateArgs>): Prisma.PrismaPromise<GetClientToClientIndividualMinorPropertiesAggregateType<T>>

    /**
     * Group by ClientToClientIndividualMinorProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientToClientIndividualMinorPropertiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientToClientIndividualMinorPropertiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientToClientIndividualMinorPropertiesGroupByArgs['orderBy'] }
        : { orderBy?: ClientToClientIndividualMinorPropertiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientToClientIndividualMinorPropertiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientToClientIndividualMinorPropertiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientToClientIndividualMinorProperties model
   */
  readonly fields: ClientToClientIndividualMinorPropertiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientToClientIndividualMinorProperties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientToClientIndividualMinorPropertiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    clientIndividualMinorProperties<T extends ClientIndividualMinorPropertiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientIndividualMinorPropertiesDefaultArgs<ExtArgs>>): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClientToClientIndividualMinorProperties model
   */ 
  interface ClientToClientIndividualMinorPropertiesFieldRefs {
    readonly clientId: FieldRef<"ClientToClientIndividualMinorProperties", 'Int'>
    readonly clientIndividualMinorPropertiesId: FieldRef<"ClientToClientIndividualMinorProperties", 'Int'>
    readonly createdAt: FieldRef<"ClientToClientIndividualMinorProperties", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientToClientIndividualMinorProperties", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientToClientIndividualMinorProperties findUnique
   */
  export type ClientToClientIndividualMinorPropertiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientToClientIndividualMinorProperties to fetch.
     */
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
  }

  /**
   * ClientToClientIndividualMinorProperties findUniqueOrThrow
   */
  export type ClientToClientIndividualMinorPropertiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientToClientIndividualMinorProperties to fetch.
     */
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
  }

  /**
   * ClientToClientIndividualMinorProperties findFirst
   */
  export type ClientToClientIndividualMinorPropertiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientToClientIndividualMinorProperties to fetch.
     */
    where?: ClientToClientIndividualMinorPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientToClientIndividualMinorProperties to fetch.
     */
    orderBy?: ClientToClientIndividualMinorPropertiesOrderByWithRelationInput | ClientToClientIndividualMinorPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientToClientIndividualMinorProperties.
     */
    cursor?: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientToClientIndividualMinorProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientToClientIndividualMinorProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientToClientIndividualMinorProperties.
     */
    distinct?: ClientToClientIndividualMinorPropertiesScalarFieldEnum | ClientToClientIndividualMinorPropertiesScalarFieldEnum[]
  }

  /**
   * ClientToClientIndividualMinorProperties findFirstOrThrow
   */
  export type ClientToClientIndividualMinorPropertiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientToClientIndividualMinorProperties to fetch.
     */
    where?: ClientToClientIndividualMinorPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientToClientIndividualMinorProperties to fetch.
     */
    orderBy?: ClientToClientIndividualMinorPropertiesOrderByWithRelationInput | ClientToClientIndividualMinorPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientToClientIndividualMinorProperties.
     */
    cursor?: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientToClientIndividualMinorProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientToClientIndividualMinorProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientToClientIndividualMinorProperties.
     */
    distinct?: ClientToClientIndividualMinorPropertiesScalarFieldEnum | ClientToClientIndividualMinorPropertiesScalarFieldEnum[]
  }

  /**
   * ClientToClientIndividualMinorProperties findMany
   */
  export type ClientToClientIndividualMinorPropertiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which ClientToClientIndividualMinorProperties to fetch.
     */
    where?: ClientToClientIndividualMinorPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientToClientIndividualMinorProperties to fetch.
     */
    orderBy?: ClientToClientIndividualMinorPropertiesOrderByWithRelationInput | ClientToClientIndividualMinorPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientToClientIndividualMinorProperties.
     */
    cursor?: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientToClientIndividualMinorProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientToClientIndividualMinorProperties.
     */
    skip?: number
    distinct?: ClientToClientIndividualMinorPropertiesScalarFieldEnum | ClientToClientIndividualMinorPropertiesScalarFieldEnum[]
  }

  /**
   * ClientToClientIndividualMinorProperties create
   */
  export type ClientToClientIndividualMinorPropertiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientToClientIndividualMinorProperties.
     */
    data: XOR<ClientToClientIndividualMinorPropertiesCreateInput, ClientToClientIndividualMinorPropertiesUncheckedCreateInput>
  }

  /**
   * ClientToClientIndividualMinorProperties createMany
   */
  export type ClientToClientIndividualMinorPropertiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientToClientIndividualMinorProperties.
     */
    data: ClientToClientIndividualMinorPropertiesCreateManyInput | ClientToClientIndividualMinorPropertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientToClientIndividualMinorProperties update
   */
  export type ClientToClientIndividualMinorPropertiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientToClientIndividualMinorProperties.
     */
    data: XOR<ClientToClientIndividualMinorPropertiesUpdateInput, ClientToClientIndividualMinorPropertiesUncheckedUpdateInput>
    /**
     * Choose, which ClientToClientIndividualMinorProperties to update.
     */
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
  }

  /**
   * ClientToClientIndividualMinorProperties updateMany
   */
  export type ClientToClientIndividualMinorPropertiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientToClientIndividualMinorProperties.
     */
    data: XOR<ClientToClientIndividualMinorPropertiesUpdateManyMutationInput, ClientToClientIndividualMinorPropertiesUncheckedUpdateManyInput>
    /**
     * Filter which ClientToClientIndividualMinorProperties to update
     */
    where?: ClientToClientIndividualMinorPropertiesWhereInput
  }

  /**
   * ClientToClientIndividualMinorProperties upsert
   */
  export type ClientToClientIndividualMinorPropertiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientToClientIndividualMinorProperties to update in case it exists.
     */
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    /**
     * In case the ClientToClientIndividualMinorProperties found by the `where` argument doesn't exist, create a new ClientToClientIndividualMinorProperties with this data.
     */
    create: XOR<ClientToClientIndividualMinorPropertiesCreateInput, ClientToClientIndividualMinorPropertiesUncheckedCreateInput>
    /**
     * In case the ClientToClientIndividualMinorProperties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientToClientIndividualMinorPropertiesUpdateInput, ClientToClientIndividualMinorPropertiesUncheckedUpdateInput>
  }

  /**
   * ClientToClientIndividualMinorProperties delete
   */
  export type ClientToClientIndividualMinorPropertiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
    /**
     * Filter which ClientToClientIndividualMinorProperties to delete.
     */
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
  }

  /**
   * ClientToClientIndividualMinorProperties deleteMany
   */
  export type ClientToClientIndividualMinorPropertiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientToClientIndividualMinorProperties to delete
     */
    where?: ClientToClientIndividualMinorPropertiesWhereInput
  }

  /**
   * ClientToClientIndividualMinorProperties without action
   */
  export type ClientToClientIndividualMinorPropertiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientToClientIndividualMinorProperties
     */
    select?: ClientToClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientToClientIndividualMinorPropertiesInclude<ExtArgs> | null
  }


  /**
   * Model ClientPassport
   */

  export type AggregateClientPassport = {
    _count: ClientPassportCountAggregateOutputType | null
    _avg: ClientPassportAvgAggregateOutputType | null
    _sum: ClientPassportSumAggregateOutputType | null
    _min: ClientPassportMinAggregateOutputType | null
    _max: ClientPassportMaxAggregateOutputType | null
  }

  export type ClientPassportAvgAggregateOutputType = {
    id: number | null
  }

  export type ClientPassportSumAggregateOutputType = {
    id: number | null
  }

  export type ClientPassportMinAggregateOutputType = {
    id: number | null
    number: string | null
    issued: string | null
    code: string | null
    placeOfBirth: string | null
    registrationAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientPassportMaxAggregateOutputType = {
    id: number | null
    number: string | null
    issued: string | null
    code: string | null
    placeOfBirth: string | null
    registrationAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientPassportCountAggregateOutputType = {
    id: number
    number: number
    issued: number
    code: number
    placeOfBirth: number
    registrationAddress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientPassportAvgAggregateInputType = {
    id?: true
  }

  export type ClientPassportSumAggregateInputType = {
    id?: true
  }

  export type ClientPassportMinAggregateInputType = {
    id?: true
    number?: true
    issued?: true
    code?: true
    placeOfBirth?: true
    registrationAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientPassportMaxAggregateInputType = {
    id?: true
    number?: true
    issued?: true
    code?: true
    placeOfBirth?: true
    registrationAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientPassportCountAggregateInputType = {
    id?: true
    number?: true
    issued?: true
    code?: true
    placeOfBirth?: true
    registrationAddress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientPassportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientPassport to aggregate.
     */
    where?: ClientPassportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPassports to fetch.
     */
    orderBy?: ClientPassportOrderByWithRelationInput | ClientPassportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientPassportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPassports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPassports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientPassports
    **/
    _count?: true | ClientPassportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientPassportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientPassportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientPassportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientPassportMaxAggregateInputType
  }

  export type GetClientPassportAggregateType<T extends ClientPassportAggregateArgs> = {
        [P in keyof T & keyof AggregateClientPassport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientPassport[P]>
      : GetScalarType<T[P], AggregateClientPassport[P]>
  }




  export type ClientPassportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientPassportWhereInput
    orderBy?: ClientPassportOrderByWithAggregationInput | ClientPassportOrderByWithAggregationInput[]
    by: ClientPassportScalarFieldEnum[] | ClientPassportScalarFieldEnum
    having?: ClientPassportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientPassportCountAggregateInputType | true
    _avg?: ClientPassportAvgAggregateInputType
    _sum?: ClientPassportSumAggregateInputType
    _min?: ClientPassportMinAggregateInputType
    _max?: ClientPassportMaxAggregateInputType
  }

  export type ClientPassportGroupByOutputType = {
    id: number
    number: string | null
    issued: string | null
    code: string | null
    placeOfBirth: string | null
    registrationAddress: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClientPassportCountAggregateOutputType | null
    _avg: ClientPassportAvgAggregateOutputType | null
    _sum: ClientPassportSumAggregateOutputType | null
    _min: ClientPassportMinAggregateOutputType | null
    _max: ClientPassportMaxAggregateOutputType | null
  }

  type GetClientPassportGroupByPayload<T extends ClientPassportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientPassportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientPassportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientPassportGroupByOutputType[P]>
            : GetScalarType<T[P], ClientPassportGroupByOutputType[P]>
        }
      >
    >


  export type ClientPassportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    issued?: boolean
    code?: boolean
    placeOfBirth?: boolean
    registrationAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientIndividualProperties?: boolean | ClientPassport$clientIndividualPropertiesArgs<ExtArgs>
    clientIndividualMinorProperties?: boolean | ClientPassport$clientIndividualMinorPropertiesArgs<ExtArgs>
  }, ExtArgs["result"]["clientPassport"]>


  export type ClientPassportSelectScalar = {
    id?: boolean
    number?: boolean
    issued?: boolean
    code?: boolean
    placeOfBirth?: boolean
    registrationAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientPassportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientIndividualProperties?: boolean | ClientPassport$clientIndividualPropertiesArgs<ExtArgs>
    clientIndividualMinorProperties?: boolean | ClientPassport$clientIndividualMinorPropertiesArgs<ExtArgs>
  }

  export type $ClientPassportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientPassport"
    objects: {
      clientIndividualProperties: Prisma.$ClientIndividualPropertiesPayload<ExtArgs> | null
      clientIndividualMinorProperties: Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      number: string | null
      issued: string | null
      code: string | null
      placeOfBirth: string | null
      registrationAddress: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientPassport"]>
    composites: {}
  }

  type ClientPassportGetPayload<S extends boolean | null | undefined | ClientPassportDefaultArgs> = $Result.GetResult<Prisma.$ClientPassportPayload, S>

  type ClientPassportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientPassportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientPassportCountAggregateInputType | true
    }

  export interface ClientPassportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientPassport'], meta: { name: 'ClientPassport' } }
    /**
     * Find zero or one ClientPassport that matches the filter.
     * @param {ClientPassportFindUniqueArgs} args - Arguments to find a ClientPassport
     * @example
     * // Get one ClientPassport
     * const clientPassport = await prisma.clientPassport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientPassportFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientPassportFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClientPassport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientPassportFindUniqueOrThrowArgs} args - Arguments to find a ClientPassport
     * @example
     * // Get one ClientPassport
     * const clientPassport = await prisma.clientPassport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientPassportFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientPassportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClientPassport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPassportFindFirstArgs} args - Arguments to find a ClientPassport
     * @example
     * // Get one ClientPassport
     * const clientPassport = await prisma.clientPassport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientPassportFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientPassportFindFirstArgs<ExtArgs>>
    ): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClientPassport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPassportFindFirstOrThrowArgs} args - Arguments to find a ClientPassport
     * @example
     * // Get one ClientPassport
     * const clientPassport = await prisma.clientPassport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientPassportFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientPassportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClientPassports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPassportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientPassports
     * const clientPassports = await prisma.clientPassport.findMany()
     * 
     * // Get first 10 ClientPassports
     * const clientPassports = await prisma.clientPassport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientPassportWithIdOnly = await prisma.clientPassport.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientPassportFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientPassportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClientPassport.
     * @param {ClientPassportCreateArgs} args - Arguments to create a ClientPassport.
     * @example
     * // Create one ClientPassport
     * const ClientPassport = await prisma.clientPassport.create({
     *   data: {
     *     // ... data to create a ClientPassport
     *   }
     * })
     * 
    **/
    create<T extends ClientPassportCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientPassportCreateArgs<ExtArgs>>
    ): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClientPassports.
     * @param {ClientPassportCreateManyArgs} args - Arguments to create many ClientPassports.
     * @example
     * // Create many ClientPassports
     * const clientPassport = await prisma.clientPassport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientPassportCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientPassportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientPassport.
     * @param {ClientPassportDeleteArgs} args - Arguments to delete one ClientPassport.
     * @example
     * // Delete one ClientPassport
     * const ClientPassport = await prisma.clientPassport.delete({
     *   where: {
     *     // ... filter to delete one ClientPassport
     *   }
     * })
     * 
    **/
    delete<T extends ClientPassportDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientPassportDeleteArgs<ExtArgs>>
    ): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClientPassport.
     * @param {ClientPassportUpdateArgs} args - Arguments to update one ClientPassport.
     * @example
     * // Update one ClientPassport
     * const clientPassport = await prisma.clientPassport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientPassportUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientPassportUpdateArgs<ExtArgs>>
    ): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClientPassports.
     * @param {ClientPassportDeleteManyArgs} args - Arguments to filter ClientPassports to delete.
     * @example
     * // Delete a few ClientPassports
     * const { count } = await prisma.clientPassport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientPassportDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientPassportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientPassports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPassportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientPassports
     * const clientPassport = await prisma.clientPassport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientPassportUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientPassportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientPassport.
     * @param {ClientPassportUpsertArgs} args - Arguments to update or create a ClientPassport.
     * @example
     * // Update or create a ClientPassport
     * const clientPassport = await prisma.clientPassport.upsert({
     *   create: {
     *     // ... data to create a ClientPassport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientPassport we want to update
     *   }
     * })
    **/
    upsert<T extends ClientPassportUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientPassportUpsertArgs<ExtArgs>>
    ): Prisma__ClientPassportClient<$Result.GetResult<Prisma.$ClientPassportPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClientPassports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPassportCountArgs} args - Arguments to filter ClientPassports to count.
     * @example
     * // Count the number of ClientPassports
     * const count = await prisma.clientPassport.count({
     *   where: {
     *     // ... the filter for the ClientPassports we want to count
     *   }
     * })
    **/
    count<T extends ClientPassportCountArgs>(
      args?: Subset<T, ClientPassportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientPassportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientPassport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPassportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientPassportAggregateArgs>(args: Subset<T, ClientPassportAggregateArgs>): Prisma.PrismaPromise<GetClientPassportAggregateType<T>>

    /**
     * Group by ClientPassport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPassportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientPassportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientPassportGroupByArgs['orderBy'] }
        : { orderBy?: ClientPassportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientPassportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientPassportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientPassport model
   */
  readonly fields: ClientPassportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientPassport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientPassportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    clientIndividualProperties<T extends ClientPassport$clientIndividualPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, ClientPassport$clientIndividualPropertiesArgs<ExtArgs>>): Prisma__ClientIndividualPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    clientIndividualMinorProperties<T extends ClientPassport$clientIndividualMinorPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, ClientPassport$clientIndividualMinorPropertiesArgs<ExtArgs>>): Prisma__ClientIndividualMinorPropertiesClient<$Result.GetResult<Prisma.$ClientIndividualMinorPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClientPassport model
   */ 
  interface ClientPassportFieldRefs {
    readonly id: FieldRef<"ClientPassport", 'Int'>
    readonly number: FieldRef<"ClientPassport", 'String'>
    readonly issued: FieldRef<"ClientPassport", 'String'>
    readonly code: FieldRef<"ClientPassport", 'String'>
    readonly placeOfBirth: FieldRef<"ClientPassport", 'String'>
    readonly registrationAddress: FieldRef<"ClientPassport", 'String'>
    readonly createdAt: FieldRef<"ClientPassport", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientPassport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientPassport findUnique
   */
  export type ClientPassportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    /**
     * Filter, which ClientPassport to fetch.
     */
    where: ClientPassportWhereUniqueInput
  }

  /**
   * ClientPassport findUniqueOrThrow
   */
  export type ClientPassportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    /**
     * Filter, which ClientPassport to fetch.
     */
    where: ClientPassportWhereUniqueInput
  }

  /**
   * ClientPassport findFirst
   */
  export type ClientPassportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    /**
     * Filter, which ClientPassport to fetch.
     */
    where?: ClientPassportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPassports to fetch.
     */
    orderBy?: ClientPassportOrderByWithRelationInput | ClientPassportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientPassports.
     */
    cursor?: ClientPassportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPassports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPassports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientPassports.
     */
    distinct?: ClientPassportScalarFieldEnum | ClientPassportScalarFieldEnum[]
  }

  /**
   * ClientPassport findFirstOrThrow
   */
  export type ClientPassportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    /**
     * Filter, which ClientPassport to fetch.
     */
    where?: ClientPassportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPassports to fetch.
     */
    orderBy?: ClientPassportOrderByWithRelationInput | ClientPassportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientPassports.
     */
    cursor?: ClientPassportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPassports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPassports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientPassports.
     */
    distinct?: ClientPassportScalarFieldEnum | ClientPassportScalarFieldEnum[]
  }

  /**
   * ClientPassport findMany
   */
  export type ClientPassportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    /**
     * Filter, which ClientPassports to fetch.
     */
    where?: ClientPassportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPassports to fetch.
     */
    orderBy?: ClientPassportOrderByWithRelationInput | ClientPassportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientPassports.
     */
    cursor?: ClientPassportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPassports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPassports.
     */
    skip?: number
    distinct?: ClientPassportScalarFieldEnum | ClientPassportScalarFieldEnum[]
  }

  /**
   * ClientPassport create
   */
  export type ClientPassportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientPassport.
     */
    data: XOR<ClientPassportCreateInput, ClientPassportUncheckedCreateInput>
  }

  /**
   * ClientPassport createMany
   */
  export type ClientPassportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientPassports.
     */
    data: ClientPassportCreateManyInput | ClientPassportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientPassport update
   */
  export type ClientPassportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientPassport.
     */
    data: XOR<ClientPassportUpdateInput, ClientPassportUncheckedUpdateInput>
    /**
     * Choose, which ClientPassport to update.
     */
    where: ClientPassportWhereUniqueInput
  }

  /**
   * ClientPassport updateMany
   */
  export type ClientPassportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientPassports.
     */
    data: XOR<ClientPassportUpdateManyMutationInput, ClientPassportUncheckedUpdateManyInput>
    /**
     * Filter which ClientPassports to update
     */
    where?: ClientPassportWhereInput
  }

  /**
   * ClientPassport upsert
   */
  export type ClientPassportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientPassport to update in case it exists.
     */
    where: ClientPassportWhereUniqueInput
    /**
     * In case the ClientPassport found by the `where` argument doesn't exist, create a new ClientPassport with this data.
     */
    create: XOR<ClientPassportCreateInput, ClientPassportUncheckedCreateInput>
    /**
     * In case the ClientPassport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientPassportUpdateInput, ClientPassportUncheckedUpdateInput>
  }

  /**
   * ClientPassport delete
   */
  export type ClientPassportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
    /**
     * Filter which ClientPassport to delete.
     */
    where: ClientPassportWhereUniqueInput
  }

  /**
   * ClientPassport deleteMany
   */
  export type ClientPassportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientPassports to delete
     */
    where?: ClientPassportWhereInput
  }

  /**
   * ClientPassport.clientIndividualProperties
   */
  export type ClientPassport$clientIndividualPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualProperties
     */
    select?: ClientIndividualPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualPropertiesInclude<ExtArgs> | null
    where?: ClientIndividualPropertiesWhereInput
  }

  /**
   * ClientPassport.clientIndividualMinorProperties
   */
  export type ClientPassport$clientIndividualMinorPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientIndividualMinorProperties
     */
    select?: ClientIndividualMinorPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIndividualMinorPropertiesInclude<ExtArgs> | null
    where?: ClientIndividualMinorPropertiesWhereInput
  }

  /**
   * ClientPassport without action
   */
  export type ClientPassportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPassport
     */
    select?: ClientPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPassportInclude<ExtArgs> | null
  }


  /**
   * Model ClientContract
   */

  export type AggregateClientContract = {
    _count: ClientContractCountAggregateOutputType | null
    _avg: ClientContractAvgAggregateOutputType | null
    _sum: ClientContractSumAggregateOutputType | null
    _min: ClientContractMinAggregateOutputType | null
    _max: ClientContractMaxAggregateOutputType | null
  }

  export type ClientContractAvgAggregateOutputType = {
    id: number | null
    price: Decimal | null
    uuContractId: number | null
    dduClientContractPropertiesId: number | null
    dkpClientContractPropertiesId: number | null
    productId: number | null
    objectId: number | null
    realEstateAgentId: number | null
    managerId: number | null
    bankId: number | null
    subsidyId: number | null
  }

  export type ClientContractSumAggregateOutputType = {
    id: number | null
    price: Decimal | null
    uuContractId: number | null
    dduClientContractPropertiesId: number | null
    dkpClientContractPropertiesId: number | null
    productId: number | null
    objectId: number | null
    realEstateAgentId: number | null
    managerId: number | null
    bankId: number | null
    subsidyId: number | null
  }

  export type ClientContractMinAggregateOutputType = {
    id: number | null
    number: string | null
    date: Date | null
    registrationDate: Date | null
    price: Decimal | null
    clientContractType: $Enums.ClientContractType | null
    isRealEstateAgencyActDisabled: boolean | null
    isTransferActDisabled: boolean | null
    comment: string | null
    link: string | null
    uuContractId: number | null
    dduClientContractPropertiesId: number | null
    dkpClientContractPropertiesId: number | null
    productId: number | null
    objectId: number | null
    realEstateAgentId: number | null
    managerId: number | null
    bankId: number | null
    subsidyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientContractMaxAggregateOutputType = {
    id: number | null
    number: string | null
    date: Date | null
    registrationDate: Date | null
    price: Decimal | null
    clientContractType: $Enums.ClientContractType | null
    isRealEstateAgencyActDisabled: boolean | null
    isTransferActDisabled: boolean | null
    comment: string | null
    link: string | null
    uuContractId: number | null
    dduClientContractPropertiesId: number | null
    dkpClientContractPropertiesId: number | null
    productId: number | null
    objectId: number | null
    realEstateAgentId: number | null
    managerId: number | null
    bankId: number | null
    subsidyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientContractCountAggregateOutputType = {
    id: number
    number: number
    date: number
    registrationDate: number
    price: number
    clientContractType: number
    isRealEstateAgencyActDisabled: number
    isTransferActDisabled: number
    comment: number
    link: number
    uuContractId: number
    dduClientContractPropertiesId: number
    dkpClientContractPropertiesId: number
    productId: number
    objectId: number
    realEstateAgentId: number
    managerId: number
    bankId: number
    subsidyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientContractAvgAggregateInputType = {
    id?: true
    price?: true
    uuContractId?: true
    dduClientContractPropertiesId?: true
    dkpClientContractPropertiesId?: true
    productId?: true
    objectId?: true
    realEstateAgentId?: true
    managerId?: true
    bankId?: true
    subsidyId?: true
  }

  export type ClientContractSumAggregateInputType = {
    id?: true
    price?: true
    uuContractId?: true
    dduClientContractPropertiesId?: true
    dkpClientContractPropertiesId?: true
    productId?: true
    objectId?: true
    realEstateAgentId?: true
    managerId?: true
    bankId?: true
    subsidyId?: true
  }

  export type ClientContractMinAggregateInputType = {
    id?: true
    number?: true
    date?: true
    registrationDate?: true
    price?: true
    clientContractType?: true
    isRealEstateAgencyActDisabled?: true
    isTransferActDisabled?: true
    comment?: true
    link?: true
    uuContractId?: true
    dduClientContractPropertiesId?: true
    dkpClientContractPropertiesId?: true
    productId?: true
    objectId?: true
    realEstateAgentId?: true
    managerId?: true
    bankId?: true
    subsidyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientContractMaxAggregateInputType = {
    id?: true
    number?: true
    date?: true
    registrationDate?: true
    price?: true
    clientContractType?: true
    isRealEstateAgencyActDisabled?: true
    isTransferActDisabled?: true
    comment?: true
    link?: true
    uuContractId?: true
    dduClientContractPropertiesId?: true
    dkpClientContractPropertiesId?: true
    productId?: true
    objectId?: true
    realEstateAgentId?: true
    managerId?: true
    bankId?: true
    subsidyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientContractCountAggregateInputType = {
    id?: true
    number?: true
    date?: true
    registrationDate?: true
    price?: true
    clientContractType?: true
    isRealEstateAgencyActDisabled?: true
    isTransferActDisabled?: true
    comment?: true
    link?: true
    uuContractId?: true
    dduClientContractPropertiesId?: true
    dkpClientContractPropertiesId?: true
    productId?: true
    objectId?: true
    realEstateAgentId?: true
    managerId?: true
    bankId?: true
    subsidyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientContract to aggregate.
     */
    where?: ClientContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContracts to fetch.
     */
    orderBy?: ClientContractOrderByWithRelationInput | ClientContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientContracts
    **/
    _count?: true | ClientContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientContractMaxAggregateInputType
  }

  export type GetClientContractAggregateType<T extends ClientContractAggregateArgs> = {
        [P in keyof T & keyof AggregateClientContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientContract[P]>
      : GetScalarType<T[P], AggregateClientContract[P]>
  }




  export type ClientContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractWhereInput
    orderBy?: ClientContractOrderByWithAggregationInput | ClientContractOrderByWithAggregationInput[]
    by: ClientContractScalarFieldEnum[] | ClientContractScalarFieldEnum
    having?: ClientContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientContractCountAggregateInputType | true
    _avg?: ClientContractAvgAggregateInputType
    _sum?: ClientContractSumAggregateInputType
    _min?: ClientContractMinAggregateInputType
    _max?: ClientContractMaxAggregateInputType
  }

  export type ClientContractGroupByOutputType = {
    id: number
    number: string
    date: Date
    registrationDate: Date | null
    price: Decimal
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled: boolean | null
    isTransferActDisabled: boolean | null
    comment: string | null
    link: string | null
    uuContractId: number | null
    dduClientContractPropertiesId: number | null
    dkpClientContractPropertiesId: number | null
    productId: number
    objectId: number
    realEstateAgentId: number | null
    managerId: number | null
    bankId: number | null
    subsidyId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ClientContractCountAggregateOutputType | null
    _avg: ClientContractAvgAggregateOutputType | null
    _sum: ClientContractSumAggregateOutputType | null
    _min: ClientContractMinAggregateOutputType | null
    _max: ClientContractMaxAggregateOutputType | null
  }

  type GetClientContractGroupByPayload<T extends ClientContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientContractGroupByOutputType[P]>
            : GetScalarType<T[P], ClientContractGroupByOutputType[P]>
        }
      >
    >


  export type ClientContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    registrationDate?: boolean
    price?: boolean
    clientContractType?: boolean
    isRealEstateAgencyActDisabled?: boolean
    isTransferActDisabled?: boolean
    comment?: boolean
    link?: boolean
    uuContractId?: boolean
    dduClientContractPropertiesId?: boolean
    dkpClientContractPropertiesId?: boolean
    productId?: boolean
    objectId?: boolean
    realEstateAgentId?: boolean
    managerId?: boolean
    bankId?: boolean
    subsidyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transferAct?: boolean | ClientContract$transferActArgs<ExtArgs>
    dduClientContractProperties?: boolean | ClientContract$dduClientContractPropertiesArgs<ExtArgs>
    dkpClientContractProperties?: boolean | ClientContract$dkpClientContractPropertiesArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    realEstateAgent?: boolean | ClientContract$realEstateAgentArgs<ExtArgs>
    manager?: boolean | ClientContract$managerArgs<ExtArgs>
    bank?: boolean | ClientContract$bankArgs<ExtArgs>
    subsidy?: boolean | ClientContract$subsidyArgs<ExtArgs>
    scheduledPayments?: boolean | ClientContract$scheduledPaymentsArgs<ExtArgs>
    actualPayments?: boolean | ClientContract$actualPaymentsArgs<ExtArgs>
    realEstateAgencyActs?: boolean | ClientContract$realEstateAgencyActsArgs<ExtArgs>
    assignments?: boolean | ClientContract$assignmentsArgs<ExtArgs>
    clientContractsToClients?: boolean | ClientContract$clientContractsToClientsArgs<ExtArgs>
    clientContractsToAgencyContracts?: boolean | ClientContract$clientContractsToAgencyContractsArgs<ExtArgs>
    _count?: boolean | ClientContractCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientContract"]>


  export type ClientContractSelectScalar = {
    id?: boolean
    number?: boolean
    date?: boolean
    registrationDate?: boolean
    price?: boolean
    clientContractType?: boolean
    isRealEstateAgencyActDisabled?: boolean
    isTransferActDisabled?: boolean
    comment?: boolean
    link?: boolean
    uuContractId?: boolean
    dduClientContractPropertiesId?: boolean
    dkpClientContractPropertiesId?: boolean
    productId?: boolean
    objectId?: boolean
    realEstateAgentId?: boolean
    managerId?: boolean
    bankId?: boolean
    subsidyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transferAct?: boolean | ClientContract$transferActArgs<ExtArgs>
    dduClientContractProperties?: boolean | ClientContract$dduClientContractPropertiesArgs<ExtArgs>
    dkpClientContractProperties?: boolean | ClientContract$dkpClientContractPropertiesArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    realEstateAgent?: boolean | ClientContract$realEstateAgentArgs<ExtArgs>
    manager?: boolean | ClientContract$managerArgs<ExtArgs>
    bank?: boolean | ClientContract$bankArgs<ExtArgs>
    subsidy?: boolean | ClientContract$subsidyArgs<ExtArgs>
    scheduledPayments?: boolean | ClientContract$scheduledPaymentsArgs<ExtArgs>
    actualPayments?: boolean | ClientContract$actualPaymentsArgs<ExtArgs>
    realEstateAgencyActs?: boolean | ClientContract$realEstateAgencyActsArgs<ExtArgs>
    assignments?: boolean | ClientContract$assignmentsArgs<ExtArgs>
    clientContractsToClients?: boolean | ClientContract$clientContractsToClientsArgs<ExtArgs>
    clientContractsToAgencyContracts?: boolean | ClientContract$clientContractsToAgencyContractsArgs<ExtArgs>
    _count?: boolean | ClientContractCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClientContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientContract"
    objects: {
      transferAct: Prisma.$TransferActPayload<ExtArgs> | null
      dduClientContractProperties: Prisma.$DduClientContractPropertiesPayload<ExtArgs> | null
      dkpClientContractProperties: Prisma.$DkpClientContractPropertiesPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs>
      object: Prisma.$ObjectPayload<ExtArgs>
      realEstateAgent: Prisma.$RealEstateAgentPayload<ExtArgs> | null
      manager: Prisma.$UserPayload<ExtArgs> | null
      bank: Prisma.$BankPayload<ExtArgs> | null
      subsidy: Prisma.$SubsidyPayload<ExtArgs> | null
      scheduledPayments: Prisma.$ScheduledPaymentPayload<ExtArgs>[]
      actualPayments: Prisma.$ActualPaymentPayload<ExtArgs>[]
      realEstateAgencyActs: Prisma.$RealEstateAgencyActPayload<ExtArgs>[]
      assignments: Prisma.$AssignmentPayload<ExtArgs>[]
      clientContractsToClients: Prisma.$ClientContractToClientPayload<ExtArgs>[]
      clientContractsToAgencyContracts: Prisma.$ClientContractToAgencyContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      number: string
      date: Date
      registrationDate: Date | null
      price: Prisma.Decimal
      clientContractType: $Enums.ClientContractType
      isRealEstateAgencyActDisabled: boolean | null
      isTransferActDisabled: boolean | null
      comment: string | null
      link: string | null
      uuContractId: number | null
      dduClientContractPropertiesId: number | null
      dkpClientContractPropertiesId: number | null
      productId: number
      objectId: number
      realEstateAgentId: number | null
      managerId: number | null
      bankId: number | null
      subsidyId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientContract"]>
    composites: {}
  }

  type ClientContractGetPayload<S extends boolean | null | undefined | ClientContractDefaultArgs> = $Result.GetResult<Prisma.$ClientContractPayload, S>

  type ClientContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientContractFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientContractCountAggregateInputType | true
    }

  export interface ClientContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientContract'], meta: { name: 'ClientContract' } }
    /**
     * Find zero or one ClientContract that matches the filter.
     * @param {ClientContractFindUniqueArgs} args - Arguments to find a ClientContract
     * @example
     * // Get one ClientContract
     * const clientContract = await prisma.clientContract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientContractFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClientContract that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientContractFindUniqueOrThrowArgs} args - Arguments to find a ClientContract
     * @example
     * // Get one ClientContract
     * const clientContract = await prisma.clientContract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientContractFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClientContract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractFindFirstArgs} args - Arguments to find a ClientContract
     * @example
     * // Get one ClientContract
     * const clientContract = await prisma.clientContract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientContractFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractFindFirstArgs<ExtArgs>>
    ): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClientContract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractFindFirstOrThrowArgs} args - Arguments to find a ClientContract
     * @example
     * // Get one ClientContract
     * const clientContract = await prisma.clientContract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientContractFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClientContracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientContracts
     * const clientContracts = await prisma.clientContract.findMany()
     * 
     * // Get first 10 ClientContracts
     * const clientContracts = await prisma.clientContract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientContractWithIdOnly = await prisma.clientContract.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientContractFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClientContract.
     * @param {ClientContractCreateArgs} args - Arguments to create a ClientContract.
     * @example
     * // Create one ClientContract
     * const ClientContract = await prisma.clientContract.create({
     *   data: {
     *     // ... data to create a ClientContract
     *   }
     * })
     * 
    **/
    create<T extends ClientContractCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractCreateArgs<ExtArgs>>
    ): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClientContracts.
     * @param {ClientContractCreateManyArgs} args - Arguments to create many ClientContracts.
     * @example
     * // Create many ClientContracts
     * const clientContract = await prisma.clientContract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientContractCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientContract.
     * @param {ClientContractDeleteArgs} args - Arguments to delete one ClientContract.
     * @example
     * // Delete one ClientContract
     * const ClientContract = await prisma.clientContract.delete({
     *   where: {
     *     // ... filter to delete one ClientContract
     *   }
     * })
     * 
    **/
    delete<T extends ClientContractDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractDeleteArgs<ExtArgs>>
    ): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClientContract.
     * @param {ClientContractUpdateArgs} args - Arguments to update one ClientContract.
     * @example
     * // Update one ClientContract
     * const clientContract = await prisma.clientContract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientContractUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractUpdateArgs<ExtArgs>>
    ): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClientContracts.
     * @param {ClientContractDeleteManyArgs} args - Arguments to filter ClientContracts to delete.
     * @example
     * // Delete a few ClientContracts
     * const { count } = await prisma.clientContract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientContractDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientContracts
     * const clientContract = await prisma.clientContract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientContractUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientContract.
     * @param {ClientContractUpsertArgs} args - Arguments to update or create a ClientContract.
     * @example
     * // Update or create a ClientContract
     * const clientContract = await prisma.clientContract.upsert({
     *   create: {
     *     // ... data to create a ClientContract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientContract we want to update
     *   }
     * })
    **/
    upsert<T extends ClientContractUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractUpsertArgs<ExtArgs>>
    ): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClientContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractCountArgs} args - Arguments to filter ClientContracts to count.
     * @example
     * // Count the number of ClientContracts
     * const count = await prisma.clientContract.count({
     *   where: {
     *     // ... the filter for the ClientContracts we want to count
     *   }
     * })
    **/
    count<T extends ClientContractCountArgs>(
      args?: Subset<T, ClientContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientContractAggregateArgs>(args: Subset<T, ClientContractAggregateArgs>): Prisma.PrismaPromise<GetClientContractAggregateType<T>>

    /**
     * Group by ClientContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientContractGroupByArgs['orderBy'] }
        : { orderBy?: ClientContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientContract model
   */
  readonly fields: ClientContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientContract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    transferAct<T extends ClientContract$transferActArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$transferActArgs<ExtArgs>>): Prisma__TransferActClient<$Result.GetResult<Prisma.$TransferActPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    dduClientContractProperties<T extends ClientContract$dduClientContractPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$dduClientContractPropertiesArgs<ExtArgs>>): Prisma__DduClientContractPropertiesClient<$Result.GetResult<Prisma.$DduClientContractPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    dkpClientContractProperties<T extends ClientContract$dkpClientContractPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$dkpClientContractPropertiesArgs<ExtArgs>>): Prisma__DkpClientContractPropertiesClient<$Result.GetResult<Prisma.$DkpClientContractPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    object<T extends ObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectDefaultArgs<ExtArgs>>): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    realEstateAgent<T extends ClientContract$realEstateAgentArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$realEstateAgentArgs<ExtArgs>>): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    manager<T extends ClientContract$managerArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    bank<T extends ClientContract$bankArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$bankArgs<ExtArgs>>): Prisma__BankClient<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    subsidy<T extends ClientContract$subsidyArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$subsidyArgs<ExtArgs>>): Prisma__SubsidyClient<$Result.GetResult<Prisma.$SubsidyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    scheduledPayments<T extends ClientContract$scheduledPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$scheduledPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    actualPayments<T extends ClientContract$actualPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$actualPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    realEstateAgencyActs<T extends ClientContract$realEstateAgencyActsArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$realEstateAgencyActsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RealEstateAgencyActPayload<ExtArgs>, T, 'findMany'> | Null>;

    assignments<T extends ClientContract$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    clientContractsToClients<T extends ClientContract$clientContractsToClientsArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$clientContractsToClientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'findMany'> | Null>;

    clientContractsToAgencyContracts<T extends ClientContract$clientContractsToAgencyContractsArgs<ExtArgs> = {}>(args?: Subset<T, ClientContract$clientContractsToAgencyContractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClientContract model
   */ 
  interface ClientContractFieldRefs {
    readonly id: FieldRef<"ClientContract", 'Int'>
    readonly number: FieldRef<"ClientContract", 'String'>
    readonly date: FieldRef<"ClientContract", 'DateTime'>
    readonly registrationDate: FieldRef<"ClientContract", 'DateTime'>
    readonly price: FieldRef<"ClientContract", 'Decimal'>
    readonly clientContractType: FieldRef<"ClientContract", 'ClientContractType'>
    readonly isRealEstateAgencyActDisabled: FieldRef<"ClientContract", 'Boolean'>
    readonly isTransferActDisabled: FieldRef<"ClientContract", 'Boolean'>
    readonly comment: FieldRef<"ClientContract", 'String'>
    readonly link: FieldRef<"ClientContract", 'String'>
    readonly uuContractId: FieldRef<"ClientContract", 'Int'>
    readonly dduClientContractPropertiesId: FieldRef<"ClientContract", 'Int'>
    readonly dkpClientContractPropertiesId: FieldRef<"ClientContract", 'Int'>
    readonly productId: FieldRef<"ClientContract", 'Int'>
    readonly objectId: FieldRef<"ClientContract", 'Int'>
    readonly realEstateAgentId: FieldRef<"ClientContract", 'Int'>
    readonly managerId: FieldRef<"ClientContract", 'Int'>
    readonly bankId: FieldRef<"ClientContract", 'Int'>
    readonly subsidyId: FieldRef<"ClientContract", 'Int'>
    readonly createdAt: FieldRef<"ClientContract", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientContract", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientContract findUnique
   */
  export type ClientContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContract to fetch.
     */
    where: ClientContractWhereUniqueInput
  }

  /**
   * ClientContract findUniqueOrThrow
   */
  export type ClientContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContract to fetch.
     */
    where: ClientContractWhereUniqueInput
  }

  /**
   * ClientContract findFirst
   */
  export type ClientContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContract to fetch.
     */
    where?: ClientContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContracts to fetch.
     */
    orderBy?: ClientContractOrderByWithRelationInput | ClientContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientContracts.
     */
    cursor?: ClientContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientContracts.
     */
    distinct?: ClientContractScalarFieldEnum | ClientContractScalarFieldEnum[]
  }

  /**
   * ClientContract findFirstOrThrow
   */
  export type ClientContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContract to fetch.
     */
    where?: ClientContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContracts to fetch.
     */
    orderBy?: ClientContractOrderByWithRelationInput | ClientContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientContracts.
     */
    cursor?: ClientContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientContracts.
     */
    distinct?: ClientContractScalarFieldEnum | ClientContractScalarFieldEnum[]
  }

  /**
   * ClientContract findMany
   */
  export type ClientContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContracts to fetch.
     */
    where?: ClientContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContracts to fetch.
     */
    orderBy?: ClientContractOrderByWithRelationInput | ClientContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientContracts.
     */
    cursor?: ClientContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContracts.
     */
    skip?: number
    distinct?: ClientContractScalarFieldEnum | ClientContractScalarFieldEnum[]
  }

  /**
   * ClientContract create
   */
  export type ClientContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientContract.
     */
    data: XOR<ClientContractCreateInput, ClientContractUncheckedCreateInput>
  }

  /**
   * ClientContract createMany
   */
  export type ClientContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientContracts.
     */
    data: ClientContractCreateManyInput | ClientContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientContract update
   */
  export type ClientContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientContract.
     */
    data: XOR<ClientContractUpdateInput, ClientContractUncheckedUpdateInput>
    /**
     * Choose, which ClientContract to update.
     */
    where: ClientContractWhereUniqueInput
  }

  /**
   * ClientContract updateMany
   */
  export type ClientContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientContracts.
     */
    data: XOR<ClientContractUpdateManyMutationInput, ClientContractUncheckedUpdateManyInput>
    /**
     * Filter which ClientContracts to update
     */
    where?: ClientContractWhereInput
  }

  /**
   * ClientContract upsert
   */
  export type ClientContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientContract to update in case it exists.
     */
    where: ClientContractWhereUniqueInput
    /**
     * In case the ClientContract found by the `where` argument doesn't exist, create a new ClientContract with this data.
     */
    create: XOR<ClientContractCreateInput, ClientContractUncheckedCreateInput>
    /**
     * In case the ClientContract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientContractUpdateInput, ClientContractUncheckedUpdateInput>
  }

  /**
   * ClientContract delete
   */
  export type ClientContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    /**
     * Filter which ClientContract to delete.
     */
    where: ClientContractWhereUniqueInput
  }

  /**
   * ClientContract deleteMany
   */
  export type ClientContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientContracts to delete
     */
    where?: ClientContractWhereInput
  }

  /**
   * ClientContract.transferAct
   */
  export type ClientContract$transferActArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferAct
     */
    select?: TransferActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActInclude<ExtArgs> | null
    where?: TransferActWhereInput
  }

  /**
   * ClientContract.dduClientContractProperties
   */
  export type ClientContract$dduClientContractPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DduClientContractProperties
     */
    select?: DduClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DduClientContractPropertiesInclude<ExtArgs> | null
    where?: DduClientContractPropertiesWhereInput
  }

  /**
   * ClientContract.dkpClientContractProperties
   */
  export type ClientContract$dkpClientContractPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DkpClientContractProperties
     */
    select?: DkpClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DkpClientContractPropertiesInclude<ExtArgs> | null
    where?: DkpClientContractPropertiesWhereInput
  }

  /**
   * ClientContract.realEstateAgent
   */
  export type ClientContract$realEstateAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    where?: RealEstateAgentWhereInput
  }

  /**
   * ClientContract.manager
   */
  export type ClientContract$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ClientContract.bank
   */
  export type ClientContract$bankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    where?: BankWhereInput
  }

  /**
   * ClientContract.subsidy
   */
  export type ClientContract$subsidyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subsidy
     */
    select?: SubsidySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyInclude<ExtArgs> | null
    where?: SubsidyWhereInput
  }

  /**
   * ClientContract.scheduledPayments
   */
  export type ClientContract$scheduledPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    where?: ScheduledPaymentWhereInput
    orderBy?: ScheduledPaymentOrderByWithRelationInput | ScheduledPaymentOrderByWithRelationInput[]
    cursor?: ScheduledPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledPaymentScalarFieldEnum | ScheduledPaymentScalarFieldEnum[]
  }

  /**
   * ClientContract.actualPayments
   */
  export type ClientContract$actualPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    where?: ActualPaymentWhereInput
    orderBy?: ActualPaymentOrderByWithRelationInput | ActualPaymentOrderByWithRelationInput[]
    cursor?: ActualPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActualPaymentScalarFieldEnum | ActualPaymentScalarFieldEnum[]
  }

  /**
   * ClientContract.realEstateAgencyActs
   */
  export type ClientContract$realEstateAgencyActsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyAct
     */
    select?: RealEstateAgencyActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyActInclude<ExtArgs> | null
    where?: RealEstateAgencyActWhereInput
    orderBy?: RealEstateAgencyActOrderByWithRelationInput | RealEstateAgencyActOrderByWithRelationInput[]
    cursor?: RealEstateAgencyActWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RealEstateAgencyActScalarFieldEnum | RealEstateAgencyActScalarFieldEnum[]
  }

  /**
   * ClientContract.assignments
   */
  export type ClientContract$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * ClientContract.clientContractsToClients
   */
  export type ClientContract$clientContractsToClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    where?: ClientContractToClientWhereInput
    orderBy?: ClientContractToClientOrderByWithRelationInput | ClientContractToClientOrderByWithRelationInput[]
    cursor?: ClientContractToClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientContractToClientScalarFieldEnum | ClientContractToClientScalarFieldEnum[]
  }

  /**
   * ClientContract.clientContractsToAgencyContracts
   */
  export type ClientContract$clientContractsToAgencyContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    where?: ClientContractToAgencyContractWhereInput
    orderBy?: ClientContractToAgencyContractOrderByWithRelationInput | ClientContractToAgencyContractOrderByWithRelationInput[]
    cursor?: ClientContractToAgencyContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientContractToAgencyContractScalarFieldEnum | ClientContractToAgencyContractScalarFieldEnum[]
  }

  /**
   * ClientContract without action
   */
  export type ClientContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
  }


  /**
   * Model DduClientContractProperties
   */

  export type AggregateDduClientContractProperties = {
    _count: DduClientContractPropertiesCountAggregateOutputType | null
    _avg: DduClientContractPropertiesAvgAggregateOutputType | null
    _sum: DduClientContractPropertiesSumAggregateOutputType | null
    _min: DduClientContractPropertiesMinAggregateOutputType | null
    _max: DduClientContractPropertiesMaxAggregateOutputType | null
  }

  export type DduClientContractPropertiesAvgAggregateOutputType = {
    id: number | null
  }

  export type DduClientContractPropertiesSumAggregateOutputType = {
    id: number | null
  }

  export type DduClientContractPropertiesMinAggregateOutputType = {
    id: number | null
    dduLink: string | null
    returnAccount: string | null
    escrowAccountOpeningDate: Date | null
    escrowPeriod: Date | null
    escrowAccountNumber: string | null
    isEscrowDiscount: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DduClientContractPropertiesMaxAggregateOutputType = {
    id: number | null
    dduLink: string | null
    returnAccount: string | null
    escrowAccountOpeningDate: Date | null
    escrowPeriod: Date | null
    escrowAccountNumber: string | null
    isEscrowDiscount: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DduClientContractPropertiesCountAggregateOutputType = {
    id: number
    dduLink: number
    returnAccount: number
    escrowAccountOpeningDate: number
    escrowPeriod: number
    escrowAccountNumber: number
    isEscrowDiscount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DduClientContractPropertiesAvgAggregateInputType = {
    id?: true
  }

  export type DduClientContractPropertiesSumAggregateInputType = {
    id?: true
  }

  export type DduClientContractPropertiesMinAggregateInputType = {
    id?: true
    dduLink?: true
    returnAccount?: true
    escrowAccountOpeningDate?: true
    escrowPeriod?: true
    escrowAccountNumber?: true
    isEscrowDiscount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DduClientContractPropertiesMaxAggregateInputType = {
    id?: true
    dduLink?: true
    returnAccount?: true
    escrowAccountOpeningDate?: true
    escrowPeriod?: true
    escrowAccountNumber?: true
    isEscrowDiscount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DduClientContractPropertiesCountAggregateInputType = {
    id?: true
    dduLink?: true
    returnAccount?: true
    escrowAccountOpeningDate?: true
    escrowPeriod?: true
    escrowAccountNumber?: true
    isEscrowDiscount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DduClientContractPropertiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DduClientContractProperties to aggregate.
     */
    where?: DduClientContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DduClientContractProperties to fetch.
     */
    orderBy?: DduClientContractPropertiesOrderByWithRelationInput | DduClientContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DduClientContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DduClientContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DduClientContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DduClientContractProperties
    **/
    _count?: true | DduClientContractPropertiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DduClientContractPropertiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DduClientContractPropertiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DduClientContractPropertiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DduClientContractPropertiesMaxAggregateInputType
  }

  export type GetDduClientContractPropertiesAggregateType<T extends DduClientContractPropertiesAggregateArgs> = {
        [P in keyof T & keyof AggregateDduClientContractProperties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDduClientContractProperties[P]>
      : GetScalarType<T[P], AggregateDduClientContractProperties[P]>
  }




  export type DduClientContractPropertiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DduClientContractPropertiesWhereInput
    orderBy?: DduClientContractPropertiesOrderByWithAggregationInput | DduClientContractPropertiesOrderByWithAggregationInput[]
    by: DduClientContractPropertiesScalarFieldEnum[] | DduClientContractPropertiesScalarFieldEnum
    having?: DduClientContractPropertiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DduClientContractPropertiesCountAggregateInputType | true
    _avg?: DduClientContractPropertiesAvgAggregateInputType
    _sum?: DduClientContractPropertiesSumAggregateInputType
    _min?: DduClientContractPropertiesMinAggregateInputType
    _max?: DduClientContractPropertiesMaxAggregateInputType
  }

  export type DduClientContractPropertiesGroupByOutputType = {
    id: number
    dduLink: string | null
    returnAccount: string | null
    escrowAccountOpeningDate: Date | null
    escrowPeriod: Date | null
    escrowAccountNumber: string | null
    isEscrowDiscount: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: DduClientContractPropertiesCountAggregateOutputType | null
    _avg: DduClientContractPropertiesAvgAggregateOutputType | null
    _sum: DduClientContractPropertiesSumAggregateOutputType | null
    _min: DduClientContractPropertiesMinAggregateOutputType | null
    _max: DduClientContractPropertiesMaxAggregateOutputType | null
  }

  type GetDduClientContractPropertiesGroupByPayload<T extends DduClientContractPropertiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DduClientContractPropertiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DduClientContractPropertiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DduClientContractPropertiesGroupByOutputType[P]>
            : GetScalarType<T[P], DduClientContractPropertiesGroupByOutputType[P]>
        }
      >
    >


  export type DduClientContractPropertiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dduLink?: boolean
    returnAccount?: boolean
    escrowAccountOpeningDate?: boolean
    escrowPeriod?: boolean
    escrowAccountNumber?: boolean
    isEscrowDiscount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientContract?: boolean | DduClientContractProperties$clientContractArgs<ExtArgs>
  }, ExtArgs["result"]["dduClientContractProperties"]>


  export type DduClientContractPropertiesSelectScalar = {
    id?: boolean
    dduLink?: boolean
    returnAccount?: boolean
    escrowAccountOpeningDate?: boolean
    escrowPeriod?: boolean
    escrowAccountNumber?: boolean
    isEscrowDiscount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DduClientContractPropertiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientContract?: boolean | DduClientContractProperties$clientContractArgs<ExtArgs>
  }

  export type $DduClientContractPropertiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DduClientContractProperties"
    objects: {
      clientContract: Prisma.$ClientContractPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dduLink: string | null
      returnAccount: string | null
      escrowAccountOpeningDate: Date | null
      escrowPeriod: Date | null
      escrowAccountNumber: string | null
      isEscrowDiscount: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dduClientContractProperties"]>
    composites: {}
  }

  type DduClientContractPropertiesGetPayload<S extends boolean | null | undefined | DduClientContractPropertiesDefaultArgs> = $Result.GetResult<Prisma.$DduClientContractPropertiesPayload, S>

  type DduClientContractPropertiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DduClientContractPropertiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DduClientContractPropertiesCountAggregateInputType | true
    }

  export interface DduClientContractPropertiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DduClientContractProperties'], meta: { name: 'DduClientContractProperties' } }
    /**
     * Find zero or one DduClientContractProperties that matches the filter.
     * @param {DduClientContractPropertiesFindUniqueArgs} args - Arguments to find a DduClientContractProperties
     * @example
     * // Get one DduClientContractProperties
     * const dduClientContractProperties = await prisma.dduClientContractProperties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DduClientContractPropertiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DduClientContractPropertiesFindUniqueArgs<ExtArgs>>
    ): Prisma__DduClientContractPropertiesClient<$Result.GetResult<Prisma.$DduClientContractPropertiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DduClientContractProperties that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DduClientContractPropertiesFindUniqueOrThrowArgs} args - Arguments to find a DduClientContractProperties
     * @example
     * // Get one DduClientContractProperties
     * const dduClientContractProperties = await prisma.dduClientContractProperties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DduClientContractPropertiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DduClientContractPropertiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DduClientContractPropertiesClient<$Result.GetResult<Prisma.$DduClientContractPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DduClientContractProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DduClientContractPropertiesFindFirstArgs} args - Arguments to find a DduClientContractProperties
     * @example
     * // Get one DduClientContractProperties
     * const dduClientContractProperties = await prisma.dduClientContractProperties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DduClientContractPropertiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DduClientContractPropertiesFindFirstArgs<ExtArgs>>
    ): Prisma__DduClientContractPropertiesClient<$Result.GetResult<Prisma.$DduClientContractPropertiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DduClientContractProperties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DduClientContractPropertiesFindFirstOrThrowArgs} args - Arguments to find a DduClientContractProperties
     * @example
     * // Get one DduClientContractProperties
     * const dduClientContractProperties = await prisma.dduClientContractProperties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DduClientContractPropertiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DduClientContractPropertiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DduClientContractPropertiesClient<$Result.GetResult<Prisma.$DduClientContractPropertiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DduClientContractProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DduClientContractPropertiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DduClientContractProperties
     * const dduClientContractProperties = await prisma.dduClientContractProperties.findMany()
     * 
     * // Get first 10 DduClientContractProperties
     * const dduClientContractProperties = await prisma.dduClientContractProperties.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dduClientContractPropertiesWithIdOnly = await prisma.dduClientContractProperties.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DduClientContractPropertiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DduClientContractPropertiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DduClientContractPropertiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DduClientContractProperties.
     * @param {DduClientContractPropertiesCreateArgs} args - Arguments to create a DduClientContractProperties.
     * @example
     * // Create one DduClientContractProperties
     * const DduClientContractProperties = await prisma.dduClientContractProperties.create({
     *   data: {
     *     // ... data to create a DduClientContractProperties
     *   }
     * })
     * 
    **/
    create<T extends DduClientContractPropertiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DduClientContractPropertiesCreateArgs<ExtArgs>>
    ): Prisma__DduClientContractPropertiesClient<$Result.GetResult<Prisma.$DduClientContractPropertiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DduClientContractProperties.
     * @param {DduClientContractPropertiesCreateManyArgs} args - Arguments to create many DduClientContractProperties.
     * @example
     * // Create many DduClientContractProperties
     * const dduClientContractProperties = await prisma.dduClientContractProperties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends DduClientContractPropertiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DduClientContractPropertiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DduClientContractProperties.
     * @param {DduClientContractPropertiesDeleteArgs} args - Arguments to delete one DduClientContractProperties.
     * @example
     * // Delete one DduClientContractProperties
     * const DduClientContractProperties = await prisma.dduClientContractProperties.delete({
     *   where: {
     *     // ... filter to delete one DduClientContractProperties
     *   }
     * })
     * 
    **/
    delete<T extends DduClientContractPropertiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DduClientContractPropertiesDeleteArgs<ExtArgs>>
    ): Prisma__DduClientContractPropertiesClient<$Result.GetResult<Prisma.$DduClientContractPropertiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DduClientContractProperties.
     * @param {DduClientContractPropertiesUpdateArgs} args - Arguments to update one DduClientContractProperties.
     * @example
     * // Update one DduClientContractProperties
     * const dduClientContractProperties = await prisma.dduClientContractProperties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DduClientContractPropertiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DduClientContractPropertiesUpdateArgs<ExtArgs>>
    ): Prisma__DduClientContractPropertiesClient<$Result.GetResult<Prisma.$DduClientContractPropertiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DduClientContractProperties.
     * @param {DduClientContractPropertiesDeleteManyArgs} args - Arguments to filter DduClientContractProperties to delete.
     * @example
     * // Delete a few DduClientContractProperties
     * const { count } = await prisma.dduClientContractProperties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DduClientContractPropertiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DduClientContractPropertiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DduClientContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DduClientContractPropertiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DduClientContractProperties
     * const dduClientContractProperties = await prisma.dduClientContractProperties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DduClientContractPropertiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DduClientContractPropertiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DduClientContractProperties.
     * @param {DduClientContractPropertiesUpsertArgs} args - Arguments to update or create a DduClientContractProperties.
     * @example
     * // Update or create a DduClientContractProperties
     * const dduClientContractProperties = await prisma.dduClientContractProperties.upsert({
     *   create: {
     *     // ... data to create a DduClientContractProperties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DduClientContractProperties we want to update
     *   }
     * })
    **/
    upsert<T extends DduClientContractPropertiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DduClientContractPropertiesUpsertArgs<ExtArgs>>
    ): Prisma__DduClientContractPropertiesClient<$Result.GetResult<Prisma.$DduClientContractPropertiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DduClientContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DduClientContractPropertiesCountArgs} args - Arguments to filter DduClientContractProperties to count.
     * @example
     * // Count the number of DduClientContractProperties
     * const count = await prisma.dduClientContractProperties.count({
     *   where: {
     *     // ... the filter for the DduClientContractProperties we want to count
     *   }
     * })
    **/
    count<T extends DduClientContractPropertiesCountArgs>(
      args?: Subset<T, DduClientContractPropertiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DduClientContractPropertiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DduClientContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DduClientContractPropertiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DduClientContractPropertiesAggregateArgs>(args: Subset<T, DduClientContractPropertiesAggregateArgs>): Prisma.PrismaPromise<GetDduClientContractPropertiesAggregateType<T>>

    /**
     * Group by DduClientContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DduClientContractPropertiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DduClientContractPropertiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DduClientContractPropertiesGroupByArgs['orderBy'] }
        : { orderBy?: DduClientContractPropertiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DduClientContractPropertiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDduClientContractPropertiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DduClientContractProperties model
   */
  readonly fields: DduClientContractPropertiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DduClientContractProperties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DduClientContractPropertiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    clientContract<T extends DduClientContractProperties$clientContractArgs<ExtArgs> = {}>(args?: Subset<T, DduClientContractProperties$clientContractArgs<ExtArgs>>): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DduClientContractProperties model
   */ 
  interface DduClientContractPropertiesFieldRefs {
    readonly id: FieldRef<"DduClientContractProperties", 'Int'>
    readonly dduLink: FieldRef<"DduClientContractProperties", 'String'>
    readonly returnAccount: FieldRef<"DduClientContractProperties", 'String'>
    readonly escrowAccountOpeningDate: FieldRef<"DduClientContractProperties", 'DateTime'>
    readonly escrowPeriod: FieldRef<"DduClientContractProperties", 'DateTime'>
    readonly escrowAccountNumber: FieldRef<"DduClientContractProperties", 'String'>
    readonly isEscrowDiscount: FieldRef<"DduClientContractProperties", 'Boolean'>
    readonly createdAt: FieldRef<"DduClientContractProperties", 'DateTime'>
    readonly updatedAt: FieldRef<"DduClientContractProperties", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DduClientContractProperties findUnique
   */
  export type DduClientContractPropertiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DduClientContractProperties
     */
    select?: DduClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DduClientContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which DduClientContractProperties to fetch.
     */
    where: DduClientContractPropertiesWhereUniqueInput
  }

  /**
   * DduClientContractProperties findUniqueOrThrow
   */
  export type DduClientContractPropertiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DduClientContractProperties
     */
    select?: DduClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DduClientContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which DduClientContractProperties to fetch.
     */
    where: DduClientContractPropertiesWhereUniqueInput
  }

  /**
   * DduClientContractProperties findFirst
   */
  export type DduClientContractPropertiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DduClientContractProperties
     */
    select?: DduClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DduClientContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which DduClientContractProperties to fetch.
     */
    where?: DduClientContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DduClientContractProperties to fetch.
     */
    orderBy?: DduClientContractPropertiesOrderByWithRelationInput | DduClientContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DduClientContractProperties.
     */
    cursor?: DduClientContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DduClientContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DduClientContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DduClientContractProperties.
     */
    distinct?: DduClientContractPropertiesScalarFieldEnum | DduClientContractPropertiesScalarFieldEnum[]
  }

  /**
   * DduClientContractProperties findFirstOrThrow
   */
  export type DduClientContractPropertiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DduClientContractProperties
     */
    select?: DduClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DduClientContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which DduClientContractProperties to fetch.
     */
    where?: DduClientContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DduClientContractProperties to fetch.
     */
    orderBy?: DduClientContractPropertiesOrderByWithRelationInput | DduClientContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DduClientContractProperties.
     */
    cursor?: DduClientContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DduClientContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DduClientContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DduClientContractProperties.
     */
    distinct?: DduClientContractPropertiesScalarFieldEnum | DduClientContractPropertiesScalarFieldEnum[]
  }

  /**
   * DduClientContractProperties findMany
   */
  export type DduClientContractPropertiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DduClientContractProperties
     */
    select?: DduClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DduClientContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which DduClientContractProperties to fetch.
     */
    where?: DduClientContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DduClientContractProperties to fetch.
     */
    orderBy?: DduClientContractPropertiesOrderByWithRelationInput | DduClientContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DduClientContractProperties.
     */
    cursor?: DduClientContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DduClientContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DduClientContractProperties.
     */
    skip?: number
    distinct?: DduClientContractPropertiesScalarFieldEnum | DduClientContractPropertiesScalarFieldEnum[]
  }

  /**
   * DduClientContractProperties create
   */
  export type DduClientContractPropertiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DduClientContractProperties
     */
    select?: DduClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DduClientContractPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to create a DduClientContractProperties.
     */
    data: XOR<DduClientContractPropertiesCreateInput, DduClientContractPropertiesUncheckedCreateInput>
  }

  /**
   * DduClientContractProperties createMany
   */
  export type DduClientContractPropertiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DduClientContractProperties.
     */
    data: DduClientContractPropertiesCreateManyInput | DduClientContractPropertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DduClientContractProperties update
   */
  export type DduClientContractPropertiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DduClientContractProperties
     */
    select?: DduClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DduClientContractPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to update a DduClientContractProperties.
     */
    data: XOR<DduClientContractPropertiesUpdateInput, DduClientContractPropertiesUncheckedUpdateInput>
    /**
     * Choose, which DduClientContractProperties to update.
     */
    where: DduClientContractPropertiesWhereUniqueInput
  }

  /**
   * DduClientContractProperties updateMany
   */
  export type DduClientContractPropertiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DduClientContractProperties.
     */
    data: XOR<DduClientContractPropertiesUpdateManyMutationInput, DduClientContractPropertiesUncheckedUpdateManyInput>
    /**
     * Filter which DduClientContractProperties to update
     */
    where?: DduClientContractPropertiesWhereInput
  }

  /**
   * DduClientContractProperties upsert
   */
  export type DduClientContractPropertiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DduClientContractProperties
     */
    select?: DduClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DduClientContractPropertiesInclude<ExtArgs> | null
    /**
     * The filter to search for the DduClientContractProperties to update in case it exists.
     */
    where: DduClientContractPropertiesWhereUniqueInput
    /**
     * In case the DduClientContractProperties found by the `where` argument doesn't exist, create a new DduClientContractProperties with this data.
     */
    create: XOR<DduClientContractPropertiesCreateInput, DduClientContractPropertiesUncheckedCreateInput>
    /**
     * In case the DduClientContractProperties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DduClientContractPropertiesUpdateInput, DduClientContractPropertiesUncheckedUpdateInput>
  }

  /**
   * DduClientContractProperties delete
   */
  export type DduClientContractPropertiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DduClientContractProperties
     */
    select?: DduClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DduClientContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter which DduClientContractProperties to delete.
     */
    where: DduClientContractPropertiesWhereUniqueInput
  }

  /**
   * DduClientContractProperties deleteMany
   */
  export type DduClientContractPropertiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DduClientContractProperties to delete
     */
    where?: DduClientContractPropertiesWhereInput
  }

  /**
   * DduClientContractProperties.clientContract
   */
  export type DduClientContractProperties$clientContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    where?: ClientContractWhereInput
  }

  /**
   * DduClientContractProperties without action
   */
  export type DduClientContractPropertiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DduClientContractProperties
     */
    select?: DduClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DduClientContractPropertiesInclude<ExtArgs> | null
  }


  /**
   * Model DkpClientContractProperties
   */

  export type AggregateDkpClientContractProperties = {
    _count: DkpClientContractPropertiesCountAggregateOutputType | null
    _avg: DkpClientContractPropertiesAvgAggregateOutputType | null
    _sum: DkpClientContractPropertiesSumAggregateOutputType | null
    _min: DkpClientContractPropertiesMinAggregateOutputType | null
    _max: DkpClientContractPropertiesMaxAggregateOutputType | null
  }

  export type DkpClientContractPropertiesAvgAggregateOutputType = {
    id: number | null
  }

  export type DkpClientContractPropertiesSumAggregateOutputType = {
    id: number | null
  }

  export type DkpClientContractPropertiesMinAggregateOutputType = {
    id: number | null
    dkpLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DkpClientContractPropertiesMaxAggregateOutputType = {
    id: number | null
    dkpLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DkpClientContractPropertiesCountAggregateOutputType = {
    id: number
    dkpLink: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DkpClientContractPropertiesAvgAggregateInputType = {
    id?: true
  }

  export type DkpClientContractPropertiesSumAggregateInputType = {
    id?: true
  }

  export type DkpClientContractPropertiesMinAggregateInputType = {
    id?: true
    dkpLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DkpClientContractPropertiesMaxAggregateInputType = {
    id?: true
    dkpLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DkpClientContractPropertiesCountAggregateInputType = {
    id?: true
    dkpLink?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DkpClientContractPropertiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DkpClientContractProperties to aggregate.
     */
    where?: DkpClientContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DkpClientContractProperties to fetch.
     */
    orderBy?: DkpClientContractPropertiesOrderByWithRelationInput | DkpClientContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DkpClientContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DkpClientContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DkpClientContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DkpClientContractProperties
    **/
    _count?: true | DkpClientContractPropertiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DkpClientContractPropertiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DkpClientContractPropertiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DkpClientContractPropertiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DkpClientContractPropertiesMaxAggregateInputType
  }

  export type GetDkpClientContractPropertiesAggregateType<T extends DkpClientContractPropertiesAggregateArgs> = {
        [P in keyof T & keyof AggregateDkpClientContractProperties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDkpClientContractProperties[P]>
      : GetScalarType<T[P], AggregateDkpClientContractProperties[P]>
  }




  export type DkpClientContractPropertiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DkpClientContractPropertiesWhereInput
    orderBy?: DkpClientContractPropertiesOrderByWithAggregationInput | DkpClientContractPropertiesOrderByWithAggregationInput[]
    by: DkpClientContractPropertiesScalarFieldEnum[] | DkpClientContractPropertiesScalarFieldEnum
    having?: DkpClientContractPropertiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DkpClientContractPropertiesCountAggregateInputType | true
    _avg?: DkpClientContractPropertiesAvgAggregateInputType
    _sum?: DkpClientContractPropertiesSumAggregateInputType
    _min?: DkpClientContractPropertiesMinAggregateInputType
    _max?: DkpClientContractPropertiesMaxAggregateInputType
  }

  export type DkpClientContractPropertiesGroupByOutputType = {
    id: number
    dkpLink: string | null
    createdAt: Date
    updatedAt: Date
    _count: DkpClientContractPropertiesCountAggregateOutputType | null
    _avg: DkpClientContractPropertiesAvgAggregateOutputType | null
    _sum: DkpClientContractPropertiesSumAggregateOutputType | null
    _min: DkpClientContractPropertiesMinAggregateOutputType | null
    _max: DkpClientContractPropertiesMaxAggregateOutputType | null
  }

  type GetDkpClientContractPropertiesGroupByPayload<T extends DkpClientContractPropertiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DkpClientContractPropertiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DkpClientContractPropertiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DkpClientContractPropertiesGroupByOutputType[P]>
            : GetScalarType<T[P], DkpClientContractPropertiesGroupByOutputType[P]>
        }
      >
    >


  export type DkpClientContractPropertiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dkpLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientContract?: boolean | DkpClientContractProperties$clientContractArgs<ExtArgs>
  }, ExtArgs["result"]["dkpClientContractProperties"]>


  export type DkpClientContractPropertiesSelectScalar = {
    id?: boolean
    dkpLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DkpClientContractPropertiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientContract?: boolean | DkpClientContractProperties$clientContractArgs<ExtArgs>
  }

  export type $DkpClientContractPropertiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DkpClientContractProperties"
    objects: {
      clientContract: Prisma.$ClientContractPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dkpLink: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dkpClientContractProperties"]>
    composites: {}
  }

  type DkpClientContractPropertiesGetPayload<S extends boolean | null | undefined | DkpClientContractPropertiesDefaultArgs> = $Result.GetResult<Prisma.$DkpClientContractPropertiesPayload, S>

  type DkpClientContractPropertiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DkpClientContractPropertiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DkpClientContractPropertiesCountAggregateInputType | true
    }

  export interface DkpClientContractPropertiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DkpClientContractProperties'], meta: { name: 'DkpClientContractProperties' } }
    /**
     * Find zero or one DkpClientContractProperties that matches the filter.
     * @param {DkpClientContractPropertiesFindUniqueArgs} args - Arguments to find a DkpClientContractProperties
     * @example
     * // Get one DkpClientContractProperties
     * const dkpClientContractProperties = await prisma.dkpClientContractProperties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DkpClientContractPropertiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DkpClientContractPropertiesFindUniqueArgs<ExtArgs>>
    ): Prisma__DkpClientContractPropertiesClient<$Result.GetResult<Prisma.$DkpClientContractPropertiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DkpClientContractProperties that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DkpClientContractPropertiesFindUniqueOrThrowArgs} args - Arguments to find a DkpClientContractProperties
     * @example
     * // Get one DkpClientContractProperties
     * const dkpClientContractProperties = await prisma.dkpClientContractProperties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DkpClientContractPropertiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DkpClientContractPropertiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DkpClientContractPropertiesClient<$Result.GetResult<Prisma.$DkpClientContractPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DkpClientContractProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DkpClientContractPropertiesFindFirstArgs} args - Arguments to find a DkpClientContractProperties
     * @example
     * // Get one DkpClientContractProperties
     * const dkpClientContractProperties = await prisma.dkpClientContractProperties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DkpClientContractPropertiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DkpClientContractPropertiesFindFirstArgs<ExtArgs>>
    ): Prisma__DkpClientContractPropertiesClient<$Result.GetResult<Prisma.$DkpClientContractPropertiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DkpClientContractProperties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DkpClientContractPropertiesFindFirstOrThrowArgs} args - Arguments to find a DkpClientContractProperties
     * @example
     * // Get one DkpClientContractProperties
     * const dkpClientContractProperties = await prisma.dkpClientContractProperties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DkpClientContractPropertiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DkpClientContractPropertiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DkpClientContractPropertiesClient<$Result.GetResult<Prisma.$DkpClientContractPropertiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DkpClientContractProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DkpClientContractPropertiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DkpClientContractProperties
     * const dkpClientContractProperties = await prisma.dkpClientContractProperties.findMany()
     * 
     * // Get first 10 DkpClientContractProperties
     * const dkpClientContractProperties = await prisma.dkpClientContractProperties.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dkpClientContractPropertiesWithIdOnly = await prisma.dkpClientContractProperties.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DkpClientContractPropertiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DkpClientContractPropertiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DkpClientContractPropertiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DkpClientContractProperties.
     * @param {DkpClientContractPropertiesCreateArgs} args - Arguments to create a DkpClientContractProperties.
     * @example
     * // Create one DkpClientContractProperties
     * const DkpClientContractProperties = await prisma.dkpClientContractProperties.create({
     *   data: {
     *     // ... data to create a DkpClientContractProperties
     *   }
     * })
     * 
    **/
    create<T extends DkpClientContractPropertiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DkpClientContractPropertiesCreateArgs<ExtArgs>>
    ): Prisma__DkpClientContractPropertiesClient<$Result.GetResult<Prisma.$DkpClientContractPropertiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DkpClientContractProperties.
     * @param {DkpClientContractPropertiesCreateManyArgs} args - Arguments to create many DkpClientContractProperties.
     * @example
     * // Create many DkpClientContractProperties
     * const dkpClientContractProperties = await prisma.dkpClientContractProperties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends DkpClientContractPropertiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DkpClientContractPropertiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DkpClientContractProperties.
     * @param {DkpClientContractPropertiesDeleteArgs} args - Arguments to delete one DkpClientContractProperties.
     * @example
     * // Delete one DkpClientContractProperties
     * const DkpClientContractProperties = await prisma.dkpClientContractProperties.delete({
     *   where: {
     *     // ... filter to delete one DkpClientContractProperties
     *   }
     * })
     * 
    **/
    delete<T extends DkpClientContractPropertiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DkpClientContractPropertiesDeleteArgs<ExtArgs>>
    ): Prisma__DkpClientContractPropertiesClient<$Result.GetResult<Prisma.$DkpClientContractPropertiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DkpClientContractProperties.
     * @param {DkpClientContractPropertiesUpdateArgs} args - Arguments to update one DkpClientContractProperties.
     * @example
     * // Update one DkpClientContractProperties
     * const dkpClientContractProperties = await prisma.dkpClientContractProperties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DkpClientContractPropertiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DkpClientContractPropertiesUpdateArgs<ExtArgs>>
    ): Prisma__DkpClientContractPropertiesClient<$Result.GetResult<Prisma.$DkpClientContractPropertiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DkpClientContractProperties.
     * @param {DkpClientContractPropertiesDeleteManyArgs} args - Arguments to filter DkpClientContractProperties to delete.
     * @example
     * // Delete a few DkpClientContractProperties
     * const { count } = await prisma.dkpClientContractProperties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DkpClientContractPropertiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DkpClientContractPropertiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DkpClientContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DkpClientContractPropertiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DkpClientContractProperties
     * const dkpClientContractProperties = await prisma.dkpClientContractProperties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DkpClientContractPropertiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DkpClientContractPropertiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DkpClientContractProperties.
     * @param {DkpClientContractPropertiesUpsertArgs} args - Arguments to update or create a DkpClientContractProperties.
     * @example
     * // Update or create a DkpClientContractProperties
     * const dkpClientContractProperties = await prisma.dkpClientContractProperties.upsert({
     *   create: {
     *     // ... data to create a DkpClientContractProperties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DkpClientContractProperties we want to update
     *   }
     * })
    **/
    upsert<T extends DkpClientContractPropertiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DkpClientContractPropertiesUpsertArgs<ExtArgs>>
    ): Prisma__DkpClientContractPropertiesClient<$Result.GetResult<Prisma.$DkpClientContractPropertiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DkpClientContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DkpClientContractPropertiesCountArgs} args - Arguments to filter DkpClientContractProperties to count.
     * @example
     * // Count the number of DkpClientContractProperties
     * const count = await prisma.dkpClientContractProperties.count({
     *   where: {
     *     // ... the filter for the DkpClientContractProperties we want to count
     *   }
     * })
    **/
    count<T extends DkpClientContractPropertiesCountArgs>(
      args?: Subset<T, DkpClientContractPropertiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DkpClientContractPropertiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DkpClientContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DkpClientContractPropertiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DkpClientContractPropertiesAggregateArgs>(args: Subset<T, DkpClientContractPropertiesAggregateArgs>): Prisma.PrismaPromise<GetDkpClientContractPropertiesAggregateType<T>>

    /**
     * Group by DkpClientContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DkpClientContractPropertiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DkpClientContractPropertiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DkpClientContractPropertiesGroupByArgs['orderBy'] }
        : { orderBy?: DkpClientContractPropertiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DkpClientContractPropertiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDkpClientContractPropertiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DkpClientContractProperties model
   */
  readonly fields: DkpClientContractPropertiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DkpClientContractProperties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DkpClientContractPropertiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    clientContract<T extends DkpClientContractProperties$clientContractArgs<ExtArgs> = {}>(args?: Subset<T, DkpClientContractProperties$clientContractArgs<ExtArgs>>): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DkpClientContractProperties model
   */ 
  interface DkpClientContractPropertiesFieldRefs {
    readonly id: FieldRef<"DkpClientContractProperties", 'Int'>
    readonly dkpLink: FieldRef<"DkpClientContractProperties", 'String'>
    readonly createdAt: FieldRef<"DkpClientContractProperties", 'DateTime'>
    readonly updatedAt: FieldRef<"DkpClientContractProperties", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DkpClientContractProperties findUnique
   */
  export type DkpClientContractPropertiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DkpClientContractProperties
     */
    select?: DkpClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DkpClientContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which DkpClientContractProperties to fetch.
     */
    where: DkpClientContractPropertiesWhereUniqueInput
  }

  /**
   * DkpClientContractProperties findUniqueOrThrow
   */
  export type DkpClientContractPropertiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DkpClientContractProperties
     */
    select?: DkpClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DkpClientContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which DkpClientContractProperties to fetch.
     */
    where: DkpClientContractPropertiesWhereUniqueInput
  }

  /**
   * DkpClientContractProperties findFirst
   */
  export type DkpClientContractPropertiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DkpClientContractProperties
     */
    select?: DkpClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DkpClientContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which DkpClientContractProperties to fetch.
     */
    where?: DkpClientContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DkpClientContractProperties to fetch.
     */
    orderBy?: DkpClientContractPropertiesOrderByWithRelationInput | DkpClientContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DkpClientContractProperties.
     */
    cursor?: DkpClientContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DkpClientContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DkpClientContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DkpClientContractProperties.
     */
    distinct?: DkpClientContractPropertiesScalarFieldEnum | DkpClientContractPropertiesScalarFieldEnum[]
  }

  /**
   * DkpClientContractProperties findFirstOrThrow
   */
  export type DkpClientContractPropertiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DkpClientContractProperties
     */
    select?: DkpClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DkpClientContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which DkpClientContractProperties to fetch.
     */
    where?: DkpClientContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DkpClientContractProperties to fetch.
     */
    orderBy?: DkpClientContractPropertiesOrderByWithRelationInput | DkpClientContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DkpClientContractProperties.
     */
    cursor?: DkpClientContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DkpClientContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DkpClientContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DkpClientContractProperties.
     */
    distinct?: DkpClientContractPropertiesScalarFieldEnum | DkpClientContractPropertiesScalarFieldEnum[]
  }

  /**
   * DkpClientContractProperties findMany
   */
  export type DkpClientContractPropertiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DkpClientContractProperties
     */
    select?: DkpClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DkpClientContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which DkpClientContractProperties to fetch.
     */
    where?: DkpClientContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DkpClientContractProperties to fetch.
     */
    orderBy?: DkpClientContractPropertiesOrderByWithRelationInput | DkpClientContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DkpClientContractProperties.
     */
    cursor?: DkpClientContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DkpClientContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DkpClientContractProperties.
     */
    skip?: number
    distinct?: DkpClientContractPropertiesScalarFieldEnum | DkpClientContractPropertiesScalarFieldEnum[]
  }

  /**
   * DkpClientContractProperties create
   */
  export type DkpClientContractPropertiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DkpClientContractProperties
     */
    select?: DkpClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DkpClientContractPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to create a DkpClientContractProperties.
     */
    data: XOR<DkpClientContractPropertiesCreateInput, DkpClientContractPropertiesUncheckedCreateInput>
  }

  /**
   * DkpClientContractProperties createMany
   */
  export type DkpClientContractPropertiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DkpClientContractProperties.
     */
    data: DkpClientContractPropertiesCreateManyInput | DkpClientContractPropertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DkpClientContractProperties update
   */
  export type DkpClientContractPropertiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DkpClientContractProperties
     */
    select?: DkpClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DkpClientContractPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to update a DkpClientContractProperties.
     */
    data: XOR<DkpClientContractPropertiesUpdateInput, DkpClientContractPropertiesUncheckedUpdateInput>
    /**
     * Choose, which DkpClientContractProperties to update.
     */
    where: DkpClientContractPropertiesWhereUniqueInput
  }

  /**
   * DkpClientContractProperties updateMany
   */
  export type DkpClientContractPropertiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DkpClientContractProperties.
     */
    data: XOR<DkpClientContractPropertiesUpdateManyMutationInput, DkpClientContractPropertiesUncheckedUpdateManyInput>
    /**
     * Filter which DkpClientContractProperties to update
     */
    where?: DkpClientContractPropertiesWhereInput
  }

  /**
   * DkpClientContractProperties upsert
   */
  export type DkpClientContractPropertiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DkpClientContractProperties
     */
    select?: DkpClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DkpClientContractPropertiesInclude<ExtArgs> | null
    /**
     * The filter to search for the DkpClientContractProperties to update in case it exists.
     */
    where: DkpClientContractPropertiesWhereUniqueInput
    /**
     * In case the DkpClientContractProperties found by the `where` argument doesn't exist, create a new DkpClientContractProperties with this data.
     */
    create: XOR<DkpClientContractPropertiesCreateInput, DkpClientContractPropertiesUncheckedCreateInput>
    /**
     * In case the DkpClientContractProperties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DkpClientContractPropertiesUpdateInput, DkpClientContractPropertiesUncheckedUpdateInput>
  }

  /**
   * DkpClientContractProperties delete
   */
  export type DkpClientContractPropertiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DkpClientContractProperties
     */
    select?: DkpClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DkpClientContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter which DkpClientContractProperties to delete.
     */
    where: DkpClientContractPropertiesWhereUniqueInput
  }

  /**
   * DkpClientContractProperties deleteMany
   */
  export type DkpClientContractPropertiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DkpClientContractProperties to delete
     */
    where?: DkpClientContractPropertiesWhereInput
  }

  /**
   * DkpClientContractProperties.clientContract
   */
  export type DkpClientContractProperties$clientContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    where?: ClientContractWhereInput
  }

  /**
   * DkpClientContractProperties without action
   */
  export type DkpClientContractPropertiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DkpClientContractProperties
     */
    select?: DkpClientContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DkpClientContractPropertiesInclude<ExtArgs> | null
  }


  /**
   * Model ClientContractToAgencyContract
   */

  export type AggregateClientContractToAgencyContract = {
    _count: ClientContractToAgencyContractCountAggregateOutputType | null
    _avg: ClientContractToAgencyContractAvgAggregateOutputType | null
    _sum: ClientContractToAgencyContractSumAggregateOutputType | null
    _min: ClientContractToAgencyContractMinAggregateOutputType | null
    _max: ClientContractToAgencyContractMaxAggregateOutputType | null
  }

  export type ClientContractToAgencyContractAvgAggregateOutputType = {
    clientContractId: number | null
    agencyContractId: number | null
  }

  export type ClientContractToAgencyContractSumAggregateOutputType = {
    clientContractId: number | null
    agencyContractId: number | null
  }

  export type ClientContractToAgencyContractMinAggregateOutputType = {
    clientContractId: number | null
    agencyContractId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientContractToAgencyContractMaxAggregateOutputType = {
    clientContractId: number | null
    agencyContractId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientContractToAgencyContractCountAggregateOutputType = {
    clientContractId: number
    agencyContractId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientContractToAgencyContractAvgAggregateInputType = {
    clientContractId?: true
    agencyContractId?: true
  }

  export type ClientContractToAgencyContractSumAggregateInputType = {
    clientContractId?: true
    agencyContractId?: true
  }

  export type ClientContractToAgencyContractMinAggregateInputType = {
    clientContractId?: true
    agencyContractId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientContractToAgencyContractMaxAggregateInputType = {
    clientContractId?: true
    agencyContractId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientContractToAgencyContractCountAggregateInputType = {
    clientContractId?: true
    agencyContractId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientContractToAgencyContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientContractToAgencyContract to aggregate.
     */
    where?: ClientContractToAgencyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContractToAgencyContracts to fetch.
     */
    orderBy?: ClientContractToAgencyContractOrderByWithRelationInput | ClientContractToAgencyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientContractToAgencyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContractToAgencyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContractToAgencyContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientContractToAgencyContracts
    **/
    _count?: true | ClientContractToAgencyContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientContractToAgencyContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientContractToAgencyContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientContractToAgencyContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientContractToAgencyContractMaxAggregateInputType
  }

  export type GetClientContractToAgencyContractAggregateType<T extends ClientContractToAgencyContractAggregateArgs> = {
        [P in keyof T & keyof AggregateClientContractToAgencyContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientContractToAgencyContract[P]>
      : GetScalarType<T[P], AggregateClientContractToAgencyContract[P]>
  }




  export type ClientContractToAgencyContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractToAgencyContractWhereInput
    orderBy?: ClientContractToAgencyContractOrderByWithAggregationInput | ClientContractToAgencyContractOrderByWithAggregationInput[]
    by: ClientContractToAgencyContractScalarFieldEnum[] | ClientContractToAgencyContractScalarFieldEnum
    having?: ClientContractToAgencyContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientContractToAgencyContractCountAggregateInputType | true
    _avg?: ClientContractToAgencyContractAvgAggregateInputType
    _sum?: ClientContractToAgencyContractSumAggregateInputType
    _min?: ClientContractToAgencyContractMinAggregateInputType
    _max?: ClientContractToAgencyContractMaxAggregateInputType
  }

  export type ClientContractToAgencyContractGroupByOutputType = {
    clientContractId: number
    agencyContractId: number
    createdAt: Date
    updatedAt: Date
    _count: ClientContractToAgencyContractCountAggregateOutputType | null
    _avg: ClientContractToAgencyContractAvgAggregateOutputType | null
    _sum: ClientContractToAgencyContractSumAggregateOutputType | null
    _min: ClientContractToAgencyContractMinAggregateOutputType | null
    _max: ClientContractToAgencyContractMaxAggregateOutputType | null
  }

  type GetClientContractToAgencyContractGroupByPayload<T extends ClientContractToAgencyContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientContractToAgencyContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientContractToAgencyContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientContractToAgencyContractGroupByOutputType[P]>
            : GetScalarType<T[P], ClientContractToAgencyContractGroupByOutputType[P]>
        }
      >
    >


  export type ClientContractToAgencyContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clientContractId?: boolean
    agencyContractId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientContract?: boolean | ClientContractDefaultArgs<ExtArgs>
    agencyContract?: boolean | AgencyContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientContractToAgencyContract"]>


  export type ClientContractToAgencyContractSelectScalar = {
    clientContractId?: boolean
    agencyContractId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientContractToAgencyContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientContract?: boolean | ClientContractDefaultArgs<ExtArgs>
    agencyContract?: boolean | AgencyContractDefaultArgs<ExtArgs>
  }

  export type $ClientContractToAgencyContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientContractToAgencyContract"
    objects: {
      clientContract: Prisma.$ClientContractPayload<ExtArgs>
      agencyContract: Prisma.$AgencyContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      clientContractId: number
      agencyContractId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientContractToAgencyContract"]>
    composites: {}
  }

  type ClientContractToAgencyContractGetPayload<S extends boolean | null | undefined | ClientContractToAgencyContractDefaultArgs> = $Result.GetResult<Prisma.$ClientContractToAgencyContractPayload, S>

  type ClientContractToAgencyContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientContractToAgencyContractFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientContractToAgencyContractCountAggregateInputType | true
    }

  export interface ClientContractToAgencyContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientContractToAgencyContract'], meta: { name: 'ClientContractToAgencyContract' } }
    /**
     * Find zero or one ClientContractToAgencyContract that matches the filter.
     * @param {ClientContractToAgencyContractFindUniqueArgs} args - Arguments to find a ClientContractToAgencyContract
     * @example
     * // Get one ClientContractToAgencyContract
     * const clientContractToAgencyContract = await prisma.clientContractToAgencyContract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientContractToAgencyContractFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToAgencyContractFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientContractToAgencyContractClient<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClientContractToAgencyContract that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientContractToAgencyContractFindUniqueOrThrowArgs} args - Arguments to find a ClientContractToAgencyContract
     * @example
     * // Get one ClientContractToAgencyContract
     * const clientContractToAgencyContract = await prisma.clientContractToAgencyContract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientContractToAgencyContractFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToAgencyContractFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientContractToAgencyContractClient<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClientContractToAgencyContract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToAgencyContractFindFirstArgs} args - Arguments to find a ClientContractToAgencyContract
     * @example
     * // Get one ClientContractToAgencyContract
     * const clientContractToAgencyContract = await prisma.clientContractToAgencyContract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientContractToAgencyContractFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToAgencyContractFindFirstArgs<ExtArgs>>
    ): Prisma__ClientContractToAgencyContractClient<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClientContractToAgencyContract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToAgencyContractFindFirstOrThrowArgs} args - Arguments to find a ClientContractToAgencyContract
     * @example
     * // Get one ClientContractToAgencyContract
     * const clientContractToAgencyContract = await prisma.clientContractToAgencyContract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientContractToAgencyContractFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToAgencyContractFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientContractToAgencyContractClient<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClientContractToAgencyContracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToAgencyContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientContractToAgencyContracts
     * const clientContractToAgencyContracts = await prisma.clientContractToAgencyContract.findMany()
     * 
     * // Get first 10 ClientContractToAgencyContracts
     * const clientContractToAgencyContracts = await prisma.clientContractToAgencyContract.findMany({ take: 10 })
     * 
     * // Only select the `clientContractId`
     * const clientContractToAgencyContractWithClientContractIdOnly = await prisma.clientContractToAgencyContract.findMany({ select: { clientContractId: true } })
     * 
    **/
    findMany<T extends ClientContractToAgencyContractFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToAgencyContractFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClientContractToAgencyContract.
     * @param {ClientContractToAgencyContractCreateArgs} args - Arguments to create a ClientContractToAgencyContract.
     * @example
     * // Create one ClientContractToAgencyContract
     * const ClientContractToAgencyContract = await prisma.clientContractToAgencyContract.create({
     *   data: {
     *     // ... data to create a ClientContractToAgencyContract
     *   }
     * })
     * 
    **/
    create<T extends ClientContractToAgencyContractCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToAgencyContractCreateArgs<ExtArgs>>
    ): Prisma__ClientContractToAgencyContractClient<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClientContractToAgencyContracts.
     * @param {ClientContractToAgencyContractCreateManyArgs} args - Arguments to create many ClientContractToAgencyContracts.
     * @example
     * // Create many ClientContractToAgencyContracts
     * const clientContractToAgencyContract = await prisma.clientContractToAgencyContract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientContractToAgencyContractCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToAgencyContractCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientContractToAgencyContract.
     * @param {ClientContractToAgencyContractDeleteArgs} args - Arguments to delete one ClientContractToAgencyContract.
     * @example
     * // Delete one ClientContractToAgencyContract
     * const ClientContractToAgencyContract = await prisma.clientContractToAgencyContract.delete({
     *   where: {
     *     // ... filter to delete one ClientContractToAgencyContract
     *   }
     * })
     * 
    **/
    delete<T extends ClientContractToAgencyContractDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToAgencyContractDeleteArgs<ExtArgs>>
    ): Prisma__ClientContractToAgencyContractClient<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClientContractToAgencyContract.
     * @param {ClientContractToAgencyContractUpdateArgs} args - Arguments to update one ClientContractToAgencyContract.
     * @example
     * // Update one ClientContractToAgencyContract
     * const clientContractToAgencyContract = await prisma.clientContractToAgencyContract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientContractToAgencyContractUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToAgencyContractUpdateArgs<ExtArgs>>
    ): Prisma__ClientContractToAgencyContractClient<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClientContractToAgencyContracts.
     * @param {ClientContractToAgencyContractDeleteManyArgs} args - Arguments to filter ClientContractToAgencyContracts to delete.
     * @example
     * // Delete a few ClientContractToAgencyContracts
     * const { count } = await prisma.clientContractToAgencyContract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientContractToAgencyContractDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToAgencyContractDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientContractToAgencyContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToAgencyContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientContractToAgencyContracts
     * const clientContractToAgencyContract = await prisma.clientContractToAgencyContract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientContractToAgencyContractUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToAgencyContractUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientContractToAgencyContract.
     * @param {ClientContractToAgencyContractUpsertArgs} args - Arguments to update or create a ClientContractToAgencyContract.
     * @example
     * // Update or create a ClientContractToAgencyContract
     * const clientContractToAgencyContract = await prisma.clientContractToAgencyContract.upsert({
     *   create: {
     *     // ... data to create a ClientContractToAgencyContract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientContractToAgencyContract we want to update
     *   }
     * })
    **/
    upsert<T extends ClientContractToAgencyContractUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToAgencyContractUpsertArgs<ExtArgs>>
    ): Prisma__ClientContractToAgencyContractClient<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClientContractToAgencyContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToAgencyContractCountArgs} args - Arguments to filter ClientContractToAgencyContracts to count.
     * @example
     * // Count the number of ClientContractToAgencyContracts
     * const count = await prisma.clientContractToAgencyContract.count({
     *   where: {
     *     // ... the filter for the ClientContractToAgencyContracts we want to count
     *   }
     * })
    **/
    count<T extends ClientContractToAgencyContractCountArgs>(
      args?: Subset<T, ClientContractToAgencyContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientContractToAgencyContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientContractToAgencyContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToAgencyContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientContractToAgencyContractAggregateArgs>(args: Subset<T, ClientContractToAgencyContractAggregateArgs>): Prisma.PrismaPromise<GetClientContractToAgencyContractAggregateType<T>>

    /**
     * Group by ClientContractToAgencyContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToAgencyContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientContractToAgencyContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientContractToAgencyContractGroupByArgs['orderBy'] }
        : { orderBy?: ClientContractToAgencyContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientContractToAgencyContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientContractToAgencyContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientContractToAgencyContract model
   */
  readonly fields: ClientContractToAgencyContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientContractToAgencyContract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientContractToAgencyContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    clientContract<T extends ClientContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientContractDefaultArgs<ExtArgs>>): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    agencyContract<T extends AgencyContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContractDefaultArgs<ExtArgs>>): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClientContractToAgencyContract model
   */ 
  interface ClientContractToAgencyContractFieldRefs {
    readonly clientContractId: FieldRef<"ClientContractToAgencyContract", 'Int'>
    readonly agencyContractId: FieldRef<"ClientContractToAgencyContract", 'Int'>
    readonly createdAt: FieldRef<"ClientContractToAgencyContract", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientContractToAgencyContract", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientContractToAgencyContract findUnique
   */
  export type ClientContractToAgencyContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToAgencyContract to fetch.
     */
    where: ClientContractToAgencyContractWhereUniqueInput
  }

  /**
   * ClientContractToAgencyContract findUniqueOrThrow
   */
  export type ClientContractToAgencyContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToAgencyContract to fetch.
     */
    where: ClientContractToAgencyContractWhereUniqueInput
  }

  /**
   * ClientContractToAgencyContract findFirst
   */
  export type ClientContractToAgencyContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToAgencyContract to fetch.
     */
    where?: ClientContractToAgencyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContractToAgencyContracts to fetch.
     */
    orderBy?: ClientContractToAgencyContractOrderByWithRelationInput | ClientContractToAgencyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientContractToAgencyContracts.
     */
    cursor?: ClientContractToAgencyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContractToAgencyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContractToAgencyContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientContractToAgencyContracts.
     */
    distinct?: ClientContractToAgencyContractScalarFieldEnum | ClientContractToAgencyContractScalarFieldEnum[]
  }

  /**
   * ClientContractToAgencyContract findFirstOrThrow
   */
  export type ClientContractToAgencyContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToAgencyContract to fetch.
     */
    where?: ClientContractToAgencyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContractToAgencyContracts to fetch.
     */
    orderBy?: ClientContractToAgencyContractOrderByWithRelationInput | ClientContractToAgencyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientContractToAgencyContracts.
     */
    cursor?: ClientContractToAgencyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContractToAgencyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContractToAgencyContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientContractToAgencyContracts.
     */
    distinct?: ClientContractToAgencyContractScalarFieldEnum | ClientContractToAgencyContractScalarFieldEnum[]
  }

  /**
   * ClientContractToAgencyContract findMany
   */
  export type ClientContractToAgencyContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToAgencyContracts to fetch.
     */
    where?: ClientContractToAgencyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContractToAgencyContracts to fetch.
     */
    orderBy?: ClientContractToAgencyContractOrderByWithRelationInput | ClientContractToAgencyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientContractToAgencyContracts.
     */
    cursor?: ClientContractToAgencyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContractToAgencyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContractToAgencyContracts.
     */
    skip?: number
    distinct?: ClientContractToAgencyContractScalarFieldEnum | ClientContractToAgencyContractScalarFieldEnum[]
  }

  /**
   * ClientContractToAgencyContract create
   */
  export type ClientContractToAgencyContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientContractToAgencyContract.
     */
    data: XOR<ClientContractToAgencyContractCreateInput, ClientContractToAgencyContractUncheckedCreateInput>
  }

  /**
   * ClientContractToAgencyContract createMany
   */
  export type ClientContractToAgencyContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientContractToAgencyContracts.
     */
    data: ClientContractToAgencyContractCreateManyInput | ClientContractToAgencyContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientContractToAgencyContract update
   */
  export type ClientContractToAgencyContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientContractToAgencyContract.
     */
    data: XOR<ClientContractToAgencyContractUpdateInput, ClientContractToAgencyContractUncheckedUpdateInput>
    /**
     * Choose, which ClientContractToAgencyContract to update.
     */
    where: ClientContractToAgencyContractWhereUniqueInput
  }

  /**
   * ClientContractToAgencyContract updateMany
   */
  export type ClientContractToAgencyContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientContractToAgencyContracts.
     */
    data: XOR<ClientContractToAgencyContractUpdateManyMutationInput, ClientContractToAgencyContractUncheckedUpdateManyInput>
    /**
     * Filter which ClientContractToAgencyContracts to update
     */
    where?: ClientContractToAgencyContractWhereInput
  }

  /**
   * ClientContractToAgencyContract upsert
   */
  export type ClientContractToAgencyContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientContractToAgencyContract to update in case it exists.
     */
    where: ClientContractToAgencyContractWhereUniqueInput
    /**
     * In case the ClientContractToAgencyContract found by the `where` argument doesn't exist, create a new ClientContractToAgencyContract with this data.
     */
    create: XOR<ClientContractToAgencyContractCreateInput, ClientContractToAgencyContractUncheckedCreateInput>
    /**
     * In case the ClientContractToAgencyContract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientContractToAgencyContractUpdateInput, ClientContractToAgencyContractUncheckedUpdateInput>
  }

  /**
   * ClientContractToAgencyContract delete
   */
  export type ClientContractToAgencyContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    /**
     * Filter which ClientContractToAgencyContract to delete.
     */
    where: ClientContractToAgencyContractWhereUniqueInput
  }

  /**
   * ClientContractToAgencyContract deleteMany
   */
  export type ClientContractToAgencyContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientContractToAgencyContracts to delete
     */
    where?: ClientContractToAgencyContractWhereInput
  }

  /**
   * ClientContractToAgencyContract without action
   */
  export type ClientContractToAgencyContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
  }


  /**
   * Model ClientContractToClient
   */

  export type AggregateClientContractToClient = {
    _count: ClientContractToClientCountAggregateOutputType | null
    _avg: ClientContractToClientAvgAggregateOutputType | null
    _sum: ClientContractToClientSumAggregateOutputType | null
    _min: ClientContractToClientMinAggregateOutputType | null
    _max: ClientContractToClientMaxAggregateOutputType | null
  }

  export type ClientContractToClientAvgAggregateOutputType = {
    share: number | null
    clientContractId: number | null
    clientId: number | null
  }

  export type ClientContractToClientSumAggregateOutputType = {
    share: number | null
    clientContractId: number | null
    clientId: number | null
  }

  export type ClientContractToClientMinAggregateOutputType = {
    isMain: boolean | null
    share: number | null
    clientContractId: number | null
    clientId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientContractToClientMaxAggregateOutputType = {
    isMain: boolean | null
    share: number | null
    clientContractId: number | null
    clientId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientContractToClientCountAggregateOutputType = {
    isMain: number
    share: number
    clientContractId: number
    clientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientContractToClientAvgAggregateInputType = {
    share?: true
    clientContractId?: true
    clientId?: true
  }

  export type ClientContractToClientSumAggregateInputType = {
    share?: true
    clientContractId?: true
    clientId?: true
  }

  export type ClientContractToClientMinAggregateInputType = {
    isMain?: true
    share?: true
    clientContractId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientContractToClientMaxAggregateInputType = {
    isMain?: true
    share?: true
    clientContractId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientContractToClientCountAggregateInputType = {
    isMain?: true
    share?: true
    clientContractId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientContractToClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientContractToClient to aggregate.
     */
    where?: ClientContractToClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContractToClients to fetch.
     */
    orderBy?: ClientContractToClientOrderByWithRelationInput | ClientContractToClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientContractToClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContractToClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContractToClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientContractToClients
    **/
    _count?: true | ClientContractToClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientContractToClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientContractToClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientContractToClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientContractToClientMaxAggregateInputType
  }

  export type GetClientContractToClientAggregateType<T extends ClientContractToClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClientContractToClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientContractToClient[P]>
      : GetScalarType<T[P], AggregateClientContractToClient[P]>
  }




  export type ClientContractToClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContractToClientWhereInput
    orderBy?: ClientContractToClientOrderByWithAggregationInput | ClientContractToClientOrderByWithAggregationInput[]
    by: ClientContractToClientScalarFieldEnum[] | ClientContractToClientScalarFieldEnum
    having?: ClientContractToClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientContractToClientCountAggregateInputType | true
    _avg?: ClientContractToClientAvgAggregateInputType
    _sum?: ClientContractToClientSumAggregateInputType
    _min?: ClientContractToClientMinAggregateInputType
    _max?: ClientContractToClientMaxAggregateInputType
  }

  export type ClientContractToClientGroupByOutputType = {
    isMain: boolean
    share: number
    clientContractId: number
    clientId: number
    createdAt: Date
    updatedAt: Date
    _count: ClientContractToClientCountAggregateOutputType | null
    _avg: ClientContractToClientAvgAggregateOutputType | null
    _sum: ClientContractToClientSumAggregateOutputType | null
    _min: ClientContractToClientMinAggregateOutputType | null
    _max: ClientContractToClientMaxAggregateOutputType | null
  }

  type GetClientContractToClientGroupByPayload<T extends ClientContractToClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientContractToClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientContractToClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientContractToClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientContractToClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientContractToClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    isMain?: boolean
    share?: boolean
    clientContractId?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    clientContract?: boolean | ClientContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientContractToClient"]>


  export type ClientContractToClientSelectScalar = {
    isMain?: boolean
    share?: boolean
    clientContractId?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientContractToClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    clientContract?: boolean | ClientContractDefaultArgs<ExtArgs>
  }

  export type $ClientContractToClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientContractToClient"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      clientContract: Prisma.$ClientContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      isMain: boolean
      share: number
      clientContractId: number
      clientId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientContractToClient"]>
    composites: {}
  }

  type ClientContractToClientGetPayload<S extends boolean | null | undefined | ClientContractToClientDefaultArgs> = $Result.GetResult<Prisma.$ClientContractToClientPayload, S>

  type ClientContractToClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientContractToClientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientContractToClientCountAggregateInputType | true
    }

  export interface ClientContractToClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientContractToClient'], meta: { name: 'ClientContractToClient' } }
    /**
     * Find zero or one ClientContractToClient that matches the filter.
     * @param {ClientContractToClientFindUniqueArgs} args - Arguments to find a ClientContractToClient
     * @example
     * // Get one ClientContractToClient
     * const clientContractToClient = await prisma.clientContractToClient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientContractToClientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToClientFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientContractToClientClient<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClientContractToClient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientContractToClientFindUniqueOrThrowArgs} args - Arguments to find a ClientContractToClient
     * @example
     * // Get one ClientContractToClient
     * const clientContractToClient = await prisma.clientContractToClient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientContractToClientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToClientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientContractToClientClient<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClientContractToClient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToClientFindFirstArgs} args - Arguments to find a ClientContractToClient
     * @example
     * // Get one ClientContractToClient
     * const clientContractToClient = await prisma.clientContractToClient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientContractToClientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToClientFindFirstArgs<ExtArgs>>
    ): Prisma__ClientContractToClientClient<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClientContractToClient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToClientFindFirstOrThrowArgs} args - Arguments to find a ClientContractToClient
     * @example
     * // Get one ClientContractToClient
     * const clientContractToClient = await prisma.clientContractToClient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientContractToClientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToClientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientContractToClientClient<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClientContractToClients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientContractToClients
     * const clientContractToClients = await prisma.clientContractToClient.findMany()
     * 
     * // Get first 10 ClientContractToClients
     * const clientContractToClients = await prisma.clientContractToClient.findMany({ take: 10 })
     * 
     * // Only select the `isMain`
     * const clientContractToClientWithIsMainOnly = await prisma.clientContractToClient.findMany({ select: { isMain: true } })
     * 
    **/
    findMany<T extends ClientContractToClientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToClientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClientContractToClient.
     * @param {ClientContractToClientCreateArgs} args - Arguments to create a ClientContractToClient.
     * @example
     * // Create one ClientContractToClient
     * const ClientContractToClient = await prisma.clientContractToClient.create({
     *   data: {
     *     // ... data to create a ClientContractToClient
     *   }
     * })
     * 
    **/
    create<T extends ClientContractToClientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToClientCreateArgs<ExtArgs>>
    ): Prisma__ClientContractToClientClient<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClientContractToClients.
     * @param {ClientContractToClientCreateManyArgs} args - Arguments to create many ClientContractToClients.
     * @example
     * // Create many ClientContractToClients
     * const clientContractToClient = await prisma.clientContractToClient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientContractToClientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToClientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientContractToClient.
     * @param {ClientContractToClientDeleteArgs} args - Arguments to delete one ClientContractToClient.
     * @example
     * // Delete one ClientContractToClient
     * const ClientContractToClient = await prisma.clientContractToClient.delete({
     *   where: {
     *     // ... filter to delete one ClientContractToClient
     *   }
     * })
     * 
    **/
    delete<T extends ClientContractToClientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToClientDeleteArgs<ExtArgs>>
    ): Prisma__ClientContractToClientClient<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClientContractToClient.
     * @param {ClientContractToClientUpdateArgs} args - Arguments to update one ClientContractToClient.
     * @example
     * // Update one ClientContractToClient
     * const clientContractToClient = await prisma.clientContractToClient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientContractToClientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToClientUpdateArgs<ExtArgs>>
    ): Prisma__ClientContractToClientClient<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClientContractToClients.
     * @param {ClientContractToClientDeleteManyArgs} args - Arguments to filter ClientContractToClients to delete.
     * @example
     * // Delete a few ClientContractToClients
     * const { count } = await prisma.clientContractToClient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientContractToClientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientContractToClientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientContractToClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientContractToClients
     * const clientContractToClient = await prisma.clientContractToClient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientContractToClientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToClientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientContractToClient.
     * @param {ClientContractToClientUpsertArgs} args - Arguments to update or create a ClientContractToClient.
     * @example
     * // Update or create a ClientContractToClient
     * const clientContractToClient = await prisma.clientContractToClient.upsert({
     *   create: {
     *     // ... data to create a ClientContractToClient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientContractToClient we want to update
     *   }
     * })
    **/
    upsert<T extends ClientContractToClientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientContractToClientUpsertArgs<ExtArgs>>
    ): Prisma__ClientContractToClientClient<$Result.GetResult<Prisma.$ClientContractToClientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClientContractToClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToClientCountArgs} args - Arguments to filter ClientContractToClients to count.
     * @example
     * // Count the number of ClientContractToClients
     * const count = await prisma.clientContractToClient.count({
     *   where: {
     *     // ... the filter for the ClientContractToClients we want to count
     *   }
     * })
    **/
    count<T extends ClientContractToClientCountArgs>(
      args?: Subset<T, ClientContractToClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientContractToClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientContractToClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientContractToClientAggregateArgs>(args: Subset<T, ClientContractToClientAggregateArgs>): Prisma.PrismaPromise<GetClientContractToClientAggregateType<T>>

    /**
     * Group by ClientContractToClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContractToClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientContractToClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientContractToClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientContractToClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientContractToClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientContractToClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientContractToClient model
   */
  readonly fields: ClientContractToClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientContractToClient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientContractToClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    clientContract<T extends ClientContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientContractDefaultArgs<ExtArgs>>): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClientContractToClient model
   */ 
  interface ClientContractToClientFieldRefs {
    readonly isMain: FieldRef<"ClientContractToClient", 'Boolean'>
    readonly share: FieldRef<"ClientContractToClient", 'Int'>
    readonly clientContractId: FieldRef<"ClientContractToClient", 'Int'>
    readonly clientId: FieldRef<"ClientContractToClient", 'Int'>
    readonly createdAt: FieldRef<"ClientContractToClient", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientContractToClient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientContractToClient findUnique
   */
  export type ClientContractToClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToClient to fetch.
     */
    where: ClientContractToClientWhereUniqueInput
  }

  /**
   * ClientContractToClient findUniqueOrThrow
   */
  export type ClientContractToClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToClient to fetch.
     */
    where: ClientContractToClientWhereUniqueInput
  }

  /**
   * ClientContractToClient findFirst
   */
  export type ClientContractToClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToClient to fetch.
     */
    where?: ClientContractToClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContractToClients to fetch.
     */
    orderBy?: ClientContractToClientOrderByWithRelationInput | ClientContractToClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientContractToClients.
     */
    cursor?: ClientContractToClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContractToClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContractToClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientContractToClients.
     */
    distinct?: ClientContractToClientScalarFieldEnum | ClientContractToClientScalarFieldEnum[]
  }

  /**
   * ClientContractToClient findFirstOrThrow
   */
  export type ClientContractToClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToClient to fetch.
     */
    where?: ClientContractToClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContractToClients to fetch.
     */
    orderBy?: ClientContractToClientOrderByWithRelationInput | ClientContractToClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientContractToClients.
     */
    cursor?: ClientContractToClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContractToClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContractToClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientContractToClients.
     */
    distinct?: ClientContractToClientScalarFieldEnum | ClientContractToClientScalarFieldEnum[]
  }

  /**
   * ClientContractToClient findMany
   */
  export type ClientContractToClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    /**
     * Filter, which ClientContractToClients to fetch.
     */
    where?: ClientContractToClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContractToClients to fetch.
     */
    orderBy?: ClientContractToClientOrderByWithRelationInput | ClientContractToClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientContractToClients.
     */
    cursor?: ClientContractToClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContractToClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContractToClients.
     */
    skip?: number
    distinct?: ClientContractToClientScalarFieldEnum | ClientContractToClientScalarFieldEnum[]
  }

  /**
   * ClientContractToClient create
   */
  export type ClientContractToClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientContractToClient.
     */
    data: XOR<ClientContractToClientCreateInput, ClientContractToClientUncheckedCreateInput>
  }

  /**
   * ClientContractToClient createMany
   */
  export type ClientContractToClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientContractToClients.
     */
    data: ClientContractToClientCreateManyInput | ClientContractToClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientContractToClient update
   */
  export type ClientContractToClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientContractToClient.
     */
    data: XOR<ClientContractToClientUpdateInput, ClientContractToClientUncheckedUpdateInput>
    /**
     * Choose, which ClientContractToClient to update.
     */
    where: ClientContractToClientWhereUniqueInput
  }

  /**
   * ClientContractToClient updateMany
   */
  export type ClientContractToClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientContractToClients.
     */
    data: XOR<ClientContractToClientUpdateManyMutationInput, ClientContractToClientUncheckedUpdateManyInput>
    /**
     * Filter which ClientContractToClients to update
     */
    where?: ClientContractToClientWhereInput
  }

  /**
   * ClientContractToClient upsert
   */
  export type ClientContractToClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientContractToClient to update in case it exists.
     */
    where: ClientContractToClientWhereUniqueInput
    /**
     * In case the ClientContractToClient found by the `where` argument doesn't exist, create a new ClientContractToClient with this data.
     */
    create: XOR<ClientContractToClientCreateInput, ClientContractToClientUncheckedCreateInput>
    /**
     * In case the ClientContractToClient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientContractToClientUpdateInput, ClientContractToClientUncheckedUpdateInput>
  }

  /**
   * ClientContractToClient delete
   */
  export type ClientContractToClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
    /**
     * Filter which ClientContractToClient to delete.
     */
    where: ClientContractToClientWhereUniqueInput
  }

  /**
   * ClientContractToClient deleteMany
   */
  export type ClientContractToClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientContractToClients to delete
     */
    where?: ClientContractToClientWhereInput
  }

  /**
   * ClientContractToClient without action
   */
  export type ClientContractToClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToClient
     */
    select?: ClientContractToClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToClientInclude<ExtArgs> | null
  }


  /**
   * Model ScheduledPayment
   */

  export type AggregateScheduledPayment = {
    _count: ScheduledPaymentCountAggregateOutputType | null
    _avg: ScheduledPaymentAvgAggregateOutputType | null
    _sum: ScheduledPaymentSumAggregateOutputType | null
    _min: ScheduledPaymentMinAggregateOutputType | null
    _max: ScheduledPaymentMaxAggregateOutputType | null
  }

  export type ScheduledPaymentAvgAggregateOutputType = {
    id: number | null
    payment: Decimal | null
    clientContractId: number | null
  }

  export type ScheduledPaymentSumAggregateOutputType = {
    id: number | null
    payment: Decimal | null
    clientContractId: number | null
  }

  export type ScheduledPaymentMinAggregateOutputType = {
    id: number | null
    payment: Decimal | null
    date: Date | null
    scheduledPaymentType: $Enums.ScheduledPaymentType | null
    clientContractId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledPaymentMaxAggregateOutputType = {
    id: number | null
    payment: Decimal | null
    date: Date | null
    scheduledPaymentType: $Enums.ScheduledPaymentType | null
    clientContractId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledPaymentCountAggregateOutputType = {
    id: number
    payment: number
    date: number
    scheduledPaymentType: number
    clientContractId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduledPaymentAvgAggregateInputType = {
    id?: true
    payment?: true
    clientContractId?: true
  }

  export type ScheduledPaymentSumAggregateInputType = {
    id?: true
    payment?: true
    clientContractId?: true
  }

  export type ScheduledPaymentMinAggregateInputType = {
    id?: true
    payment?: true
    date?: true
    scheduledPaymentType?: true
    clientContractId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledPaymentMaxAggregateInputType = {
    id?: true
    payment?: true
    date?: true
    scheduledPaymentType?: true
    clientContractId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledPaymentCountAggregateInputType = {
    id?: true
    payment?: true
    date?: true
    scheduledPaymentType?: true
    clientContractId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduledPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledPayment to aggregate.
     */
    where?: ScheduledPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPayments to fetch.
     */
    orderBy?: ScheduledPaymentOrderByWithRelationInput | ScheduledPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduledPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduledPayments
    **/
    _count?: true | ScheduledPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduledPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduledPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduledPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduledPaymentMaxAggregateInputType
  }

  export type GetScheduledPaymentAggregateType<T extends ScheduledPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduledPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduledPayment[P]>
      : GetScalarType<T[P], AggregateScheduledPayment[P]>
  }




  export type ScheduledPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledPaymentWhereInput
    orderBy?: ScheduledPaymentOrderByWithAggregationInput | ScheduledPaymentOrderByWithAggregationInput[]
    by: ScheduledPaymentScalarFieldEnum[] | ScheduledPaymentScalarFieldEnum
    having?: ScheduledPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduledPaymentCountAggregateInputType | true
    _avg?: ScheduledPaymentAvgAggregateInputType
    _sum?: ScheduledPaymentSumAggregateInputType
    _min?: ScheduledPaymentMinAggregateInputType
    _max?: ScheduledPaymentMaxAggregateInputType
  }

  export type ScheduledPaymentGroupByOutputType = {
    id: number
    payment: Decimal
    date: Date
    scheduledPaymentType: $Enums.ScheduledPaymentType
    clientContractId: number
    createdAt: Date
    updatedAt: Date
    _count: ScheduledPaymentCountAggregateOutputType | null
    _avg: ScheduledPaymentAvgAggregateOutputType | null
    _sum: ScheduledPaymentSumAggregateOutputType | null
    _min: ScheduledPaymentMinAggregateOutputType | null
    _max: ScheduledPaymentMaxAggregateOutputType | null
  }

  type GetScheduledPaymentGroupByPayload<T extends ScheduledPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduledPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduledPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduledPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduledPaymentGroupByOutputType[P]>
        }
      >
    >


  export type ScheduledPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payment?: boolean
    date?: boolean
    scheduledPaymentType?: boolean
    clientContractId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientContract?: boolean | ClientContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledPayment"]>


  export type ScheduledPaymentSelectScalar = {
    id?: boolean
    payment?: boolean
    date?: boolean
    scheduledPaymentType?: boolean
    clientContractId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduledPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientContract?: boolean | ClientContractDefaultArgs<ExtArgs>
  }

  export type $ScheduledPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduledPayment"
    objects: {
      clientContract: Prisma.$ClientContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      payment: Prisma.Decimal
      date: Date
      scheduledPaymentType: $Enums.ScheduledPaymentType
      clientContractId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scheduledPayment"]>
    composites: {}
  }

  type ScheduledPaymentGetPayload<S extends boolean | null | undefined | ScheduledPaymentDefaultArgs> = $Result.GetResult<Prisma.$ScheduledPaymentPayload, S>

  type ScheduledPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScheduledPaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScheduledPaymentCountAggregateInputType | true
    }

  export interface ScheduledPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduledPayment'], meta: { name: 'ScheduledPayment' } }
    /**
     * Find zero or one ScheduledPayment that matches the filter.
     * @param {ScheduledPaymentFindUniqueArgs} args - Arguments to find a ScheduledPayment
     * @example
     * // Get one ScheduledPayment
     * const scheduledPayment = await prisma.scheduledPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ScheduledPaymentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ScheduledPaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__ScheduledPaymentClient<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ScheduledPayment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScheduledPaymentFindUniqueOrThrowArgs} args - Arguments to find a ScheduledPayment
     * @example
     * // Get one ScheduledPayment
     * const scheduledPayment = await prisma.scheduledPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ScheduledPaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ScheduledPaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ScheduledPaymentClient<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ScheduledPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPaymentFindFirstArgs} args - Arguments to find a ScheduledPayment
     * @example
     * // Get one ScheduledPayment
     * const scheduledPayment = await prisma.scheduledPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ScheduledPaymentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ScheduledPaymentFindFirstArgs<ExtArgs>>
    ): Prisma__ScheduledPaymentClient<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ScheduledPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPaymentFindFirstOrThrowArgs} args - Arguments to find a ScheduledPayment
     * @example
     * // Get one ScheduledPayment
     * const scheduledPayment = await prisma.scheduledPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ScheduledPaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ScheduledPaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ScheduledPaymentClient<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ScheduledPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduledPayments
     * const scheduledPayments = await prisma.scheduledPayment.findMany()
     * 
     * // Get first 10 ScheduledPayments
     * const scheduledPayments = await prisma.scheduledPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduledPaymentWithIdOnly = await prisma.scheduledPayment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ScheduledPaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ScheduledPaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ScheduledPayment.
     * @param {ScheduledPaymentCreateArgs} args - Arguments to create a ScheduledPayment.
     * @example
     * // Create one ScheduledPayment
     * const ScheduledPayment = await prisma.scheduledPayment.create({
     *   data: {
     *     // ... data to create a ScheduledPayment
     *   }
     * })
     * 
    **/
    create<T extends ScheduledPaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ScheduledPaymentCreateArgs<ExtArgs>>
    ): Prisma__ScheduledPaymentClient<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ScheduledPayments.
     * @param {ScheduledPaymentCreateManyArgs} args - Arguments to create many ScheduledPayments.
     * @example
     * // Create many ScheduledPayments
     * const scheduledPayment = await prisma.scheduledPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ScheduledPaymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ScheduledPaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ScheduledPayment.
     * @param {ScheduledPaymentDeleteArgs} args - Arguments to delete one ScheduledPayment.
     * @example
     * // Delete one ScheduledPayment
     * const ScheduledPayment = await prisma.scheduledPayment.delete({
     *   where: {
     *     // ... filter to delete one ScheduledPayment
     *   }
     * })
     * 
    **/
    delete<T extends ScheduledPaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ScheduledPaymentDeleteArgs<ExtArgs>>
    ): Prisma__ScheduledPaymentClient<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ScheduledPayment.
     * @param {ScheduledPaymentUpdateArgs} args - Arguments to update one ScheduledPayment.
     * @example
     * // Update one ScheduledPayment
     * const scheduledPayment = await prisma.scheduledPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ScheduledPaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ScheduledPaymentUpdateArgs<ExtArgs>>
    ): Prisma__ScheduledPaymentClient<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ScheduledPayments.
     * @param {ScheduledPaymentDeleteManyArgs} args - Arguments to filter ScheduledPayments to delete.
     * @example
     * // Delete a few ScheduledPayments
     * const { count } = await prisma.scheduledPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ScheduledPaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ScheduledPaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduledPayments
     * const scheduledPayment = await prisma.scheduledPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ScheduledPaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ScheduledPaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScheduledPayment.
     * @param {ScheduledPaymentUpsertArgs} args - Arguments to update or create a ScheduledPayment.
     * @example
     * // Update or create a ScheduledPayment
     * const scheduledPayment = await prisma.scheduledPayment.upsert({
     *   create: {
     *     // ... data to create a ScheduledPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduledPayment we want to update
     *   }
     * })
    **/
    upsert<T extends ScheduledPaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ScheduledPaymentUpsertArgs<ExtArgs>>
    ): Prisma__ScheduledPaymentClient<$Result.GetResult<Prisma.$ScheduledPaymentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ScheduledPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPaymentCountArgs} args - Arguments to filter ScheduledPayments to count.
     * @example
     * // Count the number of ScheduledPayments
     * const count = await prisma.scheduledPayment.count({
     *   where: {
     *     // ... the filter for the ScheduledPayments we want to count
     *   }
     * })
    **/
    count<T extends ScheduledPaymentCountArgs>(
      args?: Subset<T, ScheduledPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduledPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduledPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduledPaymentAggregateArgs>(args: Subset<T, ScheduledPaymentAggregateArgs>): Prisma.PrismaPromise<GetScheduledPaymentAggregateType<T>>

    /**
     * Group by ScheduledPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduledPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduledPaymentGroupByArgs['orderBy'] }
        : { orderBy?: ScheduledPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduledPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduledPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduledPayment model
   */
  readonly fields: ScheduledPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduledPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduledPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    clientContract<T extends ClientContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientContractDefaultArgs<ExtArgs>>): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ScheduledPayment model
   */ 
  interface ScheduledPaymentFieldRefs {
    readonly id: FieldRef<"ScheduledPayment", 'Int'>
    readonly payment: FieldRef<"ScheduledPayment", 'Decimal'>
    readonly date: FieldRef<"ScheduledPayment", 'DateTime'>
    readonly scheduledPaymentType: FieldRef<"ScheduledPayment", 'ScheduledPaymentType'>
    readonly clientContractId: FieldRef<"ScheduledPayment", 'Int'>
    readonly createdAt: FieldRef<"ScheduledPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduledPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduledPayment findUnique
   */
  export type ScheduledPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPayment to fetch.
     */
    where: ScheduledPaymentWhereUniqueInput
  }

  /**
   * ScheduledPayment findUniqueOrThrow
   */
  export type ScheduledPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPayment to fetch.
     */
    where: ScheduledPaymentWhereUniqueInput
  }

  /**
   * ScheduledPayment findFirst
   */
  export type ScheduledPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPayment to fetch.
     */
    where?: ScheduledPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPayments to fetch.
     */
    orderBy?: ScheduledPaymentOrderByWithRelationInput | ScheduledPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledPayments.
     */
    cursor?: ScheduledPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledPayments.
     */
    distinct?: ScheduledPaymentScalarFieldEnum | ScheduledPaymentScalarFieldEnum[]
  }

  /**
   * ScheduledPayment findFirstOrThrow
   */
  export type ScheduledPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPayment to fetch.
     */
    where?: ScheduledPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPayments to fetch.
     */
    orderBy?: ScheduledPaymentOrderByWithRelationInput | ScheduledPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledPayments.
     */
    cursor?: ScheduledPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledPayments.
     */
    distinct?: ScheduledPaymentScalarFieldEnum | ScheduledPaymentScalarFieldEnum[]
  }

  /**
   * ScheduledPayment findMany
   */
  export type ScheduledPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledPayments to fetch.
     */
    where?: ScheduledPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPayments to fetch.
     */
    orderBy?: ScheduledPaymentOrderByWithRelationInput | ScheduledPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduledPayments.
     */
    cursor?: ScheduledPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPayments.
     */
    skip?: number
    distinct?: ScheduledPaymentScalarFieldEnum | ScheduledPaymentScalarFieldEnum[]
  }

  /**
   * ScheduledPayment create
   */
  export type ScheduledPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduledPayment.
     */
    data: XOR<ScheduledPaymentCreateInput, ScheduledPaymentUncheckedCreateInput>
  }

  /**
   * ScheduledPayment createMany
   */
  export type ScheduledPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduledPayments.
     */
    data: ScheduledPaymentCreateManyInput | ScheduledPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledPayment update
   */
  export type ScheduledPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduledPayment.
     */
    data: XOR<ScheduledPaymentUpdateInput, ScheduledPaymentUncheckedUpdateInput>
    /**
     * Choose, which ScheduledPayment to update.
     */
    where: ScheduledPaymentWhereUniqueInput
  }

  /**
   * ScheduledPayment updateMany
   */
  export type ScheduledPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduledPayments.
     */
    data: XOR<ScheduledPaymentUpdateManyMutationInput, ScheduledPaymentUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledPayments to update
     */
    where?: ScheduledPaymentWhereInput
  }

  /**
   * ScheduledPayment upsert
   */
  export type ScheduledPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduledPayment to update in case it exists.
     */
    where: ScheduledPaymentWhereUniqueInput
    /**
     * In case the ScheduledPayment found by the `where` argument doesn't exist, create a new ScheduledPayment with this data.
     */
    create: XOR<ScheduledPaymentCreateInput, ScheduledPaymentUncheckedCreateInput>
    /**
     * In case the ScheduledPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduledPaymentUpdateInput, ScheduledPaymentUncheckedUpdateInput>
  }

  /**
   * ScheduledPayment delete
   */
  export type ScheduledPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
    /**
     * Filter which ScheduledPayment to delete.
     */
    where: ScheduledPaymentWhereUniqueInput
  }

  /**
   * ScheduledPayment deleteMany
   */
  export type ScheduledPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledPayments to delete
     */
    where?: ScheduledPaymentWhereInput
  }

  /**
   * ScheduledPayment without action
   */
  export type ScheduledPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPayment
     */
    select?: ScheduledPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledPaymentInclude<ExtArgs> | null
  }


  /**
   * Model ActualPayment
   */

  export type AggregateActualPayment = {
    _count: ActualPaymentCountAggregateOutputType | null
    _avg: ActualPaymentAvgAggregateOutputType | null
    _sum: ActualPaymentSumAggregateOutputType | null
    _min: ActualPaymentMinAggregateOutputType | null
    _max: ActualPaymentMaxAggregateOutputType | null
  }

  export type ActualPaymentAvgAggregateOutputType = {
    id: number | null
    payment: Decimal | null
    clientContractId: number | null
  }

  export type ActualPaymentSumAggregateOutputType = {
    id: number | null
    payment: Decimal | null
    clientContractId: number | null
  }

  export type ActualPaymentMinAggregateOutputType = {
    id: number | null
    payment: Decimal | null
    date: Date | null
    clientContractId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActualPaymentMaxAggregateOutputType = {
    id: number | null
    payment: Decimal | null
    date: Date | null
    clientContractId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActualPaymentCountAggregateOutputType = {
    id: number
    payment: number
    date: number
    clientContractId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActualPaymentAvgAggregateInputType = {
    id?: true
    payment?: true
    clientContractId?: true
  }

  export type ActualPaymentSumAggregateInputType = {
    id?: true
    payment?: true
    clientContractId?: true
  }

  export type ActualPaymentMinAggregateInputType = {
    id?: true
    payment?: true
    date?: true
    clientContractId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActualPaymentMaxAggregateInputType = {
    id?: true
    payment?: true
    date?: true
    clientContractId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActualPaymentCountAggregateInputType = {
    id?: true
    payment?: true
    date?: true
    clientContractId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActualPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActualPayment to aggregate.
     */
    where?: ActualPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActualPayments to fetch.
     */
    orderBy?: ActualPaymentOrderByWithRelationInput | ActualPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActualPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActualPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActualPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActualPayments
    **/
    _count?: true | ActualPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActualPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActualPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActualPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActualPaymentMaxAggregateInputType
  }

  export type GetActualPaymentAggregateType<T extends ActualPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateActualPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActualPayment[P]>
      : GetScalarType<T[P], AggregateActualPayment[P]>
  }




  export type ActualPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActualPaymentWhereInput
    orderBy?: ActualPaymentOrderByWithAggregationInput | ActualPaymentOrderByWithAggregationInput[]
    by: ActualPaymentScalarFieldEnum[] | ActualPaymentScalarFieldEnum
    having?: ActualPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActualPaymentCountAggregateInputType | true
    _avg?: ActualPaymentAvgAggregateInputType
    _sum?: ActualPaymentSumAggregateInputType
    _min?: ActualPaymentMinAggregateInputType
    _max?: ActualPaymentMaxAggregateInputType
  }

  export type ActualPaymentGroupByOutputType = {
    id: number
    payment: Decimal
    date: Date
    clientContractId: number
    createdAt: Date
    updatedAt: Date
    _count: ActualPaymentCountAggregateOutputType | null
    _avg: ActualPaymentAvgAggregateOutputType | null
    _sum: ActualPaymentSumAggregateOutputType | null
    _min: ActualPaymentMinAggregateOutputType | null
    _max: ActualPaymentMaxAggregateOutputType | null
  }

  type GetActualPaymentGroupByPayload<T extends ActualPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActualPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActualPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActualPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], ActualPaymentGroupByOutputType[P]>
        }
      >
    >


  export type ActualPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payment?: boolean
    date?: boolean
    clientContractId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientContract?: boolean | ClientContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actualPayment"]>


  export type ActualPaymentSelectScalar = {
    id?: boolean
    payment?: boolean
    date?: boolean
    clientContractId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActualPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientContract?: boolean | ClientContractDefaultArgs<ExtArgs>
  }

  export type $ActualPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActualPayment"
    objects: {
      clientContract: Prisma.$ClientContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      payment: Prisma.Decimal
      date: Date
      clientContractId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["actualPayment"]>
    composites: {}
  }

  type ActualPaymentGetPayload<S extends boolean | null | undefined | ActualPaymentDefaultArgs> = $Result.GetResult<Prisma.$ActualPaymentPayload, S>

  type ActualPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActualPaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActualPaymentCountAggregateInputType | true
    }

  export interface ActualPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActualPayment'], meta: { name: 'ActualPayment' } }
    /**
     * Find zero or one ActualPayment that matches the filter.
     * @param {ActualPaymentFindUniqueArgs} args - Arguments to find a ActualPayment
     * @example
     * // Get one ActualPayment
     * const actualPayment = await prisma.actualPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActualPaymentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ActualPaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__ActualPaymentClient<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ActualPayment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActualPaymentFindUniqueOrThrowArgs} args - Arguments to find a ActualPayment
     * @example
     * // Get one ActualPayment
     * const actualPayment = await prisma.actualPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ActualPaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ActualPaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ActualPaymentClient<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ActualPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualPaymentFindFirstArgs} args - Arguments to find a ActualPayment
     * @example
     * // Get one ActualPayment
     * const actualPayment = await prisma.actualPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActualPaymentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ActualPaymentFindFirstArgs<ExtArgs>>
    ): Prisma__ActualPaymentClient<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ActualPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualPaymentFindFirstOrThrowArgs} args - Arguments to find a ActualPayment
     * @example
     * // Get one ActualPayment
     * const actualPayment = await prisma.actualPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ActualPaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ActualPaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ActualPaymentClient<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ActualPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActualPayments
     * const actualPayments = await prisma.actualPayment.findMany()
     * 
     * // Get first 10 ActualPayments
     * const actualPayments = await prisma.actualPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actualPaymentWithIdOnly = await prisma.actualPayment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ActualPaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActualPaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ActualPayment.
     * @param {ActualPaymentCreateArgs} args - Arguments to create a ActualPayment.
     * @example
     * // Create one ActualPayment
     * const ActualPayment = await prisma.actualPayment.create({
     *   data: {
     *     // ... data to create a ActualPayment
     *   }
     * })
     * 
    **/
    create<T extends ActualPaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ActualPaymentCreateArgs<ExtArgs>>
    ): Prisma__ActualPaymentClient<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ActualPayments.
     * @param {ActualPaymentCreateManyArgs} args - Arguments to create many ActualPayments.
     * @example
     * // Create many ActualPayments
     * const actualPayment = await prisma.actualPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ActualPaymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActualPaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ActualPayment.
     * @param {ActualPaymentDeleteArgs} args - Arguments to delete one ActualPayment.
     * @example
     * // Delete one ActualPayment
     * const ActualPayment = await prisma.actualPayment.delete({
     *   where: {
     *     // ... filter to delete one ActualPayment
     *   }
     * })
     * 
    **/
    delete<T extends ActualPaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ActualPaymentDeleteArgs<ExtArgs>>
    ): Prisma__ActualPaymentClient<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ActualPayment.
     * @param {ActualPaymentUpdateArgs} args - Arguments to update one ActualPayment.
     * @example
     * // Update one ActualPayment
     * const actualPayment = await prisma.actualPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActualPaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ActualPaymentUpdateArgs<ExtArgs>>
    ): Prisma__ActualPaymentClient<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ActualPayments.
     * @param {ActualPaymentDeleteManyArgs} args - Arguments to filter ActualPayments to delete.
     * @example
     * // Delete a few ActualPayments
     * const { count } = await prisma.actualPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActualPaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActualPaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActualPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActualPayments
     * const actualPayment = await prisma.actualPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActualPaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ActualPaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActualPayment.
     * @param {ActualPaymentUpsertArgs} args - Arguments to update or create a ActualPayment.
     * @example
     * // Update or create a ActualPayment
     * const actualPayment = await prisma.actualPayment.upsert({
     *   create: {
     *     // ... data to create a ActualPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActualPayment we want to update
     *   }
     * })
    **/
    upsert<T extends ActualPaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ActualPaymentUpsertArgs<ExtArgs>>
    ): Prisma__ActualPaymentClient<$Result.GetResult<Prisma.$ActualPaymentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ActualPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualPaymentCountArgs} args - Arguments to filter ActualPayments to count.
     * @example
     * // Count the number of ActualPayments
     * const count = await prisma.actualPayment.count({
     *   where: {
     *     // ... the filter for the ActualPayments we want to count
     *   }
     * })
    **/
    count<T extends ActualPaymentCountArgs>(
      args?: Subset<T, ActualPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActualPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActualPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActualPaymentAggregateArgs>(args: Subset<T, ActualPaymentAggregateArgs>): Prisma.PrismaPromise<GetActualPaymentAggregateType<T>>

    /**
     * Group by ActualPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActualPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActualPaymentGroupByArgs['orderBy'] }
        : { orderBy?: ActualPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActualPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActualPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActualPayment model
   */
  readonly fields: ActualPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActualPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActualPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    clientContract<T extends ClientContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientContractDefaultArgs<ExtArgs>>): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ActualPayment model
   */ 
  interface ActualPaymentFieldRefs {
    readonly id: FieldRef<"ActualPayment", 'Int'>
    readonly payment: FieldRef<"ActualPayment", 'Decimal'>
    readonly date: FieldRef<"ActualPayment", 'DateTime'>
    readonly clientContractId: FieldRef<"ActualPayment", 'Int'>
    readonly createdAt: FieldRef<"ActualPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"ActualPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActualPayment findUnique
   */
  export type ActualPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ActualPayment to fetch.
     */
    where: ActualPaymentWhereUniqueInput
  }

  /**
   * ActualPayment findUniqueOrThrow
   */
  export type ActualPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ActualPayment to fetch.
     */
    where: ActualPaymentWhereUniqueInput
  }

  /**
   * ActualPayment findFirst
   */
  export type ActualPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ActualPayment to fetch.
     */
    where?: ActualPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActualPayments to fetch.
     */
    orderBy?: ActualPaymentOrderByWithRelationInput | ActualPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActualPayments.
     */
    cursor?: ActualPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActualPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActualPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActualPayments.
     */
    distinct?: ActualPaymentScalarFieldEnum | ActualPaymentScalarFieldEnum[]
  }

  /**
   * ActualPayment findFirstOrThrow
   */
  export type ActualPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ActualPayment to fetch.
     */
    where?: ActualPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActualPayments to fetch.
     */
    orderBy?: ActualPaymentOrderByWithRelationInput | ActualPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActualPayments.
     */
    cursor?: ActualPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActualPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActualPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActualPayments.
     */
    distinct?: ActualPaymentScalarFieldEnum | ActualPaymentScalarFieldEnum[]
  }

  /**
   * ActualPayment findMany
   */
  export type ActualPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ActualPayments to fetch.
     */
    where?: ActualPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActualPayments to fetch.
     */
    orderBy?: ActualPaymentOrderByWithRelationInput | ActualPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActualPayments.
     */
    cursor?: ActualPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActualPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActualPayments.
     */
    skip?: number
    distinct?: ActualPaymentScalarFieldEnum | ActualPaymentScalarFieldEnum[]
  }

  /**
   * ActualPayment create
   */
  export type ActualPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a ActualPayment.
     */
    data: XOR<ActualPaymentCreateInput, ActualPaymentUncheckedCreateInput>
  }

  /**
   * ActualPayment createMany
   */
  export type ActualPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActualPayments.
     */
    data: ActualPaymentCreateManyInput | ActualPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActualPayment update
   */
  export type ActualPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a ActualPayment.
     */
    data: XOR<ActualPaymentUpdateInput, ActualPaymentUncheckedUpdateInput>
    /**
     * Choose, which ActualPayment to update.
     */
    where: ActualPaymentWhereUniqueInput
  }

  /**
   * ActualPayment updateMany
   */
  export type ActualPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActualPayments.
     */
    data: XOR<ActualPaymentUpdateManyMutationInput, ActualPaymentUncheckedUpdateManyInput>
    /**
     * Filter which ActualPayments to update
     */
    where?: ActualPaymentWhereInput
  }

  /**
   * ActualPayment upsert
   */
  export type ActualPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the ActualPayment to update in case it exists.
     */
    where: ActualPaymentWhereUniqueInput
    /**
     * In case the ActualPayment found by the `where` argument doesn't exist, create a new ActualPayment with this data.
     */
    create: XOR<ActualPaymentCreateInput, ActualPaymentUncheckedCreateInput>
    /**
     * In case the ActualPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActualPaymentUpdateInput, ActualPaymentUncheckedUpdateInput>
  }

  /**
   * ActualPayment delete
   */
  export type ActualPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
    /**
     * Filter which ActualPayment to delete.
     */
    where: ActualPaymentWhereUniqueInput
  }

  /**
   * ActualPayment deleteMany
   */
  export type ActualPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActualPayments to delete
     */
    where?: ActualPaymentWhereInput
  }

  /**
   * ActualPayment without action
   */
  export type ActualPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualPayment
     */
    select?: ActualPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualPaymentInclude<ExtArgs> | null
  }


  /**
   * Model Object
   */

  export type AggregateObject = {
    _count: ObjectCountAggregateOutputType | null
    _avg: ObjectAvgAggregateOutputType | null
    _sum: ObjectSumAggregateOutputType | null
    _min: ObjectMinAggregateOutputType | null
    _max: ObjectMaxAggregateOutputType | null
  }

  export type ObjectAvgAggregateOutputType = {
    id: number | null
    commonDbObjectsId: number | null
    entityId: number | null
  }

  export type ObjectSumAggregateOutputType = {
    id: number | null
    commonDbObjectsId: number | null
    entityId: number | null
  }

  export type ObjectMinAggregateOutputType = {
    id: number | null
    commonDbObjectsId: number | null
    name: string | null
    dateIn: Date | null
    entityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ObjectMaxAggregateOutputType = {
    id: number | null
    commonDbObjectsId: number | null
    name: string | null
    dateIn: Date | null
    entityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ObjectCountAggregateOutputType = {
    id: number
    commonDbObjectsId: number
    name: number
    dateIn: number
    entityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ObjectAvgAggregateInputType = {
    id?: true
    commonDbObjectsId?: true
    entityId?: true
  }

  export type ObjectSumAggregateInputType = {
    id?: true
    commonDbObjectsId?: true
    entityId?: true
  }

  export type ObjectMinAggregateInputType = {
    id?: true
    commonDbObjectsId?: true
    name?: true
    dateIn?: true
    entityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ObjectMaxAggregateInputType = {
    id?: true
    commonDbObjectsId?: true
    name?: true
    dateIn?: true
    entityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ObjectCountAggregateInputType = {
    id?: true
    commonDbObjectsId?: true
    name?: true
    dateIn?: true
    entityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ObjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Object to aggregate.
     */
    where?: ObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objects to fetch.
     */
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Objects
    **/
    _count?: true | ObjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjectMaxAggregateInputType
  }

  export type GetObjectAggregateType<T extends ObjectAggregateArgs> = {
        [P in keyof T & keyof AggregateObject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObject[P]>
      : GetScalarType<T[P], AggregateObject[P]>
  }




  export type ObjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectWhereInput
    orderBy?: ObjectOrderByWithAggregationInput | ObjectOrderByWithAggregationInput[]
    by: ObjectScalarFieldEnum[] | ObjectScalarFieldEnum
    having?: ObjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjectCountAggregateInputType | true
    _avg?: ObjectAvgAggregateInputType
    _sum?: ObjectSumAggregateInputType
    _min?: ObjectMinAggregateInputType
    _max?: ObjectMaxAggregateInputType
  }

  export type ObjectGroupByOutputType = {
    id: number
    commonDbObjectsId: number
    name: string
    dateIn: Date | null
    entityId: number
    createdAt: Date
    updatedAt: Date
    _count: ObjectCountAggregateOutputType | null
    _avg: ObjectAvgAggregateOutputType | null
    _sum: ObjectSumAggregateOutputType | null
    _min: ObjectMinAggregateOutputType | null
    _max: ObjectMaxAggregateOutputType | null
  }

  type GetObjectGroupByPayload<T extends ObjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjectGroupByOutputType[P]>
            : GetScalarType<T[P], ObjectGroupByOutputType[P]>
        }
      >
    >


  export type ObjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commonDbObjectsId?: boolean
    name?: boolean
    dateIn?: boolean
    entityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entity?: boolean | EntityDefaultArgs<ExtArgs>
    products?: boolean | Object$productsArgs<ExtArgs>
    clientContracts?: boolean | Object$clientContractsArgs<ExtArgs>
    agencyContracts?: boolean | Object$agencyContractsArgs<ExtArgs>
    transferActs?: boolean | Object$transferActsArgs<ExtArgs>
    _count?: boolean | ObjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["object"]>


  export type ObjectSelectScalar = {
    id?: boolean
    commonDbObjectsId?: boolean
    name?: boolean
    dateIn?: boolean
    entityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ObjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entity?: boolean | EntityDefaultArgs<ExtArgs>
    products?: boolean | Object$productsArgs<ExtArgs>
    clientContracts?: boolean | Object$clientContractsArgs<ExtArgs>
    agencyContracts?: boolean | Object$agencyContractsArgs<ExtArgs>
    transferActs?: boolean | Object$transferActsArgs<ExtArgs>
    _count?: boolean | ObjectCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ObjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Object"
    objects: {
      entity: Prisma.$EntityPayload<ExtArgs>
      products: Prisma.$ProductPayload<ExtArgs>[]
      clientContracts: Prisma.$ClientContractPayload<ExtArgs>[]
      agencyContracts: Prisma.$AgencyContractPayload<ExtArgs>[]
      transferActs: Prisma.$TransferActPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      commonDbObjectsId: number
      name: string
      dateIn: Date | null
      entityId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["object"]>
    composites: {}
  }

  type ObjectGetPayload<S extends boolean | null | undefined | ObjectDefaultArgs> = $Result.GetResult<Prisma.$ObjectPayload, S>

  type ObjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ObjectCountAggregateInputType | true
    }

  export interface ObjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Object'], meta: { name: 'Object' } }
    /**
     * Find zero or one Object that matches the filter.
     * @param {ObjectFindUniqueArgs} args - Arguments to find a Object
     * @example
     * // Get one Object
     * const object = await prisma.object.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ObjectFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectFindUniqueArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Object that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ObjectFindUniqueOrThrowArgs} args - Arguments to find a Object
     * @example
     * // Get one Object
     * const object = await prisma.object.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ObjectFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Object that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectFindFirstArgs} args - Arguments to find a Object
     * @example
     * // Get one Object
     * const object = await prisma.object.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ObjectFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectFindFirstArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Object that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectFindFirstOrThrowArgs} args - Arguments to find a Object
     * @example
     * // Get one Object
     * const object = await prisma.object.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ObjectFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Objects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Objects
     * const objects = await prisma.object.findMany()
     * 
     * // Get first 10 Objects
     * const objects = await prisma.object.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objectWithIdOnly = await prisma.object.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ObjectFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Object.
     * @param {ObjectCreateArgs} args - Arguments to create a Object.
     * @example
     * // Create one Object
     * const Object = await prisma.object.create({
     *   data: {
     *     // ... data to create a Object
     *   }
     * })
     * 
    **/
    create<T extends ObjectCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectCreateArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Objects.
     * @param {ObjectCreateManyArgs} args - Arguments to create many Objects.
     * @example
     * // Create many Objects
     * const object = await prisma.object.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ObjectCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Object.
     * @param {ObjectDeleteArgs} args - Arguments to delete one Object.
     * @example
     * // Delete one Object
     * const Object = await prisma.object.delete({
     *   where: {
     *     // ... filter to delete one Object
     *   }
     * })
     * 
    **/
    delete<T extends ObjectDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectDeleteArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Object.
     * @param {ObjectUpdateArgs} args - Arguments to update one Object.
     * @example
     * // Update one Object
     * const object = await prisma.object.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ObjectUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectUpdateArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Objects.
     * @param {ObjectDeleteManyArgs} args - Arguments to filter Objects to delete.
     * @example
     * // Delete a few Objects
     * const { count } = await prisma.object.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ObjectDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Objects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Objects
     * const object = await prisma.object.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ObjectUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Object.
     * @param {ObjectUpsertArgs} args - Arguments to update or create a Object.
     * @example
     * // Update or create a Object
     * const object = await prisma.object.upsert({
     *   create: {
     *     // ... data to create a Object
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Object we want to update
     *   }
     * })
    **/
    upsert<T extends ObjectUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectUpsertArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Objects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectCountArgs} args - Arguments to filter Objects to count.
     * @example
     * // Count the number of Objects
     * const count = await prisma.object.count({
     *   where: {
     *     // ... the filter for the Objects we want to count
     *   }
     * })
    **/
    count<T extends ObjectCountArgs>(
      args?: Subset<T, ObjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Object.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjectAggregateArgs>(args: Subset<T, ObjectAggregateArgs>): Prisma.PrismaPromise<GetObjectAggregateType<T>>

    /**
     * Group by Object.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObjectGroupByArgs['orderBy'] }
        : { orderBy?: ObjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Object model
   */
  readonly fields: ObjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Object.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entity<T extends EntityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntityDefaultArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    products<T extends Object$productsArgs<ExtArgs> = {}>(args?: Subset<T, Object$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    clientContracts<T extends Object$clientContractsArgs<ExtArgs> = {}>(args?: Subset<T, Object$clientContractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    agencyContracts<T extends Object$agencyContractsArgs<ExtArgs> = {}>(args?: Subset<T, Object$agencyContractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    transferActs<T extends Object$transferActsArgs<ExtArgs> = {}>(args?: Subset<T, Object$transferActsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferActPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Object model
   */ 
  interface ObjectFieldRefs {
    readonly id: FieldRef<"Object", 'Int'>
    readonly commonDbObjectsId: FieldRef<"Object", 'Int'>
    readonly name: FieldRef<"Object", 'String'>
    readonly dateIn: FieldRef<"Object", 'DateTime'>
    readonly entityId: FieldRef<"Object", 'Int'>
    readonly createdAt: FieldRef<"Object", 'DateTime'>
    readonly updatedAt: FieldRef<"Object", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Object findUnique
   */
  export type ObjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Object to fetch.
     */
    where: ObjectWhereUniqueInput
  }

  /**
   * Object findUniqueOrThrow
   */
  export type ObjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Object to fetch.
     */
    where: ObjectWhereUniqueInput
  }

  /**
   * Object findFirst
   */
  export type ObjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Object to fetch.
     */
    where?: ObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objects to fetch.
     */
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Objects.
     */
    cursor?: ObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Objects.
     */
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * Object findFirstOrThrow
   */
  export type ObjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Object to fetch.
     */
    where?: ObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objects to fetch.
     */
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Objects.
     */
    cursor?: ObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Objects.
     */
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * Object findMany
   */
  export type ObjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Objects to fetch.
     */
    where?: ObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objects to fetch.
     */
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Objects.
     */
    cursor?: ObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objects.
     */
    skip?: number
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * Object create
   */
  export type ObjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Object.
     */
    data: XOR<ObjectCreateInput, ObjectUncheckedCreateInput>
  }

  /**
   * Object createMany
   */
  export type ObjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Objects.
     */
    data: ObjectCreateManyInput | ObjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Object update
   */
  export type ObjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Object.
     */
    data: XOR<ObjectUpdateInput, ObjectUncheckedUpdateInput>
    /**
     * Choose, which Object to update.
     */
    where: ObjectWhereUniqueInput
  }

  /**
   * Object updateMany
   */
  export type ObjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Objects.
     */
    data: XOR<ObjectUpdateManyMutationInput, ObjectUncheckedUpdateManyInput>
    /**
     * Filter which Objects to update
     */
    where?: ObjectWhereInput
  }

  /**
   * Object upsert
   */
  export type ObjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Object to update in case it exists.
     */
    where: ObjectWhereUniqueInput
    /**
     * In case the Object found by the `where` argument doesn't exist, create a new Object with this data.
     */
    create: XOR<ObjectCreateInput, ObjectUncheckedCreateInput>
    /**
     * In case the Object was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObjectUpdateInput, ObjectUncheckedUpdateInput>
  }

  /**
   * Object delete
   */
  export type ObjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter which Object to delete.
     */
    where: ObjectWhereUniqueInput
  }

  /**
   * Object deleteMany
   */
  export type ObjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Objects to delete
     */
    where?: ObjectWhereInput
  }

  /**
   * Object.products
   */
  export type Object$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Object.clientContracts
   */
  export type Object$clientContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    where?: ClientContractWhereInput
    orderBy?: ClientContractOrderByWithRelationInput | ClientContractOrderByWithRelationInput[]
    cursor?: ClientContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientContractScalarFieldEnum | ClientContractScalarFieldEnum[]
  }

  /**
   * Object.agencyContracts
   */
  export type Object$agencyContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    where?: AgencyContractWhereInput
    orderBy?: AgencyContractOrderByWithRelationInput | AgencyContractOrderByWithRelationInput[]
    cursor?: AgencyContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyContractScalarFieldEnum | AgencyContractScalarFieldEnum[]
  }

  /**
   * Object.transferActs
   */
  export type Object$transferActsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferAct
     */
    select?: TransferActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActInclude<ExtArgs> | null
    where?: TransferActWhereInput
    orderBy?: TransferActOrderByWithRelationInput | TransferActOrderByWithRelationInput[]
    cursor?: TransferActWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferActScalarFieldEnum | TransferActScalarFieldEnum[]
  }

  /**
   * Object without action
   */
  export type ObjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    pricingProductsId: number | null
    objectId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    pricingProductsId: number | null
    objectId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    pricingProductsId: number | null
    number: string | null
    productCategory: $Enums.ProductCategory | null
    objectId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    pricingProductsId: number | null
    number: string | null
    productCategory: $Enums.ProductCategory | null
    objectId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    pricingProductsId: number
    number: number
    productCategory: number
    objectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    pricingProductsId?: true
    objectId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    pricingProductsId?: true
    objectId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    pricingProductsId?: true
    number?: true
    productCategory?: true
    objectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    pricingProductsId?: true
    number?: true
    productCategory?: true
    objectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    pricingProductsId?: true
    number?: true
    productCategory?: true
    objectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    pricingProductsId: number
    number: string
    productCategory: $Enums.ProductCategory
    objectId: number
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pricingProductsId?: boolean
    number?: boolean
    productCategory?: boolean
    objectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transferAct?: boolean | Product$transferActArgs<ExtArgs>
    clientContract?: boolean | Product$clientContractArgs<ExtArgs>
    object?: boolean | ObjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>


  export type ProductSelectScalar = {
    id?: boolean
    pricingProductsId?: boolean
    number?: boolean
    productCategory?: boolean
    objectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transferAct?: boolean | Product$transferActArgs<ExtArgs>
    clientContract?: boolean | Product$clientContractArgs<ExtArgs>
    object?: boolean | ObjectDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      transferAct: Prisma.$TransferActPayload<ExtArgs> | null
      clientContract: Prisma.$ClientContractPayload<ExtArgs> | null
      object: Prisma.$ObjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pricingProductsId: number
      number: string
      productCategory: $Enums.ProductCategory
      objectId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductCreateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    transferAct<T extends Product$transferActArgs<ExtArgs> = {}>(args?: Subset<T, Product$transferActArgs<ExtArgs>>): Prisma__TransferActClient<$Result.GetResult<Prisma.$TransferActPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    clientContract<T extends Product$clientContractArgs<ExtArgs> = {}>(args?: Subset<T, Product$clientContractArgs<ExtArgs>>): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    object<T extends ObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectDefaultArgs<ExtArgs>>): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly pricingProductsId: FieldRef<"Product", 'Int'>
    readonly number: FieldRef<"Product", 'String'>
    readonly productCategory: FieldRef<"Product", 'ProductCategory'>
    readonly objectId: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.transferAct
   */
  export type Product$transferActArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferAct
     */
    select?: TransferActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActInclude<ExtArgs> | null
    where?: TransferActWhereInput
  }

  /**
   * Product.clientContract
   */
  export type Product$clientContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    where?: ClientContractWhereInput
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Agency
   */

  export type AggregateAgency = {
    _count: AgencyCountAggregateOutputType | null
    _avg: AgencyAvgAggregateOutputType | null
    _sum: AgencySumAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  export type AgencyAvgAggregateOutputType = {
    id: number | null
    commonDbContractorsId: number | null
  }

  export type AgencySumAggregateOutputType = {
    id: number | null
    commonDbContractorsId: number | null
  }

  export type AgencyMinAggregateOutputType = {
    id: number | null
    commonDbContractorsId: number | null
    name: string | null
    inn: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyMaxAggregateOutputType = {
    id: number | null
    commonDbContractorsId: number | null
    name: string | null
    inn: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyCountAggregateOutputType = {
    id: number
    commonDbContractorsId: number
    name: number
    inn: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgencyAvgAggregateInputType = {
    id?: true
    commonDbContractorsId?: true
  }

  export type AgencySumAggregateInputType = {
    id?: true
    commonDbContractorsId?: true
  }

  export type AgencyMinAggregateInputType = {
    id?: true
    commonDbContractorsId?: true
    name?: true
    inn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyMaxAggregateInputType = {
    id?: true
    commonDbContractorsId?: true
    name?: true
    inn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyCountAggregateInputType = {
    id?: true
    commonDbContractorsId?: true
    name?: true
    inn?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agency to aggregate.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agencies
    **/
    _count?: true | AgencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyMaxAggregateInputType
  }

  export type GetAgencyAggregateType<T extends AgencyAggregateArgs> = {
        [P in keyof T & keyof AggregateAgency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgency[P]>
      : GetScalarType<T[P], AggregateAgency[P]>
  }




  export type AgencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyWhereInput
    orderBy?: AgencyOrderByWithAggregationInput | AgencyOrderByWithAggregationInput[]
    by: AgencyScalarFieldEnum[] | AgencyScalarFieldEnum
    having?: AgencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyCountAggregateInputType | true
    _avg?: AgencyAvgAggregateInputType
    _sum?: AgencySumAggregateInputType
    _min?: AgencyMinAggregateInputType
    _max?: AgencyMaxAggregateInputType
  }

  export type AgencyGroupByOutputType = {
    id: number
    commonDbContractorsId: number
    name: string
    inn: string | null
    createdAt: Date
    updatedAt: Date
    _count: AgencyCountAggregateOutputType | null
    _avg: AgencyAvgAggregateOutputType | null
    _sum: AgencySumAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  type GetAgencyGroupByPayload<T extends AgencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyGroupByOutputType[P]>
        }
      >
    >


  export type AgencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commonDbContractorsId?: boolean
    name?: boolean
    inn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agencyContracts?: boolean | Agency$agencyContractsArgs<ExtArgs>
    agencyContractSignatory?: boolean | Agency$agencyContractSignatoryArgs<ExtArgs>
    realEstateAgencyActs?: boolean | Agency$realEstateAgencyActsArgs<ExtArgs>
    agenciesToRealEstateAgents?: boolean | Agency$agenciesToRealEstateAgentsArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>


  export type AgencySelectScalar = {
    id?: boolean
    commonDbContractorsId?: boolean
    name?: boolean
    inn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agencyContracts?: boolean | Agency$agencyContractsArgs<ExtArgs>
    agencyContractSignatory?: boolean | Agency$agencyContractSignatoryArgs<ExtArgs>
    realEstateAgencyActs?: boolean | Agency$realEstateAgencyActsArgs<ExtArgs>
    agenciesToRealEstateAgents?: boolean | Agency$agenciesToRealEstateAgentsArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AgencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agency"
    objects: {
      agencyContracts: Prisma.$AgencyContractPayload<ExtArgs>[]
      agencyContractSignatory: Prisma.$AgencyContractSignatoryPayload<ExtArgs>[]
      realEstateAgencyActs: Prisma.$RealEstateAgencyActPayload<ExtArgs>[]
      agenciesToRealEstateAgents: Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      commonDbContractorsId: number
      name: string
      inn: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agency"]>
    composites: {}
  }

  type AgencyGetPayload<S extends boolean | null | undefined | AgencyDefaultArgs> = $Result.GetResult<Prisma.$AgencyPayload, S>

  type AgencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgencyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgencyCountAggregateInputType | true
    }

  export interface AgencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agency'], meta: { name: 'Agency' } }
    /**
     * Find zero or one Agency that matches the filter.
     * @param {AgencyFindUniqueArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgencyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyFindUniqueArgs<ExtArgs>>
    ): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Agency that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgencyFindUniqueOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgencyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Agency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgencyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyFindFirstArgs<ExtArgs>>
    ): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Agency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgencyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Agencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agencies
     * const agencies = await prisma.agency.findMany()
     * 
     * // Get first 10 Agencies
     * const agencies = await prisma.agency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyWithIdOnly = await prisma.agency.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgencyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Agency.
     * @param {AgencyCreateArgs} args - Arguments to create a Agency.
     * @example
     * // Create one Agency
     * const Agency = await prisma.agency.create({
     *   data: {
     *     // ... data to create a Agency
     *   }
     * })
     * 
    **/
    create<T extends AgencyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyCreateArgs<ExtArgs>>
    ): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Agencies.
     * @param {AgencyCreateManyArgs} args - Arguments to create many Agencies.
     * @example
     * // Create many Agencies
     * const agency = await prisma.agency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AgencyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Agency.
     * @param {AgencyDeleteArgs} args - Arguments to delete one Agency.
     * @example
     * // Delete one Agency
     * const Agency = await prisma.agency.delete({
     *   where: {
     *     // ... filter to delete one Agency
     *   }
     * })
     * 
    **/
    delete<T extends AgencyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyDeleteArgs<ExtArgs>>
    ): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Agency.
     * @param {AgencyUpdateArgs} args - Arguments to update one Agency.
     * @example
     * // Update one Agency
     * const agency = await prisma.agency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgencyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyUpdateArgs<ExtArgs>>
    ): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Agencies.
     * @param {AgencyDeleteManyArgs} args - Arguments to filter Agencies to delete.
     * @example
     * // Delete a few Agencies
     * const { count } = await prisma.agency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgencyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agencies
     * const agency = await prisma.agency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgencyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agency.
     * @param {AgencyUpsertArgs} args - Arguments to update or create a Agency.
     * @example
     * // Update or create a Agency
     * const agency = await prisma.agency.upsert({
     *   create: {
     *     // ... data to create a Agency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agency we want to update
     *   }
     * })
    **/
    upsert<T extends AgencyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyUpsertArgs<ExtArgs>>
    ): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyCountArgs} args - Arguments to filter Agencies to count.
     * @example
     * // Count the number of Agencies
     * const count = await prisma.agency.count({
     *   where: {
     *     // ... the filter for the Agencies we want to count
     *   }
     * })
    **/
    count<T extends AgencyCountArgs>(
      args?: Subset<T, AgencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyAggregateArgs>(args: Subset<T, AgencyAggregateArgs>): Prisma.PrismaPromise<GetAgencyAggregateType<T>>

    /**
     * Group by Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyGroupByArgs['orderBy'] }
        : { orderBy?: AgencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agency model
   */
  readonly fields: AgencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    agencyContracts<T extends Agency$agencyContractsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$agencyContractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    agencyContractSignatory<T extends Agency$agencyContractSignatoryArgs<ExtArgs> = {}>(args?: Subset<T, Agency$agencyContractSignatoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    realEstateAgencyActs<T extends Agency$realEstateAgencyActsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$realEstateAgencyActsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RealEstateAgencyActPayload<ExtArgs>, T, 'findMany'> | Null>;

    agenciesToRealEstateAgents<T extends Agency$agenciesToRealEstateAgentsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$agenciesToRealEstateAgentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Agency model
   */ 
  interface AgencyFieldRefs {
    readonly id: FieldRef<"Agency", 'Int'>
    readonly commonDbContractorsId: FieldRef<"Agency", 'Int'>
    readonly name: FieldRef<"Agency", 'String'>
    readonly inn: FieldRef<"Agency", 'String'>
    readonly createdAt: FieldRef<"Agency", 'DateTime'>
    readonly updatedAt: FieldRef<"Agency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agency findUnique
   */
  export type AgencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency findUniqueOrThrow
   */
  export type AgencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency findFirst
   */
  export type AgencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency findFirstOrThrow
   */
  export type AgencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency findMany
   */
  export type AgencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agencies to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency create
   */
  export type AgencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Agency.
     */
    data: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
  }

  /**
   * Agency createMany
   */
  export type AgencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agencies.
     */
    data: AgencyCreateManyInput | AgencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agency update
   */
  export type AgencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Agency.
     */
    data: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
    /**
     * Choose, which Agency to update.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency updateMany
   */
  export type AgencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agencies.
     */
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyInput>
    /**
     * Filter which Agencies to update
     */
    where?: AgencyWhereInput
  }

  /**
   * Agency upsert
   */
  export type AgencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Agency to update in case it exists.
     */
    where: AgencyWhereUniqueInput
    /**
     * In case the Agency found by the `where` argument doesn't exist, create a new Agency with this data.
     */
    create: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
    /**
     * In case the Agency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
  }

  /**
   * Agency delete
   */
  export type AgencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter which Agency to delete.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency deleteMany
   */
  export type AgencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agencies to delete
     */
    where?: AgencyWhereInput
  }

  /**
   * Agency.agencyContracts
   */
  export type Agency$agencyContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    where?: AgencyContractWhereInput
    orderBy?: AgencyContractOrderByWithRelationInput | AgencyContractOrderByWithRelationInput[]
    cursor?: AgencyContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyContractScalarFieldEnum | AgencyContractScalarFieldEnum[]
  }

  /**
   * Agency.agencyContractSignatory
   */
  export type Agency$agencyContractSignatoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    where?: AgencyContractSignatoryWhereInput
    orderBy?: AgencyContractSignatoryOrderByWithRelationInput | AgencyContractSignatoryOrderByWithRelationInput[]
    cursor?: AgencyContractSignatoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyContractSignatoryScalarFieldEnum | AgencyContractSignatoryScalarFieldEnum[]
  }

  /**
   * Agency.realEstateAgencyActs
   */
  export type Agency$realEstateAgencyActsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyAct
     */
    select?: RealEstateAgencyActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyActInclude<ExtArgs> | null
    where?: RealEstateAgencyActWhereInput
    orderBy?: RealEstateAgencyActOrderByWithRelationInput | RealEstateAgencyActOrderByWithRelationInput[]
    cursor?: RealEstateAgencyActWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RealEstateAgencyActScalarFieldEnum | RealEstateAgencyActScalarFieldEnum[]
  }

  /**
   * Agency.agenciesToRealEstateAgents
   */
  export type Agency$agenciesToRealEstateAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    where?: AgencyToRealEstateAgentWhereInput
    orderBy?: AgencyToRealEstateAgentOrderByWithRelationInput | AgencyToRealEstateAgentOrderByWithRelationInput[]
    cursor?: AgencyToRealEstateAgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyToRealEstateAgentScalarFieldEnum | AgencyToRealEstateAgentScalarFieldEnum[]
  }

  /**
   * Agency without action
   */
  export type AgencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
  }


  /**
   * Model AgencyContract
   */

  export type AggregateAgencyContract = {
    _count: AgencyContractCountAggregateOutputType | null
    _avg: AgencyContractAvgAggregateOutputType | null
    _sum: AgencyContractSumAggregateOutputType | null
    _min: AgencyContractMinAggregateOutputType | null
    _max: AgencyContractMaxAggregateOutputType | null
  }

  export type AgencyContractAvgAggregateOutputType = {
    id: number | null
    responsibleUserId: number | null
    entityId: number | null
    objectId: number | null
    agencyId: number | null
    agencyContractSignatoryId: number | null
    realEstateAgencyContractPropertiesId: number | null
    mipAgencyContractPropertiesId: number | null
  }

  export type AgencyContractSumAggregateOutputType = {
    id: number | null
    responsibleUserId: number | null
    entityId: number | null
    objectId: number | null
    agencyId: number | null
    agencyContractSignatoryId: number | null
    realEstateAgencyContractPropertiesId: number | null
    mipAgencyContractPropertiesId: number | null
  }

  export type AgencyContractMinAggregateOutputType = {
    id: number | null
    number: string | null
    date: Date | null
    agencyContractType: $Enums.AgencyContractType | null
    link: string | null
    responsibleUserId: number | null
    entityId: number | null
    objectId: number | null
    agencyId: number | null
    agencyContractSignatoryId: number | null
    realEstateAgencyContractPropertiesId: number | null
    mipAgencyContractPropertiesId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyContractMaxAggregateOutputType = {
    id: number | null
    number: string | null
    date: Date | null
    agencyContractType: $Enums.AgencyContractType | null
    link: string | null
    responsibleUserId: number | null
    entityId: number | null
    objectId: number | null
    agencyId: number | null
    agencyContractSignatoryId: number | null
    realEstateAgencyContractPropertiesId: number | null
    mipAgencyContractPropertiesId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyContractCountAggregateOutputType = {
    id: number
    number: number
    date: number
    agencyContractType: number
    link: number
    responsibleUserId: number
    entityId: number
    objectId: number
    agencyId: number
    agencyContractSignatoryId: number
    realEstateAgencyContractPropertiesId: number
    mipAgencyContractPropertiesId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgencyContractAvgAggregateInputType = {
    id?: true
    responsibleUserId?: true
    entityId?: true
    objectId?: true
    agencyId?: true
    agencyContractSignatoryId?: true
    realEstateAgencyContractPropertiesId?: true
    mipAgencyContractPropertiesId?: true
  }

  export type AgencyContractSumAggregateInputType = {
    id?: true
    responsibleUserId?: true
    entityId?: true
    objectId?: true
    agencyId?: true
    agencyContractSignatoryId?: true
    realEstateAgencyContractPropertiesId?: true
    mipAgencyContractPropertiesId?: true
  }

  export type AgencyContractMinAggregateInputType = {
    id?: true
    number?: true
    date?: true
    agencyContractType?: true
    link?: true
    responsibleUserId?: true
    entityId?: true
    objectId?: true
    agencyId?: true
    agencyContractSignatoryId?: true
    realEstateAgencyContractPropertiesId?: true
    mipAgencyContractPropertiesId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyContractMaxAggregateInputType = {
    id?: true
    number?: true
    date?: true
    agencyContractType?: true
    link?: true
    responsibleUserId?: true
    entityId?: true
    objectId?: true
    agencyId?: true
    agencyContractSignatoryId?: true
    realEstateAgencyContractPropertiesId?: true
    mipAgencyContractPropertiesId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyContractCountAggregateInputType = {
    id?: true
    number?: true
    date?: true
    agencyContractType?: true
    link?: true
    responsibleUserId?: true
    entityId?: true
    objectId?: true
    agencyId?: true
    agencyContractSignatoryId?: true
    realEstateAgencyContractPropertiesId?: true
    mipAgencyContractPropertiesId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencyContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyContract to aggregate.
     */
    where?: AgencyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContracts to fetch.
     */
    orderBy?: AgencyContractOrderByWithRelationInput | AgencyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyContracts
    **/
    _count?: true | AgencyContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencyContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyContractMaxAggregateInputType
  }

  export type GetAgencyContractAggregateType<T extends AgencyContractAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyContract[P]>
      : GetScalarType<T[P], AggregateAgencyContract[P]>
  }




  export type AgencyContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyContractWhereInput
    orderBy?: AgencyContractOrderByWithAggregationInput | AgencyContractOrderByWithAggregationInput[]
    by: AgencyContractScalarFieldEnum[] | AgencyContractScalarFieldEnum
    having?: AgencyContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyContractCountAggregateInputType | true
    _avg?: AgencyContractAvgAggregateInputType
    _sum?: AgencyContractSumAggregateInputType
    _min?: AgencyContractMinAggregateInputType
    _max?: AgencyContractMaxAggregateInputType
  }

  export type AgencyContractGroupByOutputType = {
    id: number
    number: string
    date: Date
    agencyContractType: $Enums.AgencyContractType
    link: string | null
    responsibleUserId: number | null
    entityId: number
    objectId: number
    agencyId: number
    agencyContractSignatoryId: number | null
    realEstateAgencyContractPropertiesId: number | null
    mipAgencyContractPropertiesId: number | null
    createdAt: Date
    updatedAt: Date
    _count: AgencyContractCountAggregateOutputType | null
    _avg: AgencyContractAvgAggregateOutputType | null
    _sum: AgencyContractSumAggregateOutputType | null
    _min: AgencyContractMinAggregateOutputType | null
    _max: AgencyContractMaxAggregateOutputType | null
  }

  type GetAgencyContractGroupByPayload<T extends AgencyContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyContractGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyContractGroupByOutputType[P]>
        }
      >
    >


  export type AgencyContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    agencyContractType?: boolean
    link?: boolean
    responsibleUserId?: boolean
    entityId?: boolean
    objectId?: boolean
    agencyId?: boolean
    agencyContractSignatoryId?: boolean
    realEstateAgencyContractPropertiesId?: boolean
    mipAgencyContractPropertiesId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    responsibleUser?: boolean | AgencyContract$responsibleUserArgs<ExtArgs>
    entity?: boolean | EntityDefaultArgs<ExtArgs>
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    agencyContractSignatory?: boolean | AgencyContract$agencyContractSignatoryArgs<ExtArgs>
    realEstateAgencyContractProperties?: boolean | AgencyContract$realEstateAgencyContractPropertiesArgs<ExtArgs>
    mipAgencyContractProperties?: boolean | AgencyContract$mipAgencyContractPropertiesArgs<ExtArgs>
    realEstateAgencyAct?: boolean | AgencyContract$realEstateAgencyActArgs<ExtArgs>
    clientContractsToAgencyContracts?: boolean | AgencyContract$clientContractsToAgencyContractsArgs<ExtArgs>
    _count?: boolean | AgencyContractCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyContract"]>


  export type AgencyContractSelectScalar = {
    id?: boolean
    number?: boolean
    date?: boolean
    agencyContractType?: boolean
    link?: boolean
    responsibleUserId?: boolean
    entityId?: boolean
    objectId?: boolean
    agencyId?: boolean
    agencyContractSignatoryId?: boolean
    realEstateAgencyContractPropertiesId?: boolean
    mipAgencyContractPropertiesId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgencyContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsibleUser?: boolean | AgencyContract$responsibleUserArgs<ExtArgs>
    entity?: boolean | EntityDefaultArgs<ExtArgs>
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    agencyContractSignatory?: boolean | AgencyContract$agencyContractSignatoryArgs<ExtArgs>
    realEstateAgencyContractProperties?: boolean | AgencyContract$realEstateAgencyContractPropertiesArgs<ExtArgs>
    mipAgencyContractProperties?: boolean | AgencyContract$mipAgencyContractPropertiesArgs<ExtArgs>
    realEstateAgencyAct?: boolean | AgencyContract$realEstateAgencyActArgs<ExtArgs>
    clientContractsToAgencyContracts?: boolean | AgencyContract$clientContractsToAgencyContractsArgs<ExtArgs>
    _count?: boolean | AgencyContractCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AgencyContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyContract"
    objects: {
      responsibleUser: Prisma.$UserPayload<ExtArgs> | null
      entity: Prisma.$EntityPayload<ExtArgs>
      object: Prisma.$ObjectPayload<ExtArgs>
      agency: Prisma.$AgencyPayload<ExtArgs>
      agencyContractSignatory: Prisma.$AgencyContractSignatoryPayload<ExtArgs> | null
      realEstateAgencyContractProperties: Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs> | null
      mipAgencyContractProperties: Prisma.$MipAgencyContractPropertiesPayload<ExtArgs> | null
      realEstateAgencyAct: Prisma.$RealEstateAgencyActPayload<ExtArgs>[]
      clientContractsToAgencyContracts: Prisma.$ClientContractToAgencyContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      number: string
      date: Date
      agencyContractType: $Enums.AgencyContractType
      link: string | null
      responsibleUserId: number | null
      entityId: number
      objectId: number
      agencyId: number
      agencyContractSignatoryId: number | null
      realEstateAgencyContractPropertiesId: number | null
      mipAgencyContractPropertiesId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agencyContract"]>
    composites: {}
  }

  type AgencyContractGetPayload<S extends boolean | null | undefined | AgencyContractDefaultArgs> = $Result.GetResult<Prisma.$AgencyContractPayload, S>

  type AgencyContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgencyContractFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgencyContractCountAggregateInputType | true
    }

  export interface AgencyContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyContract'], meta: { name: 'AgencyContract' } }
    /**
     * Find zero or one AgencyContract that matches the filter.
     * @param {AgencyContractFindUniqueArgs} args - Arguments to find a AgencyContract
     * @example
     * // Get one AgencyContract
     * const agencyContract = await prisma.agencyContract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgencyContractFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractFindUniqueArgs<ExtArgs>>
    ): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AgencyContract that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgencyContractFindUniqueOrThrowArgs} args - Arguments to find a AgencyContract
     * @example
     * // Get one AgencyContract
     * const agencyContract = await prisma.agencyContract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgencyContractFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AgencyContract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractFindFirstArgs} args - Arguments to find a AgencyContract
     * @example
     * // Get one AgencyContract
     * const agencyContract = await prisma.agencyContract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgencyContractFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractFindFirstArgs<ExtArgs>>
    ): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AgencyContract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractFindFirstOrThrowArgs} args - Arguments to find a AgencyContract
     * @example
     * // Get one AgencyContract
     * const agencyContract = await prisma.agencyContract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgencyContractFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AgencyContracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyContracts
     * const agencyContracts = await prisma.agencyContract.findMany()
     * 
     * // Get first 10 AgencyContracts
     * const agencyContracts = await prisma.agencyContract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyContractWithIdOnly = await prisma.agencyContract.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgencyContractFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AgencyContract.
     * @param {AgencyContractCreateArgs} args - Arguments to create a AgencyContract.
     * @example
     * // Create one AgencyContract
     * const AgencyContract = await prisma.agencyContract.create({
     *   data: {
     *     // ... data to create a AgencyContract
     *   }
     * })
     * 
    **/
    create<T extends AgencyContractCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractCreateArgs<ExtArgs>>
    ): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AgencyContracts.
     * @param {AgencyContractCreateManyArgs} args - Arguments to create many AgencyContracts.
     * @example
     * // Create many AgencyContracts
     * const agencyContract = await prisma.agencyContract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AgencyContractCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgencyContract.
     * @param {AgencyContractDeleteArgs} args - Arguments to delete one AgencyContract.
     * @example
     * // Delete one AgencyContract
     * const AgencyContract = await prisma.agencyContract.delete({
     *   where: {
     *     // ... filter to delete one AgencyContract
     *   }
     * })
     * 
    **/
    delete<T extends AgencyContractDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractDeleteArgs<ExtArgs>>
    ): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AgencyContract.
     * @param {AgencyContractUpdateArgs} args - Arguments to update one AgencyContract.
     * @example
     * // Update one AgencyContract
     * const agencyContract = await prisma.agencyContract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgencyContractUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractUpdateArgs<ExtArgs>>
    ): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AgencyContracts.
     * @param {AgencyContractDeleteManyArgs} args - Arguments to filter AgencyContracts to delete.
     * @example
     * // Delete a few AgencyContracts
     * const { count } = await prisma.agencyContract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgencyContractDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyContracts
     * const agencyContract = await prisma.agencyContract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgencyContractUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgencyContract.
     * @param {AgencyContractUpsertArgs} args - Arguments to update or create a AgencyContract.
     * @example
     * // Update or create a AgencyContract
     * const agencyContract = await prisma.agencyContract.upsert({
     *   create: {
     *     // ... data to create a AgencyContract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyContract we want to update
     *   }
     * })
    **/
    upsert<T extends AgencyContractUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractUpsertArgs<ExtArgs>>
    ): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AgencyContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractCountArgs} args - Arguments to filter AgencyContracts to count.
     * @example
     * // Count the number of AgencyContracts
     * const count = await prisma.agencyContract.count({
     *   where: {
     *     // ... the filter for the AgencyContracts we want to count
     *   }
     * })
    **/
    count<T extends AgencyContractCountArgs>(
      args?: Subset<T, AgencyContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyContractAggregateArgs>(args: Subset<T, AgencyContractAggregateArgs>): Prisma.PrismaPromise<GetAgencyContractAggregateType<T>>

    /**
     * Group by AgencyContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyContractGroupByArgs['orderBy'] }
        : { orderBy?: AgencyContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyContract model
   */
  readonly fields: AgencyContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyContract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    responsibleUser<T extends AgencyContract$responsibleUserArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContract$responsibleUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    entity<T extends EntityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntityDefaultArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    object<T extends ObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectDefaultArgs<ExtArgs>>): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    agencyContractSignatory<T extends AgencyContract$agencyContractSignatoryArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContract$agencyContractSignatoryArgs<ExtArgs>>): Prisma__AgencyContractSignatoryClient<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    realEstateAgencyContractProperties<T extends AgencyContract$realEstateAgencyContractPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContract$realEstateAgencyContractPropertiesArgs<ExtArgs>>): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    mipAgencyContractProperties<T extends AgencyContract$mipAgencyContractPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContract$mipAgencyContractPropertiesArgs<ExtArgs>>): Prisma__MipAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MipAgencyContractPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    realEstateAgencyAct<T extends AgencyContract$realEstateAgencyActArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContract$realEstateAgencyActArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RealEstateAgencyActPayload<ExtArgs>, T, 'findMany'> | Null>;

    clientContractsToAgencyContracts<T extends AgencyContract$clientContractsToAgencyContractsArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContract$clientContractsToAgencyContractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractToAgencyContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AgencyContract model
   */ 
  interface AgencyContractFieldRefs {
    readonly id: FieldRef<"AgencyContract", 'Int'>
    readonly number: FieldRef<"AgencyContract", 'String'>
    readonly date: FieldRef<"AgencyContract", 'DateTime'>
    readonly agencyContractType: FieldRef<"AgencyContract", 'AgencyContractType'>
    readonly link: FieldRef<"AgencyContract", 'String'>
    readonly responsibleUserId: FieldRef<"AgencyContract", 'Int'>
    readonly entityId: FieldRef<"AgencyContract", 'Int'>
    readonly objectId: FieldRef<"AgencyContract", 'Int'>
    readonly agencyId: FieldRef<"AgencyContract", 'Int'>
    readonly agencyContractSignatoryId: FieldRef<"AgencyContract", 'Int'>
    readonly realEstateAgencyContractPropertiesId: FieldRef<"AgencyContract", 'Int'>
    readonly mipAgencyContractPropertiesId: FieldRef<"AgencyContract", 'Int'>
    readonly createdAt: FieldRef<"AgencyContract", 'DateTime'>
    readonly updatedAt: FieldRef<"AgencyContract", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgencyContract findUnique
   */
  export type AgencyContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContract to fetch.
     */
    where: AgencyContractWhereUniqueInput
  }

  /**
   * AgencyContract findUniqueOrThrow
   */
  export type AgencyContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContract to fetch.
     */
    where: AgencyContractWhereUniqueInput
  }

  /**
   * AgencyContract findFirst
   */
  export type AgencyContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContract to fetch.
     */
    where?: AgencyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContracts to fetch.
     */
    orderBy?: AgencyContractOrderByWithRelationInput | AgencyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyContracts.
     */
    cursor?: AgencyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyContracts.
     */
    distinct?: AgencyContractScalarFieldEnum | AgencyContractScalarFieldEnum[]
  }

  /**
   * AgencyContract findFirstOrThrow
   */
  export type AgencyContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContract to fetch.
     */
    where?: AgencyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContracts to fetch.
     */
    orderBy?: AgencyContractOrderByWithRelationInput | AgencyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyContracts.
     */
    cursor?: AgencyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyContracts.
     */
    distinct?: AgencyContractScalarFieldEnum | AgencyContractScalarFieldEnum[]
  }

  /**
   * AgencyContract findMany
   */
  export type AgencyContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContracts to fetch.
     */
    where?: AgencyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContracts to fetch.
     */
    orderBy?: AgencyContractOrderByWithRelationInput | AgencyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyContracts.
     */
    cursor?: AgencyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContracts.
     */
    skip?: number
    distinct?: AgencyContractScalarFieldEnum | AgencyContractScalarFieldEnum[]
  }

  /**
   * AgencyContract create
   */
  export type AgencyContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyContract.
     */
    data: XOR<AgencyContractCreateInput, AgencyContractUncheckedCreateInput>
  }

  /**
   * AgencyContract createMany
   */
  export type AgencyContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyContracts.
     */
    data: AgencyContractCreateManyInput | AgencyContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyContract update
   */
  export type AgencyContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyContract.
     */
    data: XOR<AgencyContractUpdateInput, AgencyContractUncheckedUpdateInput>
    /**
     * Choose, which AgencyContract to update.
     */
    where: AgencyContractWhereUniqueInput
  }

  /**
   * AgencyContract updateMany
   */
  export type AgencyContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyContracts.
     */
    data: XOR<AgencyContractUpdateManyMutationInput, AgencyContractUncheckedUpdateManyInput>
    /**
     * Filter which AgencyContracts to update
     */
    where?: AgencyContractWhereInput
  }

  /**
   * AgencyContract upsert
   */
  export type AgencyContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyContract to update in case it exists.
     */
    where: AgencyContractWhereUniqueInput
    /**
     * In case the AgencyContract found by the `where` argument doesn't exist, create a new AgencyContract with this data.
     */
    create: XOR<AgencyContractCreateInput, AgencyContractUncheckedCreateInput>
    /**
     * In case the AgencyContract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyContractUpdateInput, AgencyContractUncheckedUpdateInput>
  }

  /**
   * AgencyContract delete
   */
  export type AgencyContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    /**
     * Filter which AgencyContract to delete.
     */
    where: AgencyContractWhereUniqueInput
  }

  /**
   * AgencyContract deleteMany
   */
  export type AgencyContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyContracts to delete
     */
    where?: AgencyContractWhereInput
  }

  /**
   * AgencyContract.responsibleUser
   */
  export type AgencyContract$responsibleUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AgencyContract.agencyContractSignatory
   */
  export type AgencyContract$agencyContractSignatoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    where?: AgencyContractSignatoryWhereInput
  }

  /**
   * AgencyContract.realEstateAgencyContractProperties
   */
  export type AgencyContract$realEstateAgencyContractPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    where?: RealEstateAgencyContractPropertiesWhereInput
  }

  /**
   * AgencyContract.mipAgencyContractProperties
   */
  export type AgencyContract$mipAgencyContractPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MipAgencyContractProperties
     */
    select?: MipAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MipAgencyContractPropertiesInclude<ExtArgs> | null
    where?: MipAgencyContractPropertiesWhereInput
  }

  /**
   * AgencyContract.realEstateAgencyAct
   */
  export type AgencyContract$realEstateAgencyActArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyAct
     */
    select?: RealEstateAgencyActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyActInclude<ExtArgs> | null
    where?: RealEstateAgencyActWhereInput
    orderBy?: RealEstateAgencyActOrderByWithRelationInput | RealEstateAgencyActOrderByWithRelationInput[]
    cursor?: RealEstateAgencyActWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RealEstateAgencyActScalarFieldEnum | RealEstateAgencyActScalarFieldEnum[]
  }

  /**
   * AgencyContract.clientContractsToAgencyContracts
   */
  export type AgencyContract$clientContractsToAgencyContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContractToAgencyContract
     */
    select?: ClientContractToAgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractToAgencyContractInclude<ExtArgs> | null
    where?: ClientContractToAgencyContractWhereInput
    orderBy?: ClientContractToAgencyContractOrderByWithRelationInput | ClientContractToAgencyContractOrderByWithRelationInput[]
    cursor?: ClientContractToAgencyContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientContractToAgencyContractScalarFieldEnum | ClientContractToAgencyContractScalarFieldEnum[]
  }

  /**
   * AgencyContract without action
   */
  export type AgencyContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
  }


  /**
   * Model AgencyContractSignatory
   */

  export type AggregateAgencyContractSignatory = {
    _count: AgencyContractSignatoryCountAggregateOutputType | null
    _avg: AgencyContractSignatoryAvgAggregateOutputType | null
    _sum: AgencyContractSignatorySumAggregateOutputType | null
    _min: AgencyContractSignatoryMinAggregateOutputType | null
    _max: AgencyContractSignatoryMaxAggregateOutputType | null
  }

  export type AgencyContractSignatoryAvgAggregateOutputType = {
    id: number | null
    agencyId: number | null
  }

  export type AgencyContractSignatorySumAggregateOutputType = {
    id: number | null
    agencyId: number | null
  }

  export type AgencyContractSignatoryMinAggregateOutputType = {
    id: number | null
    fullName: string | null
    basedOn: string | null
    title: string | null
    agencyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyContractSignatoryMaxAggregateOutputType = {
    id: number | null
    fullName: string | null
    basedOn: string | null
    title: string | null
    agencyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyContractSignatoryCountAggregateOutputType = {
    id: number
    fullName: number
    basedOn: number
    title: number
    agencyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgencyContractSignatoryAvgAggregateInputType = {
    id?: true
    agencyId?: true
  }

  export type AgencyContractSignatorySumAggregateInputType = {
    id?: true
    agencyId?: true
  }

  export type AgencyContractSignatoryMinAggregateInputType = {
    id?: true
    fullName?: true
    basedOn?: true
    title?: true
    agencyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyContractSignatoryMaxAggregateInputType = {
    id?: true
    fullName?: true
    basedOn?: true
    title?: true
    agencyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyContractSignatoryCountAggregateInputType = {
    id?: true
    fullName?: true
    basedOn?: true
    title?: true
    agencyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencyContractSignatoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyContractSignatory to aggregate.
     */
    where?: AgencyContractSignatoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContractSignatories to fetch.
     */
    orderBy?: AgencyContractSignatoryOrderByWithRelationInput | AgencyContractSignatoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyContractSignatoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContractSignatories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContractSignatories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyContractSignatories
    **/
    _count?: true | AgencyContractSignatoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyContractSignatoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencyContractSignatorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyContractSignatoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyContractSignatoryMaxAggregateInputType
  }

  export type GetAgencyContractSignatoryAggregateType<T extends AgencyContractSignatoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyContractSignatory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyContractSignatory[P]>
      : GetScalarType<T[P], AggregateAgencyContractSignatory[P]>
  }




  export type AgencyContractSignatoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyContractSignatoryWhereInput
    orderBy?: AgencyContractSignatoryOrderByWithAggregationInput | AgencyContractSignatoryOrderByWithAggregationInput[]
    by: AgencyContractSignatoryScalarFieldEnum[] | AgencyContractSignatoryScalarFieldEnum
    having?: AgencyContractSignatoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyContractSignatoryCountAggregateInputType | true
    _avg?: AgencyContractSignatoryAvgAggregateInputType
    _sum?: AgencyContractSignatorySumAggregateInputType
    _min?: AgencyContractSignatoryMinAggregateInputType
    _max?: AgencyContractSignatoryMaxAggregateInputType
  }

  export type AgencyContractSignatoryGroupByOutputType = {
    id: number
    fullName: string
    basedOn: string | null
    title: string | null
    agencyId: number
    createdAt: Date
    updatedAt: Date
    _count: AgencyContractSignatoryCountAggregateOutputType | null
    _avg: AgencyContractSignatoryAvgAggregateOutputType | null
    _sum: AgencyContractSignatorySumAggregateOutputType | null
    _min: AgencyContractSignatoryMinAggregateOutputType | null
    _max: AgencyContractSignatoryMaxAggregateOutputType | null
  }

  type GetAgencyContractSignatoryGroupByPayload<T extends AgencyContractSignatoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyContractSignatoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyContractSignatoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyContractSignatoryGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyContractSignatoryGroupByOutputType[P]>
        }
      >
    >


  export type AgencyContractSignatorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    basedOn?: boolean
    title?: boolean
    agencyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    agencyContracts?: boolean | AgencyContractSignatory$agencyContractsArgs<ExtArgs>
    _count?: boolean | AgencyContractSignatoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyContractSignatory"]>


  export type AgencyContractSignatorySelectScalar = {
    id?: boolean
    fullName?: boolean
    basedOn?: boolean
    title?: boolean
    agencyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgencyContractSignatoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    agencyContracts?: boolean | AgencyContractSignatory$agencyContractsArgs<ExtArgs>
    _count?: boolean | AgencyContractSignatoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AgencyContractSignatoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyContractSignatory"
    objects: {
      agency: Prisma.$AgencyPayload<ExtArgs>
      agencyContracts: Prisma.$AgencyContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullName: string
      basedOn: string | null
      title: string | null
      agencyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agencyContractSignatory"]>
    composites: {}
  }

  type AgencyContractSignatoryGetPayload<S extends boolean | null | undefined | AgencyContractSignatoryDefaultArgs> = $Result.GetResult<Prisma.$AgencyContractSignatoryPayload, S>

  type AgencyContractSignatoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgencyContractSignatoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgencyContractSignatoryCountAggregateInputType | true
    }

  export interface AgencyContractSignatoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyContractSignatory'], meta: { name: 'AgencyContractSignatory' } }
    /**
     * Find zero or one AgencyContractSignatory that matches the filter.
     * @param {AgencyContractSignatoryFindUniqueArgs} args - Arguments to find a AgencyContractSignatory
     * @example
     * // Get one AgencyContractSignatory
     * const agencyContractSignatory = await prisma.agencyContractSignatory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgencyContractSignatoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractSignatoryFindUniqueArgs<ExtArgs>>
    ): Prisma__AgencyContractSignatoryClient<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AgencyContractSignatory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgencyContractSignatoryFindUniqueOrThrowArgs} args - Arguments to find a AgencyContractSignatory
     * @example
     * // Get one AgencyContractSignatory
     * const agencyContractSignatory = await prisma.agencyContractSignatory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgencyContractSignatoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractSignatoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyContractSignatoryClient<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AgencyContractSignatory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractSignatoryFindFirstArgs} args - Arguments to find a AgencyContractSignatory
     * @example
     * // Get one AgencyContractSignatory
     * const agencyContractSignatory = await prisma.agencyContractSignatory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgencyContractSignatoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractSignatoryFindFirstArgs<ExtArgs>>
    ): Prisma__AgencyContractSignatoryClient<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AgencyContractSignatory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractSignatoryFindFirstOrThrowArgs} args - Arguments to find a AgencyContractSignatory
     * @example
     * // Get one AgencyContractSignatory
     * const agencyContractSignatory = await prisma.agencyContractSignatory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgencyContractSignatoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractSignatoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyContractSignatoryClient<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AgencyContractSignatories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractSignatoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyContractSignatories
     * const agencyContractSignatories = await prisma.agencyContractSignatory.findMany()
     * 
     * // Get first 10 AgencyContractSignatories
     * const agencyContractSignatories = await prisma.agencyContractSignatory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyContractSignatoryWithIdOnly = await prisma.agencyContractSignatory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgencyContractSignatoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractSignatoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AgencyContractSignatory.
     * @param {AgencyContractSignatoryCreateArgs} args - Arguments to create a AgencyContractSignatory.
     * @example
     * // Create one AgencyContractSignatory
     * const AgencyContractSignatory = await prisma.agencyContractSignatory.create({
     *   data: {
     *     // ... data to create a AgencyContractSignatory
     *   }
     * })
     * 
    **/
    create<T extends AgencyContractSignatoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractSignatoryCreateArgs<ExtArgs>>
    ): Prisma__AgencyContractSignatoryClient<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AgencyContractSignatories.
     * @param {AgencyContractSignatoryCreateManyArgs} args - Arguments to create many AgencyContractSignatories.
     * @example
     * // Create many AgencyContractSignatories
     * const agencyContractSignatory = await prisma.agencyContractSignatory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AgencyContractSignatoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractSignatoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgencyContractSignatory.
     * @param {AgencyContractSignatoryDeleteArgs} args - Arguments to delete one AgencyContractSignatory.
     * @example
     * // Delete one AgencyContractSignatory
     * const AgencyContractSignatory = await prisma.agencyContractSignatory.delete({
     *   where: {
     *     // ... filter to delete one AgencyContractSignatory
     *   }
     * })
     * 
    **/
    delete<T extends AgencyContractSignatoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractSignatoryDeleteArgs<ExtArgs>>
    ): Prisma__AgencyContractSignatoryClient<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AgencyContractSignatory.
     * @param {AgencyContractSignatoryUpdateArgs} args - Arguments to update one AgencyContractSignatory.
     * @example
     * // Update one AgencyContractSignatory
     * const agencyContractSignatory = await prisma.agencyContractSignatory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgencyContractSignatoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractSignatoryUpdateArgs<ExtArgs>>
    ): Prisma__AgencyContractSignatoryClient<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AgencyContractSignatories.
     * @param {AgencyContractSignatoryDeleteManyArgs} args - Arguments to filter AgencyContractSignatories to delete.
     * @example
     * // Delete a few AgencyContractSignatories
     * const { count } = await prisma.agencyContractSignatory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgencyContractSignatoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractSignatoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyContractSignatories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractSignatoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyContractSignatories
     * const agencyContractSignatory = await prisma.agencyContractSignatory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgencyContractSignatoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractSignatoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgencyContractSignatory.
     * @param {AgencyContractSignatoryUpsertArgs} args - Arguments to update or create a AgencyContractSignatory.
     * @example
     * // Update or create a AgencyContractSignatory
     * const agencyContractSignatory = await prisma.agencyContractSignatory.upsert({
     *   create: {
     *     // ... data to create a AgencyContractSignatory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyContractSignatory we want to update
     *   }
     * })
    **/
    upsert<T extends AgencyContractSignatoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractSignatoryUpsertArgs<ExtArgs>>
    ): Prisma__AgencyContractSignatoryClient<$Result.GetResult<Prisma.$AgencyContractSignatoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AgencyContractSignatories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractSignatoryCountArgs} args - Arguments to filter AgencyContractSignatories to count.
     * @example
     * // Count the number of AgencyContractSignatories
     * const count = await prisma.agencyContractSignatory.count({
     *   where: {
     *     // ... the filter for the AgencyContractSignatories we want to count
     *   }
     * })
    **/
    count<T extends AgencyContractSignatoryCountArgs>(
      args?: Subset<T, AgencyContractSignatoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyContractSignatoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyContractSignatory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractSignatoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyContractSignatoryAggregateArgs>(args: Subset<T, AgencyContractSignatoryAggregateArgs>): Prisma.PrismaPromise<GetAgencyContractSignatoryAggregateType<T>>

    /**
     * Group by AgencyContractSignatory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractSignatoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyContractSignatoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyContractSignatoryGroupByArgs['orderBy'] }
        : { orderBy?: AgencyContractSignatoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyContractSignatoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyContractSignatoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyContractSignatory model
   */
  readonly fields: AgencyContractSignatoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyContractSignatory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyContractSignatoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    agencyContracts<T extends AgencyContractSignatory$agencyContractsArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContractSignatory$agencyContractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AgencyContractSignatory model
   */ 
  interface AgencyContractSignatoryFieldRefs {
    readonly id: FieldRef<"AgencyContractSignatory", 'Int'>
    readonly fullName: FieldRef<"AgencyContractSignatory", 'String'>
    readonly basedOn: FieldRef<"AgencyContractSignatory", 'String'>
    readonly title: FieldRef<"AgencyContractSignatory", 'String'>
    readonly agencyId: FieldRef<"AgencyContractSignatory", 'Int'>
    readonly createdAt: FieldRef<"AgencyContractSignatory", 'DateTime'>
    readonly updatedAt: FieldRef<"AgencyContractSignatory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgencyContractSignatory findUnique
   */
  export type AgencyContractSignatoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractSignatory to fetch.
     */
    where: AgencyContractSignatoryWhereUniqueInput
  }

  /**
   * AgencyContractSignatory findUniqueOrThrow
   */
  export type AgencyContractSignatoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractSignatory to fetch.
     */
    where: AgencyContractSignatoryWhereUniqueInput
  }

  /**
   * AgencyContractSignatory findFirst
   */
  export type AgencyContractSignatoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractSignatory to fetch.
     */
    where?: AgencyContractSignatoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContractSignatories to fetch.
     */
    orderBy?: AgencyContractSignatoryOrderByWithRelationInput | AgencyContractSignatoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyContractSignatories.
     */
    cursor?: AgencyContractSignatoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContractSignatories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContractSignatories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyContractSignatories.
     */
    distinct?: AgencyContractSignatoryScalarFieldEnum | AgencyContractSignatoryScalarFieldEnum[]
  }

  /**
   * AgencyContractSignatory findFirstOrThrow
   */
  export type AgencyContractSignatoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractSignatory to fetch.
     */
    where?: AgencyContractSignatoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContractSignatories to fetch.
     */
    orderBy?: AgencyContractSignatoryOrderByWithRelationInput | AgencyContractSignatoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyContractSignatories.
     */
    cursor?: AgencyContractSignatoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContractSignatories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContractSignatories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyContractSignatories.
     */
    distinct?: AgencyContractSignatoryScalarFieldEnum | AgencyContractSignatoryScalarFieldEnum[]
  }

  /**
   * AgencyContractSignatory findMany
   */
  export type AgencyContractSignatoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractSignatories to fetch.
     */
    where?: AgencyContractSignatoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContractSignatories to fetch.
     */
    orderBy?: AgencyContractSignatoryOrderByWithRelationInput | AgencyContractSignatoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyContractSignatories.
     */
    cursor?: AgencyContractSignatoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContractSignatories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContractSignatories.
     */
    skip?: number
    distinct?: AgencyContractSignatoryScalarFieldEnum | AgencyContractSignatoryScalarFieldEnum[]
  }

  /**
   * AgencyContractSignatory create
   */
  export type AgencyContractSignatoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyContractSignatory.
     */
    data: XOR<AgencyContractSignatoryCreateInput, AgencyContractSignatoryUncheckedCreateInput>
  }

  /**
   * AgencyContractSignatory createMany
   */
  export type AgencyContractSignatoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyContractSignatories.
     */
    data: AgencyContractSignatoryCreateManyInput | AgencyContractSignatoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyContractSignatory update
   */
  export type AgencyContractSignatoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyContractSignatory.
     */
    data: XOR<AgencyContractSignatoryUpdateInput, AgencyContractSignatoryUncheckedUpdateInput>
    /**
     * Choose, which AgencyContractSignatory to update.
     */
    where: AgencyContractSignatoryWhereUniqueInput
  }

  /**
   * AgencyContractSignatory updateMany
   */
  export type AgencyContractSignatoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyContractSignatories.
     */
    data: XOR<AgencyContractSignatoryUpdateManyMutationInput, AgencyContractSignatoryUncheckedUpdateManyInput>
    /**
     * Filter which AgencyContractSignatories to update
     */
    where?: AgencyContractSignatoryWhereInput
  }

  /**
   * AgencyContractSignatory upsert
   */
  export type AgencyContractSignatoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyContractSignatory to update in case it exists.
     */
    where: AgencyContractSignatoryWhereUniqueInput
    /**
     * In case the AgencyContractSignatory found by the `where` argument doesn't exist, create a new AgencyContractSignatory with this data.
     */
    create: XOR<AgencyContractSignatoryCreateInput, AgencyContractSignatoryUncheckedCreateInput>
    /**
     * In case the AgencyContractSignatory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyContractSignatoryUpdateInput, AgencyContractSignatoryUncheckedUpdateInput>
  }

  /**
   * AgencyContractSignatory delete
   */
  export type AgencyContractSignatoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
    /**
     * Filter which AgencyContractSignatory to delete.
     */
    where: AgencyContractSignatoryWhereUniqueInput
  }

  /**
   * AgencyContractSignatory deleteMany
   */
  export type AgencyContractSignatoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyContractSignatories to delete
     */
    where?: AgencyContractSignatoryWhereInput
  }

  /**
   * AgencyContractSignatory.agencyContracts
   */
  export type AgencyContractSignatory$agencyContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    where?: AgencyContractWhereInput
    orderBy?: AgencyContractOrderByWithRelationInput | AgencyContractOrderByWithRelationInput[]
    cursor?: AgencyContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyContractScalarFieldEnum | AgencyContractScalarFieldEnum[]
  }

  /**
   * AgencyContractSignatory without action
   */
  export type AgencyContractSignatoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractSignatory
     */
    select?: AgencyContractSignatorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractSignatoryInclude<ExtArgs> | null
  }


  /**
   * Model RealEstateAgencyContractProperties
   */

  export type AggregateRealEstateAgencyContractProperties = {
    _count: RealEstateAgencyContractPropertiesCountAggregateOutputType | null
    _avg: RealEstateAgencyContractPropertiesAvgAggregateOutputType | null
    _sum: RealEstateAgencyContractPropertiesSumAggregateOutputType | null
    _min: RealEstateAgencyContractPropertiesMinAggregateOutputType | null
    _max: RealEstateAgencyContractPropertiesMaxAggregateOutputType | null
  }

  export type RealEstateAgencyContractPropertiesAvgAggregateOutputType = {
    id: number | null
    agencyContractCommissionId: number | null
  }

  export type RealEstateAgencyContractPropertiesSumAggregateOutputType = {
    id: number | null
    agencyContractCommissionId: number | null
  }

  export type RealEstateAgencyContractPropertiesMinAggregateOutputType = {
    id: number | null
    agencyContractCommissionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RealEstateAgencyContractPropertiesMaxAggregateOutputType = {
    id: number | null
    agencyContractCommissionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RealEstateAgencyContractPropertiesCountAggregateOutputType = {
    id: number
    agencyContractCommissionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RealEstateAgencyContractPropertiesAvgAggregateInputType = {
    id?: true
    agencyContractCommissionId?: true
  }

  export type RealEstateAgencyContractPropertiesSumAggregateInputType = {
    id?: true
    agencyContractCommissionId?: true
  }

  export type RealEstateAgencyContractPropertiesMinAggregateInputType = {
    id?: true
    agencyContractCommissionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RealEstateAgencyContractPropertiesMaxAggregateInputType = {
    id?: true
    agencyContractCommissionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RealEstateAgencyContractPropertiesCountAggregateInputType = {
    id?: true
    agencyContractCommissionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RealEstateAgencyContractPropertiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RealEstateAgencyContractProperties to aggregate.
     */
    where?: RealEstateAgencyContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgencyContractProperties to fetch.
     */
    orderBy?: RealEstateAgencyContractPropertiesOrderByWithRelationInput | RealEstateAgencyContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RealEstateAgencyContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgencyContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgencyContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RealEstateAgencyContractProperties
    **/
    _count?: true | RealEstateAgencyContractPropertiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RealEstateAgencyContractPropertiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RealEstateAgencyContractPropertiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RealEstateAgencyContractPropertiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RealEstateAgencyContractPropertiesMaxAggregateInputType
  }

  export type GetRealEstateAgencyContractPropertiesAggregateType<T extends RealEstateAgencyContractPropertiesAggregateArgs> = {
        [P in keyof T & keyof AggregateRealEstateAgencyContractProperties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRealEstateAgencyContractProperties[P]>
      : GetScalarType<T[P], AggregateRealEstateAgencyContractProperties[P]>
  }




  export type RealEstateAgencyContractPropertiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RealEstateAgencyContractPropertiesWhereInput
    orderBy?: RealEstateAgencyContractPropertiesOrderByWithAggregationInput | RealEstateAgencyContractPropertiesOrderByWithAggregationInput[]
    by: RealEstateAgencyContractPropertiesScalarFieldEnum[] | RealEstateAgencyContractPropertiesScalarFieldEnum
    having?: RealEstateAgencyContractPropertiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RealEstateAgencyContractPropertiesCountAggregateInputType | true
    _avg?: RealEstateAgencyContractPropertiesAvgAggregateInputType
    _sum?: RealEstateAgencyContractPropertiesSumAggregateInputType
    _min?: RealEstateAgencyContractPropertiesMinAggregateInputType
    _max?: RealEstateAgencyContractPropertiesMaxAggregateInputType
  }

  export type RealEstateAgencyContractPropertiesGroupByOutputType = {
    id: number
    agencyContractCommissionId: number
    createdAt: Date
    updatedAt: Date
    _count: RealEstateAgencyContractPropertiesCountAggregateOutputType | null
    _avg: RealEstateAgencyContractPropertiesAvgAggregateOutputType | null
    _sum: RealEstateAgencyContractPropertiesSumAggregateOutputType | null
    _min: RealEstateAgencyContractPropertiesMinAggregateOutputType | null
    _max: RealEstateAgencyContractPropertiesMaxAggregateOutputType | null
  }

  type GetRealEstateAgencyContractPropertiesGroupByPayload<T extends RealEstateAgencyContractPropertiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RealEstateAgencyContractPropertiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RealEstateAgencyContractPropertiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RealEstateAgencyContractPropertiesGroupByOutputType[P]>
            : GetScalarType<T[P], RealEstateAgencyContractPropertiesGroupByOutputType[P]>
        }
      >
    >


  export type RealEstateAgencyContractPropertiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyContractCommissionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agencyContract?: boolean | RealEstateAgencyContractProperties$agencyContractArgs<ExtArgs>
    agencyContractCommission?: boolean | AgencyContractCommissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["realEstateAgencyContractProperties"]>


  export type RealEstateAgencyContractPropertiesSelectScalar = {
    id?: boolean
    agencyContractCommissionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RealEstateAgencyContractPropertiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agencyContract?: boolean | RealEstateAgencyContractProperties$agencyContractArgs<ExtArgs>
    agencyContractCommission?: boolean | AgencyContractCommissionDefaultArgs<ExtArgs>
  }

  export type $RealEstateAgencyContractPropertiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RealEstateAgencyContractProperties"
    objects: {
      agencyContract: Prisma.$AgencyContractPayload<ExtArgs> | null
      agencyContractCommission: Prisma.$AgencyContractCommissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      agencyContractCommissionId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["realEstateAgencyContractProperties"]>
    composites: {}
  }

  type RealEstateAgencyContractPropertiesGetPayload<S extends boolean | null | undefined | RealEstateAgencyContractPropertiesDefaultArgs> = $Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload, S>

  type RealEstateAgencyContractPropertiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RealEstateAgencyContractPropertiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RealEstateAgencyContractPropertiesCountAggregateInputType | true
    }

  export interface RealEstateAgencyContractPropertiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RealEstateAgencyContractProperties'], meta: { name: 'RealEstateAgencyContractProperties' } }
    /**
     * Find zero or one RealEstateAgencyContractProperties that matches the filter.
     * @param {RealEstateAgencyContractPropertiesFindUniqueArgs} args - Arguments to find a RealEstateAgencyContractProperties
     * @example
     * // Get one RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RealEstateAgencyContractPropertiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgencyContractPropertiesFindUniqueArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RealEstateAgencyContractProperties that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RealEstateAgencyContractPropertiesFindUniqueOrThrowArgs} args - Arguments to find a RealEstateAgencyContractProperties
     * @example
     * // Get one RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RealEstateAgencyContractPropertiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgencyContractPropertiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RealEstateAgencyContractProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyContractPropertiesFindFirstArgs} args - Arguments to find a RealEstateAgencyContractProperties
     * @example
     * // Get one RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RealEstateAgencyContractPropertiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgencyContractPropertiesFindFirstArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RealEstateAgencyContractProperties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyContractPropertiesFindFirstOrThrowArgs} args - Arguments to find a RealEstateAgencyContractProperties
     * @example
     * // Get one RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RealEstateAgencyContractPropertiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgencyContractPropertiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RealEstateAgencyContractProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyContractPropertiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.findMany()
     * 
     * // Get first 10 RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const realEstateAgencyContractPropertiesWithIdOnly = await prisma.realEstateAgencyContractProperties.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RealEstateAgencyContractPropertiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgencyContractPropertiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RealEstateAgencyContractProperties.
     * @param {RealEstateAgencyContractPropertiesCreateArgs} args - Arguments to create a RealEstateAgencyContractProperties.
     * @example
     * // Create one RealEstateAgencyContractProperties
     * const RealEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.create({
     *   data: {
     *     // ... data to create a RealEstateAgencyContractProperties
     *   }
     * })
     * 
    **/
    create<T extends RealEstateAgencyContractPropertiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgencyContractPropertiesCreateArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RealEstateAgencyContractProperties.
     * @param {RealEstateAgencyContractPropertiesCreateManyArgs} args - Arguments to create many RealEstateAgencyContractProperties.
     * @example
     * // Create many RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends RealEstateAgencyContractPropertiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgencyContractPropertiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RealEstateAgencyContractProperties.
     * @param {RealEstateAgencyContractPropertiesDeleteArgs} args - Arguments to delete one RealEstateAgencyContractProperties.
     * @example
     * // Delete one RealEstateAgencyContractProperties
     * const RealEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.delete({
     *   where: {
     *     // ... filter to delete one RealEstateAgencyContractProperties
     *   }
     * })
     * 
    **/
    delete<T extends RealEstateAgencyContractPropertiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgencyContractPropertiesDeleteArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RealEstateAgencyContractProperties.
     * @param {RealEstateAgencyContractPropertiesUpdateArgs} args - Arguments to update one RealEstateAgencyContractProperties.
     * @example
     * // Update one RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RealEstateAgencyContractPropertiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgencyContractPropertiesUpdateArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RealEstateAgencyContractProperties.
     * @param {RealEstateAgencyContractPropertiesDeleteManyArgs} args - Arguments to filter RealEstateAgencyContractProperties to delete.
     * @example
     * // Delete a few RealEstateAgencyContractProperties
     * const { count } = await prisma.realEstateAgencyContractProperties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RealEstateAgencyContractPropertiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgencyContractPropertiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RealEstateAgencyContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyContractPropertiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RealEstateAgencyContractPropertiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgencyContractPropertiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RealEstateAgencyContractProperties.
     * @param {RealEstateAgencyContractPropertiesUpsertArgs} args - Arguments to update or create a RealEstateAgencyContractProperties.
     * @example
     * // Update or create a RealEstateAgencyContractProperties
     * const realEstateAgencyContractProperties = await prisma.realEstateAgencyContractProperties.upsert({
     *   create: {
     *     // ... data to create a RealEstateAgencyContractProperties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RealEstateAgencyContractProperties we want to update
     *   }
     * })
    **/
    upsert<T extends RealEstateAgencyContractPropertiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgencyContractPropertiesUpsertArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RealEstateAgencyContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyContractPropertiesCountArgs} args - Arguments to filter RealEstateAgencyContractProperties to count.
     * @example
     * // Count the number of RealEstateAgencyContractProperties
     * const count = await prisma.realEstateAgencyContractProperties.count({
     *   where: {
     *     // ... the filter for the RealEstateAgencyContractProperties we want to count
     *   }
     * })
    **/
    count<T extends RealEstateAgencyContractPropertiesCountArgs>(
      args?: Subset<T, RealEstateAgencyContractPropertiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RealEstateAgencyContractPropertiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RealEstateAgencyContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyContractPropertiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RealEstateAgencyContractPropertiesAggregateArgs>(args: Subset<T, RealEstateAgencyContractPropertiesAggregateArgs>): Prisma.PrismaPromise<GetRealEstateAgencyContractPropertiesAggregateType<T>>

    /**
     * Group by RealEstateAgencyContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyContractPropertiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RealEstateAgencyContractPropertiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RealEstateAgencyContractPropertiesGroupByArgs['orderBy'] }
        : { orderBy?: RealEstateAgencyContractPropertiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RealEstateAgencyContractPropertiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRealEstateAgencyContractPropertiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RealEstateAgencyContractProperties model
   */
  readonly fields: RealEstateAgencyContractPropertiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RealEstateAgencyContractProperties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RealEstateAgencyContractPropertiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    agencyContract<T extends RealEstateAgencyContractProperties$agencyContractArgs<ExtArgs> = {}>(args?: Subset<T, RealEstateAgencyContractProperties$agencyContractArgs<ExtArgs>>): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    agencyContractCommission<T extends AgencyContractCommissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContractCommissionDefaultArgs<ExtArgs>>): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RealEstateAgencyContractProperties model
   */ 
  interface RealEstateAgencyContractPropertiesFieldRefs {
    readonly id: FieldRef<"RealEstateAgencyContractProperties", 'Int'>
    readonly agencyContractCommissionId: FieldRef<"RealEstateAgencyContractProperties", 'Int'>
    readonly createdAt: FieldRef<"RealEstateAgencyContractProperties", 'DateTime'>
    readonly updatedAt: FieldRef<"RealEstateAgencyContractProperties", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RealEstateAgencyContractProperties findUnique
   */
  export type RealEstateAgencyContractPropertiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgencyContractProperties to fetch.
     */
    where: RealEstateAgencyContractPropertiesWhereUniqueInput
  }

  /**
   * RealEstateAgencyContractProperties findUniqueOrThrow
   */
  export type RealEstateAgencyContractPropertiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgencyContractProperties to fetch.
     */
    where: RealEstateAgencyContractPropertiesWhereUniqueInput
  }

  /**
   * RealEstateAgencyContractProperties findFirst
   */
  export type RealEstateAgencyContractPropertiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgencyContractProperties to fetch.
     */
    where?: RealEstateAgencyContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgencyContractProperties to fetch.
     */
    orderBy?: RealEstateAgencyContractPropertiesOrderByWithRelationInput | RealEstateAgencyContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealEstateAgencyContractProperties.
     */
    cursor?: RealEstateAgencyContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgencyContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgencyContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealEstateAgencyContractProperties.
     */
    distinct?: RealEstateAgencyContractPropertiesScalarFieldEnum | RealEstateAgencyContractPropertiesScalarFieldEnum[]
  }

  /**
   * RealEstateAgencyContractProperties findFirstOrThrow
   */
  export type RealEstateAgencyContractPropertiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgencyContractProperties to fetch.
     */
    where?: RealEstateAgencyContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgencyContractProperties to fetch.
     */
    orderBy?: RealEstateAgencyContractPropertiesOrderByWithRelationInput | RealEstateAgencyContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealEstateAgencyContractProperties.
     */
    cursor?: RealEstateAgencyContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgencyContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgencyContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealEstateAgencyContractProperties.
     */
    distinct?: RealEstateAgencyContractPropertiesScalarFieldEnum | RealEstateAgencyContractPropertiesScalarFieldEnum[]
  }

  /**
   * RealEstateAgencyContractProperties findMany
   */
  export type RealEstateAgencyContractPropertiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgencyContractProperties to fetch.
     */
    where?: RealEstateAgencyContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgencyContractProperties to fetch.
     */
    orderBy?: RealEstateAgencyContractPropertiesOrderByWithRelationInput | RealEstateAgencyContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RealEstateAgencyContractProperties.
     */
    cursor?: RealEstateAgencyContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgencyContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgencyContractProperties.
     */
    skip?: number
    distinct?: RealEstateAgencyContractPropertiesScalarFieldEnum | RealEstateAgencyContractPropertiesScalarFieldEnum[]
  }

  /**
   * RealEstateAgencyContractProperties create
   */
  export type RealEstateAgencyContractPropertiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to create a RealEstateAgencyContractProperties.
     */
    data: XOR<RealEstateAgencyContractPropertiesCreateInput, RealEstateAgencyContractPropertiesUncheckedCreateInput>
  }

  /**
   * RealEstateAgencyContractProperties createMany
   */
  export type RealEstateAgencyContractPropertiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RealEstateAgencyContractProperties.
     */
    data: RealEstateAgencyContractPropertiesCreateManyInput | RealEstateAgencyContractPropertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RealEstateAgencyContractProperties update
   */
  export type RealEstateAgencyContractPropertiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to update a RealEstateAgencyContractProperties.
     */
    data: XOR<RealEstateAgencyContractPropertiesUpdateInput, RealEstateAgencyContractPropertiesUncheckedUpdateInput>
    /**
     * Choose, which RealEstateAgencyContractProperties to update.
     */
    where: RealEstateAgencyContractPropertiesWhereUniqueInput
  }

  /**
   * RealEstateAgencyContractProperties updateMany
   */
  export type RealEstateAgencyContractPropertiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RealEstateAgencyContractProperties.
     */
    data: XOR<RealEstateAgencyContractPropertiesUpdateManyMutationInput, RealEstateAgencyContractPropertiesUncheckedUpdateManyInput>
    /**
     * Filter which RealEstateAgencyContractProperties to update
     */
    where?: RealEstateAgencyContractPropertiesWhereInput
  }

  /**
   * RealEstateAgencyContractProperties upsert
   */
  export type RealEstateAgencyContractPropertiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * The filter to search for the RealEstateAgencyContractProperties to update in case it exists.
     */
    where: RealEstateAgencyContractPropertiesWhereUniqueInput
    /**
     * In case the RealEstateAgencyContractProperties found by the `where` argument doesn't exist, create a new RealEstateAgencyContractProperties with this data.
     */
    create: XOR<RealEstateAgencyContractPropertiesCreateInput, RealEstateAgencyContractPropertiesUncheckedCreateInput>
    /**
     * In case the RealEstateAgencyContractProperties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RealEstateAgencyContractPropertiesUpdateInput, RealEstateAgencyContractPropertiesUncheckedUpdateInput>
  }

  /**
   * RealEstateAgencyContractProperties delete
   */
  export type RealEstateAgencyContractPropertiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter which RealEstateAgencyContractProperties to delete.
     */
    where: RealEstateAgencyContractPropertiesWhereUniqueInput
  }

  /**
   * RealEstateAgencyContractProperties deleteMany
   */
  export type RealEstateAgencyContractPropertiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RealEstateAgencyContractProperties to delete
     */
    where?: RealEstateAgencyContractPropertiesWhereInput
  }

  /**
   * RealEstateAgencyContractProperties.agencyContract
   */
  export type RealEstateAgencyContractProperties$agencyContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    where?: AgencyContractWhereInput
  }

  /**
   * RealEstateAgencyContractProperties without action
   */
  export type RealEstateAgencyContractPropertiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
  }


  /**
   * Model MipAgencyContractProperties
   */

  export type AggregateMipAgencyContractProperties = {
    _count: MipAgencyContractPropertiesCountAggregateOutputType | null
    _avg: MipAgencyContractPropertiesAvgAggregateOutputType | null
    _sum: MipAgencyContractPropertiesSumAggregateOutputType | null
    _min: MipAgencyContractPropertiesMinAggregateOutputType | null
    _max: MipAgencyContractPropertiesMaxAggregateOutputType | null
  }

  export type MipAgencyContractPropertiesAvgAggregateOutputType = {
    id: number | null
    agencyContractCommissionId: number | null
  }

  export type MipAgencyContractPropertiesSumAggregateOutputType = {
    id: number | null
    agencyContractCommissionId: number | null
  }

  export type MipAgencyContractPropertiesMinAggregateOutputType = {
    id: number | null
    agencyContractCommissionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MipAgencyContractPropertiesMaxAggregateOutputType = {
    id: number | null
    agencyContractCommissionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MipAgencyContractPropertiesCountAggregateOutputType = {
    id: number
    agencyContractCommissionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MipAgencyContractPropertiesAvgAggregateInputType = {
    id?: true
    agencyContractCommissionId?: true
  }

  export type MipAgencyContractPropertiesSumAggregateInputType = {
    id?: true
    agencyContractCommissionId?: true
  }

  export type MipAgencyContractPropertiesMinAggregateInputType = {
    id?: true
    agencyContractCommissionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MipAgencyContractPropertiesMaxAggregateInputType = {
    id?: true
    agencyContractCommissionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MipAgencyContractPropertiesCountAggregateInputType = {
    id?: true
    agencyContractCommissionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MipAgencyContractPropertiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MipAgencyContractProperties to aggregate.
     */
    where?: MipAgencyContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MipAgencyContractProperties to fetch.
     */
    orderBy?: MipAgencyContractPropertiesOrderByWithRelationInput | MipAgencyContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MipAgencyContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MipAgencyContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MipAgencyContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MipAgencyContractProperties
    **/
    _count?: true | MipAgencyContractPropertiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MipAgencyContractPropertiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MipAgencyContractPropertiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MipAgencyContractPropertiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MipAgencyContractPropertiesMaxAggregateInputType
  }

  export type GetMipAgencyContractPropertiesAggregateType<T extends MipAgencyContractPropertiesAggregateArgs> = {
        [P in keyof T & keyof AggregateMipAgencyContractProperties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMipAgencyContractProperties[P]>
      : GetScalarType<T[P], AggregateMipAgencyContractProperties[P]>
  }




  export type MipAgencyContractPropertiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MipAgencyContractPropertiesWhereInput
    orderBy?: MipAgencyContractPropertiesOrderByWithAggregationInput | MipAgencyContractPropertiesOrderByWithAggregationInput[]
    by: MipAgencyContractPropertiesScalarFieldEnum[] | MipAgencyContractPropertiesScalarFieldEnum
    having?: MipAgencyContractPropertiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MipAgencyContractPropertiesCountAggregateInputType | true
    _avg?: MipAgencyContractPropertiesAvgAggregateInputType
    _sum?: MipAgencyContractPropertiesSumAggregateInputType
    _min?: MipAgencyContractPropertiesMinAggregateInputType
    _max?: MipAgencyContractPropertiesMaxAggregateInputType
  }

  export type MipAgencyContractPropertiesGroupByOutputType = {
    id: number
    agencyContractCommissionId: number
    createdAt: Date
    updatedAt: Date
    _count: MipAgencyContractPropertiesCountAggregateOutputType | null
    _avg: MipAgencyContractPropertiesAvgAggregateOutputType | null
    _sum: MipAgencyContractPropertiesSumAggregateOutputType | null
    _min: MipAgencyContractPropertiesMinAggregateOutputType | null
    _max: MipAgencyContractPropertiesMaxAggregateOutputType | null
  }

  type GetMipAgencyContractPropertiesGroupByPayload<T extends MipAgencyContractPropertiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MipAgencyContractPropertiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MipAgencyContractPropertiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MipAgencyContractPropertiesGroupByOutputType[P]>
            : GetScalarType<T[P], MipAgencyContractPropertiesGroupByOutputType[P]>
        }
      >
    >


  export type MipAgencyContractPropertiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyContractCommissionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agencyContract?: boolean | MipAgencyContractProperties$agencyContractArgs<ExtArgs>
    agencyContractCommission?: boolean | AgencyContractCommissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mipAgencyContractProperties"]>


  export type MipAgencyContractPropertiesSelectScalar = {
    id?: boolean
    agencyContractCommissionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MipAgencyContractPropertiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agencyContract?: boolean | MipAgencyContractProperties$agencyContractArgs<ExtArgs>
    agencyContractCommission?: boolean | AgencyContractCommissionDefaultArgs<ExtArgs>
  }

  export type $MipAgencyContractPropertiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MipAgencyContractProperties"
    objects: {
      agencyContract: Prisma.$AgencyContractPayload<ExtArgs> | null
      agencyContractCommission: Prisma.$AgencyContractCommissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      agencyContractCommissionId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mipAgencyContractProperties"]>
    composites: {}
  }

  type MipAgencyContractPropertiesGetPayload<S extends boolean | null | undefined | MipAgencyContractPropertiesDefaultArgs> = $Result.GetResult<Prisma.$MipAgencyContractPropertiesPayload, S>

  type MipAgencyContractPropertiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MipAgencyContractPropertiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MipAgencyContractPropertiesCountAggregateInputType | true
    }

  export interface MipAgencyContractPropertiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MipAgencyContractProperties'], meta: { name: 'MipAgencyContractProperties' } }
    /**
     * Find zero or one MipAgencyContractProperties that matches the filter.
     * @param {MipAgencyContractPropertiesFindUniqueArgs} args - Arguments to find a MipAgencyContractProperties
     * @example
     * // Get one MipAgencyContractProperties
     * const mipAgencyContractProperties = await prisma.mipAgencyContractProperties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MipAgencyContractPropertiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MipAgencyContractPropertiesFindUniqueArgs<ExtArgs>>
    ): Prisma__MipAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MipAgencyContractPropertiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MipAgencyContractProperties that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MipAgencyContractPropertiesFindUniqueOrThrowArgs} args - Arguments to find a MipAgencyContractProperties
     * @example
     * // Get one MipAgencyContractProperties
     * const mipAgencyContractProperties = await prisma.mipAgencyContractProperties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MipAgencyContractPropertiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MipAgencyContractPropertiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MipAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MipAgencyContractPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MipAgencyContractProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MipAgencyContractPropertiesFindFirstArgs} args - Arguments to find a MipAgencyContractProperties
     * @example
     * // Get one MipAgencyContractProperties
     * const mipAgencyContractProperties = await prisma.mipAgencyContractProperties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MipAgencyContractPropertiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MipAgencyContractPropertiesFindFirstArgs<ExtArgs>>
    ): Prisma__MipAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MipAgencyContractPropertiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MipAgencyContractProperties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MipAgencyContractPropertiesFindFirstOrThrowArgs} args - Arguments to find a MipAgencyContractProperties
     * @example
     * // Get one MipAgencyContractProperties
     * const mipAgencyContractProperties = await prisma.mipAgencyContractProperties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MipAgencyContractPropertiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MipAgencyContractPropertiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MipAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MipAgencyContractPropertiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MipAgencyContractProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MipAgencyContractPropertiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MipAgencyContractProperties
     * const mipAgencyContractProperties = await prisma.mipAgencyContractProperties.findMany()
     * 
     * // Get first 10 MipAgencyContractProperties
     * const mipAgencyContractProperties = await prisma.mipAgencyContractProperties.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mipAgencyContractPropertiesWithIdOnly = await prisma.mipAgencyContractProperties.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MipAgencyContractPropertiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MipAgencyContractPropertiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MipAgencyContractPropertiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MipAgencyContractProperties.
     * @param {MipAgencyContractPropertiesCreateArgs} args - Arguments to create a MipAgencyContractProperties.
     * @example
     * // Create one MipAgencyContractProperties
     * const MipAgencyContractProperties = await prisma.mipAgencyContractProperties.create({
     *   data: {
     *     // ... data to create a MipAgencyContractProperties
     *   }
     * })
     * 
    **/
    create<T extends MipAgencyContractPropertiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MipAgencyContractPropertiesCreateArgs<ExtArgs>>
    ): Prisma__MipAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MipAgencyContractPropertiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MipAgencyContractProperties.
     * @param {MipAgencyContractPropertiesCreateManyArgs} args - Arguments to create many MipAgencyContractProperties.
     * @example
     * // Create many MipAgencyContractProperties
     * const mipAgencyContractProperties = await prisma.mipAgencyContractProperties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends MipAgencyContractPropertiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MipAgencyContractPropertiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MipAgencyContractProperties.
     * @param {MipAgencyContractPropertiesDeleteArgs} args - Arguments to delete one MipAgencyContractProperties.
     * @example
     * // Delete one MipAgencyContractProperties
     * const MipAgencyContractProperties = await prisma.mipAgencyContractProperties.delete({
     *   where: {
     *     // ... filter to delete one MipAgencyContractProperties
     *   }
     * })
     * 
    **/
    delete<T extends MipAgencyContractPropertiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MipAgencyContractPropertiesDeleteArgs<ExtArgs>>
    ): Prisma__MipAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MipAgencyContractPropertiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MipAgencyContractProperties.
     * @param {MipAgencyContractPropertiesUpdateArgs} args - Arguments to update one MipAgencyContractProperties.
     * @example
     * // Update one MipAgencyContractProperties
     * const mipAgencyContractProperties = await prisma.mipAgencyContractProperties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MipAgencyContractPropertiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MipAgencyContractPropertiesUpdateArgs<ExtArgs>>
    ): Prisma__MipAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MipAgencyContractPropertiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MipAgencyContractProperties.
     * @param {MipAgencyContractPropertiesDeleteManyArgs} args - Arguments to filter MipAgencyContractProperties to delete.
     * @example
     * // Delete a few MipAgencyContractProperties
     * const { count } = await prisma.mipAgencyContractProperties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MipAgencyContractPropertiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MipAgencyContractPropertiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MipAgencyContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MipAgencyContractPropertiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MipAgencyContractProperties
     * const mipAgencyContractProperties = await prisma.mipAgencyContractProperties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MipAgencyContractPropertiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MipAgencyContractPropertiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MipAgencyContractProperties.
     * @param {MipAgencyContractPropertiesUpsertArgs} args - Arguments to update or create a MipAgencyContractProperties.
     * @example
     * // Update or create a MipAgencyContractProperties
     * const mipAgencyContractProperties = await prisma.mipAgencyContractProperties.upsert({
     *   create: {
     *     // ... data to create a MipAgencyContractProperties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MipAgencyContractProperties we want to update
     *   }
     * })
    **/
    upsert<T extends MipAgencyContractPropertiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MipAgencyContractPropertiesUpsertArgs<ExtArgs>>
    ): Prisma__MipAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MipAgencyContractPropertiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MipAgencyContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MipAgencyContractPropertiesCountArgs} args - Arguments to filter MipAgencyContractProperties to count.
     * @example
     * // Count the number of MipAgencyContractProperties
     * const count = await prisma.mipAgencyContractProperties.count({
     *   where: {
     *     // ... the filter for the MipAgencyContractProperties we want to count
     *   }
     * })
    **/
    count<T extends MipAgencyContractPropertiesCountArgs>(
      args?: Subset<T, MipAgencyContractPropertiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MipAgencyContractPropertiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MipAgencyContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MipAgencyContractPropertiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MipAgencyContractPropertiesAggregateArgs>(args: Subset<T, MipAgencyContractPropertiesAggregateArgs>): Prisma.PrismaPromise<GetMipAgencyContractPropertiesAggregateType<T>>

    /**
     * Group by MipAgencyContractProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MipAgencyContractPropertiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MipAgencyContractPropertiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MipAgencyContractPropertiesGroupByArgs['orderBy'] }
        : { orderBy?: MipAgencyContractPropertiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MipAgencyContractPropertiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMipAgencyContractPropertiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MipAgencyContractProperties model
   */
  readonly fields: MipAgencyContractPropertiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MipAgencyContractProperties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MipAgencyContractPropertiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    agencyContract<T extends MipAgencyContractProperties$agencyContractArgs<ExtArgs> = {}>(args?: Subset<T, MipAgencyContractProperties$agencyContractArgs<ExtArgs>>): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    agencyContractCommission<T extends AgencyContractCommissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContractCommissionDefaultArgs<ExtArgs>>): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MipAgencyContractProperties model
   */ 
  interface MipAgencyContractPropertiesFieldRefs {
    readonly id: FieldRef<"MipAgencyContractProperties", 'Int'>
    readonly agencyContractCommissionId: FieldRef<"MipAgencyContractProperties", 'Int'>
    readonly createdAt: FieldRef<"MipAgencyContractProperties", 'DateTime'>
    readonly updatedAt: FieldRef<"MipAgencyContractProperties", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MipAgencyContractProperties findUnique
   */
  export type MipAgencyContractPropertiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MipAgencyContractProperties
     */
    select?: MipAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MipAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which MipAgencyContractProperties to fetch.
     */
    where: MipAgencyContractPropertiesWhereUniqueInput
  }

  /**
   * MipAgencyContractProperties findUniqueOrThrow
   */
  export type MipAgencyContractPropertiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MipAgencyContractProperties
     */
    select?: MipAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MipAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which MipAgencyContractProperties to fetch.
     */
    where: MipAgencyContractPropertiesWhereUniqueInput
  }

  /**
   * MipAgencyContractProperties findFirst
   */
  export type MipAgencyContractPropertiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MipAgencyContractProperties
     */
    select?: MipAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MipAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which MipAgencyContractProperties to fetch.
     */
    where?: MipAgencyContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MipAgencyContractProperties to fetch.
     */
    orderBy?: MipAgencyContractPropertiesOrderByWithRelationInput | MipAgencyContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MipAgencyContractProperties.
     */
    cursor?: MipAgencyContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MipAgencyContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MipAgencyContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MipAgencyContractProperties.
     */
    distinct?: MipAgencyContractPropertiesScalarFieldEnum | MipAgencyContractPropertiesScalarFieldEnum[]
  }

  /**
   * MipAgencyContractProperties findFirstOrThrow
   */
  export type MipAgencyContractPropertiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MipAgencyContractProperties
     */
    select?: MipAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MipAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which MipAgencyContractProperties to fetch.
     */
    where?: MipAgencyContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MipAgencyContractProperties to fetch.
     */
    orderBy?: MipAgencyContractPropertiesOrderByWithRelationInput | MipAgencyContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MipAgencyContractProperties.
     */
    cursor?: MipAgencyContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MipAgencyContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MipAgencyContractProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MipAgencyContractProperties.
     */
    distinct?: MipAgencyContractPropertiesScalarFieldEnum | MipAgencyContractPropertiesScalarFieldEnum[]
  }

  /**
   * MipAgencyContractProperties findMany
   */
  export type MipAgencyContractPropertiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MipAgencyContractProperties
     */
    select?: MipAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MipAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter, which MipAgencyContractProperties to fetch.
     */
    where?: MipAgencyContractPropertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MipAgencyContractProperties to fetch.
     */
    orderBy?: MipAgencyContractPropertiesOrderByWithRelationInput | MipAgencyContractPropertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MipAgencyContractProperties.
     */
    cursor?: MipAgencyContractPropertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MipAgencyContractProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MipAgencyContractProperties.
     */
    skip?: number
    distinct?: MipAgencyContractPropertiesScalarFieldEnum | MipAgencyContractPropertiesScalarFieldEnum[]
  }

  /**
   * MipAgencyContractProperties create
   */
  export type MipAgencyContractPropertiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MipAgencyContractProperties
     */
    select?: MipAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MipAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to create a MipAgencyContractProperties.
     */
    data: XOR<MipAgencyContractPropertiesCreateInput, MipAgencyContractPropertiesUncheckedCreateInput>
  }

  /**
   * MipAgencyContractProperties createMany
   */
  export type MipAgencyContractPropertiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MipAgencyContractProperties.
     */
    data: MipAgencyContractPropertiesCreateManyInput | MipAgencyContractPropertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MipAgencyContractProperties update
   */
  export type MipAgencyContractPropertiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MipAgencyContractProperties
     */
    select?: MipAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MipAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * The data needed to update a MipAgencyContractProperties.
     */
    data: XOR<MipAgencyContractPropertiesUpdateInput, MipAgencyContractPropertiesUncheckedUpdateInput>
    /**
     * Choose, which MipAgencyContractProperties to update.
     */
    where: MipAgencyContractPropertiesWhereUniqueInput
  }

  /**
   * MipAgencyContractProperties updateMany
   */
  export type MipAgencyContractPropertiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MipAgencyContractProperties.
     */
    data: XOR<MipAgencyContractPropertiesUpdateManyMutationInput, MipAgencyContractPropertiesUncheckedUpdateManyInput>
    /**
     * Filter which MipAgencyContractProperties to update
     */
    where?: MipAgencyContractPropertiesWhereInput
  }

  /**
   * MipAgencyContractProperties upsert
   */
  export type MipAgencyContractPropertiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MipAgencyContractProperties
     */
    select?: MipAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MipAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * The filter to search for the MipAgencyContractProperties to update in case it exists.
     */
    where: MipAgencyContractPropertiesWhereUniqueInput
    /**
     * In case the MipAgencyContractProperties found by the `where` argument doesn't exist, create a new MipAgencyContractProperties with this data.
     */
    create: XOR<MipAgencyContractPropertiesCreateInput, MipAgencyContractPropertiesUncheckedCreateInput>
    /**
     * In case the MipAgencyContractProperties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MipAgencyContractPropertiesUpdateInput, MipAgencyContractPropertiesUncheckedUpdateInput>
  }

  /**
   * MipAgencyContractProperties delete
   */
  export type MipAgencyContractPropertiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MipAgencyContractProperties
     */
    select?: MipAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MipAgencyContractPropertiesInclude<ExtArgs> | null
    /**
     * Filter which MipAgencyContractProperties to delete.
     */
    where: MipAgencyContractPropertiesWhereUniqueInput
  }

  /**
   * MipAgencyContractProperties deleteMany
   */
  export type MipAgencyContractPropertiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MipAgencyContractProperties to delete
     */
    where?: MipAgencyContractPropertiesWhereInput
  }

  /**
   * MipAgencyContractProperties.agencyContract
   */
  export type MipAgencyContractProperties$agencyContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    where?: AgencyContractWhereInput
  }

  /**
   * MipAgencyContractProperties without action
   */
  export type MipAgencyContractPropertiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MipAgencyContractProperties
     */
    select?: MipAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MipAgencyContractPropertiesInclude<ExtArgs> | null
  }


  /**
   * Model AgencyContractCommission
   */

  export type AggregateAgencyContractCommission = {
    _count: AgencyContractCommissionCountAggregateOutputType | null
    _avg: AgencyContractCommissionAvgAggregateOutputType | null
    _sum: AgencyContractCommissionSumAggregateOutputType | null
    _min: AgencyContractCommissionMinAggregateOutputType | null
    _max: AgencyContractCommissionMaxAggregateOutputType | null
  }

  export type AgencyContractCommissionAvgAggregateOutputType = {
    id: number | null
    percent: Decimal | null
    threshold: Decimal | null
    maxDays: number | null
  }

  export type AgencyContractCommissionSumAggregateOutputType = {
    id: number | null
    percent: Decimal | null
    threshold: Decimal | null
    maxDays: number | null
  }

  export type AgencyContractCommissionMinAggregateOutputType = {
    id: number | null
    percent: Decimal | null
    threshold: Decimal | null
    maxDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyContractCommissionMaxAggregateOutputType = {
    id: number | null
    percent: Decimal | null
    threshold: Decimal | null
    maxDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyContractCommissionCountAggregateOutputType = {
    id: number
    percent: number
    threshold: number
    maxDays: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgencyContractCommissionAvgAggregateInputType = {
    id?: true
    percent?: true
    threshold?: true
    maxDays?: true
  }

  export type AgencyContractCommissionSumAggregateInputType = {
    id?: true
    percent?: true
    threshold?: true
    maxDays?: true
  }

  export type AgencyContractCommissionMinAggregateInputType = {
    id?: true
    percent?: true
    threshold?: true
    maxDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyContractCommissionMaxAggregateInputType = {
    id?: true
    percent?: true
    threshold?: true
    maxDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyContractCommissionCountAggregateInputType = {
    id?: true
    percent?: true
    threshold?: true
    maxDays?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencyContractCommissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyContractCommission to aggregate.
     */
    where?: AgencyContractCommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContractCommissions to fetch.
     */
    orderBy?: AgencyContractCommissionOrderByWithRelationInput | AgencyContractCommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyContractCommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContractCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContractCommissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyContractCommissions
    **/
    _count?: true | AgencyContractCommissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyContractCommissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencyContractCommissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyContractCommissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyContractCommissionMaxAggregateInputType
  }

  export type GetAgencyContractCommissionAggregateType<T extends AgencyContractCommissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyContractCommission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyContractCommission[P]>
      : GetScalarType<T[P], AggregateAgencyContractCommission[P]>
  }




  export type AgencyContractCommissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyContractCommissionWhereInput
    orderBy?: AgencyContractCommissionOrderByWithAggregationInput | AgencyContractCommissionOrderByWithAggregationInput[]
    by: AgencyContractCommissionScalarFieldEnum[] | AgencyContractCommissionScalarFieldEnum
    having?: AgencyContractCommissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyContractCommissionCountAggregateInputType | true
    _avg?: AgencyContractCommissionAvgAggregateInputType
    _sum?: AgencyContractCommissionSumAggregateInputType
    _min?: AgencyContractCommissionMinAggregateInputType
    _max?: AgencyContractCommissionMaxAggregateInputType
  }

  export type AgencyContractCommissionGroupByOutputType = {
    id: number
    percent: Decimal
    threshold: Decimal
    maxDays: number
    createdAt: Date
    updatedAt: Date
    _count: AgencyContractCommissionCountAggregateOutputType | null
    _avg: AgencyContractCommissionAvgAggregateOutputType | null
    _sum: AgencyContractCommissionSumAggregateOutputType | null
    _min: AgencyContractCommissionMinAggregateOutputType | null
    _max: AgencyContractCommissionMaxAggregateOutputType | null
  }

  type GetAgencyContractCommissionGroupByPayload<T extends AgencyContractCommissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyContractCommissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyContractCommissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyContractCommissionGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyContractCommissionGroupByOutputType[P]>
        }
      >
    >


  export type AgencyContractCommissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    percent?: boolean
    threshold?: boolean
    maxDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    realEstateAgencyContractProperties?: boolean | AgencyContractCommission$realEstateAgencyContractPropertiesArgs<ExtArgs>
    mipAgencyContractProperties?: boolean | AgencyContractCommission$mipAgencyContractPropertiesArgs<ExtArgs>
  }, ExtArgs["result"]["agencyContractCommission"]>


  export type AgencyContractCommissionSelectScalar = {
    id?: boolean
    percent?: boolean
    threshold?: boolean
    maxDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgencyContractCommissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    realEstateAgencyContractProperties?: boolean | AgencyContractCommission$realEstateAgencyContractPropertiesArgs<ExtArgs>
    mipAgencyContractProperties?: boolean | AgencyContractCommission$mipAgencyContractPropertiesArgs<ExtArgs>
  }

  export type $AgencyContractCommissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyContractCommission"
    objects: {
      realEstateAgencyContractProperties: Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs> | null
      mipAgencyContractProperties: Prisma.$MipAgencyContractPropertiesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      percent: Prisma.Decimal
      threshold: Prisma.Decimal
      maxDays: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agencyContractCommission"]>
    composites: {}
  }

  type AgencyContractCommissionGetPayload<S extends boolean | null | undefined | AgencyContractCommissionDefaultArgs> = $Result.GetResult<Prisma.$AgencyContractCommissionPayload, S>

  type AgencyContractCommissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgencyContractCommissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgencyContractCommissionCountAggregateInputType | true
    }

  export interface AgencyContractCommissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyContractCommission'], meta: { name: 'AgencyContractCommission' } }
    /**
     * Find zero or one AgencyContractCommission that matches the filter.
     * @param {AgencyContractCommissionFindUniqueArgs} args - Arguments to find a AgencyContractCommission
     * @example
     * // Get one AgencyContractCommission
     * const agencyContractCommission = await prisma.agencyContractCommission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgencyContractCommissionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractCommissionFindUniqueArgs<ExtArgs>>
    ): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AgencyContractCommission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgencyContractCommissionFindUniqueOrThrowArgs} args - Arguments to find a AgencyContractCommission
     * @example
     * // Get one AgencyContractCommission
     * const agencyContractCommission = await prisma.agencyContractCommission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgencyContractCommissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractCommissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AgencyContractCommission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractCommissionFindFirstArgs} args - Arguments to find a AgencyContractCommission
     * @example
     * // Get one AgencyContractCommission
     * const agencyContractCommission = await prisma.agencyContractCommission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgencyContractCommissionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractCommissionFindFirstArgs<ExtArgs>>
    ): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AgencyContractCommission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractCommissionFindFirstOrThrowArgs} args - Arguments to find a AgencyContractCommission
     * @example
     * // Get one AgencyContractCommission
     * const agencyContractCommission = await prisma.agencyContractCommission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgencyContractCommissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractCommissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AgencyContractCommissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractCommissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyContractCommissions
     * const agencyContractCommissions = await prisma.agencyContractCommission.findMany()
     * 
     * // Get first 10 AgencyContractCommissions
     * const agencyContractCommissions = await prisma.agencyContractCommission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyContractCommissionWithIdOnly = await prisma.agencyContractCommission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgencyContractCommissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractCommissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AgencyContractCommission.
     * @param {AgencyContractCommissionCreateArgs} args - Arguments to create a AgencyContractCommission.
     * @example
     * // Create one AgencyContractCommission
     * const AgencyContractCommission = await prisma.agencyContractCommission.create({
     *   data: {
     *     // ... data to create a AgencyContractCommission
     *   }
     * })
     * 
    **/
    create<T extends AgencyContractCommissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractCommissionCreateArgs<ExtArgs>>
    ): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AgencyContractCommissions.
     * @param {AgencyContractCommissionCreateManyArgs} args - Arguments to create many AgencyContractCommissions.
     * @example
     * // Create many AgencyContractCommissions
     * const agencyContractCommission = await prisma.agencyContractCommission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AgencyContractCommissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractCommissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgencyContractCommission.
     * @param {AgencyContractCommissionDeleteArgs} args - Arguments to delete one AgencyContractCommission.
     * @example
     * // Delete one AgencyContractCommission
     * const AgencyContractCommission = await prisma.agencyContractCommission.delete({
     *   where: {
     *     // ... filter to delete one AgencyContractCommission
     *   }
     * })
     * 
    **/
    delete<T extends AgencyContractCommissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractCommissionDeleteArgs<ExtArgs>>
    ): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AgencyContractCommission.
     * @param {AgencyContractCommissionUpdateArgs} args - Arguments to update one AgencyContractCommission.
     * @example
     * // Update one AgencyContractCommission
     * const agencyContractCommission = await prisma.agencyContractCommission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgencyContractCommissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractCommissionUpdateArgs<ExtArgs>>
    ): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AgencyContractCommissions.
     * @param {AgencyContractCommissionDeleteManyArgs} args - Arguments to filter AgencyContractCommissions to delete.
     * @example
     * // Delete a few AgencyContractCommissions
     * const { count } = await prisma.agencyContractCommission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgencyContractCommissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyContractCommissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyContractCommissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractCommissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyContractCommissions
     * const agencyContractCommission = await prisma.agencyContractCommission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgencyContractCommissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractCommissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgencyContractCommission.
     * @param {AgencyContractCommissionUpsertArgs} args - Arguments to update or create a AgencyContractCommission.
     * @example
     * // Update or create a AgencyContractCommission
     * const agencyContractCommission = await prisma.agencyContractCommission.upsert({
     *   create: {
     *     // ... data to create a AgencyContractCommission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyContractCommission we want to update
     *   }
     * })
    **/
    upsert<T extends AgencyContractCommissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyContractCommissionUpsertArgs<ExtArgs>>
    ): Prisma__AgencyContractCommissionClient<$Result.GetResult<Prisma.$AgencyContractCommissionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AgencyContractCommissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractCommissionCountArgs} args - Arguments to filter AgencyContractCommissions to count.
     * @example
     * // Count the number of AgencyContractCommissions
     * const count = await prisma.agencyContractCommission.count({
     *   where: {
     *     // ... the filter for the AgencyContractCommissions we want to count
     *   }
     * })
    **/
    count<T extends AgencyContractCommissionCountArgs>(
      args?: Subset<T, AgencyContractCommissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyContractCommissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyContractCommission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractCommissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyContractCommissionAggregateArgs>(args: Subset<T, AgencyContractCommissionAggregateArgs>): Prisma.PrismaPromise<GetAgencyContractCommissionAggregateType<T>>

    /**
     * Group by AgencyContractCommission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyContractCommissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyContractCommissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyContractCommissionGroupByArgs['orderBy'] }
        : { orderBy?: AgencyContractCommissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyContractCommissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyContractCommissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyContractCommission model
   */
  readonly fields: AgencyContractCommissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyContractCommission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyContractCommissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    realEstateAgencyContractProperties<T extends AgencyContractCommission$realEstateAgencyContractPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContractCommission$realEstateAgencyContractPropertiesArgs<ExtArgs>>): Prisma__RealEstateAgencyContractPropertiesClient<$Result.GetResult<Prisma.$RealEstateAgencyContractPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    mipAgencyContractProperties<T extends AgencyContractCommission$mipAgencyContractPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContractCommission$mipAgencyContractPropertiesArgs<ExtArgs>>): Prisma__MipAgencyContractPropertiesClient<$Result.GetResult<Prisma.$MipAgencyContractPropertiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AgencyContractCommission model
   */ 
  interface AgencyContractCommissionFieldRefs {
    readonly id: FieldRef<"AgencyContractCommission", 'Int'>
    readonly percent: FieldRef<"AgencyContractCommission", 'Decimal'>
    readonly threshold: FieldRef<"AgencyContractCommission", 'Decimal'>
    readonly maxDays: FieldRef<"AgencyContractCommission", 'Int'>
    readonly createdAt: FieldRef<"AgencyContractCommission", 'DateTime'>
    readonly updatedAt: FieldRef<"AgencyContractCommission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgencyContractCommission findUnique
   */
  export type AgencyContractCommissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractCommission to fetch.
     */
    where: AgencyContractCommissionWhereUniqueInput
  }

  /**
   * AgencyContractCommission findUniqueOrThrow
   */
  export type AgencyContractCommissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractCommission to fetch.
     */
    where: AgencyContractCommissionWhereUniqueInput
  }

  /**
   * AgencyContractCommission findFirst
   */
  export type AgencyContractCommissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractCommission to fetch.
     */
    where?: AgencyContractCommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContractCommissions to fetch.
     */
    orderBy?: AgencyContractCommissionOrderByWithRelationInput | AgencyContractCommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyContractCommissions.
     */
    cursor?: AgencyContractCommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContractCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContractCommissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyContractCommissions.
     */
    distinct?: AgencyContractCommissionScalarFieldEnum | AgencyContractCommissionScalarFieldEnum[]
  }

  /**
   * AgencyContractCommission findFirstOrThrow
   */
  export type AgencyContractCommissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractCommission to fetch.
     */
    where?: AgencyContractCommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContractCommissions to fetch.
     */
    orderBy?: AgencyContractCommissionOrderByWithRelationInput | AgencyContractCommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyContractCommissions.
     */
    cursor?: AgencyContractCommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContractCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContractCommissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyContractCommissions.
     */
    distinct?: AgencyContractCommissionScalarFieldEnum | AgencyContractCommissionScalarFieldEnum[]
  }

  /**
   * AgencyContractCommission findMany
   */
  export type AgencyContractCommissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
    /**
     * Filter, which AgencyContractCommissions to fetch.
     */
    where?: AgencyContractCommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyContractCommissions to fetch.
     */
    orderBy?: AgencyContractCommissionOrderByWithRelationInput | AgencyContractCommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyContractCommissions.
     */
    cursor?: AgencyContractCommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyContractCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyContractCommissions.
     */
    skip?: number
    distinct?: AgencyContractCommissionScalarFieldEnum | AgencyContractCommissionScalarFieldEnum[]
  }

  /**
   * AgencyContractCommission create
   */
  export type AgencyContractCommissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyContractCommission.
     */
    data: XOR<AgencyContractCommissionCreateInput, AgencyContractCommissionUncheckedCreateInput>
  }

  /**
   * AgencyContractCommission createMany
   */
  export type AgencyContractCommissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyContractCommissions.
     */
    data: AgencyContractCommissionCreateManyInput | AgencyContractCommissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyContractCommission update
   */
  export type AgencyContractCommissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyContractCommission.
     */
    data: XOR<AgencyContractCommissionUpdateInput, AgencyContractCommissionUncheckedUpdateInput>
    /**
     * Choose, which AgencyContractCommission to update.
     */
    where: AgencyContractCommissionWhereUniqueInput
  }

  /**
   * AgencyContractCommission updateMany
   */
  export type AgencyContractCommissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyContractCommissions.
     */
    data: XOR<AgencyContractCommissionUpdateManyMutationInput, AgencyContractCommissionUncheckedUpdateManyInput>
    /**
     * Filter which AgencyContractCommissions to update
     */
    where?: AgencyContractCommissionWhereInput
  }

  /**
   * AgencyContractCommission upsert
   */
  export type AgencyContractCommissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyContractCommission to update in case it exists.
     */
    where: AgencyContractCommissionWhereUniqueInput
    /**
     * In case the AgencyContractCommission found by the `where` argument doesn't exist, create a new AgencyContractCommission with this data.
     */
    create: XOR<AgencyContractCommissionCreateInput, AgencyContractCommissionUncheckedCreateInput>
    /**
     * In case the AgencyContractCommission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyContractCommissionUpdateInput, AgencyContractCommissionUncheckedUpdateInput>
  }

  /**
   * AgencyContractCommission delete
   */
  export type AgencyContractCommissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
    /**
     * Filter which AgencyContractCommission to delete.
     */
    where: AgencyContractCommissionWhereUniqueInput
  }

  /**
   * AgencyContractCommission deleteMany
   */
  export type AgencyContractCommissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyContractCommissions to delete
     */
    where?: AgencyContractCommissionWhereInput
  }

  /**
   * AgencyContractCommission.realEstateAgencyContractProperties
   */
  export type AgencyContractCommission$realEstateAgencyContractPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyContractProperties
     */
    select?: RealEstateAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyContractPropertiesInclude<ExtArgs> | null
    where?: RealEstateAgencyContractPropertiesWhereInput
  }

  /**
   * AgencyContractCommission.mipAgencyContractProperties
   */
  export type AgencyContractCommission$mipAgencyContractPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MipAgencyContractProperties
     */
    select?: MipAgencyContractPropertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MipAgencyContractPropertiesInclude<ExtArgs> | null
    where?: MipAgencyContractPropertiesWhereInput
  }

  /**
   * AgencyContractCommission without action
   */
  export type AgencyContractCommissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContractCommission
     */
    select?: AgencyContractCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractCommissionInclude<ExtArgs> | null
  }


  /**
   * Model RealEstateAgent
   */

  export type AggregateRealEstateAgent = {
    _count: RealEstateAgentCountAggregateOutputType | null
    _avg: RealEstateAgentAvgAggregateOutputType | null
    _sum: RealEstateAgentSumAggregateOutputType | null
    _min: RealEstateAgentMinAggregateOutputType | null
    _max: RealEstateAgentMaxAggregateOutputType | null
  }

  export type RealEstateAgentAvgAggregateOutputType = {
    id: number | null
    oneGtId: number | null
  }

  export type RealEstateAgentSumAggregateOutputType = {
    id: number | null
    oneGtId: number | null
  }

  export type RealEstateAgentMinAggregateOutputType = {
    id: number | null
    fullName: string | null
    phone: string | null
    oneGtId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RealEstateAgentMaxAggregateOutputType = {
    id: number | null
    fullName: string | null
    phone: string | null
    oneGtId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RealEstateAgentCountAggregateOutputType = {
    id: number
    fullName: number
    phone: number
    oneGtId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RealEstateAgentAvgAggregateInputType = {
    id?: true
    oneGtId?: true
  }

  export type RealEstateAgentSumAggregateInputType = {
    id?: true
    oneGtId?: true
  }

  export type RealEstateAgentMinAggregateInputType = {
    id?: true
    fullName?: true
    phone?: true
    oneGtId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RealEstateAgentMaxAggregateInputType = {
    id?: true
    fullName?: true
    phone?: true
    oneGtId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RealEstateAgentCountAggregateInputType = {
    id?: true
    fullName?: true
    phone?: true
    oneGtId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RealEstateAgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RealEstateAgent to aggregate.
     */
    where?: RealEstateAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgents to fetch.
     */
    orderBy?: RealEstateAgentOrderByWithRelationInput | RealEstateAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RealEstateAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RealEstateAgents
    **/
    _count?: true | RealEstateAgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RealEstateAgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RealEstateAgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RealEstateAgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RealEstateAgentMaxAggregateInputType
  }

  export type GetRealEstateAgentAggregateType<T extends RealEstateAgentAggregateArgs> = {
        [P in keyof T & keyof AggregateRealEstateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRealEstateAgent[P]>
      : GetScalarType<T[P], AggregateRealEstateAgent[P]>
  }




  export type RealEstateAgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RealEstateAgentWhereInput
    orderBy?: RealEstateAgentOrderByWithAggregationInput | RealEstateAgentOrderByWithAggregationInput[]
    by: RealEstateAgentScalarFieldEnum[] | RealEstateAgentScalarFieldEnum
    having?: RealEstateAgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RealEstateAgentCountAggregateInputType | true
    _avg?: RealEstateAgentAvgAggregateInputType
    _sum?: RealEstateAgentSumAggregateInputType
    _min?: RealEstateAgentMinAggregateInputType
    _max?: RealEstateAgentMaxAggregateInputType
  }

  export type RealEstateAgentGroupByOutputType = {
    id: number
    fullName: string
    phone: string | null
    oneGtId: number | null
    createdAt: Date
    updatedAt: Date
    _count: RealEstateAgentCountAggregateOutputType | null
    _avg: RealEstateAgentAvgAggregateOutputType | null
    _sum: RealEstateAgentSumAggregateOutputType | null
    _min: RealEstateAgentMinAggregateOutputType | null
    _max: RealEstateAgentMaxAggregateOutputType | null
  }

  type GetRealEstateAgentGroupByPayload<T extends RealEstateAgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RealEstateAgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RealEstateAgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RealEstateAgentGroupByOutputType[P]>
            : GetScalarType<T[P], RealEstateAgentGroupByOutputType[P]>
        }
      >
    >


  export type RealEstateAgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    phone?: boolean
    oneGtId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientContracts?: boolean | RealEstateAgent$clientContractsArgs<ExtArgs>
    agenciesToRealEstateAgents?: boolean | RealEstateAgent$agenciesToRealEstateAgentsArgs<ExtArgs>
    _count?: boolean | RealEstateAgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["realEstateAgent"]>


  export type RealEstateAgentSelectScalar = {
    id?: boolean
    fullName?: boolean
    phone?: boolean
    oneGtId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RealEstateAgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientContracts?: boolean | RealEstateAgent$clientContractsArgs<ExtArgs>
    agenciesToRealEstateAgents?: boolean | RealEstateAgent$agenciesToRealEstateAgentsArgs<ExtArgs>
    _count?: boolean | RealEstateAgentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RealEstateAgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RealEstateAgent"
    objects: {
      clientContracts: Prisma.$ClientContractPayload<ExtArgs>[]
      agenciesToRealEstateAgents: Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullName: string
      phone: string | null
      oneGtId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["realEstateAgent"]>
    composites: {}
  }

  type RealEstateAgentGetPayload<S extends boolean | null | undefined | RealEstateAgentDefaultArgs> = $Result.GetResult<Prisma.$RealEstateAgentPayload, S>

  type RealEstateAgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RealEstateAgentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RealEstateAgentCountAggregateInputType | true
    }

  export interface RealEstateAgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RealEstateAgent'], meta: { name: 'RealEstateAgent' } }
    /**
     * Find zero or one RealEstateAgent that matches the filter.
     * @param {RealEstateAgentFindUniqueArgs} args - Arguments to find a RealEstateAgent
     * @example
     * // Get one RealEstateAgent
     * const realEstateAgent = await prisma.realEstateAgent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RealEstateAgentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgentFindUniqueArgs<ExtArgs>>
    ): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RealEstateAgent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RealEstateAgentFindUniqueOrThrowArgs} args - Arguments to find a RealEstateAgent
     * @example
     * // Get one RealEstateAgent
     * const realEstateAgent = await prisma.realEstateAgent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RealEstateAgentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RealEstateAgent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentFindFirstArgs} args - Arguments to find a RealEstateAgent
     * @example
     * // Get one RealEstateAgent
     * const realEstateAgent = await prisma.realEstateAgent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RealEstateAgentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgentFindFirstArgs<ExtArgs>>
    ): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RealEstateAgent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentFindFirstOrThrowArgs} args - Arguments to find a RealEstateAgent
     * @example
     * // Get one RealEstateAgent
     * const realEstateAgent = await prisma.realEstateAgent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RealEstateAgentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RealEstateAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RealEstateAgents
     * const realEstateAgents = await prisma.realEstateAgent.findMany()
     * 
     * // Get first 10 RealEstateAgents
     * const realEstateAgents = await prisma.realEstateAgent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const realEstateAgentWithIdOnly = await prisma.realEstateAgent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RealEstateAgentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RealEstateAgent.
     * @param {RealEstateAgentCreateArgs} args - Arguments to create a RealEstateAgent.
     * @example
     * // Create one RealEstateAgent
     * const RealEstateAgent = await prisma.realEstateAgent.create({
     *   data: {
     *     // ... data to create a RealEstateAgent
     *   }
     * })
     * 
    **/
    create<T extends RealEstateAgentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgentCreateArgs<ExtArgs>>
    ): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RealEstateAgents.
     * @param {RealEstateAgentCreateManyArgs} args - Arguments to create many RealEstateAgents.
     * @example
     * // Create many RealEstateAgents
     * const realEstateAgent = await prisma.realEstateAgent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends RealEstateAgentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RealEstateAgent.
     * @param {RealEstateAgentDeleteArgs} args - Arguments to delete one RealEstateAgent.
     * @example
     * // Delete one RealEstateAgent
     * const RealEstateAgent = await prisma.realEstateAgent.delete({
     *   where: {
     *     // ... filter to delete one RealEstateAgent
     *   }
     * })
     * 
    **/
    delete<T extends RealEstateAgentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgentDeleteArgs<ExtArgs>>
    ): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RealEstateAgent.
     * @param {RealEstateAgentUpdateArgs} args - Arguments to update one RealEstateAgent.
     * @example
     * // Update one RealEstateAgent
     * const realEstateAgent = await prisma.realEstateAgent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RealEstateAgentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgentUpdateArgs<ExtArgs>>
    ): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RealEstateAgents.
     * @param {RealEstateAgentDeleteManyArgs} args - Arguments to filter RealEstateAgents to delete.
     * @example
     * // Delete a few RealEstateAgents
     * const { count } = await prisma.realEstateAgent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RealEstateAgentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RealEstateAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RealEstateAgents
     * const realEstateAgent = await prisma.realEstateAgent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RealEstateAgentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RealEstateAgent.
     * @param {RealEstateAgentUpsertArgs} args - Arguments to update or create a RealEstateAgent.
     * @example
     * // Update or create a RealEstateAgent
     * const realEstateAgent = await prisma.realEstateAgent.upsert({
     *   create: {
     *     // ... data to create a RealEstateAgent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RealEstateAgent we want to update
     *   }
     * })
    **/
    upsert<T extends RealEstateAgentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgentUpsertArgs<ExtArgs>>
    ): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RealEstateAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentCountArgs} args - Arguments to filter RealEstateAgents to count.
     * @example
     * // Count the number of RealEstateAgents
     * const count = await prisma.realEstateAgent.count({
     *   where: {
     *     // ... the filter for the RealEstateAgents we want to count
     *   }
     * })
    **/
    count<T extends RealEstateAgentCountArgs>(
      args?: Subset<T, RealEstateAgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RealEstateAgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RealEstateAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RealEstateAgentAggregateArgs>(args: Subset<T, RealEstateAgentAggregateArgs>): Prisma.PrismaPromise<GetRealEstateAgentAggregateType<T>>

    /**
     * Group by RealEstateAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RealEstateAgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RealEstateAgentGroupByArgs['orderBy'] }
        : { orderBy?: RealEstateAgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RealEstateAgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRealEstateAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RealEstateAgent model
   */
  readonly fields: RealEstateAgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RealEstateAgent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RealEstateAgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    clientContracts<T extends RealEstateAgent$clientContractsArgs<ExtArgs> = {}>(args?: Subset<T, RealEstateAgent$clientContractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    agenciesToRealEstateAgents<T extends RealEstateAgent$agenciesToRealEstateAgentsArgs<ExtArgs> = {}>(args?: Subset<T, RealEstateAgent$agenciesToRealEstateAgentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RealEstateAgent model
   */ 
  interface RealEstateAgentFieldRefs {
    readonly id: FieldRef<"RealEstateAgent", 'Int'>
    readonly fullName: FieldRef<"RealEstateAgent", 'String'>
    readonly phone: FieldRef<"RealEstateAgent", 'String'>
    readonly oneGtId: FieldRef<"RealEstateAgent", 'Int'>
    readonly createdAt: FieldRef<"RealEstateAgent", 'DateTime'>
    readonly updatedAt: FieldRef<"RealEstateAgent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RealEstateAgent findUnique
   */
  export type RealEstateAgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgent to fetch.
     */
    where: RealEstateAgentWhereUniqueInput
  }

  /**
   * RealEstateAgent findUniqueOrThrow
   */
  export type RealEstateAgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgent to fetch.
     */
    where: RealEstateAgentWhereUniqueInput
  }

  /**
   * RealEstateAgent findFirst
   */
  export type RealEstateAgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgent to fetch.
     */
    where?: RealEstateAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgents to fetch.
     */
    orderBy?: RealEstateAgentOrderByWithRelationInput | RealEstateAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealEstateAgents.
     */
    cursor?: RealEstateAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealEstateAgents.
     */
    distinct?: RealEstateAgentScalarFieldEnum | RealEstateAgentScalarFieldEnum[]
  }

  /**
   * RealEstateAgent findFirstOrThrow
   */
  export type RealEstateAgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgent to fetch.
     */
    where?: RealEstateAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgents to fetch.
     */
    orderBy?: RealEstateAgentOrderByWithRelationInput | RealEstateAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealEstateAgents.
     */
    cursor?: RealEstateAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealEstateAgents.
     */
    distinct?: RealEstateAgentScalarFieldEnum | RealEstateAgentScalarFieldEnum[]
  }

  /**
   * RealEstateAgent findMany
   */
  export type RealEstateAgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgents to fetch.
     */
    where?: RealEstateAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgents to fetch.
     */
    orderBy?: RealEstateAgentOrderByWithRelationInput | RealEstateAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RealEstateAgents.
     */
    cursor?: RealEstateAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgents.
     */
    skip?: number
    distinct?: RealEstateAgentScalarFieldEnum | RealEstateAgentScalarFieldEnum[]
  }

  /**
   * RealEstateAgent create
   */
  export type RealEstateAgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    /**
     * The data needed to create a RealEstateAgent.
     */
    data: XOR<RealEstateAgentCreateInput, RealEstateAgentUncheckedCreateInput>
  }

  /**
   * RealEstateAgent createMany
   */
  export type RealEstateAgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RealEstateAgents.
     */
    data: RealEstateAgentCreateManyInput | RealEstateAgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RealEstateAgent update
   */
  export type RealEstateAgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    /**
     * The data needed to update a RealEstateAgent.
     */
    data: XOR<RealEstateAgentUpdateInput, RealEstateAgentUncheckedUpdateInput>
    /**
     * Choose, which RealEstateAgent to update.
     */
    where: RealEstateAgentWhereUniqueInput
  }

  /**
   * RealEstateAgent updateMany
   */
  export type RealEstateAgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RealEstateAgents.
     */
    data: XOR<RealEstateAgentUpdateManyMutationInput, RealEstateAgentUncheckedUpdateManyInput>
    /**
     * Filter which RealEstateAgents to update
     */
    where?: RealEstateAgentWhereInput
  }

  /**
   * RealEstateAgent upsert
   */
  export type RealEstateAgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    /**
     * The filter to search for the RealEstateAgent to update in case it exists.
     */
    where: RealEstateAgentWhereUniqueInput
    /**
     * In case the RealEstateAgent found by the `where` argument doesn't exist, create a new RealEstateAgent with this data.
     */
    create: XOR<RealEstateAgentCreateInput, RealEstateAgentUncheckedCreateInput>
    /**
     * In case the RealEstateAgent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RealEstateAgentUpdateInput, RealEstateAgentUncheckedUpdateInput>
  }

  /**
   * RealEstateAgent delete
   */
  export type RealEstateAgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter which RealEstateAgent to delete.
     */
    where: RealEstateAgentWhereUniqueInput
  }

  /**
   * RealEstateAgent deleteMany
   */
  export type RealEstateAgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RealEstateAgents to delete
     */
    where?: RealEstateAgentWhereInput
  }

  /**
   * RealEstateAgent.clientContracts
   */
  export type RealEstateAgent$clientContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    where?: ClientContractWhereInput
    orderBy?: ClientContractOrderByWithRelationInput | ClientContractOrderByWithRelationInput[]
    cursor?: ClientContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientContractScalarFieldEnum | ClientContractScalarFieldEnum[]
  }

  /**
   * RealEstateAgent.agenciesToRealEstateAgents
   */
  export type RealEstateAgent$agenciesToRealEstateAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    where?: AgencyToRealEstateAgentWhereInput
    orderBy?: AgencyToRealEstateAgentOrderByWithRelationInput | AgencyToRealEstateAgentOrderByWithRelationInput[]
    cursor?: AgencyToRealEstateAgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyToRealEstateAgentScalarFieldEnum | AgencyToRealEstateAgentScalarFieldEnum[]
  }

  /**
   * RealEstateAgent without action
   */
  export type RealEstateAgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgent
     */
    select?: RealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgentInclude<ExtArgs> | null
  }


  /**
   * Model AgencyToRealEstateAgent
   */

  export type AggregateAgencyToRealEstateAgent = {
    _count: AgencyToRealEstateAgentCountAggregateOutputType | null
    _avg: AgencyToRealEstateAgentAvgAggregateOutputType | null
    _sum: AgencyToRealEstateAgentSumAggregateOutputType | null
    _min: AgencyToRealEstateAgentMinAggregateOutputType | null
    _max: AgencyToRealEstateAgentMaxAggregateOutputType | null
  }

  export type AgencyToRealEstateAgentAvgAggregateOutputType = {
    agencyId: number | null
    realEstateAgentId: number | null
  }

  export type AgencyToRealEstateAgentSumAggregateOutputType = {
    agencyId: number | null
    realEstateAgentId: number | null
  }

  export type AgencyToRealEstateAgentMinAggregateOutputType = {
    agencyId: number | null
    realEstateAgentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyToRealEstateAgentMaxAggregateOutputType = {
    agencyId: number | null
    realEstateAgentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyToRealEstateAgentCountAggregateOutputType = {
    agencyId: number
    realEstateAgentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgencyToRealEstateAgentAvgAggregateInputType = {
    agencyId?: true
    realEstateAgentId?: true
  }

  export type AgencyToRealEstateAgentSumAggregateInputType = {
    agencyId?: true
    realEstateAgentId?: true
  }

  export type AgencyToRealEstateAgentMinAggregateInputType = {
    agencyId?: true
    realEstateAgentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyToRealEstateAgentMaxAggregateInputType = {
    agencyId?: true
    realEstateAgentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyToRealEstateAgentCountAggregateInputType = {
    agencyId?: true
    realEstateAgentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencyToRealEstateAgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyToRealEstateAgent to aggregate.
     */
    where?: AgencyToRealEstateAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyToRealEstateAgents to fetch.
     */
    orderBy?: AgencyToRealEstateAgentOrderByWithRelationInput | AgencyToRealEstateAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyToRealEstateAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyToRealEstateAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyToRealEstateAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyToRealEstateAgents
    **/
    _count?: true | AgencyToRealEstateAgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyToRealEstateAgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencyToRealEstateAgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyToRealEstateAgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyToRealEstateAgentMaxAggregateInputType
  }

  export type GetAgencyToRealEstateAgentAggregateType<T extends AgencyToRealEstateAgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyToRealEstateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyToRealEstateAgent[P]>
      : GetScalarType<T[P], AggregateAgencyToRealEstateAgent[P]>
  }




  export type AgencyToRealEstateAgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyToRealEstateAgentWhereInput
    orderBy?: AgencyToRealEstateAgentOrderByWithAggregationInput | AgencyToRealEstateAgentOrderByWithAggregationInput[]
    by: AgencyToRealEstateAgentScalarFieldEnum[] | AgencyToRealEstateAgentScalarFieldEnum
    having?: AgencyToRealEstateAgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyToRealEstateAgentCountAggregateInputType | true
    _avg?: AgencyToRealEstateAgentAvgAggregateInputType
    _sum?: AgencyToRealEstateAgentSumAggregateInputType
    _min?: AgencyToRealEstateAgentMinAggregateInputType
    _max?: AgencyToRealEstateAgentMaxAggregateInputType
  }

  export type AgencyToRealEstateAgentGroupByOutputType = {
    agencyId: number
    realEstateAgentId: number
    createdAt: Date
    updatedAt: Date
    _count: AgencyToRealEstateAgentCountAggregateOutputType | null
    _avg: AgencyToRealEstateAgentAvgAggregateOutputType | null
    _sum: AgencyToRealEstateAgentSumAggregateOutputType | null
    _min: AgencyToRealEstateAgentMinAggregateOutputType | null
    _max: AgencyToRealEstateAgentMaxAggregateOutputType | null
  }

  type GetAgencyToRealEstateAgentGroupByPayload<T extends AgencyToRealEstateAgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyToRealEstateAgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyToRealEstateAgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyToRealEstateAgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyToRealEstateAgentGroupByOutputType[P]>
        }
      >
    >


  export type AgencyToRealEstateAgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    agencyId?: boolean
    realEstateAgentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    realEstateAgent?: boolean | RealEstateAgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyToRealEstateAgent"]>


  export type AgencyToRealEstateAgentSelectScalar = {
    agencyId?: boolean
    realEstateAgentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgencyToRealEstateAgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    realEstateAgent?: boolean | RealEstateAgentDefaultArgs<ExtArgs>
  }

  export type $AgencyToRealEstateAgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyToRealEstateAgent"
    objects: {
      agency: Prisma.$AgencyPayload<ExtArgs>
      realEstateAgent: Prisma.$RealEstateAgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      agencyId: number
      realEstateAgentId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agencyToRealEstateAgent"]>
    composites: {}
  }

  type AgencyToRealEstateAgentGetPayload<S extends boolean | null | undefined | AgencyToRealEstateAgentDefaultArgs> = $Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload, S>

  type AgencyToRealEstateAgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgencyToRealEstateAgentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgencyToRealEstateAgentCountAggregateInputType | true
    }

  export interface AgencyToRealEstateAgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyToRealEstateAgent'], meta: { name: 'AgencyToRealEstateAgent' } }
    /**
     * Find zero or one AgencyToRealEstateAgent that matches the filter.
     * @param {AgencyToRealEstateAgentFindUniqueArgs} args - Arguments to find a AgencyToRealEstateAgent
     * @example
     * // Get one AgencyToRealEstateAgent
     * const agencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgencyToRealEstateAgentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyToRealEstateAgentFindUniqueArgs<ExtArgs>>
    ): Prisma__AgencyToRealEstateAgentClient<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AgencyToRealEstateAgent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgencyToRealEstateAgentFindUniqueOrThrowArgs} args - Arguments to find a AgencyToRealEstateAgent
     * @example
     * // Get one AgencyToRealEstateAgent
     * const agencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgencyToRealEstateAgentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyToRealEstateAgentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyToRealEstateAgentClient<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AgencyToRealEstateAgent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyToRealEstateAgentFindFirstArgs} args - Arguments to find a AgencyToRealEstateAgent
     * @example
     * // Get one AgencyToRealEstateAgent
     * const agencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgencyToRealEstateAgentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyToRealEstateAgentFindFirstArgs<ExtArgs>>
    ): Prisma__AgencyToRealEstateAgentClient<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AgencyToRealEstateAgent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyToRealEstateAgentFindFirstOrThrowArgs} args - Arguments to find a AgencyToRealEstateAgent
     * @example
     * // Get one AgencyToRealEstateAgent
     * const agencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgencyToRealEstateAgentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyToRealEstateAgentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AgencyToRealEstateAgentClient<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AgencyToRealEstateAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyToRealEstateAgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyToRealEstateAgents
     * const agencyToRealEstateAgents = await prisma.agencyToRealEstateAgent.findMany()
     * 
     * // Get first 10 AgencyToRealEstateAgents
     * const agencyToRealEstateAgents = await prisma.agencyToRealEstateAgent.findMany({ take: 10 })
     * 
     * // Only select the `agencyId`
     * const agencyToRealEstateAgentWithAgencyIdOnly = await prisma.agencyToRealEstateAgent.findMany({ select: { agencyId: true } })
     * 
    **/
    findMany<T extends AgencyToRealEstateAgentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyToRealEstateAgentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AgencyToRealEstateAgent.
     * @param {AgencyToRealEstateAgentCreateArgs} args - Arguments to create a AgencyToRealEstateAgent.
     * @example
     * // Create one AgencyToRealEstateAgent
     * const AgencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.create({
     *   data: {
     *     // ... data to create a AgencyToRealEstateAgent
     *   }
     * })
     * 
    **/
    create<T extends AgencyToRealEstateAgentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyToRealEstateAgentCreateArgs<ExtArgs>>
    ): Prisma__AgencyToRealEstateAgentClient<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AgencyToRealEstateAgents.
     * @param {AgencyToRealEstateAgentCreateManyArgs} args - Arguments to create many AgencyToRealEstateAgents.
     * @example
     * // Create many AgencyToRealEstateAgents
     * const agencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AgencyToRealEstateAgentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyToRealEstateAgentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgencyToRealEstateAgent.
     * @param {AgencyToRealEstateAgentDeleteArgs} args - Arguments to delete one AgencyToRealEstateAgent.
     * @example
     * // Delete one AgencyToRealEstateAgent
     * const AgencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.delete({
     *   where: {
     *     // ... filter to delete one AgencyToRealEstateAgent
     *   }
     * })
     * 
    **/
    delete<T extends AgencyToRealEstateAgentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyToRealEstateAgentDeleteArgs<ExtArgs>>
    ): Prisma__AgencyToRealEstateAgentClient<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AgencyToRealEstateAgent.
     * @param {AgencyToRealEstateAgentUpdateArgs} args - Arguments to update one AgencyToRealEstateAgent.
     * @example
     * // Update one AgencyToRealEstateAgent
     * const agencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgencyToRealEstateAgentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyToRealEstateAgentUpdateArgs<ExtArgs>>
    ): Prisma__AgencyToRealEstateAgentClient<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AgencyToRealEstateAgents.
     * @param {AgencyToRealEstateAgentDeleteManyArgs} args - Arguments to filter AgencyToRealEstateAgents to delete.
     * @example
     * // Delete a few AgencyToRealEstateAgents
     * const { count } = await prisma.agencyToRealEstateAgent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgencyToRealEstateAgentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgencyToRealEstateAgentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyToRealEstateAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyToRealEstateAgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyToRealEstateAgents
     * const agencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgencyToRealEstateAgentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyToRealEstateAgentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgencyToRealEstateAgent.
     * @param {AgencyToRealEstateAgentUpsertArgs} args - Arguments to update or create a AgencyToRealEstateAgent.
     * @example
     * // Update or create a AgencyToRealEstateAgent
     * const agencyToRealEstateAgent = await prisma.agencyToRealEstateAgent.upsert({
     *   create: {
     *     // ... data to create a AgencyToRealEstateAgent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyToRealEstateAgent we want to update
     *   }
     * })
    **/
    upsert<T extends AgencyToRealEstateAgentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AgencyToRealEstateAgentUpsertArgs<ExtArgs>>
    ): Prisma__AgencyToRealEstateAgentClient<$Result.GetResult<Prisma.$AgencyToRealEstateAgentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AgencyToRealEstateAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyToRealEstateAgentCountArgs} args - Arguments to filter AgencyToRealEstateAgents to count.
     * @example
     * // Count the number of AgencyToRealEstateAgents
     * const count = await prisma.agencyToRealEstateAgent.count({
     *   where: {
     *     // ... the filter for the AgencyToRealEstateAgents we want to count
     *   }
     * })
    **/
    count<T extends AgencyToRealEstateAgentCountArgs>(
      args?: Subset<T, AgencyToRealEstateAgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyToRealEstateAgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyToRealEstateAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyToRealEstateAgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyToRealEstateAgentAggregateArgs>(args: Subset<T, AgencyToRealEstateAgentAggregateArgs>): Prisma.PrismaPromise<GetAgencyToRealEstateAgentAggregateType<T>>

    /**
     * Group by AgencyToRealEstateAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyToRealEstateAgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyToRealEstateAgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyToRealEstateAgentGroupByArgs['orderBy'] }
        : { orderBy?: AgencyToRealEstateAgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyToRealEstateAgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyToRealEstateAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyToRealEstateAgent model
   */
  readonly fields: AgencyToRealEstateAgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyToRealEstateAgent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyToRealEstateAgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    realEstateAgent<T extends RealEstateAgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RealEstateAgentDefaultArgs<ExtArgs>>): Prisma__RealEstateAgentClient<$Result.GetResult<Prisma.$RealEstateAgentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AgencyToRealEstateAgent model
   */ 
  interface AgencyToRealEstateAgentFieldRefs {
    readonly agencyId: FieldRef<"AgencyToRealEstateAgent", 'Int'>
    readonly realEstateAgentId: FieldRef<"AgencyToRealEstateAgent", 'Int'>
    readonly createdAt: FieldRef<"AgencyToRealEstateAgent", 'DateTime'>
    readonly updatedAt: FieldRef<"AgencyToRealEstateAgent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgencyToRealEstateAgent findUnique
   */
  export type AgencyToRealEstateAgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which AgencyToRealEstateAgent to fetch.
     */
    where: AgencyToRealEstateAgentWhereUniqueInput
  }

  /**
   * AgencyToRealEstateAgent findUniqueOrThrow
   */
  export type AgencyToRealEstateAgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which AgencyToRealEstateAgent to fetch.
     */
    where: AgencyToRealEstateAgentWhereUniqueInput
  }

  /**
   * AgencyToRealEstateAgent findFirst
   */
  export type AgencyToRealEstateAgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which AgencyToRealEstateAgent to fetch.
     */
    where?: AgencyToRealEstateAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyToRealEstateAgents to fetch.
     */
    orderBy?: AgencyToRealEstateAgentOrderByWithRelationInput | AgencyToRealEstateAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyToRealEstateAgents.
     */
    cursor?: AgencyToRealEstateAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyToRealEstateAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyToRealEstateAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyToRealEstateAgents.
     */
    distinct?: AgencyToRealEstateAgentScalarFieldEnum | AgencyToRealEstateAgentScalarFieldEnum[]
  }

  /**
   * AgencyToRealEstateAgent findFirstOrThrow
   */
  export type AgencyToRealEstateAgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which AgencyToRealEstateAgent to fetch.
     */
    where?: AgencyToRealEstateAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyToRealEstateAgents to fetch.
     */
    orderBy?: AgencyToRealEstateAgentOrderByWithRelationInput | AgencyToRealEstateAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyToRealEstateAgents.
     */
    cursor?: AgencyToRealEstateAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyToRealEstateAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyToRealEstateAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyToRealEstateAgents.
     */
    distinct?: AgencyToRealEstateAgentScalarFieldEnum | AgencyToRealEstateAgentScalarFieldEnum[]
  }

  /**
   * AgencyToRealEstateAgent findMany
   */
  export type AgencyToRealEstateAgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter, which AgencyToRealEstateAgents to fetch.
     */
    where?: AgencyToRealEstateAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyToRealEstateAgents to fetch.
     */
    orderBy?: AgencyToRealEstateAgentOrderByWithRelationInput | AgencyToRealEstateAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyToRealEstateAgents.
     */
    cursor?: AgencyToRealEstateAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyToRealEstateAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyToRealEstateAgents.
     */
    skip?: number
    distinct?: AgencyToRealEstateAgentScalarFieldEnum | AgencyToRealEstateAgentScalarFieldEnum[]
  }

  /**
   * AgencyToRealEstateAgent create
   */
  export type AgencyToRealEstateAgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyToRealEstateAgent.
     */
    data: XOR<AgencyToRealEstateAgentCreateInput, AgencyToRealEstateAgentUncheckedCreateInput>
  }

  /**
   * AgencyToRealEstateAgent createMany
   */
  export type AgencyToRealEstateAgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyToRealEstateAgents.
     */
    data: AgencyToRealEstateAgentCreateManyInput | AgencyToRealEstateAgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyToRealEstateAgent update
   */
  export type AgencyToRealEstateAgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyToRealEstateAgent.
     */
    data: XOR<AgencyToRealEstateAgentUpdateInput, AgencyToRealEstateAgentUncheckedUpdateInput>
    /**
     * Choose, which AgencyToRealEstateAgent to update.
     */
    where: AgencyToRealEstateAgentWhereUniqueInput
  }

  /**
   * AgencyToRealEstateAgent updateMany
   */
  export type AgencyToRealEstateAgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyToRealEstateAgents.
     */
    data: XOR<AgencyToRealEstateAgentUpdateManyMutationInput, AgencyToRealEstateAgentUncheckedUpdateManyInput>
    /**
     * Filter which AgencyToRealEstateAgents to update
     */
    where?: AgencyToRealEstateAgentWhereInput
  }

  /**
   * AgencyToRealEstateAgent upsert
   */
  export type AgencyToRealEstateAgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyToRealEstateAgent to update in case it exists.
     */
    where: AgencyToRealEstateAgentWhereUniqueInput
    /**
     * In case the AgencyToRealEstateAgent found by the `where` argument doesn't exist, create a new AgencyToRealEstateAgent with this data.
     */
    create: XOR<AgencyToRealEstateAgentCreateInput, AgencyToRealEstateAgentUncheckedCreateInput>
    /**
     * In case the AgencyToRealEstateAgent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyToRealEstateAgentUpdateInput, AgencyToRealEstateAgentUncheckedUpdateInput>
  }

  /**
   * AgencyToRealEstateAgent delete
   */
  export type AgencyToRealEstateAgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
    /**
     * Filter which AgencyToRealEstateAgent to delete.
     */
    where: AgencyToRealEstateAgentWhereUniqueInput
  }

  /**
   * AgencyToRealEstateAgent deleteMany
   */
  export type AgencyToRealEstateAgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyToRealEstateAgents to delete
     */
    where?: AgencyToRealEstateAgentWhereInput
  }

  /**
   * AgencyToRealEstateAgent without action
   */
  export type AgencyToRealEstateAgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyToRealEstateAgent
     */
    select?: AgencyToRealEstateAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyToRealEstateAgentInclude<ExtArgs> | null
  }


  /**
   * Model Entity
   */

  export type AggregateEntity = {
    _count: EntityCountAggregateOutputType | null
    _avg: EntityAvgAggregateOutputType | null
    _sum: EntitySumAggregateOutputType | null
    _min: EntityMinAggregateOutputType | null
    _max: EntityMaxAggregateOutputType | null
  }

  export type EntityAvgAggregateOutputType = {
    id: number | null
    commonDbEntitiesId: number | null
    commonContractorId: number | null
  }

  export type EntitySumAggregateOutputType = {
    id: number | null
    commonDbEntitiesId: number | null
    commonContractorId: number | null
  }

  export type EntityMinAggregateOutputType = {
    id: number | null
    commonDbEntitiesId: number | null
    commonContractorId: number | null
    name: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EntityMaxAggregateOutputType = {
    id: number | null
    commonDbEntitiesId: number | null
    commonContractorId: number | null
    name: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EntityCountAggregateOutputType = {
    id: number
    commonDbEntitiesId: number
    commonContractorId: number
    name: number
    website: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EntityAvgAggregateInputType = {
    id?: true
    commonDbEntitiesId?: true
    commonContractorId?: true
  }

  export type EntitySumAggregateInputType = {
    id?: true
    commonDbEntitiesId?: true
    commonContractorId?: true
  }

  export type EntityMinAggregateInputType = {
    id?: true
    commonDbEntitiesId?: true
    commonContractorId?: true
    name?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EntityMaxAggregateInputType = {
    id?: true
    commonDbEntitiesId?: true
    commonContractorId?: true
    name?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EntityCountAggregateInputType = {
    id?: true
    commonDbEntitiesId?: true
    commonContractorId?: true
    name?: true
    website?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EntityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entity to aggregate.
     */
    where?: EntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entities to fetch.
     */
    orderBy?: EntityOrderByWithRelationInput | EntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Entities
    **/
    _count?: true | EntityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntityMaxAggregateInputType
  }

  export type GetEntityAggregateType<T extends EntityAggregateArgs> = {
        [P in keyof T & keyof AggregateEntity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntity[P]>
      : GetScalarType<T[P], AggregateEntity[P]>
  }




  export type EntityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityWhereInput
    orderBy?: EntityOrderByWithAggregationInput | EntityOrderByWithAggregationInput[]
    by: EntityScalarFieldEnum[] | EntityScalarFieldEnum
    having?: EntityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntityCountAggregateInputType | true
    _avg?: EntityAvgAggregateInputType
    _sum?: EntitySumAggregateInputType
    _min?: EntityMinAggregateInputType
    _max?: EntityMaxAggregateInputType
  }

  export type EntityGroupByOutputType = {
    id: number
    commonDbEntitiesId: number
    commonContractorId: number | null
    name: string
    website: string | null
    createdAt: Date
    updatedAt: Date
    _count: EntityCountAggregateOutputType | null
    _avg: EntityAvgAggregateOutputType | null
    _sum: EntitySumAggregateOutputType | null
    _min: EntityMinAggregateOutputType | null
    _max: EntityMaxAggregateOutputType | null
  }

  type GetEntityGroupByPayload<T extends EntityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntityGroupByOutputType[P]>
            : GetScalarType<T[P], EntityGroupByOutputType[P]>
        }
      >
    >


  export type EntitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commonDbEntitiesId?: boolean
    commonContractorId?: boolean
    name?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agencyContracts?: boolean | Entity$agencyContractsArgs<ExtArgs>
    objects?: boolean | Entity$objectsArgs<ExtArgs>
    entityForbiddenWebsites?: boolean | Entity$entityForbiddenWebsitesArgs<ExtArgs>
    entityForbiddenBrands?: boolean | Entity$entityForbiddenBrandsArgs<ExtArgs>
    _count?: boolean | EntityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entity"]>


  export type EntitySelectScalar = {
    id?: boolean
    commonDbEntitiesId?: boolean
    commonContractorId?: boolean
    name?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EntityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agencyContracts?: boolean | Entity$agencyContractsArgs<ExtArgs>
    objects?: boolean | Entity$objectsArgs<ExtArgs>
    entityForbiddenWebsites?: boolean | Entity$entityForbiddenWebsitesArgs<ExtArgs>
    entityForbiddenBrands?: boolean | Entity$entityForbiddenBrandsArgs<ExtArgs>
    _count?: boolean | EntityCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EntityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Entity"
    objects: {
      agencyContracts: Prisma.$AgencyContractPayload<ExtArgs>[]
      objects: Prisma.$ObjectPayload<ExtArgs>[]
      entityForbiddenWebsites: Prisma.$EntityForbiddenWebsitePayload<ExtArgs>[]
      entityForbiddenBrands: Prisma.$EntityForbiddenBrandPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      commonDbEntitiesId: number
      commonContractorId: number | null
      name: string
      website: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["entity"]>
    composites: {}
  }

  type EntityGetPayload<S extends boolean | null | undefined | EntityDefaultArgs> = $Result.GetResult<Prisma.$EntityPayload, S>

  type EntityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EntityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntityCountAggregateInputType | true
    }

  export interface EntityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Entity'], meta: { name: 'Entity' } }
    /**
     * Find zero or one Entity that matches the filter.
     * @param {EntityFindUniqueArgs} args - Arguments to find a Entity
     * @example
     * // Get one Entity
     * const entity = await prisma.entity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EntityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EntityFindUniqueArgs<ExtArgs>>
    ): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Entity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EntityFindUniqueOrThrowArgs} args - Arguments to find a Entity
     * @example
     * // Get one Entity
     * const entity = await prisma.entity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EntityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Entity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityFindFirstArgs} args - Arguments to find a Entity
     * @example
     * // Get one Entity
     * const entity = await prisma.entity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EntityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityFindFirstArgs<ExtArgs>>
    ): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Entity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityFindFirstOrThrowArgs} args - Arguments to find a Entity
     * @example
     * // Get one Entity
     * const entity = await prisma.entity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EntityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Entities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entities
     * const entities = await prisma.entity.findMany()
     * 
     * // Get first 10 Entities
     * const entities = await prisma.entity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entityWithIdOnly = await prisma.entity.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EntityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Entity.
     * @param {EntityCreateArgs} args - Arguments to create a Entity.
     * @example
     * // Create one Entity
     * const Entity = await prisma.entity.create({
     *   data: {
     *     // ... data to create a Entity
     *   }
     * })
     * 
    **/
    create<T extends EntityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EntityCreateArgs<ExtArgs>>
    ): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Entities.
     * @param {EntityCreateManyArgs} args - Arguments to create many Entities.
     * @example
     * // Create many Entities
     * const entity = await prisma.entity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends EntityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Entity.
     * @param {EntityDeleteArgs} args - Arguments to delete one Entity.
     * @example
     * // Delete one Entity
     * const Entity = await prisma.entity.delete({
     *   where: {
     *     // ... filter to delete one Entity
     *   }
     * })
     * 
    **/
    delete<T extends EntityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EntityDeleteArgs<ExtArgs>>
    ): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Entity.
     * @param {EntityUpdateArgs} args - Arguments to update one Entity.
     * @example
     * // Update one Entity
     * const entity = await prisma.entity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EntityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EntityUpdateArgs<ExtArgs>>
    ): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Entities.
     * @param {EntityDeleteManyArgs} args - Arguments to filter Entities to delete.
     * @example
     * // Delete a few Entities
     * const { count } = await prisma.entity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EntityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entities
     * const entity = await prisma.entity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EntityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EntityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entity.
     * @param {EntityUpsertArgs} args - Arguments to update or create a Entity.
     * @example
     * // Update or create a Entity
     * const entity = await prisma.entity.upsert({
     *   create: {
     *     // ... data to create a Entity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entity we want to update
     *   }
     * })
    **/
    upsert<T extends EntityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EntityUpsertArgs<ExtArgs>>
    ): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityCountArgs} args - Arguments to filter Entities to count.
     * @example
     * // Count the number of Entities
     * const count = await prisma.entity.count({
     *   where: {
     *     // ... the filter for the Entities we want to count
     *   }
     * })
    **/
    count<T extends EntityCountArgs>(
      args?: Subset<T, EntityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntityAggregateArgs>(args: Subset<T, EntityAggregateArgs>): Prisma.PrismaPromise<GetEntityAggregateType<T>>

    /**
     * Group by Entity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntityGroupByArgs['orderBy'] }
        : { orderBy?: EntityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Entity model
   */
  readonly fields: EntityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Entity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    agencyContracts<T extends Entity$agencyContractsArgs<ExtArgs> = {}>(args?: Subset<T, Entity$agencyContractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    objects<T extends Entity$objectsArgs<ExtArgs> = {}>(args?: Subset<T, Entity$objectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findMany'> | Null>;

    entityForbiddenWebsites<T extends Entity$entityForbiddenWebsitesArgs<ExtArgs> = {}>(args?: Subset<T, Entity$entityForbiddenWebsitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'findMany'> | Null>;

    entityForbiddenBrands<T extends Entity$entityForbiddenBrandsArgs<ExtArgs> = {}>(args?: Subset<T, Entity$entityForbiddenBrandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Entity model
   */ 
  interface EntityFieldRefs {
    readonly id: FieldRef<"Entity", 'Int'>
    readonly commonDbEntitiesId: FieldRef<"Entity", 'Int'>
    readonly commonContractorId: FieldRef<"Entity", 'Int'>
    readonly name: FieldRef<"Entity", 'String'>
    readonly website: FieldRef<"Entity", 'String'>
    readonly createdAt: FieldRef<"Entity", 'DateTime'>
    readonly updatedAt: FieldRef<"Entity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Entity findUnique
   */
  export type EntityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * Filter, which Entity to fetch.
     */
    where: EntityWhereUniqueInput
  }

  /**
   * Entity findUniqueOrThrow
   */
  export type EntityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * Filter, which Entity to fetch.
     */
    where: EntityWhereUniqueInput
  }

  /**
   * Entity findFirst
   */
  export type EntityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * Filter, which Entity to fetch.
     */
    where?: EntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entities to fetch.
     */
    orderBy?: EntityOrderByWithRelationInput | EntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entities.
     */
    cursor?: EntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entities.
     */
    distinct?: EntityScalarFieldEnum | EntityScalarFieldEnum[]
  }

  /**
   * Entity findFirstOrThrow
   */
  export type EntityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * Filter, which Entity to fetch.
     */
    where?: EntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entities to fetch.
     */
    orderBy?: EntityOrderByWithRelationInput | EntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entities.
     */
    cursor?: EntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entities.
     */
    distinct?: EntityScalarFieldEnum | EntityScalarFieldEnum[]
  }

  /**
   * Entity findMany
   */
  export type EntityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * Filter, which Entities to fetch.
     */
    where?: EntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entities to fetch.
     */
    orderBy?: EntityOrderByWithRelationInput | EntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Entities.
     */
    cursor?: EntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entities.
     */
    skip?: number
    distinct?: EntityScalarFieldEnum | EntityScalarFieldEnum[]
  }

  /**
   * Entity create
   */
  export type EntityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * The data needed to create a Entity.
     */
    data: XOR<EntityCreateInput, EntityUncheckedCreateInput>
  }

  /**
   * Entity createMany
   */
  export type EntityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Entities.
     */
    data: EntityCreateManyInput | EntityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Entity update
   */
  export type EntityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * The data needed to update a Entity.
     */
    data: XOR<EntityUpdateInput, EntityUncheckedUpdateInput>
    /**
     * Choose, which Entity to update.
     */
    where: EntityWhereUniqueInput
  }

  /**
   * Entity updateMany
   */
  export type EntityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Entities.
     */
    data: XOR<EntityUpdateManyMutationInput, EntityUncheckedUpdateManyInput>
    /**
     * Filter which Entities to update
     */
    where?: EntityWhereInput
  }

  /**
   * Entity upsert
   */
  export type EntityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * The filter to search for the Entity to update in case it exists.
     */
    where: EntityWhereUniqueInput
    /**
     * In case the Entity found by the `where` argument doesn't exist, create a new Entity with this data.
     */
    create: XOR<EntityCreateInput, EntityUncheckedCreateInput>
    /**
     * In case the Entity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntityUpdateInput, EntityUncheckedUpdateInput>
  }

  /**
   * Entity delete
   */
  export type EntityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * Filter which Entity to delete.
     */
    where: EntityWhereUniqueInput
  }

  /**
   * Entity deleteMany
   */
  export type EntityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entities to delete
     */
    where?: EntityWhereInput
  }

  /**
   * Entity.agencyContracts
   */
  export type Entity$agencyContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyContract
     */
    select?: AgencyContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyContractInclude<ExtArgs> | null
    where?: AgencyContractWhereInput
    orderBy?: AgencyContractOrderByWithRelationInput | AgencyContractOrderByWithRelationInput[]
    cursor?: AgencyContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyContractScalarFieldEnum | AgencyContractScalarFieldEnum[]
  }

  /**
   * Entity.objects
   */
  export type Entity$objectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    where?: ObjectWhereInput
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    cursor?: ObjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * Entity.entityForbiddenWebsites
   */
  export type Entity$entityForbiddenWebsitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    where?: EntityForbiddenWebsiteWhereInput
    orderBy?: EntityForbiddenWebsiteOrderByWithRelationInput | EntityForbiddenWebsiteOrderByWithRelationInput[]
    cursor?: EntityForbiddenWebsiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntityForbiddenWebsiteScalarFieldEnum | EntityForbiddenWebsiteScalarFieldEnum[]
  }

  /**
   * Entity.entityForbiddenBrands
   */
  export type Entity$entityForbiddenBrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    where?: EntityForbiddenBrandWhereInput
    orderBy?: EntityForbiddenBrandOrderByWithRelationInput | EntityForbiddenBrandOrderByWithRelationInput[]
    cursor?: EntityForbiddenBrandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntityForbiddenBrandScalarFieldEnum | EntityForbiddenBrandScalarFieldEnum[]
  }

  /**
   * Entity without action
   */
  export type EntityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
  }


  /**
   * Model EntityForbiddenWebsite
   */

  export type AggregateEntityForbiddenWebsite = {
    _count: EntityForbiddenWebsiteCountAggregateOutputType | null
    _avg: EntityForbiddenWebsiteAvgAggregateOutputType | null
    _sum: EntityForbiddenWebsiteSumAggregateOutputType | null
    _min: EntityForbiddenWebsiteMinAggregateOutputType | null
    _max: EntityForbiddenWebsiteMaxAggregateOutputType | null
  }

  export type EntityForbiddenWebsiteAvgAggregateOutputType = {
    id: number | null
    entityId: number | null
  }

  export type EntityForbiddenWebsiteSumAggregateOutputType = {
    id: number | null
    entityId: number | null
  }

  export type EntityForbiddenWebsiteMinAggregateOutputType = {
    id: number | null
    name: string | null
    entityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EntityForbiddenWebsiteMaxAggregateOutputType = {
    id: number | null
    name: string | null
    entityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EntityForbiddenWebsiteCountAggregateOutputType = {
    id: number
    name: number
    entityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EntityForbiddenWebsiteAvgAggregateInputType = {
    id?: true
    entityId?: true
  }

  export type EntityForbiddenWebsiteSumAggregateInputType = {
    id?: true
    entityId?: true
  }

  export type EntityForbiddenWebsiteMinAggregateInputType = {
    id?: true
    name?: true
    entityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EntityForbiddenWebsiteMaxAggregateInputType = {
    id?: true
    name?: true
    entityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EntityForbiddenWebsiteCountAggregateInputType = {
    id?: true
    name?: true
    entityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EntityForbiddenWebsiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntityForbiddenWebsite to aggregate.
     */
    where?: EntityForbiddenWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityForbiddenWebsites to fetch.
     */
    orderBy?: EntityForbiddenWebsiteOrderByWithRelationInput | EntityForbiddenWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntityForbiddenWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityForbiddenWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityForbiddenWebsites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EntityForbiddenWebsites
    **/
    _count?: true | EntityForbiddenWebsiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntityForbiddenWebsiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntityForbiddenWebsiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntityForbiddenWebsiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntityForbiddenWebsiteMaxAggregateInputType
  }

  export type GetEntityForbiddenWebsiteAggregateType<T extends EntityForbiddenWebsiteAggregateArgs> = {
        [P in keyof T & keyof AggregateEntityForbiddenWebsite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntityForbiddenWebsite[P]>
      : GetScalarType<T[P], AggregateEntityForbiddenWebsite[P]>
  }




  export type EntityForbiddenWebsiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityForbiddenWebsiteWhereInput
    orderBy?: EntityForbiddenWebsiteOrderByWithAggregationInput | EntityForbiddenWebsiteOrderByWithAggregationInput[]
    by: EntityForbiddenWebsiteScalarFieldEnum[] | EntityForbiddenWebsiteScalarFieldEnum
    having?: EntityForbiddenWebsiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntityForbiddenWebsiteCountAggregateInputType | true
    _avg?: EntityForbiddenWebsiteAvgAggregateInputType
    _sum?: EntityForbiddenWebsiteSumAggregateInputType
    _min?: EntityForbiddenWebsiteMinAggregateInputType
    _max?: EntityForbiddenWebsiteMaxAggregateInputType
  }

  export type EntityForbiddenWebsiteGroupByOutputType = {
    id: number
    name: string
    entityId: number
    createdAt: Date
    updatedAt: Date
    _count: EntityForbiddenWebsiteCountAggregateOutputType | null
    _avg: EntityForbiddenWebsiteAvgAggregateOutputType | null
    _sum: EntityForbiddenWebsiteSumAggregateOutputType | null
    _min: EntityForbiddenWebsiteMinAggregateOutputType | null
    _max: EntityForbiddenWebsiteMaxAggregateOutputType | null
  }

  type GetEntityForbiddenWebsiteGroupByPayload<T extends EntityForbiddenWebsiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntityForbiddenWebsiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntityForbiddenWebsiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntityForbiddenWebsiteGroupByOutputType[P]>
            : GetScalarType<T[P], EntityForbiddenWebsiteGroupByOutputType[P]>
        }
      >
    >


  export type EntityForbiddenWebsiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    entityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entity?: boolean | EntityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entityForbiddenWebsite"]>


  export type EntityForbiddenWebsiteSelectScalar = {
    id?: boolean
    name?: boolean
    entityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EntityForbiddenWebsiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entity?: boolean | EntityDefaultArgs<ExtArgs>
  }

  export type $EntityForbiddenWebsitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EntityForbiddenWebsite"
    objects: {
      entity: Prisma.$EntityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      entityId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["entityForbiddenWebsite"]>
    composites: {}
  }

  type EntityForbiddenWebsiteGetPayload<S extends boolean | null | undefined | EntityForbiddenWebsiteDefaultArgs> = $Result.GetResult<Prisma.$EntityForbiddenWebsitePayload, S>

  type EntityForbiddenWebsiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EntityForbiddenWebsiteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntityForbiddenWebsiteCountAggregateInputType | true
    }

  export interface EntityForbiddenWebsiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EntityForbiddenWebsite'], meta: { name: 'EntityForbiddenWebsite' } }
    /**
     * Find zero or one EntityForbiddenWebsite that matches the filter.
     * @param {EntityForbiddenWebsiteFindUniqueArgs} args - Arguments to find a EntityForbiddenWebsite
     * @example
     * // Get one EntityForbiddenWebsite
     * const entityForbiddenWebsite = await prisma.entityForbiddenWebsite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EntityForbiddenWebsiteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenWebsiteFindUniqueArgs<ExtArgs>>
    ): Prisma__EntityForbiddenWebsiteClient<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EntityForbiddenWebsite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EntityForbiddenWebsiteFindUniqueOrThrowArgs} args - Arguments to find a EntityForbiddenWebsite
     * @example
     * // Get one EntityForbiddenWebsite
     * const entityForbiddenWebsite = await prisma.entityForbiddenWebsite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EntityForbiddenWebsiteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenWebsiteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EntityForbiddenWebsiteClient<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EntityForbiddenWebsite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenWebsiteFindFirstArgs} args - Arguments to find a EntityForbiddenWebsite
     * @example
     * // Get one EntityForbiddenWebsite
     * const entityForbiddenWebsite = await prisma.entityForbiddenWebsite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EntityForbiddenWebsiteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenWebsiteFindFirstArgs<ExtArgs>>
    ): Prisma__EntityForbiddenWebsiteClient<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EntityForbiddenWebsite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenWebsiteFindFirstOrThrowArgs} args - Arguments to find a EntityForbiddenWebsite
     * @example
     * // Get one EntityForbiddenWebsite
     * const entityForbiddenWebsite = await prisma.entityForbiddenWebsite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EntityForbiddenWebsiteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenWebsiteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EntityForbiddenWebsiteClient<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EntityForbiddenWebsites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenWebsiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EntityForbiddenWebsites
     * const entityForbiddenWebsites = await prisma.entityForbiddenWebsite.findMany()
     * 
     * // Get first 10 EntityForbiddenWebsites
     * const entityForbiddenWebsites = await prisma.entityForbiddenWebsite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entityForbiddenWebsiteWithIdOnly = await prisma.entityForbiddenWebsite.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EntityForbiddenWebsiteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenWebsiteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EntityForbiddenWebsite.
     * @param {EntityForbiddenWebsiteCreateArgs} args - Arguments to create a EntityForbiddenWebsite.
     * @example
     * // Create one EntityForbiddenWebsite
     * const EntityForbiddenWebsite = await prisma.entityForbiddenWebsite.create({
     *   data: {
     *     // ... data to create a EntityForbiddenWebsite
     *   }
     * })
     * 
    **/
    create<T extends EntityForbiddenWebsiteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenWebsiteCreateArgs<ExtArgs>>
    ): Prisma__EntityForbiddenWebsiteClient<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EntityForbiddenWebsites.
     * @param {EntityForbiddenWebsiteCreateManyArgs} args - Arguments to create many EntityForbiddenWebsites.
     * @example
     * // Create many EntityForbiddenWebsites
     * const entityForbiddenWebsite = await prisma.entityForbiddenWebsite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends EntityForbiddenWebsiteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenWebsiteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EntityForbiddenWebsite.
     * @param {EntityForbiddenWebsiteDeleteArgs} args - Arguments to delete one EntityForbiddenWebsite.
     * @example
     * // Delete one EntityForbiddenWebsite
     * const EntityForbiddenWebsite = await prisma.entityForbiddenWebsite.delete({
     *   where: {
     *     // ... filter to delete one EntityForbiddenWebsite
     *   }
     * })
     * 
    **/
    delete<T extends EntityForbiddenWebsiteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenWebsiteDeleteArgs<ExtArgs>>
    ): Prisma__EntityForbiddenWebsiteClient<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EntityForbiddenWebsite.
     * @param {EntityForbiddenWebsiteUpdateArgs} args - Arguments to update one EntityForbiddenWebsite.
     * @example
     * // Update one EntityForbiddenWebsite
     * const entityForbiddenWebsite = await prisma.entityForbiddenWebsite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EntityForbiddenWebsiteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenWebsiteUpdateArgs<ExtArgs>>
    ): Prisma__EntityForbiddenWebsiteClient<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EntityForbiddenWebsites.
     * @param {EntityForbiddenWebsiteDeleteManyArgs} args - Arguments to filter EntityForbiddenWebsites to delete.
     * @example
     * // Delete a few EntityForbiddenWebsites
     * const { count } = await prisma.entityForbiddenWebsite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EntityForbiddenWebsiteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenWebsiteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EntityForbiddenWebsites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenWebsiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EntityForbiddenWebsites
     * const entityForbiddenWebsite = await prisma.entityForbiddenWebsite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EntityForbiddenWebsiteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenWebsiteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EntityForbiddenWebsite.
     * @param {EntityForbiddenWebsiteUpsertArgs} args - Arguments to update or create a EntityForbiddenWebsite.
     * @example
     * // Update or create a EntityForbiddenWebsite
     * const entityForbiddenWebsite = await prisma.entityForbiddenWebsite.upsert({
     *   create: {
     *     // ... data to create a EntityForbiddenWebsite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EntityForbiddenWebsite we want to update
     *   }
     * })
    **/
    upsert<T extends EntityForbiddenWebsiteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenWebsiteUpsertArgs<ExtArgs>>
    ): Prisma__EntityForbiddenWebsiteClient<$Result.GetResult<Prisma.$EntityForbiddenWebsitePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EntityForbiddenWebsites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenWebsiteCountArgs} args - Arguments to filter EntityForbiddenWebsites to count.
     * @example
     * // Count the number of EntityForbiddenWebsites
     * const count = await prisma.entityForbiddenWebsite.count({
     *   where: {
     *     // ... the filter for the EntityForbiddenWebsites we want to count
     *   }
     * })
    **/
    count<T extends EntityForbiddenWebsiteCountArgs>(
      args?: Subset<T, EntityForbiddenWebsiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntityForbiddenWebsiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EntityForbiddenWebsite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenWebsiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntityForbiddenWebsiteAggregateArgs>(args: Subset<T, EntityForbiddenWebsiteAggregateArgs>): Prisma.PrismaPromise<GetEntityForbiddenWebsiteAggregateType<T>>

    /**
     * Group by EntityForbiddenWebsite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenWebsiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntityForbiddenWebsiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntityForbiddenWebsiteGroupByArgs['orderBy'] }
        : { orderBy?: EntityForbiddenWebsiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntityForbiddenWebsiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityForbiddenWebsiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EntityForbiddenWebsite model
   */
  readonly fields: EntityForbiddenWebsiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EntityForbiddenWebsite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntityForbiddenWebsiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entity<T extends EntityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntityDefaultArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EntityForbiddenWebsite model
   */ 
  interface EntityForbiddenWebsiteFieldRefs {
    readonly id: FieldRef<"EntityForbiddenWebsite", 'Int'>
    readonly name: FieldRef<"EntityForbiddenWebsite", 'String'>
    readonly entityId: FieldRef<"EntityForbiddenWebsite", 'Int'>
    readonly createdAt: FieldRef<"EntityForbiddenWebsite", 'DateTime'>
    readonly updatedAt: FieldRef<"EntityForbiddenWebsite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EntityForbiddenWebsite findUnique
   */
  export type EntityForbiddenWebsiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenWebsite to fetch.
     */
    where: EntityForbiddenWebsiteWhereUniqueInput
  }

  /**
   * EntityForbiddenWebsite findUniqueOrThrow
   */
  export type EntityForbiddenWebsiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenWebsite to fetch.
     */
    where: EntityForbiddenWebsiteWhereUniqueInput
  }

  /**
   * EntityForbiddenWebsite findFirst
   */
  export type EntityForbiddenWebsiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenWebsite to fetch.
     */
    where?: EntityForbiddenWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityForbiddenWebsites to fetch.
     */
    orderBy?: EntityForbiddenWebsiteOrderByWithRelationInput | EntityForbiddenWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityForbiddenWebsites.
     */
    cursor?: EntityForbiddenWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityForbiddenWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityForbiddenWebsites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityForbiddenWebsites.
     */
    distinct?: EntityForbiddenWebsiteScalarFieldEnum | EntityForbiddenWebsiteScalarFieldEnum[]
  }

  /**
   * EntityForbiddenWebsite findFirstOrThrow
   */
  export type EntityForbiddenWebsiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenWebsite to fetch.
     */
    where?: EntityForbiddenWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityForbiddenWebsites to fetch.
     */
    orderBy?: EntityForbiddenWebsiteOrderByWithRelationInput | EntityForbiddenWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityForbiddenWebsites.
     */
    cursor?: EntityForbiddenWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityForbiddenWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityForbiddenWebsites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityForbiddenWebsites.
     */
    distinct?: EntityForbiddenWebsiteScalarFieldEnum | EntityForbiddenWebsiteScalarFieldEnum[]
  }

  /**
   * EntityForbiddenWebsite findMany
   */
  export type EntityForbiddenWebsiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenWebsites to fetch.
     */
    where?: EntityForbiddenWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityForbiddenWebsites to fetch.
     */
    orderBy?: EntityForbiddenWebsiteOrderByWithRelationInput | EntityForbiddenWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EntityForbiddenWebsites.
     */
    cursor?: EntityForbiddenWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityForbiddenWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityForbiddenWebsites.
     */
    skip?: number
    distinct?: EntityForbiddenWebsiteScalarFieldEnum | EntityForbiddenWebsiteScalarFieldEnum[]
  }

  /**
   * EntityForbiddenWebsite create
   */
  export type EntityForbiddenWebsiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    /**
     * The data needed to create a EntityForbiddenWebsite.
     */
    data: XOR<EntityForbiddenWebsiteCreateInput, EntityForbiddenWebsiteUncheckedCreateInput>
  }

  /**
   * EntityForbiddenWebsite createMany
   */
  export type EntityForbiddenWebsiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EntityForbiddenWebsites.
     */
    data: EntityForbiddenWebsiteCreateManyInput | EntityForbiddenWebsiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EntityForbiddenWebsite update
   */
  export type EntityForbiddenWebsiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    /**
     * The data needed to update a EntityForbiddenWebsite.
     */
    data: XOR<EntityForbiddenWebsiteUpdateInput, EntityForbiddenWebsiteUncheckedUpdateInput>
    /**
     * Choose, which EntityForbiddenWebsite to update.
     */
    where: EntityForbiddenWebsiteWhereUniqueInput
  }

  /**
   * EntityForbiddenWebsite updateMany
   */
  export type EntityForbiddenWebsiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EntityForbiddenWebsites.
     */
    data: XOR<EntityForbiddenWebsiteUpdateManyMutationInput, EntityForbiddenWebsiteUncheckedUpdateManyInput>
    /**
     * Filter which EntityForbiddenWebsites to update
     */
    where?: EntityForbiddenWebsiteWhereInput
  }

  /**
   * EntityForbiddenWebsite upsert
   */
  export type EntityForbiddenWebsiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    /**
     * The filter to search for the EntityForbiddenWebsite to update in case it exists.
     */
    where: EntityForbiddenWebsiteWhereUniqueInput
    /**
     * In case the EntityForbiddenWebsite found by the `where` argument doesn't exist, create a new EntityForbiddenWebsite with this data.
     */
    create: XOR<EntityForbiddenWebsiteCreateInput, EntityForbiddenWebsiteUncheckedCreateInput>
    /**
     * In case the EntityForbiddenWebsite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntityForbiddenWebsiteUpdateInput, EntityForbiddenWebsiteUncheckedUpdateInput>
  }

  /**
   * EntityForbiddenWebsite delete
   */
  export type EntityForbiddenWebsiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
    /**
     * Filter which EntityForbiddenWebsite to delete.
     */
    where: EntityForbiddenWebsiteWhereUniqueInput
  }

  /**
   * EntityForbiddenWebsite deleteMany
   */
  export type EntityForbiddenWebsiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntityForbiddenWebsites to delete
     */
    where?: EntityForbiddenWebsiteWhereInput
  }

  /**
   * EntityForbiddenWebsite without action
   */
  export type EntityForbiddenWebsiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenWebsite
     */
    select?: EntityForbiddenWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenWebsiteInclude<ExtArgs> | null
  }


  /**
   * Model EntityForbiddenBrand
   */

  export type AggregateEntityForbiddenBrand = {
    _count: EntityForbiddenBrandCountAggregateOutputType | null
    _avg: EntityForbiddenBrandAvgAggregateOutputType | null
    _sum: EntityForbiddenBrandSumAggregateOutputType | null
    _min: EntityForbiddenBrandMinAggregateOutputType | null
    _max: EntityForbiddenBrandMaxAggregateOutputType | null
  }

  export type EntityForbiddenBrandAvgAggregateOutputType = {
    id: number | null
    entityId: number | null
  }

  export type EntityForbiddenBrandSumAggregateOutputType = {
    id: number | null
    entityId: number | null
  }

  export type EntityForbiddenBrandMinAggregateOutputType = {
    id: number | null
    name: string | null
    entityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EntityForbiddenBrandMaxAggregateOutputType = {
    id: number | null
    name: string | null
    entityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EntityForbiddenBrandCountAggregateOutputType = {
    id: number
    name: number
    entityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EntityForbiddenBrandAvgAggregateInputType = {
    id?: true
    entityId?: true
  }

  export type EntityForbiddenBrandSumAggregateInputType = {
    id?: true
    entityId?: true
  }

  export type EntityForbiddenBrandMinAggregateInputType = {
    id?: true
    name?: true
    entityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EntityForbiddenBrandMaxAggregateInputType = {
    id?: true
    name?: true
    entityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EntityForbiddenBrandCountAggregateInputType = {
    id?: true
    name?: true
    entityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EntityForbiddenBrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntityForbiddenBrand to aggregate.
     */
    where?: EntityForbiddenBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityForbiddenBrands to fetch.
     */
    orderBy?: EntityForbiddenBrandOrderByWithRelationInput | EntityForbiddenBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntityForbiddenBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityForbiddenBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityForbiddenBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EntityForbiddenBrands
    **/
    _count?: true | EntityForbiddenBrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntityForbiddenBrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntityForbiddenBrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntityForbiddenBrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntityForbiddenBrandMaxAggregateInputType
  }

  export type GetEntityForbiddenBrandAggregateType<T extends EntityForbiddenBrandAggregateArgs> = {
        [P in keyof T & keyof AggregateEntityForbiddenBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntityForbiddenBrand[P]>
      : GetScalarType<T[P], AggregateEntityForbiddenBrand[P]>
  }




  export type EntityForbiddenBrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityForbiddenBrandWhereInput
    orderBy?: EntityForbiddenBrandOrderByWithAggregationInput | EntityForbiddenBrandOrderByWithAggregationInput[]
    by: EntityForbiddenBrandScalarFieldEnum[] | EntityForbiddenBrandScalarFieldEnum
    having?: EntityForbiddenBrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntityForbiddenBrandCountAggregateInputType | true
    _avg?: EntityForbiddenBrandAvgAggregateInputType
    _sum?: EntityForbiddenBrandSumAggregateInputType
    _min?: EntityForbiddenBrandMinAggregateInputType
    _max?: EntityForbiddenBrandMaxAggregateInputType
  }

  export type EntityForbiddenBrandGroupByOutputType = {
    id: number
    name: string
    entityId: number
    createdAt: Date
    updatedAt: Date
    _count: EntityForbiddenBrandCountAggregateOutputType | null
    _avg: EntityForbiddenBrandAvgAggregateOutputType | null
    _sum: EntityForbiddenBrandSumAggregateOutputType | null
    _min: EntityForbiddenBrandMinAggregateOutputType | null
    _max: EntityForbiddenBrandMaxAggregateOutputType | null
  }

  type GetEntityForbiddenBrandGroupByPayload<T extends EntityForbiddenBrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntityForbiddenBrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntityForbiddenBrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntityForbiddenBrandGroupByOutputType[P]>
            : GetScalarType<T[P], EntityForbiddenBrandGroupByOutputType[P]>
        }
      >
    >


  export type EntityForbiddenBrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    entityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entity?: boolean | EntityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entityForbiddenBrand"]>


  export type EntityForbiddenBrandSelectScalar = {
    id?: boolean
    name?: boolean
    entityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EntityForbiddenBrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entity?: boolean | EntityDefaultArgs<ExtArgs>
  }

  export type $EntityForbiddenBrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EntityForbiddenBrand"
    objects: {
      entity: Prisma.$EntityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      entityId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["entityForbiddenBrand"]>
    composites: {}
  }

  type EntityForbiddenBrandGetPayload<S extends boolean | null | undefined | EntityForbiddenBrandDefaultArgs> = $Result.GetResult<Prisma.$EntityForbiddenBrandPayload, S>

  type EntityForbiddenBrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EntityForbiddenBrandFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntityForbiddenBrandCountAggregateInputType | true
    }

  export interface EntityForbiddenBrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EntityForbiddenBrand'], meta: { name: 'EntityForbiddenBrand' } }
    /**
     * Find zero or one EntityForbiddenBrand that matches the filter.
     * @param {EntityForbiddenBrandFindUniqueArgs} args - Arguments to find a EntityForbiddenBrand
     * @example
     * // Get one EntityForbiddenBrand
     * const entityForbiddenBrand = await prisma.entityForbiddenBrand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EntityForbiddenBrandFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenBrandFindUniqueArgs<ExtArgs>>
    ): Prisma__EntityForbiddenBrandClient<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EntityForbiddenBrand that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EntityForbiddenBrandFindUniqueOrThrowArgs} args - Arguments to find a EntityForbiddenBrand
     * @example
     * // Get one EntityForbiddenBrand
     * const entityForbiddenBrand = await prisma.entityForbiddenBrand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EntityForbiddenBrandFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenBrandFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EntityForbiddenBrandClient<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EntityForbiddenBrand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenBrandFindFirstArgs} args - Arguments to find a EntityForbiddenBrand
     * @example
     * // Get one EntityForbiddenBrand
     * const entityForbiddenBrand = await prisma.entityForbiddenBrand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EntityForbiddenBrandFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenBrandFindFirstArgs<ExtArgs>>
    ): Prisma__EntityForbiddenBrandClient<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EntityForbiddenBrand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenBrandFindFirstOrThrowArgs} args - Arguments to find a EntityForbiddenBrand
     * @example
     * // Get one EntityForbiddenBrand
     * const entityForbiddenBrand = await prisma.entityForbiddenBrand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EntityForbiddenBrandFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenBrandFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EntityForbiddenBrandClient<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EntityForbiddenBrands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenBrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EntityForbiddenBrands
     * const entityForbiddenBrands = await prisma.entityForbiddenBrand.findMany()
     * 
     * // Get first 10 EntityForbiddenBrands
     * const entityForbiddenBrands = await prisma.entityForbiddenBrand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entityForbiddenBrandWithIdOnly = await prisma.entityForbiddenBrand.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EntityForbiddenBrandFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenBrandFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EntityForbiddenBrand.
     * @param {EntityForbiddenBrandCreateArgs} args - Arguments to create a EntityForbiddenBrand.
     * @example
     * // Create one EntityForbiddenBrand
     * const EntityForbiddenBrand = await prisma.entityForbiddenBrand.create({
     *   data: {
     *     // ... data to create a EntityForbiddenBrand
     *   }
     * })
     * 
    **/
    create<T extends EntityForbiddenBrandCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenBrandCreateArgs<ExtArgs>>
    ): Prisma__EntityForbiddenBrandClient<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EntityForbiddenBrands.
     * @param {EntityForbiddenBrandCreateManyArgs} args - Arguments to create many EntityForbiddenBrands.
     * @example
     * // Create many EntityForbiddenBrands
     * const entityForbiddenBrand = await prisma.entityForbiddenBrand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends EntityForbiddenBrandCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenBrandCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EntityForbiddenBrand.
     * @param {EntityForbiddenBrandDeleteArgs} args - Arguments to delete one EntityForbiddenBrand.
     * @example
     * // Delete one EntityForbiddenBrand
     * const EntityForbiddenBrand = await prisma.entityForbiddenBrand.delete({
     *   where: {
     *     // ... filter to delete one EntityForbiddenBrand
     *   }
     * })
     * 
    **/
    delete<T extends EntityForbiddenBrandDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenBrandDeleteArgs<ExtArgs>>
    ): Prisma__EntityForbiddenBrandClient<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EntityForbiddenBrand.
     * @param {EntityForbiddenBrandUpdateArgs} args - Arguments to update one EntityForbiddenBrand.
     * @example
     * // Update one EntityForbiddenBrand
     * const entityForbiddenBrand = await prisma.entityForbiddenBrand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EntityForbiddenBrandUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenBrandUpdateArgs<ExtArgs>>
    ): Prisma__EntityForbiddenBrandClient<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EntityForbiddenBrands.
     * @param {EntityForbiddenBrandDeleteManyArgs} args - Arguments to filter EntityForbiddenBrands to delete.
     * @example
     * // Delete a few EntityForbiddenBrands
     * const { count } = await prisma.entityForbiddenBrand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EntityForbiddenBrandDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntityForbiddenBrandDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EntityForbiddenBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenBrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EntityForbiddenBrands
     * const entityForbiddenBrand = await prisma.entityForbiddenBrand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EntityForbiddenBrandUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenBrandUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EntityForbiddenBrand.
     * @param {EntityForbiddenBrandUpsertArgs} args - Arguments to update or create a EntityForbiddenBrand.
     * @example
     * // Update or create a EntityForbiddenBrand
     * const entityForbiddenBrand = await prisma.entityForbiddenBrand.upsert({
     *   create: {
     *     // ... data to create a EntityForbiddenBrand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EntityForbiddenBrand we want to update
     *   }
     * })
    **/
    upsert<T extends EntityForbiddenBrandUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EntityForbiddenBrandUpsertArgs<ExtArgs>>
    ): Prisma__EntityForbiddenBrandClient<$Result.GetResult<Prisma.$EntityForbiddenBrandPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EntityForbiddenBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenBrandCountArgs} args - Arguments to filter EntityForbiddenBrands to count.
     * @example
     * // Count the number of EntityForbiddenBrands
     * const count = await prisma.entityForbiddenBrand.count({
     *   where: {
     *     // ... the filter for the EntityForbiddenBrands we want to count
     *   }
     * })
    **/
    count<T extends EntityForbiddenBrandCountArgs>(
      args?: Subset<T, EntityForbiddenBrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntityForbiddenBrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EntityForbiddenBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenBrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntityForbiddenBrandAggregateArgs>(args: Subset<T, EntityForbiddenBrandAggregateArgs>): Prisma.PrismaPromise<GetEntityForbiddenBrandAggregateType<T>>

    /**
     * Group by EntityForbiddenBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityForbiddenBrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntityForbiddenBrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntityForbiddenBrandGroupByArgs['orderBy'] }
        : { orderBy?: EntityForbiddenBrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntityForbiddenBrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityForbiddenBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EntityForbiddenBrand model
   */
  readonly fields: EntityForbiddenBrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EntityForbiddenBrand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntityForbiddenBrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entity<T extends EntityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntityDefaultArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EntityForbiddenBrand model
   */ 
  interface EntityForbiddenBrandFieldRefs {
    readonly id: FieldRef<"EntityForbiddenBrand", 'Int'>
    readonly name: FieldRef<"EntityForbiddenBrand", 'String'>
    readonly entityId: FieldRef<"EntityForbiddenBrand", 'Int'>
    readonly createdAt: FieldRef<"EntityForbiddenBrand", 'DateTime'>
    readonly updatedAt: FieldRef<"EntityForbiddenBrand", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EntityForbiddenBrand findUnique
   */
  export type EntityForbiddenBrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenBrand to fetch.
     */
    where: EntityForbiddenBrandWhereUniqueInput
  }

  /**
   * EntityForbiddenBrand findUniqueOrThrow
   */
  export type EntityForbiddenBrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenBrand to fetch.
     */
    where: EntityForbiddenBrandWhereUniqueInput
  }

  /**
   * EntityForbiddenBrand findFirst
   */
  export type EntityForbiddenBrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenBrand to fetch.
     */
    where?: EntityForbiddenBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityForbiddenBrands to fetch.
     */
    orderBy?: EntityForbiddenBrandOrderByWithRelationInput | EntityForbiddenBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityForbiddenBrands.
     */
    cursor?: EntityForbiddenBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityForbiddenBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityForbiddenBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityForbiddenBrands.
     */
    distinct?: EntityForbiddenBrandScalarFieldEnum | EntityForbiddenBrandScalarFieldEnum[]
  }

  /**
   * EntityForbiddenBrand findFirstOrThrow
   */
  export type EntityForbiddenBrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenBrand to fetch.
     */
    where?: EntityForbiddenBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityForbiddenBrands to fetch.
     */
    orderBy?: EntityForbiddenBrandOrderByWithRelationInput | EntityForbiddenBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityForbiddenBrands.
     */
    cursor?: EntityForbiddenBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityForbiddenBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityForbiddenBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityForbiddenBrands.
     */
    distinct?: EntityForbiddenBrandScalarFieldEnum | EntityForbiddenBrandScalarFieldEnum[]
  }

  /**
   * EntityForbiddenBrand findMany
   */
  export type EntityForbiddenBrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    /**
     * Filter, which EntityForbiddenBrands to fetch.
     */
    where?: EntityForbiddenBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityForbiddenBrands to fetch.
     */
    orderBy?: EntityForbiddenBrandOrderByWithRelationInput | EntityForbiddenBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EntityForbiddenBrands.
     */
    cursor?: EntityForbiddenBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityForbiddenBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityForbiddenBrands.
     */
    skip?: number
    distinct?: EntityForbiddenBrandScalarFieldEnum | EntityForbiddenBrandScalarFieldEnum[]
  }

  /**
   * EntityForbiddenBrand create
   */
  export type EntityForbiddenBrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    /**
     * The data needed to create a EntityForbiddenBrand.
     */
    data: XOR<EntityForbiddenBrandCreateInput, EntityForbiddenBrandUncheckedCreateInput>
  }

  /**
   * EntityForbiddenBrand createMany
   */
  export type EntityForbiddenBrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EntityForbiddenBrands.
     */
    data: EntityForbiddenBrandCreateManyInput | EntityForbiddenBrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EntityForbiddenBrand update
   */
  export type EntityForbiddenBrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    /**
     * The data needed to update a EntityForbiddenBrand.
     */
    data: XOR<EntityForbiddenBrandUpdateInput, EntityForbiddenBrandUncheckedUpdateInput>
    /**
     * Choose, which EntityForbiddenBrand to update.
     */
    where: EntityForbiddenBrandWhereUniqueInput
  }

  /**
   * EntityForbiddenBrand updateMany
   */
  export type EntityForbiddenBrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EntityForbiddenBrands.
     */
    data: XOR<EntityForbiddenBrandUpdateManyMutationInput, EntityForbiddenBrandUncheckedUpdateManyInput>
    /**
     * Filter which EntityForbiddenBrands to update
     */
    where?: EntityForbiddenBrandWhereInput
  }

  /**
   * EntityForbiddenBrand upsert
   */
  export type EntityForbiddenBrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    /**
     * The filter to search for the EntityForbiddenBrand to update in case it exists.
     */
    where: EntityForbiddenBrandWhereUniqueInput
    /**
     * In case the EntityForbiddenBrand found by the `where` argument doesn't exist, create a new EntityForbiddenBrand with this data.
     */
    create: XOR<EntityForbiddenBrandCreateInput, EntityForbiddenBrandUncheckedCreateInput>
    /**
     * In case the EntityForbiddenBrand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntityForbiddenBrandUpdateInput, EntityForbiddenBrandUncheckedUpdateInput>
  }

  /**
   * EntityForbiddenBrand delete
   */
  export type EntityForbiddenBrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
    /**
     * Filter which EntityForbiddenBrand to delete.
     */
    where: EntityForbiddenBrandWhereUniqueInput
  }

  /**
   * EntityForbiddenBrand deleteMany
   */
  export type EntityForbiddenBrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntityForbiddenBrands to delete
     */
    where?: EntityForbiddenBrandWhereInput
  }

  /**
   * EntityForbiddenBrand without action
   */
  export type EntityForbiddenBrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityForbiddenBrand
     */
    select?: EntityForbiddenBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityForbiddenBrandInclude<ExtArgs> | null
  }


  /**
   * Model Bank
   */

  export type AggregateBank = {
    _count: BankCountAggregateOutputType | null
    _avg: BankAvgAggregateOutputType | null
    _sum: BankSumAggregateOutputType | null
    _min: BankMinAggregateOutputType | null
    _max: BankMaxAggregateOutputType | null
  }

  export type BankAvgAggregateOutputType = {
    id: number | null
  }

  export type BankSumAggregateOutputType = {
    id: number | null
  }

  export type BankMinAggregateOutputType = {
    id: number | null
    name: string | null
    isVisible: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankMaxAggregateOutputType = {
    id: number | null
    name: string | null
    isVisible: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankCountAggregateOutputType = {
    id: number
    name: number
    isVisible: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankAvgAggregateInputType = {
    id?: true
  }

  export type BankSumAggregateInputType = {
    id?: true
  }

  export type BankMinAggregateInputType = {
    id?: true
    name?: true
    isVisible?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankMaxAggregateInputType = {
    id?: true
    name?: true
    isVisible?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankCountAggregateInputType = {
    id?: true
    name?: true
    isVisible?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bank to aggregate.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: BankOrderByWithRelationInput | BankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banks
    **/
    _count?: true | BankCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankMaxAggregateInputType
  }

  export type GetBankAggregateType<T extends BankAggregateArgs> = {
        [P in keyof T & keyof AggregateBank]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBank[P]>
      : GetScalarType<T[P], AggregateBank[P]>
  }




  export type BankGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankWhereInput
    orderBy?: BankOrderByWithAggregationInput | BankOrderByWithAggregationInput[]
    by: BankScalarFieldEnum[] | BankScalarFieldEnum
    having?: BankScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankCountAggregateInputType | true
    _avg?: BankAvgAggregateInputType
    _sum?: BankSumAggregateInputType
    _min?: BankMinAggregateInputType
    _max?: BankMaxAggregateInputType
  }

  export type BankGroupByOutputType = {
    id: number
    name: string
    isVisible: boolean
    createdAt: Date
    updatedAt: Date
    _count: BankCountAggregateOutputType | null
    _avg: BankAvgAggregateOutputType | null
    _sum: BankSumAggregateOutputType | null
    _min: BankMinAggregateOutputType | null
    _max: BankMaxAggregateOutputType | null
  }

  type GetBankGroupByPayload<T extends BankGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankGroupByOutputType[P]>
            : GetScalarType<T[P], BankGroupByOutputType[P]>
        }
      >
    >


  export type BankSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isVisible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientContracts?: boolean | Bank$clientContractsArgs<ExtArgs>
    _count?: boolean | BankCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bank"]>


  export type BankSelectScalar = {
    id?: boolean
    name?: boolean
    isVisible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BankInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientContracts?: boolean | Bank$clientContractsArgs<ExtArgs>
    _count?: boolean | BankCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BankPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bank"
    objects: {
      clientContracts: Prisma.$ClientContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      isVisible: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bank"]>
    composites: {}
  }

  type BankGetPayload<S extends boolean | null | undefined | BankDefaultArgs> = $Result.GetResult<Prisma.$BankPayload, S>

  type BankCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BankFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BankCountAggregateInputType | true
    }

  export interface BankDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bank'], meta: { name: 'Bank' } }
    /**
     * Find zero or one Bank that matches the filter.
     * @param {BankFindUniqueArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BankFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BankFindUniqueArgs<ExtArgs>>
    ): Prisma__BankClient<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bank that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BankFindUniqueOrThrowArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BankFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BankClient<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bank that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFindFirstArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BankFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFindFirstArgs<ExtArgs>>
    ): Prisma__BankClient<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bank that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFindFirstOrThrowArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BankFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BankClient<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Banks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banks
     * const banks = await prisma.bank.findMany()
     * 
     * // Get first 10 Banks
     * const banks = await prisma.bank.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankWithIdOnly = await prisma.bank.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BankFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bank.
     * @param {BankCreateArgs} args - Arguments to create a Bank.
     * @example
     * // Create one Bank
     * const Bank = await prisma.bank.create({
     *   data: {
     *     // ... data to create a Bank
     *   }
     * })
     * 
    **/
    create<T extends BankCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BankCreateArgs<ExtArgs>>
    ): Prisma__BankClient<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Banks.
     * @param {BankCreateManyArgs} args - Arguments to create many Banks.
     * @example
     * // Create many Banks
     * const bank = await prisma.bank.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends BankCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bank.
     * @param {BankDeleteArgs} args - Arguments to delete one Bank.
     * @example
     * // Delete one Bank
     * const Bank = await prisma.bank.delete({
     *   where: {
     *     // ... filter to delete one Bank
     *   }
     * })
     * 
    **/
    delete<T extends BankDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BankDeleteArgs<ExtArgs>>
    ): Prisma__BankClient<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bank.
     * @param {BankUpdateArgs} args - Arguments to update one Bank.
     * @example
     * // Update one Bank
     * const bank = await prisma.bank.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BankUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BankUpdateArgs<ExtArgs>>
    ): Prisma__BankClient<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Banks.
     * @param {BankDeleteManyArgs} args - Arguments to filter Banks to delete.
     * @example
     * // Delete a few Banks
     * const { count } = await prisma.bank.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BankDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banks
     * const bank = await prisma.bank.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BankUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BankUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bank.
     * @param {BankUpsertArgs} args - Arguments to update or create a Bank.
     * @example
     * // Update or create a Bank
     * const bank = await prisma.bank.upsert({
     *   create: {
     *     // ... data to create a Bank
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bank we want to update
     *   }
     * })
    **/
    upsert<T extends BankUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BankUpsertArgs<ExtArgs>>
    ): Prisma__BankClient<$Result.GetResult<Prisma.$BankPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankCountArgs} args - Arguments to filter Banks to count.
     * @example
     * // Count the number of Banks
     * const count = await prisma.bank.count({
     *   where: {
     *     // ... the filter for the Banks we want to count
     *   }
     * })
    **/
    count<T extends BankCountArgs>(
      args?: Subset<T, BankCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAggregateArgs>(args: Subset<T, BankAggregateArgs>): Prisma.PrismaPromise<GetBankAggregateType<T>>

    /**
     * Group by Bank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankGroupByArgs['orderBy'] }
        : { orderBy?: BankGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bank model
   */
  readonly fields: BankFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bank.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    clientContracts<T extends Bank$clientContractsArgs<ExtArgs> = {}>(args?: Subset<T, Bank$clientContractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Bank model
   */ 
  interface BankFieldRefs {
    readonly id: FieldRef<"Bank", 'Int'>
    readonly name: FieldRef<"Bank", 'String'>
    readonly isVisible: FieldRef<"Bank", 'Boolean'>
    readonly createdAt: FieldRef<"Bank", 'DateTime'>
    readonly updatedAt: FieldRef<"Bank", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bank findUnique
   */
  export type BankFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    /**
     * Filter, which Bank to fetch.
     */
    where: BankWhereUniqueInput
  }

  /**
   * Bank findUniqueOrThrow
   */
  export type BankFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    /**
     * Filter, which Bank to fetch.
     */
    where: BankWhereUniqueInput
  }

  /**
   * Bank findFirst
   */
  export type BankFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    /**
     * Filter, which Bank to fetch.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: BankOrderByWithRelationInput | BankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banks.
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banks.
     */
    distinct?: BankScalarFieldEnum | BankScalarFieldEnum[]
  }

  /**
   * Bank findFirstOrThrow
   */
  export type BankFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    /**
     * Filter, which Bank to fetch.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: BankOrderByWithRelationInput | BankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banks.
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banks.
     */
    distinct?: BankScalarFieldEnum | BankScalarFieldEnum[]
  }

  /**
   * Bank findMany
   */
  export type BankFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    /**
     * Filter, which Banks to fetch.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: BankOrderByWithRelationInput | BankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banks.
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    distinct?: BankScalarFieldEnum | BankScalarFieldEnum[]
  }

  /**
   * Bank create
   */
  export type BankCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    /**
     * The data needed to create a Bank.
     */
    data: XOR<BankCreateInput, BankUncheckedCreateInput>
  }

  /**
   * Bank createMany
   */
  export type BankCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Banks.
     */
    data: BankCreateManyInput | BankCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bank update
   */
  export type BankUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    /**
     * The data needed to update a Bank.
     */
    data: XOR<BankUpdateInput, BankUncheckedUpdateInput>
    /**
     * Choose, which Bank to update.
     */
    where: BankWhereUniqueInput
  }

  /**
   * Bank updateMany
   */
  export type BankUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Banks.
     */
    data: XOR<BankUpdateManyMutationInput, BankUncheckedUpdateManyInput>
    /**
     * Filter which Banks to update
     */
    where?: BankWhereInput
  }

  /**
   * Bank upsert
   */
  export type BankUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    /**
     * The filter to search for the Bank to update in case it exists.
     */
    where: BankWhereUniqueInput
    /**
     * In case the Bank found by the `where` argument doesn't exist, create a new Bank with this data.
     */
    create: XOR<BankCreateInput, BankUncheckedCreateInput>
    /**
     * In case the Bank was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankUpdateInput, BankUncheckedUpdateInput>
  }

  /**
   * Bank delete
   */
  export type BankDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
    /**
     * Filter which Bank to delete.
     */
    where: BankWhereUniqueInput
  }

  /**
   * Bank deleteMany
   */
  export type BankDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banks to delete
     */
    where?: BankWhereInput
  }

  /**
   * Bank.clientContracts
   */
  export type Bank$clientContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    where?: ClientContractWhereInput
    orderBy?: ClientContractOrderByWithRelationInput | ClientContractOrderByWithRelationInput[]
    cursor?: ClientContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientContractScalarFieldEnum | ClientContractScalarFieldEnum[]
  }

  /**
   * Bank without action
   */
  export type BankDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankInclude<ExtArgs> | null
  }


  /**
   * Model EscrowAccountHistory
   */

  export type AggregateEscrowAccountHistory = {
    _count: EscrowAccountHistoryCountAggregateOutputType | null
    _avg: EscrowAccountHistoryAvgAggregateOutputType | null
    _sum: EscrowAccountHistorySumAggregateOutputType | null
    _min: EscrowAccountHistoryMinAggregateOutputType | null
    _max: EscrowAccountHistoryMaxAggregateOutputType | null
  }

  export type EscrowAccountHistoryAvgAggregateOutputType = {
    id: number | null
    depositedAmount: Decimal | null
    incomingBalance: Decimal | null
    transactionAmount: Decimal | null
    outgoingBalance: Decimal | null
  }

  export type EscrowAccountHistorySumAggregateOutputType = {
    id: number | null
    depositedAmount: Decimal | null
    incomingBalance: Decimal | null
    transactionAmount: Decimal | null
    outgoingBalance: Decimal | null
  }

  export type EscrowAccountHistoryMinAggregateOutputType = {
    id: number | null
    status: $Enums.EscrowAccountStatus | null
    number: string | null
    openingDate: Date | null
    depositedAmount: Decimal | null
    incomingBalance: Decimal | null
    dateOfTransaction: Date | null
    transactionAmount: Decimal | null
    outgoingBalance: Decimal | null
    expirationDate: Date | null
    depositor: string | null
    depositorInn: string | null
    dduNumber: string | null
    dduDate: Date | null
    loanAgreementNumber: string | null
    loanAgreementDate: Date | null
    closingDate: Date | null
    builderInn: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EscrowAccountHistoryMaxAggregateOutputType = {
    id: number | null
    status: $Enums.EscrowAccountStatus | null
    number: string | null
    openingDate: Date | null
    depositedAmount: Decimal | null
    incomingBalance: Decimal | null
    dateOfTransaction: Date | null
    transactionAmount: Decimal | null
    outgoingBalance: Decimal | null
    expirationDate: Date | null
    depositor: string | null
    depositorInn: string | null
    dduNumber: string | null
    dduDate: Date | null
    loanAgreementNumber: string | null
    loanAgreementDate: Date | null
    closingDate: Date | null
    builderInn: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EscrowAccountHistoryCountAggregateOutputType = {
    id: number
    status: number
    number: number
    openingDate: number
    depositedAmount: number
    incomingBalance: number
    dateOfTransaction: number
    transactionAmount: number
    outgoingBalance: number
    expirationDate: number
    depositor: number
    depositorInn: number
    dduNumber: number
    dduDate: number
    loanAgreementNumber: number
    loanAgreementDate: number
    closingDate: number
    builderInn: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EscrowAccountHistoryAvgAggregateInputType = {
    id?: true
    depositedAmount?: true
    incomingBalance?: true
    transactionAmount?: true
    outgoingBalance?: true
  }

  export type EscrowAccountHistorySumAggregateInputType = {
    id?: true
    depositedAmount?: true
    incomingBalance?: true
    transactionAmount?: true
    outgoingBalance?: true
  }

  export type EscrowAccountHistoryMinAggregateInputType = {
    id?: true
    status?: true
    number?: true
    openingDate?: true
    depositedAmount?: true
    incomingBalance?: true
    dateOfTransaction?: true
    transactionAmount?: true
    outgoingBalance?: true
    expirationDate?: true
    depositor?: true
    depositorInn?: true
    dduNumber?: true
    dduDate?: true
    loanAgreementNumber?: true
    loanAgreementDate?: true
    closingDate?: true
    builderInn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EscrowAccountHistoryMaxAggregateInputType = {
    id?: true
    status?: true
    number?: true
    openingDate?: true
    depositedAmount?: true
    incomingBalance?: true
    dateOfTransaction?: true
    transactionAmount?: true
    outgoingBalance?: true
    expirationDate?: true
    depositor?: true
    depositorInn?: true
    dduNumber?: true
    dduDate?: true
    loanAgreementNumber?: true
    loanAgreementDate?: true
    closingDate?: true
    builderInn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EscrowAccountHistoryCountAggregateInputType = {
    id?: true
    status?: true
    number?: true
    openingDate?: true
    depositedAmount?: true
    incomingBalance?: true
    dateOfTransaction?: true
    transactionAmount?: true
    outgoingBalance?: true
    expirationDate?: true
    depositor?: true
    depositorInn?: true
    dduNumber?: true
    dduDate?: true
    loanAgreementNumber?: true
    loanAgreementDate?: true
    closingDate?: true
    builderInn?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EscrowAccountHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscrowAccountHistory to aggregate.
     */
    where?: EscrowAccountHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowAccountHistories to fetch.
     */
    orderBy?: EscrowAccountHistoryOrderByWithRelationInput | EscrowAccountHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EscrowAccountHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowAccountHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowAccountHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EscrowAccountHistories
    **/
    _count?: true | EscrowAccountHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EscrowAccountHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EscrowAccountHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscrowAccountHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscrowAccountHistoryMaxAggregateInputType
  }

  export type GetEscrowAccountHistoryAggregateType<T extends EscrowAccountHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateEscrowAccountHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscrowAccountHistory[P]>
      : GetScalarType<T[P], AggregateEscrowAccountHistory[P]>
  }




  export type EscrowAccountHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscrowAccountHistoryWhereInput
    orderBy?: EscrowAccountHistoryOrderByWithAggregationInput | EscrowAccountHistoryOrderByWithAggregationInput[]
    by: EscrowAccountHistoryScalarFieldEnum[] | EscrowAccountHistoryScalarFieldEnum
    having?: EscrowAccountHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscrowAccountHistoryCountAggregateInputType | true
    _avg?: EscrowAccountHistoryAvgAggregateInputType
    _sum?: EscrowAccountHistorySumAggregateInputType
    _min?: EscrowAccountHistoryMinAggregateInputType
    _max?: EscrowAccountHistoryMaxAggregateInputType
  }

  export type EscrowAccountHistoryGroupByOutputType = {
    id: number
    status: $Enums.EscrowAccountStatus
    number: string
    openingDate: Date
    depositedAmount: Decimal
    incomingBalance: Decimal
    dateOfTransaction: Date
    transactionAmount: Decimal
    outgoingBalance: Decimal
    expirationDate: Date
    depositor: string
    depositorInn: string | null
    dduNumber: string
    dduDate: Date
    loanAgreementNumber: string | null
    loanAgreementDate: Date | null
    closingDate: Date | null
    builderInn: string
    createdAt: Date
    updatedAt: Date
    _count: EscrowAccountHistoryCountAggregateOutputType | null
    _avg: EscrowAccountHistoryAvgAggregateOutputType | null
    _sum: EscrowAccountHistorySumAggregateOutputType | null
    _min: EscrowAccountHistoryMinAggregateOutputType | null
    _max: EscrowAccountHistoryMaxAggregateOutputType | null
  }

  type GetEscrowAccountHistoryGroupByPayload<T extends EscrowAccountHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscrowAccountHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscrowAccountHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscrowAccountHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], EscrowAccountHistoryGroupByOutputType[P]>
        }
      >
    >


  export type EscrowAccountHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    number?: boolean
    openingDate?: boolean
    depositedAmount?: boolean
    incomingBalance?: boolean
    dateOfTransaction?: boolean
    transactionAmount?: boolean
    outgoingBalance?: boolean
    expirationDate?: boolean
    depositor?: boolean
    depositorInn?: boolean
    dduNumber?: boolean
    dduDate?: boolean
    loanAgreementNumber?: boolean
    loanAgreementDate?: boolean
    closingDate?: boolean
    builderInn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["escrowAccountHistory"]>


  export type EscrowAccountHistorySelectScalar = {
    id?: boolean
    status?: boolean
    number?: boolean
    openingDate?: boolean
    depositedAmount?: boolean
    incomingBalance?: boolean
    dateOfTransaction?: boolean
    transactionAmount?: boolean
    outgoingBalance?: boolean
    expirationDate?: boolean
    depositor?: boolean
    depositorInn?: boolean
    dduNumber?: boolean
    dduDate?: boolean
    loanAgreementNumber?: boolean
    loanAgreementDate?: boolean
    closingDate?: boolean
    builderInn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $EscrowAccountHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EscrowAccountHistory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      status: $Enums.EscrowAccountStatus
      number: string
      openingDate: Date
      depositedAmount: Prisma.Decimal
      incomingBalance: Prisma.Decimal
      dateOfTransaction: Date
      transactionAmount: Prisma.Decimal
      outgoingBalance: Prisma.Decimal
      expirationDate: Date
      depositor: string
      depositorInn: string | null
      dduNumber: string
      dduDate: Date
      loanAgreementNumber: string | null
      loanAgreementDate: Date | null
      closingDate: Date | null
      builderInn: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["escrowAccountHistory"]>
    composites: {}
  }

  type EscrowAccountHistoryGetPayload<S extends boolean | null | undefined | EscrowAccountHistoryDefaultArgs> = $Result.GetResult<Prisma.$EscrowAccountHistoryPayload, S>

  type EscrowAccountHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EscrowAccountHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EscrowAccountHistoryCountAggregateInputType | true
    }

  export interface EscrowAccountHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EscrowAccountHistory'], meta: { name: 'EscrowAccountHistory' } }
    /**
     * Find zero or one EscrowAccountHistory that matches the filter.
     * @param {EscrowAccountHistoryFindUniqueArgs} args - Arguments to find a EscrowAccountHistory
     * @example
     * // Get one EscrowAccountHistory
     * const escrowAccountHistory = await prisma.escrowAccountHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EscrowAccountHistoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EscrowAccountHistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__EscrowAccountHistoryClient<$Result.GetResult<Prisma.$EscrowAccountHistoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EscrowAccountHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EscrowAccountHistoryFindUniqueOrThrowArgs} args - Arguments to find a EscrowAccountHistory
     * @example
     * // Get one EscrowAccountHistory
     * const escrowAccountHistory = await prisma.escrowAccountHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EscrowAccountHistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EscrowAccountHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EscrowAccountHistoryClient<$Result.GetResult<Prisma.$EscrowAccountHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EscrowAccountHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowAccountHistoryFindFirstArgs} args - Arguments to find a EscrowAccountHistory
     * @example
     * // Get one EscrowAccountHistory
     * const escrowAccountHistory = await prisma.escrowAccountHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EscrowAccountHistoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EscrowAccountHistoryFindFirstArgs<ExtArgs>>
    ): Prisma__EscrowAccountHistoryClient<$Result.GetResult<Prisma.$EscrowAccountHistoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EscrowAccountHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowAccountHistoryFindFirstOrThrowArgs} args - Arguments to find a EscrowAccountHistory
     * @example
     * // Get one EscrowAccountHistory
     * const escrowAccountHistory = await prisma.escrowAccountHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EscrowAccountHistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EscrowAccountHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EscrowAccountHistoryClient<$Result.GetResult<Prisma.$EscrowAccountHistoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EscrowAccountHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowAccountHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EscrowAccountHistories
     * const escrowAccountHistories = await prisma.escrowAccountHistory.findMany()
     * 
     * // Get first 10 EscrowAccountHistories
     * const escrowAccountHistories = await prisma.escrowAccountHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const escrowAccountHistoryWithIdOnly = await prisma.escrowAccountHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EscrowAccountHistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EscrowAccountHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowAccountHistoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EscrowAccountHistory.
     * @param {EscrowAccountHistoryCreateArgs} args - Arguments to create a EscrowAccountHistory.
     * @example
     * // Create one EscrowAccountHistory
     * const EscrowAccountHistory = await prisma.escrowAccountHistory.create({
     *   data: {
     *     // ... data to create a EscrowAccountHistory
     *   }
     * })
     * 
    **/
    create<T extends EscrowAccountHistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EscrowAccountHistoryCreateArgs<ExtArgs>>
    ): Prisma__EscrowAccountHistoryClient<$Result.GetResult<Prisma.$EscrowAccountHistoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EscrowAccountHistories.
     * @param {EscrowAccountHistoryCreateManyArgs} args - Arguments to create many EscrowAccountHistories.
     * @example
     * // Create many EscrowAccountHistories
     * const escrowAccountHistory = await prisma.escrowAccountHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends EscrowAccountHistoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EscrowAccountHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EscrowAccountHistory.
     * @param {EscrowAccountHistoryDeleteArgs} args - Arguments to delete one EscrowAccountHistory.
     * @example
     * // Delete one EscrowAccountHistory
     * const EscrowAccountHistory = await prisma.escrowAccountHistory.delete({
     *   where: {
     *     // ... filter to delete one EscrowAccountHistory
     *   }
     * })
     * 
    **/
    delete<T extends EscrowAccountHistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EscrowAccountHistoryDeleteArgs<ExtArgs>>
    ): Prisma__EscrowAccountHistoryClient<$Result.GetResult<Prisma.$EscrowAccountHistoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EscrowAccountHistory.
     * @param {EscrowAccountHistoryUpdateArgs} args - Arguments to update one EscrowAccountHistory.
     * @example
     * // Update one EscrowAccountHistory
     * const escrowAccountHistory = await prisma.escrowAccountHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EscrowAccountHistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EscrowAccountHistoryUpdateArgs<ExtArgs>>
    ): Prisma__EscrowAccountHistoryClient<$Result.GetResult<Prisma.$EscrowAccountHistoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EscrowAccountHistories.
     * @param {EscrowAccountHistoryDeleteManyArgs} args - Arguments to filter EscrowAccountHistories to delete.
     * @example
     * // Delete a few EscrowAccountHistories
     * const { count } = await prisma.escrowAccountHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EscrowAccountHistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EscrowAccountHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EscrowAccountHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowAccountHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EscrowAccountHistories
     * const escrowAccountHistory = await prisma.escrowAccountHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EscrowAccountHistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EscrowAccountHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EscrowAccountHistory.
     * @param {EscrowAccountHistoryUpsertArgs} args - Arguments to update or create a EscrowAccountHistory.
     * @example
     * // Update or create a EscrowAccountHistory
     * const escrowAccountHistory = await prisma.escrowAccountHistory.upsert({
     *   create: {
     *     // ... data to create a EscrowAccountHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EscrowAccountHistory we want to update
     *   }
     * })
    **/
    upsert<T extends EscrowAccountHistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EscrowAccountHistoryUpsertArgs<ExtArgs>>
    ): Prisma__EscrowAccountHistoryClient<$Result.GetResult<Prisma.$EscrowAccountHistoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EscrowAccountHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowAccountHistoryCountArgs} args - Arguments to filter EscrowAccountHistories to count.
     * @example
     * // Count the number of EscrowAccountHistories
     * const count = await prisma.escrowAccountHistory.count({
     *   where: {
     *     // ... the filter for the EscrowAccountHistories we want to count
     *   }
     * })
    **/
    count<T extends EscrowAccountHistoryCountArgs>(
      args?: Subset<T, EscrowAccountHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscrowAccountHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EscrowAccountHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowAccountHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscrowAccountHistoryAggregateArgs>(args: Subset<T, EscrowAccountHistoryAggregateArgs>): Prisma.PrismaPromise<GetEscrowAccountHistoryAggregateType<T>>

    /**
     * Group by EscrowAccountHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowAccountHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EscrowAccountHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EscrowAccountHistoryGroupByArgs['orderBy'] }
        : { orderBy?: EscrowAccountHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EscrowAccountHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscrowAccountHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EscrowAccountHistory model
   */
  readonly fields: EscrowAccountHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EscrowAccountHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EscrowAccountHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EscrowAccountHistory model
   */ 
  interface EscrowAccountHistoryFieldRefs {
    readonly id: FieldRef<"EscrowAccountHistory", 'Int'>
    readonly status: FieldRef<"EscrowAccountHistory", 'EscrowAccountStatus'>
    readonly number: FieldRef<"EscrowAccountHistory", 'String'>
    readonly openingDate: FieldRef<"EscrowAccountHistory", 'DateTime'>
    readonly depositedAmount: FieldRef<"EscrowAccountHistory", 'Decimal'>
    readonly incomingBalance: FieldRef<"EscrowAccountHistory", 'Decimal'>
    readonly dateOfTransaction: FieldRef<"EscrowAccountHistory", 'DateTime'>
    readonly transactionAmount: FieldRef<"EscrowAccountHistory", 'Decimal'>
    readonly outgoingBalance: FieldRef<"EscrowAccountHistory", 'Decimal'>
    readonly expirationDate: FieldRef<"EscrowAccountHistory", 'DateTime'>
    readonly depositor: FieldRef<"EscrowAccountHistory", 'String'>
    readonly depositorInn: FieldRef<"EscrowAccountHistory", 'String'>
    readonly dduNumber: FieldRef<"EscrowAccountHistory", 'String'>
    readonly dduDate: FieldRef<"EscrowAccountHistory", 'DateTime'>
    readonly loanAgreementNumber: FieldRef<"EscrowAccountHistory", 'String'>
    readonly loanAgreementDate: FieldRef<"EscrowAccountHistory", 'DateTime'>
    readonly closingDate: FieldRef<"EscrowAccountHistory", 'DateTime'>
    readonly builderInn: FieldRef<"EscrowAccountHistory", 'String'>
    readonly createdAt: FieldRef<"EscrowAccountHistory", 'DateTime'>
    readonly updatedAt: FieldRef<"EscrowAccountHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EscrowAccountHistory findUnique
   */
  export type EscrowAccountHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowAccountHistory
     */
    select?: EscrowAccountHistorySelect<ExtArgs> | null
    /**
     * Filter, which EscrowAccountHistory to fetch.
     */
    where: EscrowAccountHistoryWhereUniqueInput
  }

  /**
   * EscrowAccountHistory findUniqueOrThrow
   */
  export type EscrowAccountHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowAccountHistory
     */
    select?: EscrowAccountHistorySelect<ExtArgs> | null
    /**
     * Filter, which EscrowAccountHistory to fetch.
     */
    where: EscrowAccountHistoryWhereUniqueInput
  }

  /**
   * EscrowAccountHistory findFirst
   */
  export type EscrowAccountHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowAccountHistory
     */
    select?: EscrowAccountHistorySelect<ExtArgs> | null
    /**
     * Filter, which EscrowAccountHistory to fetch.
     */
    where?: EscrowAccountHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowAccountHistories to fetch.
     */
    orderBy?: EscrowAccountHistoryOrderByWithRelationInput | EscrowAccountHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscrowAccountHistories.
     */
    cursor?: EscrowAccountHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowAccountHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowAccountHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscrowAccountHistories.
     */
    distinct?: EscrowAccountHistoryScalarFieldEnum | EscrowAccountHistoryScalarFieldEnum[]
  }

  /**
   * EscrowAccountHistory findFirstOrThrow
   */
  export type EscrowAccountHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowAccountHistory
     */
    select?: EscrowAccountHistorySelect<ExtArgs> | null
    /**
     * Filter, which EscrowAccountHistory to fetch.
     */
    where?: EscrowAccountHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowAccountHistories to fetch.
     */
    orderBy?: EscrowAccountHistoryOrderByWithRelationInput | EscrowAccountHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscrowAccountHistories.
     */
    cursor?: EscrowAccountHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowAccountHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowAccountHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscrowAccountHistories.
     */
    distinct?: EscrowAccountHistoryScalarFieldEnum | EscrowAccountHistoryScalarFieldEnum[]
  }

  /**
   * EscrowAccountHistory findMany
   */
  export type EscrowAccountHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowAccountHistory
     */
    select?: EscrowAccountHistorySelect<ExtArgs> | null
    /**
     * Filter, which EscrowAccountHistories to fetch.
     */
    where?: EscrowAccountHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowAccountHistories to fetch.
     */
    orderBy?: EscrowAccountHistoryOrderByWithRelationInput | EscrowAccountHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EscrowAccountHistories.
     */
    cursor?: EscrowAccountHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowAccountHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowAccountHistories.
     */
    skip?: number
    distinct?: EscrowAccountHistoryScalarFieldEnum | EscrowAccountHistoryScalarFieldEnum[]
  }

  /**
   * EscrowAccountHistory create
   */
  export type EscrowAccountHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowAccountHistory
     */
    select?: EscrowAccountHistorySelect<ExtArgs> | null
    /**
     * The data needed to create a EscrowAccountHistory.
     */
    data: XOR<EscrowAccountHistoryCreateInput, EscrowAccountHistoryUncheckedCreateInput>
  }

  /**
   * EscrowAccountHistory createMany
   */
  export type EscrowAccountHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EscrowAccountHistories.
     */
    data: EscrowAccountHistoryCreateManyInput | EscrowAccountHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EscrowAccountHistory update
   */
  export type EscrowAccountHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowAccountHistory
     */
    select?: EscrowAccountHistorySelect<ExtArgs> | null
    /**
     * The data needed to update a EscrowAccountHistory.
     */
    data: XOR<EscrowAccountHistoryUpdateInput, EscrowAccountHistoryUncheckedUpdateInput>
    /**
     * Choose, which EscrowAccountHistory to update.
     */
    where: EscrowAccountHistoryWhereUniqueInput
  }

  /**
   * EscrowAccountHistory updateMany
   */
  export type EscrowAccountHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EscrowAccountHistories.
     */
    data: XOR<EscrowAccountHistoryUpdateManyMutationInput, EscrowAccountHistoryUncheckedUpdateManyInput>
    /**
     * Filter which EscrowAccountHistories to update
     */
    where?: EscrowAccountHistoryWhereInput
  }

  /**
   * EscrowAccountHistory upsert
   */
  export type EscrowAccountHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowAccountHistory
     */
    select?: EscrowAccountHistorySelect<ExtArgs> | null
    /**
     * The filter to search for the EscrowAccountHistory to update in case it exists.
     */
    where: EscrowAccountHistoryWhereUniqueInput
    /**
     * In case the EscrowAccountHistory found by the `where` argument doesn't exist, create a new EscrowAccountHistory with this data.
     */
    create: XOR<EscrowAccountHistoryCreateInput, EscrowAccountHistoryUncheckedCreateInput>
    /**
     * In case the EscrowAccountHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EscrowAccountHistoryUpdateInput, EscrowAccountHistoryUncheckedUpdateInput>
  }

  /**
   * EscrowAccountHistory delete
   */
  export type EscrowAccountHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowAccountHistory
     */
    select?: EscrowAccountHistorySelect<ExtArgs> | null
    /**
     * Filter which EscrowAccountHistory to delete.
     */
    where: EscrowAccountHistoryWhereUniqueInput
  }

  /**
   * EscrowAccountHistory deleteMany
   */
  export type EscrowAccountHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscrowAccountHistories to delete
     */
    where?: EscrowAccountHistoryWhereInput
  }

  /**
   * EscrowAccountHistory without action
   */
  export type EscrowAccountHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowAccountHistory
     */
    select?: EscrowAccountHistorySelect<ExtArgs> | null
  }


  /**
   * Model RealEstateAgencyAct
   */

  export type AggregateRealEstateAgencyAct = {
    _count: RealEstateAgencyActCountAggregateOutputType | null
    _avg: RealEstateAgencyActAvgAggregateOutputType | null
    _sum: RealEstateAgencyActSumAggregateOutputType | null
    _min: RealEstateAgencyActMinAggregateOutputType | null
    _max: RealEstateAgencyActMaxAggregateOutputType | null
  }

  export type RealEstateAgencyActAvgAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    retention: Decimal | null
    clientContractId: number | null
    agencyId: number | null
    agencyContractId: number | null
  }

  export type RealEstateAgencyActSumAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    retention: Decimal | null
    clientContractId: number | null
    agencyId: number | null
    agencyContractId: number | null
  }

  export type RealEstateAgencyActMinAggregateOutputType = {
    id: number | null
    number: string | null
    date: Date | null
    amount: Decimal | null
    retention: Decimal | null
    note: string | null
    link: string | null
    clientContractId: number | null
    agencyId: number | null
    agencyContractId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RealEstateAgencyActMaxAggregateOutputType = {
    id: number | null
    number: string | null
    date: Date | null
    amount: Decimal | null
    retention: Decimal | null
    note: string | null
    link: string | null
    clientContractId: number | null
    agencyId: number | null
    agencyContractId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RealEstateAgencyActCountAggregateOutputType = {
    id: number
    number: number
    date: number
    amount: number
    retention: number
    note: number
    link: number
    clientContractId: number
    agencyId: number
    agencyContractId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RealEstateAgencyActAvgAggregateInputType = {
    id?: true
    amount?: true
    retention?: true
    clientContractId?: true
    agencyId?: true
    agencyContractId?: true
  }

  export type RealEstateAgencyActSumAggregateInputType = {
    id?: true
    amount?: true
    retention?: true
    clientContractId?: true
    agencyId?: true
    agencyContractId?: true
  }

  export type RealEstateAgencyActMinAggregateInputType = {
    id?: true
    number?: true
    date?: true
    amount?: true
    retention?: true
    note?: true
    link?: true
    clientContractId?: true
    agencyId?: true
    agencyContractId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RealEstateAgencyActMaxAggregateInputType = {
    id?: true
    number?: true
    date?: true
    amount?: true
    retention?: true
    note?: true
    link?: true
    clientContractId?: true
    agencyId?: true
    agencyContractId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RealEstateAgencyActCountAggregateInputType = {
    id?: true
    number?: true
    date?: true
    amount?: true
    retention?: true
    note?: true
    link?: true
    clientContractId?: true
    agencyId?: true
    agencyContractId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RealEstateAgencyActAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RealEstateAgencyAct to aggregate.
     */
    where?: RealEstateAgencyActWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgencyActs to fetch.
     */
    orderBy?: RealEstateAgencyActOrderByWithRelationInput | RealEstateAgencyActOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RealEstateAgencyActWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgencyActs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgencyActs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RealEstateAgencyActs
    **/
    _count?: true | RealEstateAgencyActCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RealEstateAgencyActAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RealEstateAgencyActSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RealEstateAgencyActMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RealEstateAgencyActMaxAggregateInputType
  }

  export type GetRealEstateAgencyActAggregateType<T extends RealEstateAgencyActAggregateArgs> = {
        [P in keyof T & keyof AggregateRealEstateAgencyAct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRealEstateAgencyAct[P]>
      : GetScalarType<T[P], AggregateRealEstateAgencyAct[P]>
  }




  export type RealEstateAgencyActGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RealEstateAgencyActWhereInput
    orderBy?: RealEstateAgencyActOrderByWithAggregationInput | RealEstateAgencyActOrderByWithAggregationInput[]
    by: RealEstateAgencyActScalarFieldEnum[] | RealEstateAgencyActScalarFieldEnum
    having?: RealEstateAgencyActScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RealEstateAgencyActCountAggregateInputType | true
    _avg?: RealEstateAgencyActAvgAggregateInputType
    _sum?: RealEstateAgencyActSumAggregateInputType
    _min?: RealEstateAgencyActMinAggregateInputType
    _max?: RealEstateAgencyActMaxAggregateInputType
  }

  export type RealEstateAgencyActGroupByOutputType = {
    id: number
    number: string
    date: Date
    amount: Decimal
    retention: Decimal | null
    note: string | null
    link: string | null
    clientContractId: number
    agencyId: number
    agencyContractId: number
    createdAt: Date
    updatedAt: Date
    _count: RealEstateAgencyActCountAggregateOutputType | null
    _avg: RealEstateAgencyActAvgAggregateOutputType | null
    _sum: RealEstateAgencyActSumAggregateOutputType | null
    _min: RealEstateAgencyActMinAggregateOutputType | null
    _max: RealEstateAgencyActMaxAggregateOutputType | null
  }

  type GetRealEstateAgencyActGroupByPayload<T extends RealEstateAgencyActGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RealEstateAgencyActGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RealEstateAgencyActGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RealEstateAgencyActGroupByOutputType[P]>
            : GetScalarType<T[P], RealEstateAgencyActGroupByOutputType[P]>
        }
      >
    >


  export type RealEstateAgencyActSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    amount?: boolean
    retention?: boolean
    note?: boolean
    link?: boolean
    clientContractId?: boolean
    agencyId?: boolean
    agencyContractId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientContract?: boolean | ClientContractDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    agencyContract?: boolean | AgencyContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["realEstateAgencyAct"]>


  export type RealEstateAgencyActSelectScalar = {
    id?: boolean
    number?: boolean
    date?: boolean
    amount?: boolean
    retention?: boolean
    note?: boolean
    link?: boolean
    clientContractId?: boolean
    agencyId?: boolean
    agencyContractId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RealEstateAgencyActInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientContract?: boolean | ClientContractDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    agencyContract?: boolean | AgencyContractDefaultArgs<ExtArgs>
  }

  export type $RealEstateAgencyActPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RealEstateAgencyAct"
    objects: {
      clientContract: Prisma.$ClientContractPayload<ExtArgs>
      agency: Prisma.$AgencyPayload<ExtArgs>
      agencyContract: Prisma.$AgencyContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      number: string
      date: Date
      amount: Prisma.Decimal
      retention: Prisma.Decimal | null
      note: string | null
      link: string | null
      clientContractId: number
      agencyId: number
      agencyContractId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["realEstateAgencyAct"]>
    composites: {}
  }

  type RealEstateAgencyActGetPayload<S extends boolean | null | undefined | RealEstateAgencyActDefaultArgs> = $Result.GetResult<Prisma.$RealEstateAgencyActPayload, S>

  type RealEstateAgencyActCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RealEstateAgencyActFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RealEstateAgencyActCountAggregateInputType | true
    }

  export interface RealEstateAgencyActDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RealEstateAgencyAct'], meta: { name: 'RealEstateAgencyAct' } }
    /**
     * Find zero or one RealEstateAgencyAct that matches the filter.
     * @param {RealEstateAgencyActFindUniqueArgs} args - Arguments to find a RealEstateAgencyAct
     * @example
     * // Get one RealEstateAgencyAct
     * const realEstateAgencyAct = await prisma.realEstateAgencyAct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RealEstateAgencyActFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgencyActFindUniqueArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyActClient<$Result.GetResult<Prisma.$RealEstateAgencyActPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RealEstateAgencyAct that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RealEstateAgencyActFindUniqueOrThrowArgs} args - Arguments to find a RealEstateAgencyAct
     * @example
     * // Get one RealEstateAgencyAct
     * const realEstateAgencyAct = await prisma.realEstateAgencyAct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RealEstateAgencyActFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgencyActFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyActClient<$Result.GetResult<Prisma.$RealEstateAgencyActPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RealEstateAgencyAct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyActFindFirstArgs} args - Arguments to find a RealEstateAgencyAct
     * @example
     * // Get one RealEstateAgencyAct
     * const realEstateAgencyAct = await prisma.realEstateAgencyAct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RealEstateAgencyActFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgencyActFindFirstArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyActClient<$Result.GetResult<Prisma.$RealEstateAgencyActPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RealEstateAgencyAct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyActFindFirstOrThrowArgs} args - Arguments to find a RealEstateAgencyAct
     * @example
     * // Get one RealEstateAgencyAct
     * const realEstateAgencyAct = await prisma.realEstateAgencyAct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RealEstateAgencyActFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgencyActFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyActClient<$Result.GetResult<Prisma.$RealEstateAgencyActPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RealEstateAgencyActs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyActFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RealEstateAgencyActs
     * const realEstateAgencyActs = await prisma.realEstateAgencyAct.findMany()
     * 
     * // Get first 10 RealEstateAgencyActs
     * const realEstateAgencyActs = await prisma.realEstateAgencyAct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const realEstateAgencyActWithIdOnly = await prisma.realEstateAgencyAct.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RealEstateAgencyActFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgencyActFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RealEstateAgencyActPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RealEstateAgencyAct.
     * @param {RealEstateAgencyActCreateArgs} args - Arguments to create a RealEstateAgencyAct.
     * @example
     * // Create one RealEstateAgencyAct
     * const RealEstateAgencyAct = await prisma.realEstateAgencyAct.create({
     *   data: {
     *     // ... data to create a RealEstateAgencyAct
     *   }
     * })
     * 
    **/
    create<T extends RealEstateAgencyActCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgencyActCreateArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyActClient<$Result.GetResult<Prisma.$RealEstateAgencyActPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RealEstateAgencyActs.
     * @param {RealEstateAgencyActCreateManyArgs} args - Arguments to create many RealEstateAgencyActs.
     * @example
     * // Create many RealEstateAgencyActs
     * const realEstateAgencyAct = await prisma.realEstateAgencyAct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends RealEstateAgencyActCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgencyActCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RealEstateAgencyAct.
     * @param {RealEstateAgencyActDeleteArgs} args - Arguments to delete one RealEstateAgencyAct.
     * @example
     * // Delete one RealEstateAgencyAct
     * const RealEstateAgencyAct = await prisma.realEstateAgencyAct.delete({
     *   where: {
     *     // ... filter to delete one RealEstateAgencyAct
     *   }
     * })
     * 
    **/
    delete<T extends RealEstateAgencyActDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgencyActDeleteArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyActClient<$Result.GetResult<Prisma.$RealEstateAgencyActPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RealEstateAgencyAct.
     * @param {RealEstateAgencyActUpdateArgs} args - Arguments to update one RealEstateAgencyAct.
     * @example
     * // Update one RealEstateAgencyAct
     * const realEstateAgencyAct = await prisma.realEstateAgencyAct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RealEstateAgencyActUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgencyActUpdateArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyActClient<$Result.GetResult<Prisma.$RealEstateAgencyActPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RealEstateAgencyActs.
     * @param {RealEstateAgencyActDeleteManyArgs} args - Arguments to filter RealEstateAgencyActs to delete.
     * @example
     * // Delete a few RealEstateAgencyActs
     * const { count } = await prisma.realEstateAgencyAct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RealEstateAgencyActDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RealEstateAgencyActDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RealEstateAgencyActs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyActUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RealEstateAgencyActs
     * const realEstateAgencyAct = await prisma.realEstateAgencyAct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RealEstateAgencyActUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgencyActUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RealEstateAgencyAct.
     * @param {RealEstateAgencyActUpsertArgs} args - Arguments to update or create a RealEstateAgencyAct.
     * @example
     * // Update or create a RealEstateAgencyAct
     * const realEstateAgencyAct = await prisma.realEstateAgencyAct.upsert({
     *   create: {
     *     // ... data to create a RealEstateAgencyAct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RealEstateAgencyAct we want to update
     *   }
     * })
    **/
    upsert<T extends RealEstateAgencyActUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RealEstateAgencyActUpsertArgs<ExtArgs>>
    ): Prisma__RealEstateAgencyActClient<$Result.GetResult<Prisma.$RealEstateAgencyActPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RealEstateAgencyActs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyActCountArgs} args - Arguments to filter RealEstateAgencyActs to count.
     * @example
     * // Count the number of RealEstateAgencyActs
     * const count = await prisma.realEstateAgencyAct.count({
     *   where: {
     *     // ... the filter for the RealEstateAgencyActs we want to count
     *   }
     * })
    **/
    count<T extends RealEstateAgencyActCountArgs>(
      args?: Subset<T, RealEstateAgencyActCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RealEstateAgencyActCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RealEstateAgencyAct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyActAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RealEstateAgencyActAggregateArgs>(args: Subset<T, RealEstateAgencyActAggregateArgs>): Prisma.PrismaPromise<GetRealEstateAgencyActAggregateType<T>>

    /**
     * Group by RealEstateAgencyAct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgencyActGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RealEstateAgencyActGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RealEstateAgencyActGroupByArgs['orderBy'] }
        : { orderBy?: RealEstateAgencyActGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RealEstateAgencyActGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRealEstateAgencyActGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RealEstateAgencyAct model
   */
  readonly fields: RealEstateAgencyActFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RealEstateAgencyAct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RealEstateAgencyActClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    clientContract<T extends ClientContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientContractDefaultArgs<ExtArgs>>): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    agencyContract<T extends AgencyContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyContractDefaultArgs<ExtArgs>>): Prisma__AgencyContractClient<$Result.GetResult<Prisma.$AgencyContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RealEstateAgencyAct model
   */ 
  interface RealEstateAgencyActFieldRefs {
    readonly id: FieldRef<"RealEstateAgencyAct", 'Int'>
    readonly number: FieldRef<"RealEstateAgencyAct", 'String'>
    readonly date: FieldRef<"RealEstateAgencyAct", 'DateTime'>
    readonly amount: FieldRef<"RealEstateAgencyAct", 'Decimal'>
    readonly retention: FieldRef<"RealEstateAgencyAct", 'Decimal'>
    readonly note: FieldRef<"RealEstateAgencyAct", 'String'>
    readonly link: FieldRef<"RealEstateAgencyAct", 'String'>
    readonly clientContractId: FieldRef<"RealEstateAgencyAct", 'Int'>
    readonly agencyId: FieldRef<"RealEstateAgencyAct", 'Int'>
    readonly agencyContractId: FieldRef<"RealEstateAgencyAct", 'Int'>
    readonly createdAt: FieldRef<"RealEstateAgencyAct", 'DateTime'>
    readonly updatedAt: FieldRef<"RealEstateAgencyAct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RealEstateAgencyAct findUnique
   */
  export type RealEstateAgencyActFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyAct
     */
    select?: RealEstateAgencyActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyActInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgencyAct to fetch.
     */
    where: RealEstateAgencyActWhereUniqueInput
  }

  /**
   * RealEstateAgencyAct findUniqueOrThrow
   */
  export type RealEstateAgencyActFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyAct
     */
    select?: RealEstateAgencyActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyActInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgencyAct to fetch.
     */
    where: RealEstateAgencyActWhereUniqueInput
  }

  /**
   * RealEstateAgencyAct findFirst
   */
  export type RealEstateAgencyActFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyAct
     */
    select?: RealEstateAgencyActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyActInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgencyAct to fetch.
     */
    where?: RealEstateAgencyActWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgencyActs to fetch.
     */
    orderBy?: RealEstateAgencyActOrderByWithRelationInput | RealEstateAgencyActOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealEstateAgencyActs.
     */
    cursor?: RealEstateAgencyActWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgencyActs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgencyActs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealEstateAgencyActs.
     */
    distinct?: RealEstateAgencyActScalarFieldEnum | RealEstateAgencyActScalarFieldEnum[]
  }

  /**
   * RealEstateAgencyAct findFirstOrThrow
   */
  export type RealEstateAgencyActFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyAct
     */
    select?: RealEstateAgencyActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyActInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgencyAct to fetch.
     */
    where?: RealEstateAgencyActWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgencyActs to fetch.
     */
    orderBy?: RealEstateAgencyActOrderByWithRelationInput | RealEstateAgencyActOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealEstateAgencyActs.
     */
    cursor?: RealEstateAgencyActWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgencyActs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgencyActs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealEstateAgencyActs.
     */
    distinct?: RealEstateAgencyActScalarFieldEnum | RealEstateAgencyActScalarFieldEnum[]
  }

  /**
   * RealEstateAgencyAct findMany
   */
  export type RealEstateAgencyActFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyAct
     */
    select?: RealEstateAgencyActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyActInclude<ExtArgs> | null
    /**
     * Filter, which RealEstateAgencyActs to fetch.
     */
    where?: RealEstateAgencyActWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgencyActs to fetch.
     */
    orderBy?: RealEstateAgencyActOrderByWithRelationInput | RealEstateAgencyActOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RealEstateAgencyActs.
     */
    cursor?: RealEstateAgencyActWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgencyActs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgencyActs.
     */
    skip?: number
    distinct?: RealEstateAgencyActScalarFieldEnum | RealEstateAgencyActScalarFieldEnum[]
  }

  /**
   * RealEstateAgencyAct create
   */
  export type RealEstateAgencyActCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyAct
     */
    select?: RealEstateAgencyActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyActInclude<ExtArgs> | null
    /**
     * The data needed to create a RealEstateAgencyAct.
     */
    data: XOR<RealEstateAgencyActCreateInput, RealEstateAgencyActUncheckedCreateInput>
  }

  /**
   * RealEstateAgencyAct createMany
   */
  export type RealEstateAgencyActCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RealEstateAgencyActs.
     */
    data: RealEstateAgencyActCreateManyInput | RealEstateAgencyActCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RealEstateAgencyAct update
   */
  export type RealEstateAgencyActUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyAct
     */
    select?: RealEstateAgencyActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyActInclude<ExtArgs> | null
    /**
     * The data needed to update a RealEstateAgencyAct.
     */
    data: XOR<RealEstateAgencyActUpdateInput, RealEstateAgencyActUncheckedUpdateInput>
    /**
     * Choose, which RealEstateAgencyAct to update.
     */
    where: RealEstateAgencyActWhereUniqueInput
  }

  /**
   * RealEstateAgencyAct updateMany
   */
  export type RealEstateAgencyActUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RealEstateAgencyActs.
     */
    data: XOR<RealEstateAgencyActUpdateManyMutationInput, RealEstateAgencyActUncheckedUpdateManyInput>
    /**
     * Filter which RealEstateAgencyActs to update
     */
    where?: RealEstateAgencyActWhereInput
  }

  /**
   * RealEstateAgencyAct upsert
   */
  export type RealEstateAgencyActUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyAct
     */
    select?: RealEstateAgencyActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyActInclude<ExtArgs> | null
    /**
     * The filter to search for the RealEstateAgencyAct to update in case it exists.
     */
    where: RealEstateAgencyActWhereUniqueInput
    /**
     * In case the RealEstateAgencyAct found by the `where` argument doesn't exist, create a new RealEstateAgencyAct with this data.
     */
    create: XOR<RealEstateAgencyActCreateInput, RealEstateAgencyActUncheckedCreateInput>
    /**
     * In case the RealEstateAgencyAct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RealEstateAgencyActUpdateInput, RealEstateAgencyActUncheckedUpdateInput>
  }

  /**
   * RealEstateAgencyAct delete
   */
  export type RealEstateAgencyActDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyAct
     */
    select?: RealEstateAgencyActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyActInclude<ExtArgs> | null
    /**
     * Filter which RealEstateAgencyAct to delete.
     */
    where: RealEstateAgencyActWhereUniqueInput
  }

  /**
   * RealEstateAgencyAct deleteMany
   */
  export type RealEstateAgencyActDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RealEstateAgencyActs to delete
     */
    where?: RealEstateAgencyActWhereInput
  }

  /**
   * RealEstateAgencyAct without action
   */
  export type RealEstateAgencyActDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealEstateAgencyAct
     */
    select?: RealEstateAgencyActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealEstateAgencyActInclude<ExtArgs> | null
  }


  /**
   * Model Subsidy
   */

  export type AggregateSubsidy = {
    _count: SubsidyCountAggregateOutputType | null
    _avg: SubsidyAvgAggregateOutputType | null
    _sum: SubsidySumAggregateOutputType | null
    _min: SubsidyMinAggregateOutputType | null
    _max: SubsidyMaxAggregateOutputType | null
  }

  export type SubsidyAvgAggregateOutputType = {
    id: number | null
  }

  export type SubsidySumAggregateOutputType = {
    id: number | null
  }

  export type SubsidyMinAggregateOutputType = {
    id: number | null
    name: string | null
    isVisible: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubsidyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    isVisible: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubsidyCountAggregateOutputType = {
    id: number
    name: number
    isVisible: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubsidyAvgAggregateInputType = {
    id?: true
  }

  export type SubsidySumAggregateInputType = {
    id?: true
  }

  export type SubsidyMinAggregateInputType = {
    id?: true
    name?: true
    isVisible?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubsidyMaxAggregateInputType = {
    id?: true
    name?: true
    isVisible?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubsidyCountAggregateInputType = {
    id?: true
    name?: true
    isVisible?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubsidyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subsidy to aggregate.
     */
    where?: SubsidyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subsidies to fetch.
     */
    orderBy?: SubsidyOrderByWithRelationInput | SubsidyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubsidyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subsidies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subsidies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subsidies
    **/
    _count?: true | SubsidyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubsidyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubsidySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubsidyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubsidyMaxAggregateInputType
  }

  export type GetSubsidyAggregateType<T extends SubsidyAggregateArgs> = {
        [P in keyof T & keyof AggregateSubsidy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubsidy[P]>
      : GetScalarType<T[P], AggregateSubsidy[P]>
  }




  export type SubsidyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubsidyWhereInput
    orderBy?: SubsidyOrderByWithAggregationInput | SubsidyOrderByWithAggregationInput[]
    by: SubsidyScalarFieldEnum[] | SubsidyScalarFieldEnum
    having?: SubsidyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubsidyCountAggregateInputType | true
    _avg?: SubsidyAvgAggregateInputType
    _sum?: SubsidySumAggregateInputType
    _min?: SubsidyMinAggregateInputType
    _max?: SubsidyMaxAggregateInputType
  }

  export type SubsidyGroupByOutputType = {
    id: number
    name: string
    isVisible: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubsidyCountAggregateOutputType | null
    _avg: SubsidyAvgAggregateOutputType | null
    _sum: SubsidySumAggregateOutputType | null
    _min: SubsidyMinAggregateOutputType | null
    _max: SubsidyMaxAggregateOutputType | null
  }

  type GetSubsidyGroupByPayload<T extends SubsidyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubsidyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubsidyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubsidyGroupByOutputType[P]>
            : GetScalarType<T[P], SubsidyGroupByOutputType[P]>
        }
      >
    >


  export type SubsidySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isVisible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientContracts?: boolean | Subsidy$clientContractsArgs<ExtArgs>
    _count?: boolean | SubsidyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subsidy"]>


  export type SubsidySelectScalar = {
    id?: boolean
    name?: boolean
    isVisible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubsidyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientContracts?: boolean | Subsidy$clientContractsArgs<ExtArgs>
    _count?: boolean | SubsidyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SubsidyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subsidy"
    objects: {
      clientContracts: Prisma.$ClientContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      isVisible: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subsidy"]>
    composites: {}
  }

  type SubsidyGetPayload<S extends boolean | null | undefined | SubsidyDefaultArgs> = $Result.GetResult<Prisma.$SubsidyPayload, S>

  type SubsidyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubsidyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubsidyCountAggregateInputType | true
    }

  export interface SubsidyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subsidy'], meta: { name: 'Subsidy' } }
    /**
     * Find zero or one Subsidy that matches the filter.
     * @param {SubsidyFindUniqueArgs} args - Arguments to find a Subsidy
     * @example
     * // Get one Subsidy
     * const subsidy = await prisma.subsidy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubsidyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SubsidyFindUniqueArgs<ExtArgs>>
    ): Prisma__SubsidyClient<$Result.GetResult<Prisma.$SubsidyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Subsidy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubsidyFindUniqueOrThrowArgs} args - Arguments to find a Subsidy
     * @example
     * // Get one Subsidy
     * const subsidy = await prisma.subsidy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubsidyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubsidyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SubsidyClient<$Result.GetResult<Prisma.$SubsidyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Subsidy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidyFindFirstArgs} args - Arguments to find a Subsidy
     * @example
     * // Get one Subsidy
     * const subsidy = await prisma.subsidy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubsidyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SubsidyFindFirstArgs<ExtArgs>>
    ): Prisma__SubsidyClient<$Result.GetResult<Prisma.$SubsidyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Subsidy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidyFindFirstOrThrowArgs} args - Arguments to find a Subsidy
     * @example
     * // Get one Subsidy
     * const subsidy = await prisma.subsidy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubsidyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubsidyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SubsidyClient<$Result.GetResult<Prisma.$SubsidyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Subsidies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subsidies
     * const subsidies = await prisma.subsidy.findMany()
     * 
     * // Get first 10 Subsidies
     * const subsidies = await prisma.subsidy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subsidyWithIdOnly = await prisma.subsidy.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubsidyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubsidyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubsidyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Subsidy.
     * @param {SubsidyCreateArgs} args - Arguments to create a Subsidy.
     * @example
     * // Create one Subsidy
     * const Subsidy = await prisma.subsidy.create({
     *   data: {
     *     // ... data to create a Subsidy
     *   }
     * })
     * 
    **/
    create<T extends SubsidyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SubsidyCreateArgs<ExtArgs>>
    ): Prisma__SubsidyClient<$Result.GetResult<Prisma.$SubsidyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Subsidies.
     * @param {SubsidyCreateManyArgs} args - Arguments to create many Subsidies.
     * @example
     * // Create many Subsidies
     * const subsidy = await prisma.subsidy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends SubsidyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubsidyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subsidy.
     * @param {SubsidyDeleteArgs} args - Arguments to delete one Subsidy.
     * @example
     * // Delete one Subsidy
     * const Subsidy = await prisma.subsidy.delete({
     *   where: {
     *     // ... filter to delete one Subsidy
     *   }
     * })
     * 
    **/
    delete<T extends SubsidyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SubsidyDeleteArgs<ExtArgs>>
    ): Prisma__SubsidyClient<$Result.GetResult<Prisma.$SubsidyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Subsidy.
     * @param {SubsidyUpdateArgs} args - Arguments to update one Subsidy.
     * @example
     * // Update one Subsidy
     * const subsidy = await prisma.subsidy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubsidyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SubsidyUpdateArgs<ExtArgs>>
    ): Prisma__SubsidyClient<$Result.GetResult<Prisma.$SubsidyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Subsidies.
     * @param {SubsidyDeleteManyArgs} args - Arguments to filter Subsidies to delete.
     * @example
     * // Delete a few Subsidies
     * const { count } = await prisma.subsidy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubsidyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubsidyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subsidies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subsidies
     * const subsidy = await prisma.subsidy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubsidyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SubsidyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subsidy.
     * @param {SubsidyUpsertArgs} args - Arguments to update or create a Subsidy.
     * @example
     * // Update or create a Subsidy
     * const subsidy = await prisma.subsidy.upsert({
     *   create: {
     *     // ... data to create a Subsidy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subsidy we want to update
     *   }
     * })
    **/
    upsert<T extends SubsidyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SubsidyUpsertArgs<ExtArgs>>
    ): Prisma__SubsidyClient<$Result.GetResult<Prisma.$SubsidyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Subsidies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidyCountArgs} args - Arguments to filter Subsidies to count.
     * @example
     * // Count the number of Subsidies
     * const count = await prisma.subsidy.count({
     *   where: {
     *     // ... the filter for the Subsidies we want to count
     *   }
     * })
    **/
    count<T extends SubsidyCountArgs>(
      args?: Subset<T, SubsidyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubsidyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subsidy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubsidyAggregateArgs>(args: Subset<T, SubsidyAggregateArgs>): Prisma.PrismaPromise<GetSubsidyAggregateType<T>>

    /**
     * Group by Subsidy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubsidyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubsidyGroupByArgs['orderBy'] }
        : { orderBy?: SubsidyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubsidyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubsidyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subsidy model
   */
  readonly fields: SubsidyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subsidy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubsidyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    clientContracts<T extends Subsidy$clientContractsArgs<ExtArgs> = {}>(args?: Subset<T, Subsidy$clientContractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Subsidy model
   */ 
  interface SubsidyFieldRefs {
    readonly id: FieldRef<"Subsidy", 'Int'>
    readonly name: FieldRef<"Subsidy", 'String'>
    readonly isVisible: FieldRef<"Subsidy", 'Boolean'>
    readonly createdAt: FieldRef<"Subsidy", 'DateTime'>
    readonly updatedAt: FieldRef<"Subsidy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subsidy findUnique
   */
  export type SubsidyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subsidy
     */
    select?: SubsidySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyInclude<ExtArgs> | null
    /**
     * Filter, which Subsidy to fetch.
     */
    where: SubsidyWhereUniqueInput
  }

  /**
   * Subsidy findUniqueOrThrow
   */
  export type SubsidyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subsidy
     */
    select?: SubsidySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyInclude<ExtArgs> | null
    /**
     * Filter, which Subsidy to fetch.
     */
    where: SubsidyWhereUniqueInput
  }

  /**
   * Subsidy findFirst
   */
  export type SubsidyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subsidy
     */
    select?: SubsidySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyInclude<ExtArgs> | null
    /**
     * Filter, which Subsidy to fetch.
     */
    where?: SubsidyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subsidies to fetch.
     */
    orderBy?: SubsidyOrderByWithRelationInput | SubsidyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subsidies.
     */
    cursor?: SubsidyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subsidies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subsidies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subsidies.
     */
    distinct?: SubsidyScalarFieldEnum | SubsidyScalarFieldEnum[]
  }

  /**
   * Subsidy findFirstOrThrow
   */
  export type SubsidyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subsidy
     */
    select?: SubsidySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyInclude<ExtArgs> | null
    /**
     * Filter, which Subsidy to fetch.
     */
    where?: SubsidyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subsidies to fetch.
     */
    orderBy?: SubsidyOrderByWithRelationInput | SubsidyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subsidies.
     */
    cursor?: SubsidyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subsidies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subsidies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subsidies.
     */
    distinct?: SubsidyScalarFieldEnum | SubsidyScalarFieldEnum[]
  }

  /**
   * Subsidy findMany
   */
  export type SubsidyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subsidy
     */
    select?: SubsidySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyInclude<ExtArgs> | null
    /**
     * Filter, which Subsidies to fetch.
     */
    where?: SubsidyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subsidies to fetch.
     */
    orderBy?: SubsidyOrderByWithRelationInput | SubsidyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subsidies.
     */
    cursor?: SubsidyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subsidies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subsidies.
     */
    skip?: number
    distinct?: SubsidyScalarFieldEnum | SubsidyScalarFieldEnum[]
  }

  /**
   * Subsidy create
   */
  export type SubsidyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subsidy
     */
    select?: SubsidySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyInclude<ExtArgs> | null
    /**
     * The data needed to create a Subsidy.
     */
    data: XOR<SubsidyCreateInput, SubsidyUncheckedCreateInput>
  }

  /**
   * Subsidy createMany
   */
  export type SubsidyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subsidies.
     */
    data: SubsidyCreateManyInput | SubsidyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subsidy update
   */
  export type SubsidyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subsidy
     */
    select?: SubsidySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyInclude<ExtArgs> | null
    /**
     * The data needed to update a Subsidy.
     */
    data: XOR<SubsidyUpdateInput, SubsidyUncheckedUpdateInput>
    /**
     * Choose, which Subsidy to update.
     */
    where: SubsidyWhereUniqueInput
  }

  /**
   * Subsidy updateMany
   */
  export type SubsidyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subsidies.
     */
    data: XOR<SubsidyUpdateManyMutationInput, SubsidyUncheckedUpdateManyInput>
    /**
     * Filter which Subsidies to update
     */
    where?: SubsidyWhereInput
  }

  /**
   * Subsidy upsert
   */
  export type SubsidyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subsidy
     */
    select?: SubsidySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyInclude<ExtArgs> | null
    /**
     * The filter to search for the Subsidy to update in case it exists.
     */
    where: SubsidyWhereUniqueInput
    /**
     * In case the Subsidy found by the `where` argument doesn't exist, create a new Subsidy with this data.
     */
    create: XOR<SubsidyCreateInput, SubsidyUncheckedCreateInput>
    /**
     * In case the Subsidy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubsidyUpdateInput, SubsidyUncheckedUpdateInput>
  }

  /**
   * Subsidy delete
   */
  export type SubsidyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subsidy
     */
    select?: SubsidySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyInclude<ExtArgs> | null
    /**
     * Filter which Subsidy to delete.
     */
    where: SubsidyWhereUniqueInput
  }

  /**
   * Subsidy deleteMany
   */
  export type SubsidyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subsidies to delete
     */
    where?: SubsidyWhereInput
  }

  /**
   * Subsidy.clientContracts
   */
  export type Subsidy$clientContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContract
     */
    select?: ClientContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContractInclude<ExtArgs> | null
    where?: ClientContractWhereInput
    orderBy?: ClientContractOrderByWithRelationInput | ClientContractOrderByWithRelationInput[]
    cursor?: ClientContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientContractScalarFieldEnum | ClientContractScalarFieldEnum[]
  }

  /**
   * Subsidy without action
   */
  export type SubsidyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subsidy
     */
    select?: SubsidySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyInclude<ExtArgs> | null
  }


  /**
   * Model Assignment
   */

  export type AggregateAssignment = {
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  export type AssignmentAvgAggregateOutputType = {
    id: number | null
    order: number | null
    clientContractId: number | null
    clientId: number | null
  }

  export type AssignmentSumAggregateOutputType = {
    id: number | null
    order: number | null
    clientContractId: number | null
    clientId: number | null
  }

  export type AssignmentMinAggregateOutputType = {
    id: number | null
    order: number | null
    clientContractId: number | null
    clientId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssignmentMaxAggregateOutputType = {
    id: number | null
    order: number | null
    clientContractId: number | null
    clientId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssignmentCountAggregateOutputType = {
    id: number
    order: number
    clientContractId: number
    clientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssignmentAvgAggregateInputType = {
    id?: true
    order?: true
    clientContractId?: true
    clientId?: true
  }

  export type AssignmentSumAggregateInputType = {
    id?: true
    order?: true
    clientContractId?: true
    clientId?: true
  }

  export type AssignmentMinAggregateInputType = {
    id?: true
    order?: true
    clientContractId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssignmentMaxAggregateInputType = {
    id?: true
    order?: true
    clientContractId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssignmentCountAggregateInputType = {
    id?: true
    order?: true
    clientContractId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignment to aggregate.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assignments
    **/
    _count?: true | AssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentMaxAggregateInputType
  }

  export type GetAssignmentAggregateType<T extends AssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignment[P]>
      : GetScalarType<T[P], AggregateAssignment[P]>
  }




  export type AssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithAggregationInput | AssignmentOrderByWithAggregationInput[]
    by: AssignmentScalarFieldEnum[] | AssignmentScalarFieldEnum
    having?: AssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentCountAggregateInputType | true
    _avg?: AssignmentAvgAggregateInputType
    _sum?: AssignmentSumAggregateInputType
    _min?: AssignmentMinAggregateInputType
    _max?: AssignmentMaxAggregateInputType
  }

  export type AssignmentGroupByOutputType = {
    id: number
    order: number
    clientContractId: number
    clientId: number
    createdAt: Date
    updatedAt: Date
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  type GetAssignmentGroupByPayload<T extends AssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    clientContractId?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientContract?: boolean | ClientContractDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>


  export type AssignmentSelectScalar = {
    id?: boolean
    order?: boolean
    clientContractId?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientContract?: boolean | ClientContractDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $AssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assignment"
    objects: {
      clientContract: Prisma.$ClientContractPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      order: number
      clientContractId: number
      clientId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["assignment"]>
    composites: {}
  }

  type AssignmentGetPayload<S extends boolean | null | undefined | AssignmentDefaultArgs> = $Result.GetResult<Prisma.$AssignmentPayload, S>

  type AssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssignmentCountAggregateInputType | true
    }

  export interface AssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assignment'], meta: { name: 'Assignment' } }
    /**
     * Find zero or one Assignment that matches the filter.
     * @param {AssignmentFindUniqueArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AssignmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AssignmentFindUniqueArgs<ExtArgs>>
    ): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Assignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssignmentFindUniqueOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AssignmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssignmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Assignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AssignmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AssignmentFindFirstArgs<ExtArgs>>
    ): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Assignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AssignmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssignmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignments
     * const assignments = await prisma.assignment.findMany()
     * 
     * // Get first 10 Assignments
     * const assignments = await prisma.assignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentWithIdOnly = await prisma.assignment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AssignmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssignmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Assignment.
     * @param {AssignmentCreateArgs} args - Arguments to create a Assignment.
     * @example
     * // Create one Assignment
     * const Assignment = await prisma.assignment.create({
     *   data: {
     *     // ... data to create a Assignment
     *   }
     * })
     * 
    **/
    create<T extends AssignmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AssignmentCreateArgs<ExtArgs>>
    ): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Assignments.
     * @param {AssignmentCreateManyArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AssignmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssignmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Assignment.
     * @param {AssignmentDeleteArgs} args - Arguments to delete one Assignment.
     * @example
     * // Delete one Assignment
     * const Assignment = await prisma.assignment.delete({
     *   where: {
     *     // ... filter to delete one Assignment
     *   }
     * })
     * 
    **/
    delete<T extends AssignmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AssignmentDeleteArgs<ExtArgs>>
    ): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Assignment.
     * @param {AssignmentUpdateArgs} args - Arguments to update one Assignment.
     * @example
     * // Update one Assignment
     * const assignment = await prisma.assignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AssignmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AssignmentUpdateArgs<ExtArgs>>
    ): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Assignments.
     * @param {AssignmentDeleteManyArgs} args - Arguments to filter Assignments to delete.
     * @example
     * // Delete a few Assignments
     * const { count } = await prisma.assignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AssignmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssignmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AssignmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AssignmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Assignment.
     * @param {AssignmentUpsertArgs} args - Arguments to update or create a Assignment.
     * @example
     * // Update or create a Assignment
     * const assignment = await prisma.assignment.upsert({
     *   create: {
     *     // ... data to create a Assignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignment we want to update
     *   }
     * })
    **/
    upsert<T extends AssignmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AssignmentUpsertArgs<ExtArgs>>
    ): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentCountArgs} args - Arguments to filter Assignments to count.
     * @example
     * // Count the number of Assignments
     * const count = await prisma.assignment.count({
     *   where: {
     *     // ... the filter for the Assignments we want to count
     *   }
     * })
    **/
    count<T extends AssignmentCountArgs>(
      args?: Subset<T, AssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentAggregateArgs>(args: Subset<T, AssignmentAggregateArgs>): Prisma.PrismaPromise<GetAssignmentAggregateType<T>>

    /**
     * Group by Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assignment model
   */
  readonly fields: AssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    clientContract<T extends ClientContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientContractDefaultArgs<ExtArgs>>): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Assignment model
   */ 
  interface AssignmentFieldRefs {
    readonly id: FieldRef<"Assignment", 'Int'>
    readonly order: FieldRef<"Assignment", 'Int'>
    readonly clientContractId: FieldRef<"Assignment", 'Int'>
    readonly clientId: FieldRef<"Assignment", 'Int'>
    readonly createdAt: FieldRef<"Assignment", 'DateTime'>
    readonly updatedAt: FieldRef<"Assignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Assignment findUnique
   */
  export type AssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findUniqueOrThrow
   */
  export type AssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findFirst
   */
  export type AssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findFirstOrThrow
   */
  export type AssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findMany
   */
  export type AssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignments to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment create
   */
  export type AssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Assignment.
     */
    data: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
  }

  /**
   * Assignment createMany
   */
  export type AssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assignment update
   */
  export type AssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Assignment.
     */
    data: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
    /**
     * Choose, which Assignment to update.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment updateMany
   */
  export type AssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
  }

  /**
   * Assignment upsert
   */
  export type AssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Assignment to update in case it exists.
     */
    where: AssignmentWhereUniqueInput
    /**
     * In case the Assignment found by the `where` argument doesn't exist, create a new Assignment with this data.
     */
    create: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
    /**
     * In case the Assignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
  }

  /**
   * Assignment delete
   */
  export type AssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter which Assignment to delete.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment deleteMany
   */
  export type AssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignments to delete
     */
    where?: AssignmentWhereInput
  }

  /**
   * Assignment without action
   */
  export type AssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
  }


  /**
   * Model TransferAct
   */

  export type AggregateTransferAct = {
    _count: TransferActCountAggregateOutputType | null
    _avg: TransferActAvgAggregateOutputType | null
    _sum: TransferActSumAggregateOutputType | null
    _min: TransferActMinAggregateOutputType | null
    _max: TransferActMaxAggregateOutputType | null
  }

  export type TransferActAvgAggregateOutputType = {
    id: number | null
    clientContractId: number | null
    objectId: number | null
    productId: number | null
  }

  export type TransferActSumAggregateOutputType = {
    id: number | null
    clientContractId: number | null
    objectId: number | null
    productId: number | null
  }

  export type TransferActMinAggregateOutputType = {
    id: number | null
    number: string | null
    date: Date | null
    link: string | null
    clientContractId: number | null
    objectId: number | null
    productId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferActMaxAggregateOutputType = {
    id: number | null
    number: string | null
    date: Date | null
    link: string | null
    clientContractId: number | null
    objectId: number | null
    productId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferActCountAggregateOutputType = {
    id: number
    number: number
    date: number
    link: number
    clientContractId: number
    objectId: number
    productId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransferActAvgAggregateInputType = {
    id?: true
    clientContractId?: true
    objectId?: true
    productId?: true
  }

  export type TransferActSumAggregateInputType = {
    id?: true
    clientContractId?: true
    objectId?: true
    productId?: true
  }

  export type TransferActMinAggregateInputType = {
    id?: true
    number?: true
    date?: true
    link?: true
    clientContractId?: true
    objectId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferActMaxAggregateInputType = {
    id?: true
    number?: true
    date?: true
    link?: true
    clientContractId?: true
    objectId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferActCountAggregateInputType = {
    id?: true
    number?: true
    date?: true
    link?: true
    clientContractId?: true
    objectId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransferActAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferAct to aggregate.
     */
    where?: TransferActWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferActs to fetch.
     */
    orderBy?: TransferActOrderByWithRelationInput | TransferActOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferActWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferActs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferActs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransferActs
    **/
    _count?: true | TransferActCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransferActAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransferActSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferActMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferActMaxAggregateInputType
  }

  export type GetTransferActAggregateType<T extends TransferActAggregateArgs> = {
        [P in keyof T & keyof AggregateTransferAct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransferAct[P]>
      : GetScalarType<T[P], AggregateTransferAct[P]>
  }




  export type TransferActGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferActWhereInput
    orderBy?: TransferActOrderByWithAggregationInput | TransferActOrderByWithAggregationInput[]
    by: TransferActScalarFieldEnum[] | TransferActScalarFieldEnum
    having?: TransferActScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferActCountAggregateInputType | true
    _avg?: TransferActAvgAggregateInputType
    _sum?: TransferActSumAggregateInputType
    _min?: TransferActMinAggregateInputType
    _max?: TransferActMaxAggregateInputType
  }

  export type TransferActGroupByOutputType = {
    id: number
    number: string
    date: Date
    link: string | null
    clientContractId: number
    objectId: number
    productId: number
    createdAt: Date
    updatedAt: Date
    _count: TransferActCountAggregateOutputType | null
    _avg: TransferActAvgAggregateOutputType | null
    _sum: TransferActSumAggregateOutputType | null
    _min: TransferActMinAggregateOutputType | null
    _max: TransferActMaxAggregateOutputType | null
  }

  type GetTransferActGroupByPayload<T extends TransferActGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferActGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferActGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferActGroupByOutputType[P]>
            : GetScalarType<T[P], TransferActGroupByOutputType[P]>
        }
      >
    >


  export type TransferActSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    link?: boolean
    clientContractId?: boolean
    objectId?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientContract?: boolean | ClientContractDefaultArgs<ExtArgs>
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    transferActsToRepresentatives?: boolean | TransferAct$transferActsToRepresentativesArgs<ExtArgs>
    _count?: boolean | TransferActCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferAct"]>


  export type TransferActSelectScalar = {
    id?: boolean
    number?: boolean
    date?: boolean
    link?: boolean
    clientContractId?: boolean
    objectId?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransferActInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientContract?: boolean | ClientContractDefaultArgs<ExtArgs>
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    transferActsToRepresentatives?: boolean | TransferAct$transferActsToRepresentativesArgs<ExtArgs>
    _count?: boolean | TransferActCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TransferActPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransferAct"
    objects: {
      clientContract: Prisma.$ClientContractPayload<ExtArgs>
      object: Prisma.$ObjectPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      transferActsToRepresentatives: Prisma.$TransferActToRepresentativePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      number: string
      date: Date
      link: string | null
      clientContractId: number
      objectId: number
      productId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transferAct"]>
    composites: {}
  }

  type TransferActGetPayload<S extends boolean | null | undefined | TransferActDefaultArgs> = $Result.GetResult<Prisma.$TransferActPayload, S>

  type TransferActCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransferActFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransferActCountAggregateInputType | true
    }

  export interface TransferActDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransferAct'], meta: { name: 'TransferAct' } }
    /**
     * Find zero or one TransferAct that matches the filter.
     * @param {TransferActFindUniqueArgs} args - Arguments to find a TransferAct
     * @example
     * // Get one TransferAct
     * const transferAct = await prisma.transferAct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TransferActFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TransferActFindUniqueArgs<ExtArgs>>
    ): Prisma__TransferActClient<$Result.GetResult<Prisma.$TransferActPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TransferAct that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransferActFindUniqueOrThrowArgs} args - Arguments to find a TransferAct
     * @example
     * // Get one TransferAct
     * const transferAct = await prisma.transferAct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TransferActFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TransferActFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TransferActClient<$Result.GetResult<Prisma.$TransferActPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TransferAct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferActFindFirstArgs} args - Arguments to find a TransferAct
     * @example
     * // Get one TransferAct
     * const transferAct = await prisma.transferAct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TransferActFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TransferActFindFirstArgs<ExtArgs>>
    ): Prisma__TransferActClient<$Result.GetResult<Prisma.$TransferActPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TransferAct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferActFindFirstOrThrowArgs} args - Arguments to find a TransferAct
     * @example
     * // Get one TransferAct
     * const transferAct = await prisma.transferAct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TransferActFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TransferActFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TransferActClient<$Result.GetResult<Prisma.$TransferActPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TransferActs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferActFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransferActs
     * const transferActs = await prisma.transferAct.findMany()
     * 
     * // Get first 10 TransferActs
     * const transferActs = await prisma.transferAct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferActWithIdOnly = await prisma.transferAct.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TransferActFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TransferActFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferActPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TransferAct.
     * @param {TransferActCreateArgs} args - Arguments to create a TransferAct.
     * @example
     * // Create one TransferAct
     * const TransferAct = await prisma.transferAct.create({
     *   data: {
     *     // ... data to create a TransferAct
     *   }
     * })
     * 
    **/
    create<T extends TransferActCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TransferActCreateArgs<ExtArgs>>
    ): Prisma__TransferActClient<$Result.GetResult<Prisma.$TransferActPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TransferActs.
     * @param {TransferActCreateManyArgs} args - Arguments to create many TransferActs.
     * @example
     * // Create many TransferActs
     * const transferAct = await prisma.transferAct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends TransferActCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TransferActCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TransferAct.
     * @param {TransferActDeleteArgs} args - Arguments to delete one TransferAct.
     * @example
     * // Delete one TransferAct
     * const TransferAct = await prisma.transferAct.delete({
     *   where: {
     *     // ... filter to delete one TransferAct
     *   }
     * })
     * 
    **/
    delete<T extends TransferActDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TransferActDeleteArgs<ExtArgs>>
    ): Prisma__TransferActClient<$Result.GetResult<Prisma.$TransferActPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TransferAct.
     * @param {TransferActUpdateArgs} args - Arguments to update one TransferAct.
     * @example
     * // Update one TransferAct
     * const transferAct = await prisma.transferAct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TransferActUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TransferActUpdateArgs<ExtArgs>>
    ): Prisma__TransferActClient<$Result.GetResult<Prisma.$TransferActPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TransferActs.
     * @param {TransferActDeleteManyArgs} args - Arguments to filter TransferActs to delete.
     * @example
     * // Delete a few TransferActs
     * const { count } = await prisma.transferAct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TransferActDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TransferActDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferActs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferActUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransferActs
     * const transferAct = await prisma.transferAct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TransferActUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TransferActUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransferAct.
     * @param {TransferActUpsertArgs} args - Arguments to update or create a TransferAct.
     * @example
     * // Update or create a TransferAct
     * const transferAct = await prisma.transferAct.upsert({
     *   create: {
     *     // ... data to create a TransferAct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransferAct we want to update
     *   }
     * })
    **/
    upsert<T extends TransferActUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TransferActUpsertArgs<ExtArgs>>
    ): Prisma__TransferActClient<$Result.GetResult<Prisma.$TransferActPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TransferActs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferActCountArgs} args - Arguments to filter TransferActs to count.
     * @example
     * // Count the number of TransferActs
     * const count = await prisma.transferAct.count({
     *   where: {
     *     // ... the filter for the TransferActs we want to count
     *   }
     * })
    **/
    count<T extends TransferActCountArgs>(
      args?: Subset<T, TransferActCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferActCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransferAct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferActAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferActAggregateArgs>(args: Subset<T, TransferActAggregateArgs>): Prisma.PrismaPromise<GetTransferActAggregateType<T>>

    /**
     * Group by TransferAct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferActGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferActGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferActGroupByArgs['orderBy'] }
        : { orderBy?: TransferActGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferActGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferActGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransferAct model
   */
  readonly fields: TransferActFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransferAct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferActClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    clientContract<T extends ClientContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientContractDefaultArgs<ExtArgs>>): Prisma__ClientContractClient<$Result.GetResult<Prisma.$ClientContractPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    object<T extends ObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectDefaultArgs<ExtArgs>>): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    transferActsToRepresentatives<T extends TransferAct$transferActsToRepresentativesArgs<ExtArgs> = {}>(args?: Subset<T, TransferAct$transferActsToRepresentativesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferActToRepresentativePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TransferAct model
   */ 
  interface TransferActFieldRefs {
    readonly id: FieldRef<"TransferAct", 'Int'>
    readonly number: FieldRef<"TransferAct", 'String'>
    readonly date: FieldRef<"TransferAct", 'DateTime'>
    readonly link: FieldRef<"TransferAct", 'String'>
    readonly clientContractId: FieldRef<"TransferAct", 'Int'>
    readonly objectId: FieldRef<"TransferAct", 'Int'>
    readonly productId: FieldRef<"TransferAct", 'Int'>
    readonly createdAt: FieldRef<"TransferAct", 'DateTime'>
    readonly updatedAt: FieldRef<"TransferAct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransferAct findUnique
   */
  export type TransferActFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferAct
     */
    select?: TransferActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActInclude<ExtArgs> | null
    /**
     * Filter, which TransferAct to fetch.
     */
    where: TransferActWhereUniqueInput
  }

  /**
   * TransferAct findUniqueOrThrow
   */
  export type TransferActFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferAct
     */
    select?: TransferActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActInclude<ExtArgs> | null
    /**
     * Filter, which TransferAct to fetch.
     */
    where: TransferActWhereUniqueInput
  }

  /**
   * TransferAct findFirst
   */
  export type TransferActFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferAct
     */
    select?: TransferActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActInclude<ExtArgs> | null
    /**
     * Filter, which TransferAct to fetch.
     */
    where?: TransferActWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferActs to fetch.
     */
    orderBy?: TransferActOrderByWithRelationInput | TransferActOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferActs.
     */
    cursor?: TransferActWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferActs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferActs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferActs.
     */
    distinct?: TransferActScalarFieldEnum | TransferActScalarFieldEnum[]
  }

  /**
   * TransferAct findFirstOrThrow
   */
  export type TransferActFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferAct
     */
    select?: TransferActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActInclude<ExtArgs> | null
    /**
     * Filter, which TransferAct to fetch.
     */
    where?: TransferActWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferActs to fetch.
     */
    orderBy?: TransferActOrderByWithRelationInput | TransferActOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferActs.
     */
    cursor?: TransferActWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferActs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferActs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferActs.
     */
    distinct?: TransferActScalarFieldEnum | TransferActScalarFieldEnum[]
  }

  /**
   * TransferAct findMany
   */
  export type TransferActFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferAct
     */
    select?: TransferActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActInclude<ExtArgs> | null
    /**
     * Filter, which TransferActs to fetch.
     */
    where?: TransferActWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferActs to fetch.
     */
    orderBy?: TransferActOrderByWithRelationInput | TransferActOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransferActs.
     */
    cursor?: TransferActWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferActs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferActs.
     */
    skip?: number
    distinct?: TransferActScalarFieldEnum | TransferActScalarFieldEnum[]
  }

  /**
   * TransferAct create
   */
  export type TransferActCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferAct
     */
    select?: TransferActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActInclude<ExtArgs> | null
    /**
     * The data needed to create a TransferAct.
     */
    data: XOR<TransferActCreateInput, TransferActUncheckedCreateInput>
  }

  /**
   * TransferAct createMany
   */
  export type TransferActCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransferActs.
     */
    data: TransferActCreateManyInput | TransferActCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransferAct update
   */
  export type TransferActUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferAct
     */
    select?: TransferActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActInclude<ExtArgs> | null
    /**
     * The data needed to update a TransferAct.
     */
    data: XOR<TransferActUpdateInput, TransferActUncheckedUpdateInput>
    /**
     * Choose, which TransferAct to update.
     */
    where: TransferActWhereUniqueInput
  }

  /**
   * TransferAct updateMany
   */
  export type TransferActUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransferActs.
     */
    data: XOR<TransferActUpdateManyMutationInput, TransferActUncheckedUpdateManyInput>
    /**
     * Filter which TransferActs to update
     */
    where?: TransferActWhereInput
  }

  /**
   * TransferAct upsert
   */
  export type TransferActUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferAct
     */
    select?: TransferActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActInclude<ExtArgs> | null
    /**
     * The filter to search for the TransferAct to update in case it exists.
     */
    where: TransferActWhereUniqueInput
    /**
     * In case the TransferAct found by the `where` argument doesn't exist, create a new TransferAct with this data.
     */
    create: XOR<TransferActCreateInput, TransferActUncheckedCreateInput>
    /**
     * In case the TransferAct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferActUpdateInput, TransferActUncheckedUpdateInput>
  }

  /**
   * TransferAct delete
   */
  export type TransferActDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferAct
     */
    select?: TransferActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActInclude<ExtArgs> | null
    /**
     * Filter which TransferAct to delete.
     */
    where: TransferActWhereUniqueInput
  }

  /**
   * TransferAct deleteMany
   */
  export type TransferActDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferActs to delete
     */
    where?: TransferActWhereInput
  }

  /**
   * TransferAct.transferActsToRepresentatives
   */
  export type TransferAct$transferActsToRepresentativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferActToRepresentative
     */
    select?: TransferActToRepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActToRepresentativeInclude<ExtArgs> | null
    where?: TransferActToRepresentativeWhereInput
    orderBy?: TransferActToRepresentativeOrderByWithRelationInput | TransferActToRepresentativeOrderByWithRelationInput[]
    cursor?: TransferActToRepresentativeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferActToRepresentativeScalarFieldEnum | TransferActToRepresentativeScalarFieldEnum[]
  }

  /**
   * TransferAct without action
   */
  export type TransferActDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferAct
     */
    select?: TransferActSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActInclude<ExtArgs> | null
  }


  /**
   * Model Representative
   */

  export type AggregateRepresentative = {
    _count: RepresentativeCountAggregateOutputType | null
    _avg: RepresentativeAvgAggregateOutputType | null
    _sum: RepresentativeSumAggregateOutputType | null
    _min: RepresentativeMinAggregateOutputType | null
    _max: RepresentativeMaxAggregateOutputType | null
  }

  export type RepresentativeAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type RepresentativeSumAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type RepresentativeMinAggregateOutputType = {
    id: number | null
    fullName: string | null
    attorneyNumber: string | null
    attorneyDate: Date | null
    authorizedBy: string | null
    authorizedRole: string | null
    clientId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RepresentativeMaxAggregateOutputType = {
    id: number | null
    fullName: string | null
    attorneyNumber: string | null
    attorneyDate: Date | null
    authorizedBy: string | null
    authorizedRole: string | null
    clientId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RepresentativeCountAggregateOutputType = {
    id: number
    fullName: number
    attorneyNumber: number
    attorneyDate: number
    authorizedBy: number
    authorizedRole: number
    clientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RepresentativeAvgAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type RepresentativeSumAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type RepresentativeMinAggregateInputType = {
    id?: true
    fullName?: true
    attorneyNumber?: true
    attorneyDate?: true
    authorizedBy?: true
    authorizedRole?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RepresentativeMaxAggregateInputType = {
    id?: true
    fullName?: true
    attorneyNumber?: true
    attorneyDate?: true
    authorizedBy?: true
    authorizedRole?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RepresentativeCountAggregateInputType = {
    id?: true
    fullName?: true
    attorneyNumber?: true
    attorneyDate?: true
    authorizedBy?: true
    authorizedRole?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RepresentativeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Representative to aggregate.
     */
    where?: RepresentativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Representatives to fetch.
     */
    orderBy?: RepresentativeOrderByWithRelationInput | RepresentativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepresentativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Representatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Representatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Representatives
    **/
    _count?: true | RepresentativeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepresentativeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepresentativeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepresentativeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepresentativeMaxAggregateInputType
  }

  export type GetRepresentativeAggregateType<T extends RepresentativeAggregateArgs> = {
        [P in keyof T & keyof AggregateRepresentative]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepresentative[P]>
      : GetScalarType<T[P], AggregateRepresentative[P]>
  }




  export type RepresentativeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepresentativeWhereInput
    orderBy?: RepresentativeOrderByWithAggregationInput | RepresentativeOrderByWithAggregationInput[]
    by: RepresentativeScalarFieldEnum[] | RepresentativeScalarFieldEnum
    having?: RepresentativeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepresentativeCountAggregateInputType | true
    _avg?: RepresentativeAvgAggregateInputType
    _sum?: RepresentativeSumAggregateInputType
    _min?: RepresentativeMinAggregateInputType
    _max?: RepresentativeMaxAggregateInputType
  }

  export type RepresentativeGroupByOutputType = {
    id: number
    fullName: string
    attorneyNumber: string | null
    attorneyDate: Date | null
    authorizedBy: string | null
    authorizedRole: string | null
    clientId: number
    createdAt: Date
    updatedAt: Date
    _count: RepresentativeCountAggregateOutputType | null
    _avg: RepresentativeAvgAggregateOutputType | null
    _sum: RepresentativeSumAggregateOutputType | null
    _min: RepresentativeMinAggregateOutputType | null
    _max: RepresentativeMaxAggregateOutputType | null
  }

  type GetRepresentativeGroupByPayload<T extends RepresentativeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RepresentativeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepresentativeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepresentativeGroupByOutputType[P]>
            : GetScalarType<T[P], RepresentativeGroupByOutputType[P]>
        }
      >
    >


  export type RepresentativeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    attorneyNumber?: boolean
    attorneyDate?: boolean
    authorizedBy?: boolean
    authorizedRole?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    transferActsToRepresentatives?: boolean | Representative$transferActsToRepresentativesArgs<ExtArgs>
    _count?: boolean | RepresentativeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["representative"]>


  export type RepresentativeSelectScalar = {
    id?: boolean
    fullName?: boolean
    attorneyNumber?: boolean
    attorneyDate?: boolean
    authorizedBy?: boolean
    authorizedRole?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RepresentativeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    transferActsToRepresentatives?: boolean | Representative$transferActsToRepresentativesArgs<ExtArgs>
    _count?: boolean | RepresentativeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RepresentativePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Representative"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      transferActsToRepresentatives: Prisma.$TransferActToRepresentativePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullName: string
      attorneyNumber: string | null
      attorneyDate: Date | null
      authorizedBy: string | null
      authorizedRole: string | null
      clientId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["representative"]>
    composites: {}
  }

  type RepresentativeGetPayload<S extends boolean | null | undefined | RepresentativeDefaultArgs> = $Result.GetResult<Prisma.$RepresentativePayload, S>

  type RepresentativeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RepresentativeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RepresentativeCountAggregateInputType | true
    }

  export interface RepresentativeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Representative'], meta: { name: 'Representative' } }
    /**
     * Find zero or one Representative that matches the filter.
     * @param {RepresentativeFindUniqueArgs} args - Arguments to find a Representative
     * @example
     * // Get one Representative
     * const representative = await prisma.representative.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RepresentativeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RepresentativeFindUniqueArgs<ExtArgs>>
    ): Prisma__RepresentativeClient<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Representative that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RepresentativeFindUniqueOrThrowArgs} args - Arguments to find a Representative
     * @example
     * // Get one Representative
     * const representative = await prisma.representative.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RepresentativeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RepresentativeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RepresentativeClient<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Representative that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepresentativeFindFirstArgs} args - Arguments to find a Representative
     * @example
     * // Get one Representative
     * const representative = await prisma.representative.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RepresentativeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RepresentativeFindFirstArgs<ExtArgs>>
    ): Prisma__RepresentativeClient<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Representative that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepresentativeFindFirstOrThrowArgs} args - Arguments to find a Representative
     * @example
     * // Get one Representative
     * const representative = await prisma.representative.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RepresentativeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RepresentativeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RepresentativeClient<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Representatives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepresentativeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Representatives
     * const representatives = await prisma.representative.findMany()
     * 
     * // Get first 10 Representatives
     * const representatives = await prisma.representative.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const representativeWithIdOnly = await prisma.representative.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RepresentativeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RepresentativeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Representative.
     * @param {RepresentativeCreateArgs} args - Arguments to create a Representative.
     * @example
     * // Create one Representative
     * const Representative = await prisma.representative.create({
     *   data: {
     *     // ... data to create a Representative
     *   }
     * })
     * 
    **/
    create<T extends RepresentativeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RepresentativeCreateArgs<ExtArgs>>
    ): Prisma__RepresentativeClient<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Representatives.
     * @param {RepresentativeCreateManyArgs} args - Arguments to create many Representatives.
     * @example
     * // Create many Representatives
     * const representative = await prisma.representative.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends RepresentativeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RepresentativeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Representative.
     * @param {RepresentativeDeleteArgs} args - Arguments to delete one Representative.
     * @example
     * // Delete one Representative
     * const Representative = await prisma.representative.delete({
     *   where: {
     *     // ... filter to delete one Representative
     *   }
     * })
     * 
    **/
    delete<T extends RepresentativeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RepresentativeDeleteArgs<ExtArgs>>
    ): Prisma__RepresentativeClient<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Representative.
     * @param {RepresentativeUpdateArgs} args - Arguments to update one Representative.
     * @example
     * // Update one Representative
     * const representative = await prisma.representative.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RepresentativeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RepresentativeUpdateArgs<ExtArgs>>
    ): Prisma__RepresentativeClient<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Representatives.
     * @param {RepresentativeDeleteManyArgs} args - Arguments to filter Representatives to delete.
     * @example
     * // Delete a few Representatives
     * const { count } = await prisma.representative.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RepresentativeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RepresentativeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Representatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepresentativeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Representatives
     * const representative = await prisma.representative.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RepresentativeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RepresentativeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Representative.
     * @param {RepresentativeUpsertArgs} args - Arguments to update or create a Representative.
     * @example
     * // Update or create a Representative
     * const representative = await prisma.representative.upsert({
     *   create: {
     *     // ... data to create a Representative
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Representative we want to update
     *   }
     * })
    **/
    upsert<T extends RepresentativeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RepresentativeUpsertArgs<ExtArgs>>
    ): Prisma__RepresentativeClient<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Representatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepresentativeCountArgs} args - Arguments to filter Representatives to count.
     * @example
     * // Count the number of Representatives
     * const count = await prisma.representative.count({
     *   where: {
     *     // ... the filter for the Representatives we want to count
     *   }
     * })
    **/
    count<T extends RepresentativeCountArgs>(
      args?: Subset<T, RepresentativeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepresentativeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Representative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepresentativeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepresentativeAggregateArgs>(args: Subset<T, RepresentativeAggregateArgs>): Prisma.PrismaPromise<GetRepresentativeAggregateType<T>>

    /**
     * Group by Representative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepresentativeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepresentativeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepresentativeGroupByArgs['orderBy'] }
        : { orderBy?: RepresentativeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepresentativeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepresentativeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Representative model
   */
  readonly fields: RepresentativeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Representative.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RepresentativeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    transferActsToRepresentatives<T extends Representative$transferActsToRepresentativesArgs<ExtArgs> = {}>(args?: Subset<T, Representative$transferActsToRepresentativesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferActToRepresentativePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Representative model
   */ 
  interface RepresentativeFieldRefs {
    readonly id: FieldRef<"Representative", 'Int'>
    readonly fullName: FieldRef<"Representative", 'String'>
    readonly attorneyNumber: FieldRef<"Representative", 'String'>
    readonly attorneyDate: FieldRef<"Representative", 'DateTime'>
    readonly authorizedBy: FieldRef<"Representative", 'String'>
    readonly authorizedRole: FieldRef<"Representative", 'String'>
    readonly clientId: FieldRef<"Representative", 'Int'>
    readonly createdAt: FieldRef<"Representative", 'DateTime'>
    readonly updatedAt: FieldRef<"Representative", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Representative findUnique
   */
  export type RepresentativeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    /**
     * Filter, which Representative to fetch.
     */
    where: RepresentativeWhereUniqueInput
  }

  /**
   * Representative findUniqueOrThrow
   */
  export type RepresentativeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    /**
     * Filter, which Representative to fetch.
     */
    where: RepresentativeWhereUniqueInput
  }

  /**
   * Representative findFirst
   */
  export type RepresentativeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    /**
     * Filter, which Representative to fetch.
     */
    where?: RepresentativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Representatives to fetch.
     */
    orderBy?: RepresentativeOrderByWithRelationInput | RepresentativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Representatives.
     */
    cursor?: RepresentativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Representatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Representatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Representatives.
     */
    distinct?: RepresentativeScalarFieldEnum | RepresentativeScalarFieldEnum[]
  }

  /**
   * Representative findFirstOrThrow
   */
  export type RepresentativeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    /**
     * Filter, which Representative to fetch.
     */
    where?: RepresentativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Representatives to fetch.
     */
    orderBy?: RepresentativeOrderByWithRelationInput | RepresentativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Representatives.
     */
    cursor?: RepresentativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Representatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Representatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Representatives.
     */
    distinct?: RepresentativeScalarFieldEnum | RepresentativeScalarFieldEnum[]
  }

  /**
   * Representative findMany
   */
  export type RepresentativeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    /**
     * Filter, which Representatives to fetch.
     */
    where?: RepresentativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Representatives to fetch.
     */
    orderBy?: RepresentativeOrderByWithRelationInput | RepresentativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Representatives.
     */
    cursor?: RepresentativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Representatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Representatives.
     */
    skip?: number
    distinct?: RepresentativeScalarFieldEnum | RepresentativeScalarFieldEnum[]
  }

  /**
   * Representative create
   */
  export type RepresentativeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    /**
     * The data needed to create a Representative.
     */
    data: XOR<RepresentativeCreateInput, RepresentativeUncheckedCreateInput>
  }

  /**
   * Representative createMany
   */
  export type RepresentativeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Representatives.
     */
    data: RepresentativeCreateManyInput | RepresentativeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Representative update
   */
  export type RepresentativeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    /**
     * The data needed to update a Representative.
     */
    data: XOR<RepresentativeUpdateInput, RepresentativeUncheckedUpdateInput>
    /**
     * Choose, which Representative to update.
     */
    where: RepresentativeWhereUniqueInput
  }

  /**
   * Representative updateMany
   */
  export type RepresentativeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Representatives.
     */
    data: XOR<RepresentativeUpdateManyMutationInput, RepresentativeUncheckedUpdateManyInput>
    /**
     * Filter which Representatives to update
     */
    where?: RepresentativeWhereInput
  }

  /**
   * Representative upsert
   */
  export type RepresentativeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    /**
     * The filter to search for the Representative to update in case it exists.
     */
    where: RepresentativeWhereUniqueInput
    /**
     * In case the Representative found by the `where` argument doesn't exist, create a new Representative with this data.
     */
    create: XOR<RepresentativeCreateInput, RepresentativeUncheckedCreateInput>
    /**
     * In case the Representative was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepresentativeUpdateInput, RepresentativeUncheckedUpdateInput>
  }

  /**
   * Representative delete
   */
  export type RepresentativeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
    /**
     * Filter which Representative to delete.
     */
    where: RepresentativeWhereUniqueInput
  }

  /**
   * Representative deleteMany
   */
  export type RepresentativeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Representatives to delete
     */
    where?: RepresentativeWhereInput
  }

  /**
   * Representative.transferActsToRepresentatives
   */
  export type Representative$transferActsToRepresentativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferActToRepresentative
     */
    select?: TransferActToRepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActToRepresentativeInclude<ExtArgs> | null
    where?: TransferActToRepresentativeWhereInput
    orderBy?: TransferActToRepresentativeOrderByWithRelationInput | TransferActToRepresentativeOrderByWithRelationInput[]
    cursor?: TransferActToRepresentativeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferActToRepresentativeScalarFieldEnum | TransferActToRepresentativeScalarFieldEnum[]
  }

  /**
   * Representative without action
   */
  export type RepresentativeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Representative
     */
    select?: RepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepresentativeInclude<ExtArgs> | null
  }


  /**
   * Model TransferActToRepresentative
   */

  export type AggregateTransferActToRepresentative = {
    _count: TransferActToRepresentativeCountAggregateOutputType | null
    _avg: TransferActToRepresentativeAvgAggregateOutputType | null
    _sum: TransferActToRepresentativeSumAggregateOutputType | null
    _min: TransferActToRepresentativeMinAggregateOutputType | null
    _max: TransferActToRepresentativeMaxAggregateOutputType | null
  }

  export type TransferActToRepresentativeAvgAggregateOutputType = {
    transferActId: number | null
    representativeId: number | null
  }

  export type TransferActToRepresentativeSumAggregateOutputType = {
    transferActId: number | null
    representativeId: number | null
  }

  export type TransferActToRepresentativeMinAggregateOutputType = {
    transferActId: number | null
    representativeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferActToRepresentativeMaxAggregateOutputType = {
    transferActId: number | null
    representativeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferActToRepresentativeCountAggregateOutputType = {
    transferActId: number
    representativeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransferActToRepresentativeAvgAggregateInputType = {
    transferActId?: true
    representativeId?: true
  }

  export type TransferActToRepresentativeSumAggregateInputType = {
    transferActId?: true
    representativeId?: true
  }

  export type TransferActToRepresentativeMinAggregateInputType = {
    transferActId?: true
    representativeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferActToRepresentativeMaxAggregateInputType = {
    transferActId?: true
    representativeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferActToRepresentativeCountAggregateInputType = {
    transferActId?: true
    representativeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransferActToRepresentativeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferActToRepresentative to aggregate.
     */
    where?: TransferActToRepresentativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferActToRepresentatives to fetch.
     */
    orderBy?: TransferActToRepresentativeOrderByWithRelationInput | TransferActToRepresentativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferActToRepresentativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferActToRepresentatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferActToRepresentatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransferActToRepresentatives
    **/
    _count?: true | TransferActToRepresentativeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransferActToRepresentativeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransferActToRepresentativeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferActToRepresentativeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferActToRepresentativeMaxAggregateInputType
  }

  export type GetTransferActToRepresentativeAggregateType<T extends TransferActToRepresentativeAggregateArgs> = {
        [P in keyof T & keyof AggregateTransferActToRepresentative]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransferActToRepresentative[P]>
      : GetScalarType<T[P], AggregateTransferActToRepresentative[P]>
  }




  export type TransferActToRepresentativeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferActToRepresentativeWhereInput
    orderBy?: TransferActToRepresentativeOrderByWithAggregationInput | TransferActToRepresentativeOrderByWithAggregationInput[]
    by: TransferActToRepresentativeScalarFieldEnum[] | TransferActToRepresentativeScalarFieldEnum
    having?: TransferActToRepresentativeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferActToRepresentativeCountAggregateInputType | true
    _avg?: TransferActToRepresentativeAvgAggregateInputType
    _sum?: TransferActToRepresentativeSumAggregateInputType
    _min?: TransferActToRepresentativeMinAggregateInputType
    _max?: TransferActToRepresentativeMaxAggregateInputType
  }

  export type TransferActToRepresentativeGroupByOutputType = {
    transferActId: number
    representativeId: number
    createdAt: Date
    updatedAt: Date
    _count: TransferActToRepresentativeCountAggregateOutputType | null
    _avg: TransferActToRepresentativeAvgAggregateOutputType | null
    _sum: TransferActToRepresentativeSumAggregateOutputType | null
    _min: TransferActToRepresentativeMinAggregateOutputType | null
    _max: TransferActToRepresentativeMaxAggregateOutputType | null
  }

  type GetTransferActToRepresentativeGroupByPayload<T extends TransferActToRepresentativeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferActToRepresentativeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferActToRepresentativeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferActToRepresentativeGroupByOutputType[P]>
            : GetScalarType<T[P], TransferActToRepresentativeGroupByOutputType[P]>
        }
      >
    >


  export type TransferActToRepresentativeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    transferActId?: boolean
    representativeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transferAct?: boolean | TransferActDefaultArgs<ExtArgs>
    representative?: boolean | RepresentativeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferActToRepresentative"]>


  export type TransferActToRepresentativeSelectScalar = {
    transferActId?: boolean
    representativeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransferActToRepresentativeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transferAct?: boolean | TransferActDefaultArgs<ExtArgs>
    representative?: boolean | RepresentativeDefaultArgs<ExtArgs>
  }

  export type $TransferActToRepresentativePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransferActToRepresentative"
    objects: {
      transferAct: Prisma.$TransferActPayload<ExtArgs>
      representative: Prisma.$RepresentativePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      transferActId: number
      representativeId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transferActToRepresentative"]>
    composites: {}
  }

  type TransferActToRepresentativeGetPayload<S extends boolean | null | undefined | TransferActToRepresentativeDefaultArgs> = $Result.GetResult<Prisma.$TransferActToRepresentativePayload, S>

  type TransferActToRepresentativeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransferActToRepresentativeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransferActToRepresentativeCountAggregateInputType | true
    }

  export interface TransferActToRepresentativeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransferActToRepresentative'], meta: { name: 'TransferActToRepresentative' } }
    /**
     * Find zero or one TransferActToRepresentative that matches the filter.
     * @param {TransferActToRepresentativeFindUniqueArgs} args - Arguments to find a TransferActToRepresentative
     * @example
     * // Get one TransferActToRepresentative
     * const transferActToRepresentative = await prisma.transferActToRepresentative.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TransferActToRepresentativeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TransferActToRepresentativeFindUniqueArgs<ExtArgs>>
    ): Prisma__TransferActToRepresentativeClient<$Result.GetResult<Prisma.$TransferActToRepresentativePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TransferActToRepresentative that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransferActToRepresentativeFindUniqueOrThrowArgs} args - Arguments to find a TransferActToRepresentative
     * @example
     * // Get one TransferActToRepresentative
     * const transferActToRepresentative = await prisma.transferActToRepresentative.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TransferActToRepresentativeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TransferActToRepresentativeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TransferActToRepresentativeClient<$Result.GetResult<Prisma.$TransferActToRepresentativePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TransferActToRepresentative that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferActToRepresentativeFindFirstArgs} args - Arguments to find a TransferActToRepresentative
     * @example
     * // Get one TransferActToRepresentative
     * const transferActToRepresentative = await prisma.transferActToRepresentative.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TransferActToRepresentativeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TransferActToRepresentativeFindFirstArgs<ExtArgs>>
    ): Prisma__TransferActToRepresentativeClient<$Result.GetResult<Prisma.$TransferActToRepresentativePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TransferActToRepresentative that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferActToRepresentativeFindFirstOrThrowArgs} args - Arguments to find a TransferActToRepresentative
     * @example
     * // Get one TransferActToRepresentative
     * const transferActToRepresentative = await prisma.transferActToRepresentative.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TransferActToRepresentativeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TransferActToRepresentativeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TransferActToRepresentativeClient<$Result.GetResult<Prisma.$TransferActToRepresentativePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TransferActToRepresentatives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferActToRepresentativeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransferActToRepresentatives
     * const transferActToRepresentatives = await prisma.transferActToRepresentative.findMany()
     * 
     * // Get first 10 TransferActToRepresentatives
     * const transferActToRepresentatives = await prisma.transferActToRepresentative.findMany({ take: 10 })
     * 
     * // Only select the `transferActId`
     * const transferActToRepresentativeWithTransferActIdOnly = await prisma.transferActToRepresentative.findMany({ select: { transferActId: true } })
     * 
    **/
    findMany<T extends TransferActToRepresentativeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TransferActToRepresentativeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferActToRepresentativePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TransferActToRepresentative.
     * @param {TransferActToRepresentativeCreateArgs} args - Arguments to create a TransferActToRepresentative.
     * @example
     * // Create one TransferActToRepresentative
     * const TransferActToRepresentative = await prisma.transferActToRepresentative.create({
     *   data: {
     *     // ... data to create a TransferActToRepresentative
     *   }
     * })
     * 
    **/
    create<T extends TransferActToRepresentativeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TransferActToRepresentativeCreateArgs<ExtArgs>>
    ): Prisma__TransferActToRepresentativeClient<$Result.GetResult<Prisma.$TransferActToRepresentativePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TransferActToRepresentatives.
     * @param {TransferActToRepresentativeCreateManyArgs} args - Arguments to create many TransferActToRepresentatives.
     * @example
     * // Create many TransferActToRepresentatives
     * const transferActToRepresentative = await prisma.transferActToRepresentative.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends TransferActToRepresentativeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TransferActToRepresentativeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TransferActToRepresentative.
     * @param {TransferActToRepresentativeDeleteArgs} args - Arguments to delete one TransferActToRepresentative.
     * @example
     * // Delete one TransferActToRepresentative
     * const TransferActToRepresentative = await prisma.transferActToRepresentative.delete({
     *   where: {
     *     // ... filter to delete one TransferActToRepresentative
     *   }
     * })
     * 
    **/
    delete<T extends TransferActToRepresentativeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TransferActToRepresentativeDeleteArgs<ExtArgs>>
    ): Prisma__TransferActToRepresentativeClient<$Result.GetResult<Prisma.$TransferActToRepresentativePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TransferActToRepresentative.
     * @param {TransferActToRepresentativeUpdateArgs} args - Arguments to update one TransferActToRepresentative.
     * @example
     * // Update one TransferActToRepresentative
     * const transferActToRepresentative = await prisma.transferActToRepresentative.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TransferActToRepresentativeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TransferActToRepresentativeUpdateArgs<ExtArgs>>
    ): Prisma__TransferActToRepresentativeClient<$Result.GetResult<Prisma.$TransferActToRepresentativePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TransferActToRepresentatives.
     * @param {TransferActToRepresentativeDeleteManyArgs} args - Arguments to filter TransferActToRepresentatives to delete.
     * @example
     * // Delete a few TransferActToRepresentatives
     * const { count } = await prisma.transferActToRepresentative.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TransferActToRepresentativeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TransferActToRepresentativeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferActToRepresentatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferActToRepresentativeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransferActToRepresentatives
     * const transferActToRepresentative = await prisma.transferActToRepresentative.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TransferActToRepresentativeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TransferActToRepresentativeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransferActToRepresentative.
     * @param {TransferActToRepresentativeUpsertArgs} args - Arguments to update or create a TransferActToRepresentative.
     * @example
     * // Update or create a TransferActToRepresentative
     * const transferActToRepresentative = await prisma.transferActToRepresentative.upsert({
     *   create: {
     *     // ... data to create a TransferActToRepresentative
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransferActToRepresentative we want to update
     *   }
     * })
    **/
    upsert<T extends TransferActToRepresentativeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TransferActToRepresentativeUpsertArgs<ExtArgs>>
    ): Prisma__TransferActToRepresentativeClient<$Result.GetResult<Prisma.$TransferActToRepresentativePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TransferActToRepresentatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferActToRepresentativeCountArgs} args - Arguments to filter TransferActToRepresentatives to count.
     * @example
     * // Count the number of TransferActToRepresentatives
     * const count = await prisma.transferActToRepresentative.count({
     *   where: {
     *     // ... the filter for the TransferActToRepresentatives we want to count
     *   }
     * })
    **/
    count<T extends TransferActToRepresentativeCountArgs>(
      args?: Subset<T, TransferActToRepresentativeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferActToRepresentativeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransferActToRepresentative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferActToRepresentativeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferActToRepresentativeAggregateArgs>(args: Subset<T, TransferActToRepresentativeAggregateArgs>): Prisma.PrismaPromise<GetTransferActToRepresentativeAggregateType<T>>

    /**
     * Group by TransferActToRepresentative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferActToRepresentativeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferActToRepresentativeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferActToRepresentativeGroupByArgs['orderBy'] }
        : { orderBy?: TransferActToRepresentativeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferActToRepresentativeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferActToRepresentativeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransferActToRepresentative model
   */
  readonly fields: TransferActToRepresentativeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransferActToRepresentative.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferActToRepresentativeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    transferAct<T extends TransferActDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransferActDefaultArgs<ExtArgs>>): Prisma__TransferActClient<$Result.GetResult<Prisma.$TransferActPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    representative<T extends RepresentativeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RepresentativeDefaultArgs<ExtArgs>>): Prisma__RepresentativeClient<$Result.GetResult<Prisma.$RepresentativePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TransferActToRepresentative model
   */ 
  interface TransferActToRepresentativeFieldRefs {
    readonly transferActId: FieldRef<"TransferActToRepresentative", 'Int'>
    readonly representativeId: FieldRef<"TransferActToRepresentative", 'Int'>
    readonly createdAt: FieldRef<"TransferActToRepresentative", 'DateTime'>
    readonly updatedAt: FieldRef<"TransferActToRepresentative", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransferActToRepresentative findUnique
   */
  export type TransferActToRepresentativeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferActToRepresentative
     */
    select?: TransferActToRepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActToRepresentativeInclude<ExtArgs> | null
    /**
     * Filter, which TransferActToRepresentative to fetch.
     */
    where: TransferActToRepresentativeWhereUniqueInput
  }

  /**
   * TransferActToRepresentative findUniqueOrThrow
   */
  export type TransferActToRepresentativeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferActToRepresentative
     */
    select?: TransferActToRepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActToRepresentativeInclude<ExtArgs> | null
    /**
     * Filter, which TransferActToRepresentative to fetch.
     */
    where: TransferActToRepresentativeWhereUniqueInput
  }

  /**
   * TransferActToRepresentative findFirst
   */
  export type TransferActToRepresentativeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferActToRepresentative
     */
    select?: TransferActToRepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActToRepresentativeInclude<ExtArgs> | null
    /**
     * Filter, which TransferActToRepresentative to fetch.
     */
    where?: TransferActToRepresentativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferActToRepresentatives to fetch.
     */
    orderBy?: TransferActToRepresentativeOrderByWithRelationInput | TransferActToRepresentativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferActToRepresentatives.
     */
    cursor?: TransferActToRepresentativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferActToRepresentatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferActToRepresentatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferActToRepresentatives.
     */
    distinct?: TransferActToRepresentativeScalarFieldEnum | TransferActToRepresentativeScalarFieldEnum[]
  }

  /**
   * TransferActToRepresentative findFirstOrThrow
   */
  export type TransferActToRepresentativeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferActToRepresentative
     */
    select?: TransferActToRepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActToRepresentativeInclude<ExtArgs> | null
    /**
     * Filter, which TransferActToRepresentative to fetch.
     */
    where?: TransferActToRepresentativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferActToRepresentatives to fetch.
     */
    orderBy?: TransferActToRepresentativeOrderByWithRelationInput | TransferActToRepresentativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferActToRepresentatives.
     */
    cursor?: TransferActToRepresentativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferActToRepresentatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferActToRepresentatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferActToRepresentatives.
     */
    distinct?: TransferActToRepresentativeScalarFieldEnum | TransferActToRepresentativeScalarFieldEnum[]
  }

  /**
   * TransferActToRepresentative findMany
   */
  export type TransferActToRepresentativeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferActToRepresentative
     */
    select?: TransferActToRepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActToRepresentativeInclude<ExtArgs> | null
    /**
     * Filter, which TransferActToRepresentatives to fetch.
     */
    where?: TransferActToRepresentativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferActToRepresentatives to fetch.
     */
    orderBy?: TransferActToRepresentativeOrderByWithRelationInput | TransferActToRepresentativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransferActToRepresentatives.
     */
    cursor?: TransferActToRepresentativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferActToRepresentatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferActToRepresentatives.
     */
    skip?: number
    distinct?: TransferActToRepresentativeScalarFieldEnum | TransferActToRepresentativeScalarFieldEnum[]
  }

  /**
   * TransferActToRepresentative create
   */
  export type TransferActToRepresentativeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferActToRepresentative
     */
    select?: TransferActToRepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActToRepresentativeInclude<ExtArgs> | null
    /**
     * The data needed to create a TransferActToRepresentative.
     */
    data: XOR<TransferActToRepresentativeCreateInput, TransferActToRepresentativeUncheckedCreateInput>
  }

  /**
   * TransferActToRepresentative createMany
   */
  export type TransferActToRepresentativeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransferActToRepresentatives.
     */
    data: TransferActToRepresentativeCreateManyInput | TransferActToRepresentativeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransferActToRepresentative update
   */
  export type TransferActToRepresentativeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferActToRepresentative
     */
    select?: TransferActToRepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActToRepresentativeInclude<ExtArgs> | null
    /**
     * The data needed to update a TransferActToRepresentative.
     */
    data: XOR<TransferActToRepresentativeUpdateInput, TransferActToRepresentativeUncheckedUpdateInput>
    /**
     * Choose, which TransferActToRepresentative to update.
     */
    where: TransferActToRepresentativeWhereUniqueInput
  }

  /**
   * TransferActToRepresentative updateMany
   */
  export type TransferActToRepresentativeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransferActToRepresentatives.
     */
    data: XOR<TransferActToRepresentativeUpdateManyMutationInput, TransferActToRepresentativeUncheckedUpdateManyInput>
    /**
     * Filter which TransferActToRepresentatives to update
     */
    where?: TransferActToRepresentativeWhereInput
  }

  /**
   * TransferActToRepresentative upsert
   */
  export type TransferActToRepresentativeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferActToRepresentative
     */
    select?: TransferActToRepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActToRepresentativeInclude<ExtArgs> | null
    /**
     * The filter to search for the TransferActToRepresentative to update in case it exists.
     */
    where: TransferActToRepresentativeWhereUniqueInput
    /**
     * In case the TransferActToRepresentative found by the `where` argument doesn't exist, create a new TransferActToRepresentative with this data.
     */
    create: XOR<TransferActToRepresentativeCreateInput, TransferActToRepresentativeUncheckedCreateInput>
    /**
     * In case the TransferActToRepresentative was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferActToRepresentativeUpdateInput, TransferActToRepresentativeUncheckedUpdateInput>
  }

  /**
   * TransferActToRepresentative delete
   */
  export type TransferActToRepresentativeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferActToRepresentative
     */
    select?: TransferActToRepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActToRepresentativeInclude<ExtArgs> | null
    /**
     * Filter which TransferActToRepresentative to delete.
     */
    where: TransferActToRepresentativeWhereUniqueInput
  }

  /**
   * TransferActToRepresentative deleteMany
   */
  export type TransferActToRepresentativeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferActToRepresentatives to delete
     */
    where?: TransferActToRepresentativeWhereInput
  }

  /**
   * TransferActToRepresentative without action
   */
  export type TransferActToRepresentativeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferActToRepresentative
     */
    select?: TransferActToRepresentativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferActToRepresentativeInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    email: 'email',
    phone: 'phone',
    isManager: 'isManager',
    isStaff: 'isStaff',
    userRole: 'userRole',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    inn: 'inn',
    phone: 'phone',
    email: 'email',
    address: 'address',
    clientCategory: 'clientCategory',
    clientIndividualPropertiesId: 'clientIndividualPropertiesId',
    clientIndividualMinorPropertiesId: 'clientIndividualMinorPropertiesId',
    clientEntityPropertiesId: 'clientEntityPropertiesId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ClientIndividualPropertiesScalarFieldEnum: {
    id: 'id',
    dob: 'dob',
    snils: 'snils',
    clientPassportId: 'clientPassportId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientIndividualPropertiesScalarFieldEnum = (typeof ClientIndividualPropertiesScalarFieldEnum)[keyof typeof ClientIndividualPropertiesScalarFieldEnum]


  export const ClientIndividualMinorPropertiesScalarFieldEnum: {
    id: 'id',
    dob: 'dob',
    snils: 'snils',
    birthCertificate: 'birthCertificate',
    clientPassportId: 'clientPassportId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientIndividualMinorPropertiesScalarFieldEnum = (typeof ClientIndividualMinorPropertiesScalarFieldEnum)[keyof typeof ClientIndividualMinorPropertiesScalarFieldEnum]


  export const ClientEntityPropertiesScalarFieldEnum: {
    id: 'id',
    kpp: 'kpp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientEntityPropertiesScalarFieldEnum = (typeof ClientEntityPropertiesScalarFieldEnum)[keyof typeof ClientEntityPropertiesScalarFieldEnum]


  export const ClientToClientIndividualMinorPropertiesScalarFieldEnum: {
    clientId: 'clientId',
    clientIndividualMinorPropertiesId: 'clientIndividualMinorPropertiesId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientToClientIndividualMinorPropertiesScalarFieldEnum = (typeof ClientToClientIndividualMinorPropertiesScalarFieldEnum)[keyof typeof ClientToClientIndividualMinorPropertiesScalarFieldEnum]


  export const ClientPassportScalarFieldEnum: {
    id: 'id',
    number: 'number',
    issued: 'issued',
    code: 'code',
    placeOfBirth: 'placeOfBirth',
    registrationAddress: 'registrationAddress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientPassportScalarFieldEnum = (typeof ClientPassportScalarFieldEnum)[keyof typeof ClientPassportScalarFieldEnum]


  export const ClientContractScalarFieldEnum: {
    id: 'id',
    number: 'number',
    date: 'date',
    registrationDate: 'registrationDate',
    price: 'price',
    clientContractType: 'clientContractType',
    isRealEstateAgencyActDisabled: 'isRealEstateAgencyActDisabled',
    isTransferActDisabled: 'isTransferActDisabled',
    comment: 'comment',
    link: 'link',
    uuContractId: 'uuContractId',
    dduClientContractPropertiesId: 'dduClientContractPropertiesId',
    dkpClientContractPropertiesId: 'dkpClientContractPropertiesId',
    productId: 'productId',
    objectId: 'objectId',
    realEstateAgentId: 'realEstateAgentId',
    managerId: 'managerId',
    bankId: 'bankId',
    subsidyId: 'subsidyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientContractScalarFieldEnum = (typeof ClientContractScalarFieldEnum)[keyof typeof ClientContractScalarFieldEnum]


  export const DduClientContractPropertiesScalarFieldEnum: {
    id: 'id',
    dduLink: 'dduLink',
    returnAccount: 'returnAccount',
    escrowAccountOpeningDate: 'escrowAccountOpeningDate',
    escrowPeriod: 'escrowPeriod',
    escrowAccountNumber: 'escrowAccountNumber',
    isEscrowDiscount: 'isEscrowDiscount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DduClientContractPropertiesScalarFieldEnum = (typeof DduClientContractPropertiesScalarFieldEnum)[keyof typeof DduClientContractPropertiesScalarFieldEnum]


  export const DkpClientContractPropertiesScalarFieldEnum: {
    id: 'id',
    dkpLink: 'dkpLink',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DkpClientContractPropertiesScalarFieldEnum = (typeof DkpClientContractPropertiesScalarFieldEnum)[keyof typeof DkpClientContractPropertiesScalarFieldEnum]


  export const ClientContractToAgencyContractScalarFieldEnum: {
    clientContractId: 'clientContractId',
    agencyContractId: 'agencyContractId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientContractToAgencyContractScalarFieldEnum = (typeof ClientContractToAgencyContractScalarFieldEnum)[keyof typeof ClientContractToAgencyContractScalarFieldEnum]


  export const ClientContractToClientScalarFieldEnum: {
    isMain: 'isMain',
    share: 'share',
    clientContractId: 'clientContractId',
    clientId: 'clientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientContractToClientScalarFieldEnum = (typeof ClientContractToClientScalarFieldEnum)[keyof typeof ClientContractToClientScalarFieldEnum]


  export const ScheduledPaymentScalarFieldEnum: {
    id: 'id',
    payment: 'payment',
    date: 'date',
    scheduledPaymentType: 'scheduledPaymentType',
    clientContractId: 'clientContractId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduledPaymentScalarFieldEnum = (typeof ScheduledPaymentScalarFieldEnum)[keyof typeof ScheduledPaymentScalarFieldEnum]


  export const ActualPaymentScalarFieldEnum: {
    id: 'id',
    payment: 'payment',
    date: 'date',
    clientContractId: 'clientContractId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActualPaymentScalarFieldEnum = (typeof ActualPaymentScalarFieldEnum)[keyof typeof ActualPaymentScalarFieldEnum]


  export const ObjectScalarFieldEnum: {
    id: 'id',
    commonDbObjectsId: 'commonDbObjectsId',
    name: 'name',
    dateIn: 'dateIn',
    entityId: 'entityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ObjectScalarFieldEnum = (typeof ObjectScalarFieldEnum)[keyof typeof ObjectScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    pricingProductsId: 'pricingProductsId',
    number: 'number',
    productCategory: 'productCategory',
    objectId: 'objectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const AgencyScalarFieldEnum: {
    id: 'id',
    commonDbContractorsId: 'commonDbContractorsId',
    name: 'name',
    inn: 'inn',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgencyScalarFieldEnum = (typeof AgencyScalarFieldEnum)[keyof typeof AgencyScalarFieldEnum]


  export const AgencyContractScalarFieldEnum: {
    id: 'id',
    number: 'number',
    date: 'date',
    agencyContractType: 'agencyContractType',
    link: 'link',
    responsibleUserId: 'responsibleUserId',
    entityId: 'entityId',
    objectId: 'objectId',
    agencyId: 'agencyId',
    agencyContractSignatoryId: 'agencyContractSignatoryId',
    realEstateAgencyContractPropertiesId: 'realEstateAgencyContractPropertiesId',
    mipAgencyContractPropertiesId: 'mipAgencyContractPropertiesId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgencyContractScalarFieldEnum = (typeof AgencyContractScalarFieldEnum)[keyof typeof AgencyContractScalarFieldEnum]


  export const AgencyContractSignatoryScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    basedOn: 'basedOn',
    title: 'title',
    agencyId: 'agencyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgencyContractSignatoryScalarFieldEnum = (typeof AgencyContractSignatoryScalarFieldEnum)[keyof typeof AgencyContractSignatoryScalarFieldEnum]


  export const RealEstateAgencyContractPropertiesScalarFieldEnum: {
    id: 'id',
    agencyContractCommissionId: 'agencyContractCommissionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RealEstateAgencyContractPropertiesScalarFieldEnum = (typeof RealEstateAgencyContractPropertiesScalarFieldEnum)[keyof typeof RealEstateAgencyContractPropertiesScalarFieldEnum]


  export const MipAgencyContractPropertiesScalarFieldEnum: {
    id: 'id',
    agencyContractCommissionId: 'agencyContractCommissionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MipAgencyContractPropertiesScalarFieldEnum = (typeof MipAgencyContractPropertiesScalarFieldEnum)[keyof typeof MipAgencyContractPropertiesScalarFieldEnum]


  export const AgencyContractCommissionScalarFieldEnum: {
    id: 'id',
    percent: 'percent',
    threshold: 'threshold',
    maxDays: 'maxDays',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgencyContractCommissionScalarFieldEnum = (typeof AgencyContractCommissionScalarFieldEnum)[keyof typeof AgencyContractCommissionScalarFieldEnum]


  export const RealEstateAgentScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    phone: 'phone',
    oneGtId: 'oneGtId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RealEstateAgentScalarFieldEnum = (typeof RealEstateAgentScalarFieldEnum)[keyof typeof RealEstateAgentScalarFieldEnum]


  export const AgencyToRealEstateAgentScalarFieldEnum: {
    agencyId: 'agencyId',
    realEstateAgentId: 'realEstateAgentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgencyToRealEstateAgentScalarFieldEnum = (typeof AgencyToRealEstateAgentScalarFieldEnum)[keyof typeof AgencyToRealEstateAgentScalarFieldEnum]


  export const EntityScalarFieldEnum: {
    id: 'id',
    commonDbEntitiesId: 'commonDbEntitiesId',
    commonContractorId: 'commonContractorId',
    name: 'name',
    website: 'website',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EntityScalarFieldEnum = (typeof EntityScalarFieldEnum)[keyof typeof EntityScalarFieldEnum]


  export const EntityForbiddenWebsiteScalarFieldEnum: {
    id: 'id',
    name: 'name',
    entityId: 'entityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EntityForbiddenWebsiteScalarFieldEnum = (typeof EntityForbiddenWebsiteScalarFieldEnum)[keyof typeof EntityForbiddenWebsiteScalarFieldEnum]


  export const EntityForbiddenBrandScalarFieldEnum: {
    id: 'id',
    name: 'name',
    entityId: 'entityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EntityForbiddenBrandScalarFieldEnum = (typeof EntityForbiddenBrandScalarFieldEnum)[keyof typeof EntityForbiddenBrandScalarFieldEnum]


  export const BankScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isVisible: 'isVisible',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankScalarFieldEnum = (typeof BankScalarFieldEnum)[keyof typeof BankScalarFieldEnum]


  export const EscrowAccountHistoryScalarFieldEnum: {
    id: 'id',
    status: 'status',
    number: 'number',
    openingDate: 'openingDate',
    depositedAmount: 'depositedAmount',
    incomingBalance: 'incomingBalance',
    dateOfTransaction: 'dateOfTransaction',
    transactionAmount: 'transactionAmount',
    outgoingBalance: 'outgoingBalance',
    expirationDate: 'expirationDate',
    depositor: 'depositor',
    depositorInn: 'depositorInn',
    dduNumber: 'dduNumber',
    dduDate: 'dduDate',
    loanAgreementNumber: 'loanAgreementNumber',
    loanAgreementDate: 'loanAgreementDate',
    closingDate: 'closingDate',
    builderInn: 'builderInn',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EscrowAccountHistoryScalarFieldEnum = (typeof EscrowAccountHistoryScalarFieldEnum)[keyof typeof EscrowAccountHistoryScalarFieldEnum]


  export const RealEstateAgencyActScalarFieldEnum: {
    id: 'id',
    number: 'number',
    date: 'date',
    amount: 'amount',
    retention: 'retention',
    note: 'note',
    link: 'link',
    clientContractId: 'clientContractId',
    agencyId: 'agencyId',
    agencyContractId: 'agencyContractId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RealEstateAgencyActScalarFieldEnum = (typeof RealEstateAgencyActScalarFieldEnum)[keyof typeof RealEstateAgencyActScalarFieldEnum]


  export const SubsidyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isVisible: 'isVisible',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubsidyScalarFieldEnum = (typeof SubsidyScalarFieldEnum)[keyof typeof SubsidyScalarFieldEnum]


  export const AssignmentScalarFieldEnum: {
    id: 'id',
    order: 'order',
    clientContractId: 'clientContractId',
    clientId: 'clientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssignmentScalarFieldEnum = (typeof AssignmentScalarFieldEnum)[keyof typeof AssignmentScalarFieldEnum]


  export const TransferActScalarFieldEnum: {
    id: 'id',
    number: 'number',
    date: 'date',
    link: 'link',
    clientContractId: 'clientContractId',
    objectId: 'objectId',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransferActScalarFieldEnum = (typeof TransferActScalarFieldEnum)[keyof typeof TransferActScalarFieldEnum]


  export const RepresentativeScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    attorneyNumber: 'attorneyNumber',
    attorneyDate: 'attorneyDate',
    authorizedBy: 'authorizedBy',
    authorizedRole: 'authorizedRole',
    clientId: 'clientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RepresentativeScalarFieldEnum = (typeof RepresentativeScalarFieldEnum)[keyof typeof RepresentativeScalarFieldEnum]


  export const TransferActToRepresentativeScalarFieldEnum: {
    transferActId: 'transferActId',
    representativeId: 'representativeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransferActToRepresentativeScalarFieldEnum = (typeof TransferActToRepresentativeScalarFieldEnum)[keyof typeof TransferActToRepresentativeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'ClientCategory'
   */
  export type EnumClientCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientCategory'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'ClientContractType'
   */
  export type EnumClientContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientContractType'>
    


  /**
   * Reference to a field of type 'ScheduledPaymentType'
   */
  export type EnumScheduledPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduledPaymentType'>
    


  /**
   * Reference to a field of type 'ProductCategory'
   */
  export type EnumProductCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductCategory'>
    


  /**
   * Reference to a field of type 'AgencyContractType'
   */
  export type EnumAgencyContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgencyContractType'>
    


  /**
   * Reference to a field of type 'EscrowAccountStatus'
   */
  export type EnumEscrowAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EscrowAccountStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    fullName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    isManager?: BoolFilter<"User"> | boolean
    isStaff?: BoolFilter<"User"> | boolean
    userRole?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    clientContracts?: ClientContractListRelationFilter
    agencyContracts?: AgencyContractListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    isManager?: SortOrder
    isStaff?: SortOrder
    userRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientContracts?: ClientContractOrderByRelationAggregateInput
    agencyContracts?: AgencyContractOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    fullName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    isManager?: BoolFilter<"User"> | boolean
    isStaff?: BoolFilter<"User"> | boolean
    userRole?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    clientContracts?: ClientContractListRelationFilter
    agencyContracts?: AgencyContractListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    isManager?: SortOrder
    isStaff?: SortOrder
    userRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    fullName?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    isManager?: BoolWithAggregatesFilter<"User"> | boolean
    isStaff?: BoolWithAggregatesFilter<"User"> | boolean
    userRole?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: IntFilter<"Client"> | number
    fullName?: StringFilter<"Client"> | string
    inn?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    email?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    clientCategory?: EnumClientCategoryFilter<"Client"> | $Enums.ClientCategory
    clientIndividualPropertiesId?: IntNullableFilter<"Client"> | number | null
    clientIndividualMinorPropertiesId?: IntNullableFilter<"Client"> | number | null
    clientEntityPropertiesId?: IntNullableFilter<"Client"> | number | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    clientIndividualProperties?: XOR<ClientIndividualPropertiesNullableRelationFilter, ClientIndividualPropertiesWhereInput> | null
    clientIndividualMinorProperties?: XOR<ClientIndividualMinorPropertiesNullableRelationFilter, ClientIndividualMinorPropertiesWhereInput> | null
    clientEntityProperties?: XOR<ClientEntityPropertiesNullableRelationFilter, ClientEntityPropertiesWhereInput> | null
    assignments?: AssignmentListRelationFilter
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesListRelationFilter
    clientContractsToClients?: ClientContractToClientListRelationFilter
    representatives?: RepresentativeListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    inn?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    clientCategory?: SortOrder
    clientIndividualPropertiesId?: SortOrderInput | SortOrder
    clientIndividualMinorPropertiesId?: SortOrderInput | SortOrder
    clientEntityPropertiesId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientIndividualProperties?: ClientIndividualPropertiesOrderByWithRelationInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesOrderByWithRelationInput
    clientEntityProperties?: ClientEntityPropertiesOrderByWithRelationInput
    assignments?: AssignmentOrderByRelationAggregateInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesOrderByRelationAggregateInput
    clientContractsToClients?: ClientContractToClientOrderByRelationAggregateInput
    representatives?: RepresentativeOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    clientIndividualPropertiesId?: number
    clientIndividualMinorPropertiesId?: number
    clientEntityPropertiesId?: number
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    fullName?: StringFilter<"Client"> | string
    inn?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    email?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    clientCategory?: EnumClientCategoryFilter<"Client"> | $Enums.ClientCategory
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    clientIndividualProperties?: XOR<ClientIndividualPropertiesNullableRelationFilter, ClientIndividualPropertiesWhereInput> | null
    clientIndividualMinorProperties?: XOR<ClientIndividualMinorPropertiesNullableRelationFilter, ClientIndividualMinorPropertiesWhereInput> | null
    clientEntityProperties?: XOR<ClientEntityPropertiesNullableRelationFilter, ClientEntityPropertiesWhereInput> | null
    assignments?: AssignmentListRelationFilter
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesListRelationFilter
    clientContractsToClients?: ClientContractToClientListRelationFilter
    representatives?: RepresentativeListRelationFilter
  }, "id" | "clientIndividualPropertiesId" | "clientIndividualMinorPropertiesId" | "clientEntityPropertiesId">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    inn?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    clientCategory?: SortOrder
    clientIndividualPropertiesId?: SortOrderInput | SortOrder
    clientIndividualMinorPropertiesId?: SortOrderInput | SortOrder
    clientEntityPropertiesId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Client"> | number
    fullName?: StringWithAggregatesFilter<"Client"> | string
    inn?: StringNullableWithAggregatesFilter<"Client"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Client"> | string | null
    email?: StringNullableWithAggregatesFilter<"Client"> | string | null
    address?: StringNullableWithAggregatesFilter<"Client"> | string | null
    clientCategory?: EnumClientCategoryWithAggregatesFilter<"Client"> | $Enums.ClientCategory
    clientIndividualPropertiesId?: IntNullableWithAggregatesFilter<"Client"> | number | null
    clientIndividualMinorPropertiesId?: IntNullableWithAggregatesFilter<"Client"> | number | null
    clientEntityPropertiesId?: IntNullableWithAggregatesFilter<"Client"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type ClientIndividualPropertiesWhereInput = {
    AND?: ClientIndividualPropertiesWhereInput | ClientIndividualPropertiesWhereInput[]
    OR?: ClientIndividualPropertiesWhereInput[]
    NOT?: ClientIndividualPropertiesWhereInput | ClientIndividualPropertiesWhereInput[]
    id?: IntFilter<"ClientIndividualProperties"> | number
    dob?: DateTimeNullableFilter<"ClientIndividualProperties"> | Date | string | null
    snils?: StringNullableFilter<"ClientIndividualProperties"> | string | null
    clientPassportId?: IntNullableFilter<"ClientIndividualProperties"> | number | null
    createdAt?: DateTimeFilter<"ClientIndividualProperties"> | Date | string
    updatedAt?: DateTimeFilter<"ClientIndividualProperties"> | Date | string
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    clientPassport?: XOR<ClientPassportNullableRelationFilter, ClientPassportWhereInput> | null
  }

  export type ClientIndividualPropertiesOrderByWithRelationInput = {
    id?: SortOrder
    dob?: SortOrderInput | SortOrder
    snils?: SortOrderInput | SortOrder
    clientPassportId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    clientPassport?: ClientPassportOrderByWithRelationInput
  }

  export type ClientIndividualPropertiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    clientPassportId?: number
    AND?: ClientIndividualPropertiesWhereInput | ClientIndividualPropertiesWhereInput[]
    OR?: ClientIndividualPropertiesWhereInput[]
    NOT?: ClientIndividualPropertiesWhereInput | ClientIndividualPropertiesWhereInput[]
    dob?: DateTimeNullableFilter<"ClientIndividualProperties"> | Date | string | null
    snils?: StringNullableFilter<"ClientIndividualProperties"> | string | null
    createdAt?: DateTimeFilter<"ClientIndividualProperties"> | Date | string
    updatedAt?: DateTimeFilter<"ClientIndividualProperties"> | Date | string
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    clientPassport?: XOR<ClientPassportNullableRelationFilter, ClientPassportWhereInput> | null
  }, "id" | "clientPassportId">

  export type ClientIndividualPropertiesOrderByWithAggregationInput = {
    id?: SortOrder
    dob?: SortOrderInput | SortOrder
    snils?: SortOrderInput | SortOrder
    clientPassportId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientIndividualPropertiesCountOrderByAggregateInput
    _avg?: ClientIndividualPropertiesAvgOrderByAggregateInput
    _max?: ClientIndividualPropertiesMaxOrderByAggregateInput
    _min?: ClientIndividualPropertiesMinOrderByAggregateInput
    _sum?: ClientIndividualPropertiesSumOrderByAggregateInput
  }

  export type ClientIndividualPropertiesScalarWhereWithAggregatesInput = {
    AND?: ClientIndividualPropertiesScalarWhereWithAggregatesInput | ClientIndividualPropertiesScalarWhereWithAggregatesInput[]
    OR?: ClientIndividualPropertiesScalarWhereWithAggregatesInput[]
    NOT?: ClientIndividualPropertiesScalarWhereWithAggregatesInput | ClientIndividualPropertiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClientIndividualProperties"> | number
    dob?: DateTimeNullableWithAggregatesFilter<"ClientIndividualProperties"> | Date | string | null
    snils?: StringNullableWithAggregatesFilter<"ClientIndividualProperties"> | string | null
    clientPassportId?: IntNullableWithAggregatesFilter<"ClientIndividualProperties"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ClientIndividualProperties"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientIndividualProperties"> | Date | string
  }

  export type ClientIndividualMinorPropertiesWhereInput = {
    AND?: ClientIndividualMinorPropertiesWhereInput | ClientIndividualMinorPropertiesWhereInput[]
    OR?: ClientIndividualMinorPropertiesWhereInput[]
    NOT?: ClientIndividualMinorPropertiesWhereInput | ClientIndividualMinorPropertiesWhereInput[]
    id?: IntFilter<"ClientIndividualMinorProperties"> | number
    dob?: DateTimeNullableFilter<"ClientIndividualMinorProperties"> | Date | string | null
    snils?: StringNullableFilter<"ClientIndividualMinorProperties"> | string | null
    birthCertificate?: StringNullableFilter<"ClientIndividualMinorProperties"> | string | null
    clientPassportId?: IntNullableFilter<"ClientIndividualMinorProperties"> | number | null
    createdAt?: DateTimeFilter<"ClientIndividualMinorProperties"> | Date | string
    updatedAt?: DateTimeFilter<"ClientIndividualMinorProperties"> | Date | string
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    clientPassport?: XOR<ClientPassportNullableRelationFilter, ClientPassportWhereInput> | null
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesListRelationFilter
  }

  export type ClientIndividualMinorPropertiesOrderByWithRelationInput = {
    id?: SortOrder
    dob?: SortOrderInput | SortOrder
    snils?: SortOrderInput | SortOrder
    birthCertificate?: SortOrderInput | SortOrder
    clientPassportId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    clientPassport?: ClientPassportOrderByWithRelationInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesOrderByRelationAggregateInput
  }

  export type ClientIndividualMinorPropertiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    clientPassportId?: number
    AND?: ClientIndividualMinorPropertiesWhereInput | ClientIndividualMinorPropertiesWhereInput[]
    OR?: ClientIndividualMinorPropertiesWhereInput[]
    NOT?: ClientIndividualMinorPropertiesWhereInput | ClientIndividualMinorPropertiesWhereInput[]
    dob?: DateTimeNullableFilter<"ClientIndividualMinorProperties"> | Date | string | null
    snils?: StringNullableFilter<"ClientIndividualMinorProperties"> | string | null
    birthCertificate?: StringNullableFilter<"ClientIndividualMinorProperties"> | string | null
    createdAt?: DateTimeFilter<"ClientIndividualMinorProperties"> | Date | string
    updatedAt?: DateTimeFilter<"ClientIndividualMinorProperties"> | Date | string
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    clientPassport?: XOR<ClientPassportNullableRelationFilter, ClientPassportWhereInput> | null
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesListRelationFilter
  }, "id" | "clientPassportId">

  export type ClientIndividualMinorPropertiesOrderByWithAggregationInput = {
    id?: SortOrder
    dob?: SortOrderInput | SortOrder
    snils?: SortOrderInput | SortOrder
    birthCertificate?: SortOrderInput | SortOrder
    clientPassportId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientIndividualMinorPropertiesCountOrderByAggregateInput
    _avg?: ClientIndividualMinorPropertiesAvgOrderByAggregateInput
    _max?: ClientIndividualMinorPropertiesMaxOrderByAggregateInput
    _min?: ClientIndividualMinorPropertiesMinOrderByAggregateInput
    _sum?: ClientIndividualMinorPropertiesSumOrderByAggregateInput
  }

  export type ClientIndividualMinorPropertiesScalarWhereWithAggregatesInput = {
    AND?: ClientIndividualMinorPropertiesScalarWhereWithAggregatesInput | ClientIndividualMinorPropertiesScalarWhereWithAggregatesInput[]
    OR?: ClientIndividualMinorPropertiesScalarWhereWithAggregatesInput[]
    NOT?: ClientIndividualMinorPropertiesScalarWhereWithAggregatesInput | ClientIndividualMinorPropertiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClientIndividualMinorProperties"> | number
    dob?: DateTimeNullableWithAggregatesFilter<"ClientIndividualMinorProperties"> | Date | string | null
    snils?: StringNullableWithAggregatesFilter<"ClientIndividualMinorProperties"> | string | null
    birthCertificate?: StringNullableWithAggregatesFilter<"ClientIndividualMinorProperties"> | string | null
    clientPassportId?: IntNullableWithAggregatesFilter<"ClientIndividualMinorProperties"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ClientIndividualMinorProperties"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientIndividualMinorProperties"> | Date | string
  }

  export type ClientEntityPropertiesWhereInput = {
    AND?: ClientEntityPropertiesWhereInput | ClientEntityPropertiesWhereInput[]
    OR?: ClientEntityPropertiesWhereInput[]
    NOT?: ClientEntityPropertiesWhereInput | ClientEntityPropertiesWhereInput[]
    id?: IntFilter<"ClientEntityProperties"> | number
    kpp?: StringNullableFilter<"ClientEntityProperties"> | string | null
    createdAt?: DateTimeFilter<"ClientEntityProperties"> | Date | string
    updatedAt?: DateTimeFilter<"ClientEntityProperties"> | Date | string
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
  }

  export type ClientEntityPropertiesOrderByWithRelationInput = {
    id?: SortOrder
    kpp?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type ClientEntityPropertiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClientEntityPropertiesWhereInput | ClientEntityPropertiesWhereInput[]
    OR?: ClientEntityPropertiesWhereInput[]
    NOT?: ClientEntityPropertiesWhereInput | ClientEntityPropertiesWhereInput[]
    kpp?: StringNullableFilter<"ClientEntityProperties"> | string | null
    createdAt?: DateTimeFilter<"ClientEntityProperties"> | Date | string
    updatedAt?: DateTimeFilter<"ClientEntityProperties"> | Date | string
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
  }, "id">

  export type ClientEntityPropertiesOrderByWithAggregationInput = {
    id?: SortOrder
    kpp?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientEntityPropertiesCountOrderByAggregateInput
    _avg?: ClientEntityPropertiesAvgOrderByAggregateInput
    _max?: ClientEntityPropertiesMaxOrderByAggregateInput
    _min?: ClientEntityPropertiesMinOrderByAggregateInput
    _sum?: ClientEntityPropertiesSumOrderByAggregateInput
  }

  export type ClientEntityPropertiesScalarWhereWithAggregatesInput = {
    AND?: ClientEntityPropertiesScalarWhereWithAggregatesInput | ClientEntityPropertiesScalarWhereWithAggregatesInput[]
    OR?: ClientEntityPropertiesScalarWhereWithAggregatesInput[]
    NOT?: ClientEntityPropertiesScalarWhereWithAggregatesInput | ClientEntityPropertiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClientEntityProperties"> | number
    kpp?: StringNullableWithAggregatesFilter<"ClientEntityProperties"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClientEntityProperties"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientEntityProperties"> | Date | string
  }

  export type ClientToClientIndividualMinorPropertiesWhereInput = {
    AND?: ClientToClientIndividualMinorPropertiesWhereInput | ClientToClientIndividualMinorPropertiesWhereInput[]
    OR?: ClientToClientIndividualMinorPropertiesWhereInput[]
    NOT?: ClientToClientIndividualMinorPropertiesWhereInput | ClientToClientIndividualMinorPropertiesWhereInput[]
    clientId?: IntFilter<"ClientToClientIndividualMinorProperties"> | number
    clientIndividualMinorPropertiesId?: IntFilter<"ClientToClientIndividualMinorProperties"> | number
    createdAt?: DateTimeFilter<"ClientToClientIndividualMinorProperties"> | Date | string
    updatedAt?: DateTimeFilter<"ClientToClientIndividualMinorProperties"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    clientIndividualMinorProperties?: XOR<ClientIndividualMinorPropertiesRelationFilter, ClientIndividualMinorPropertiesWhereInput>
  }

  export type ClientToClientIndividualMinorPropertiesOrderByWithRelationInput = {
    clientId?: SortOrder
    clientIndividualMinorPropertiesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesOrderByWithRelationInput
  }

  export type ClientToClientIndividualMinorPropertiesWhereUniqueInput = Prisma.AtLeast<{
    clientId_clientIndividualMinorPropertiesId?: ClientToClientIndividualMinorPropertiesClientIdClientIndividualMinorPropertiesIdCompoundUniqueInput
    AND?: ClientToClientIndividualMinorPropertiesWhereInput | ClientToClientIndividualMinorPropertiesWhereInput[]
    OR?: ClientToClientIndividualMinorPropertiesWhereInput[]
    NOT?: ClientToClientIndividualMinorPropertiesWhereInput | ClientToClientIndividualMinorPropertiesWhereInput[]
    clientId?: IntFilter<"ClientToClientIndividualMinorProperties"> | number
    clientIndividualMinorPropertiesId?: IntFilter<"ClientToClientIndividualMinorProperties"> | number
    createdAt?: DateTimeFilter<"ClientToClientIndividualMinorProperties"> | Date | string
    updatedAt?: DateTimeFilter<"ClientToClientIndividualMinorProperties"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    clientIndividualMinorProperties?: XOR<ClientIndividualMinorPropertiesRelationFilter, ClientIndividualMinorPropertiesWhereInput>
  }, "clientId_clientIndividualMinorPropertiesId">

  export type ClientToClientIndividualMinorPropertiesOrderByWithAggregationInput = {
    clientId?: SortOrder
    clientIndividualMinorPropertiesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientToClientIndividualMinorPropertiesCountOrderByAggregateInput
    _avg?: ClientToClientIndividualMinorPropertiesAvgOrderByAggregateInput
    _max?: ClientToClientIndividualMinorPropertiesMaxOrderByAggregateInput
    _min?: ClientToClientIndividualMinorPropertiesMinOrderByAggregateInput
    _sum?: ClientToClientIndividualMinorPropertiesSumOrderByAggregateInput
  }

  export type ClientToClientIndividualMinorPropertiesScalarWhereWithAggregatesInput = {
    AND?: ClientToClientIndividualMinorPropertiesScalarWhereWithAggregatesInput | ClientToClientIndividualMinorPropertiesScalarWhereWithAggregatesInput[]
    OR?: ClientToClientIndividualMinorPropertiesScalarWhereWithAggregatesInput[]
    NOT?: ClientToClientIndividualMinorPropertiesScalarWhereWithAggregatesInput | ClientToClientIndividualMinorPropertiesScalarWhereWithAggregatesInput[]
    clientId?: IntWithAggregatesFilter<"ClientToClientIndividualMinorProperties"> | number
    clientIndividualMinorPropertiesId?: IntWithAggregatesFilter<"ClientToClientIndividualMinorProperties"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ClientToClientIndividualMinorProperties"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientToClientIndividualMinorProperties"> | Date | string
  }

  export type ClientPassportWhereInput = {
    AND?: ClientPassportWhereInput | ClientPassportWhereInput[]
    OR?: ClientPassportWhereInput[]
    NOT?: ClientPassportWhereInput | ClientPassportWhereInput[]
    id?: IntFilter<"ClientPassport"> | number
    number?: StringNullableFilter<"ClientPassport"> | string | null
    issued?: StringNullableFilter<"ClientPassport"> | string | null
    code?: StringNullableFilter<"ClientPassport"> | string | null
    placeOfBirth?: StringNullableFilter<"ClientPassport"> | string | null
    registrationAddress?: StringNullableFilter<"ClientPassport"> | string | null
    createdAt?: DateTimeFilter<"ClientPassport"> | Date | string
    updatedAt?: DateTimeFilter<"ClientPassport"> | Date | string
    clientIndividualProperties?: XOR<ClientIndividualPropertiesNullableRelationFilter, ClientIndividualPropertiesWhereInput> | null
    clientIndividualMinorProperties?: XOR<ClientIndividualMinorPropertiesNullableRelationFilter, ClientIndividualMinorPropertiesWhereInput> | null
  }

  export type ClientPassportOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrderInput | SortOrder
    issued?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    placeOfBirth?: SortOrderInput | SortOrder
    registrationAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientIndividualProperties?: ClientIndividualPropertiesOrderByWithRelationInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesOrderByWithRelationInput
  }

  export type ClientPassportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClientPassportWhereInput | ClientPassportWhereInput[]
    OR?: ClientPassportWhereInput[]
    NOT?: ClientPassportWhereInput | ClientPassportWhereInput[]
    number?: StringNullableFilter<"ClientPassport"> | string | null
    issued?: StringNullableFilter<"ClientPassport"> | string | null
    code?: StringNullableFilter<"ClientPassport"> | string | null
    placeOfBirth?: StringNullableFilter<"ClientPassport"> | string | null
    registrationAddress?: StringNullableFilter<"ClientPassport"> | string | null
    createdAt?: DateTimeFilter<"ClientPassport"> | Date | string
    updatedAt?: DateTimeFilter<"ClientPassport"> | Date | string
    clientIndividualProperties?: XOR<ClientIndividualPropertiesNullableRelationFilter, ClientIndividualPropertiesWhereInput> | null
    clientIndividualMinorProperties?: XOR<ClientIndividualMinorPropertiesNullableRelationFilter, ClientIndividualMinorPropertiesWhereInput> | null
  }, "id">

  export type ClientPassportOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrderInput | SortOrder
    issued?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    placeOfBirth?: SortOrderInput | SortOrder
    registrationAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientPassportCountOrderByAggregateInput
    _avg?: ClientPassportAvgOrderByAggregateInput
    _max?: ClientPassportMaxOrderByAggregateInput
    _min?: ClientPassportMinOrderByAggregateInput
    _sum?: ClientPassportSumOrderByAggregateInput
  }

  export type ClientPassportScalarWhereWithAggregatesInput = {
    AND?: ClientPassportScalarWhereWithAggregatesInput | ClientPassportScalarWhereWithAggregatesInput[]
    OR?: ClientPassportScalarWhereWithAggregatesInput[]
    NOT?: ClientPassportScalarWhereWithAggregatesInput | ClientPassportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClientPassport"> | number
    number?: StringNullableWithAggregatesFilter<"ClientPassport"> | string | null
    issued?: StringNullableWithAggregatesFilter<"ClientPassport"> | string | null
    code?: StringNullableWithAggregatesFilter<"ClientPassport"> | string | null
    placeOfBirth?: StringNullableWithAggregatesFilter<"ClientPassport"> | string | null
    registrationAddress?: StringNullableWithAggregatesFilter<"ClientPassport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClientPassport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientPassport"> | Date | string
  }

  export type ClientContractWhereInput = {
    AND?: ClientContractWhereInput | ClientContractWhereInput[]
    OR?: ClientContractWhereInput[]
    NOT?: ClientContractWhereInput | ClientContractWhereInput[]
    id?: IntFilter<"ClientContract"> | number
    number?: StringFilter<"ClientContract"> | string
    date?: DateTimeFilter<"ClientContract"> | Date | string
    registrationDate?: DateTimeNullableFilter<"ClientContract"> | Date | string | null
    price?: DecimalFilter<"ClientContract"> | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFilter<"ClientContract"> | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: BoolNullableFilter<"ClientContract"> | boolean | null
    isTransferActDisabled?: BoolNullableFilter<"ClientContract"> | boolean | null
    comment?: StringNullableFilter<"ClientContract"> | string | null
    link?: StringNullableFilter<"ClientContract"> | string | null
    uuContractId?: IntNullableFilter<"ClientContract"> | number | null
    dduClientContractPropertiesId?: IntNullableFilter<"ClientContract"> | number | null
    dkpClientContractPropertiesId?: IntNullableFilter<"ClientContract"> | number | null
    productId?: IntFilter<"ClientContract"> | number
    objectId?: IntFilter<"ClientContract"> | number
    realEstateAgentId?: IntNullableFilter<"ClientContract"> | number | null
    managerId?: IntNullableFilter<"ClientContract"> | number | null
    bankId?: IntNullableFilter<"ClientContract"> | number | null
    subsidyId?: IntNullableFilter<"ClientContract"> | number | null
    createdAt?: DateTimeFilter<"ClientContract"> | Date | string
    updatedAt?: DateTimeFilter<"ClientContract"> | Date | string
    transferAct?: XOR<TransferActNullableRelationFilter, TransferActWhereInput> | null
    dduClientContractProperties?: XOR<DduClientContractPropertiesNullableRelationFilter, DduClientContractPropertiesWhereInput> | null
    dkpClientContractProperties?: XOR<DkpClientContractPropertiesNullableRelationFilter, DkpClientContractPropertiesWhereInput> | null
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
    realEstateAgent?: XOR<RealEstateAgentNullableRelationFilter, RealEstateAgentWhereInput> | null
    manager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    bank?: XOR<BankNullableRelationFilter, BankWhereInput> | null
    subsidy?: XOR<SubsidyNullableRelationFilter, SubsidyWhereInput> | null
    scheduledPayments?: ScheduledPaymentListRelationFilter
    actualPayments?: ActualPaymentListRelationFilter
    realEstateAgencyActs?: RealEstateAgencyActListRelationFilter
    assignments?: AssignmentListRelationFilter
    clientContractsToClients?: ClientContractToClientListRelationFilter
    clientContractsToAgencyContracts?: ClientContractToAgencyContractListRelationFilter
  }

  export type ClientContractOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    registrationDate?: SortOrderInput | SortOrder
    price?: SortOrder
    clientContractType?: SortOrder
    isRealEstateAgencyActDisabled?: SortOrderInput | SortOrder
    isTransferActDisabled?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    uuContractId?: SortOrderInput | SortOrder
    dduClientContractPropertiesId?: SortOrderInput | SortOrder
    dkpClientContractPropertiesId?: SortOrderInput | SortOrder
    productId?: SortOrder
    objectId?: SortOrder
    realEstateAgentId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    bankId?: SortOrderInput | SortOrder
    subsidyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transferAct?: TransferActOrderByWithRelationInput
    dduClientContractProperties?: DduClientContractPropertiesOrderByWithRelationInput
    dkpClientContractProperties?: DkpClientContractPropertiesOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    object?: ObjectOrderByWithRelationInput
    realEstateAgent?: RealEstateAgentOrderByWithRelationInput
    manager?: UserOrderByWithRelationInput
    bank?: BankOrderByWithRelationInput
    subsidy?: SubsidyOrderByWithRelationInput
    scheduledPayments?: ScheduledPaymentOrderByRelationAggregateInput
    actualPayments?: ActualPaymentOrderByRelationAggregateInput
    realEstateAgencyActs?: RealEstateAgencyActOrderByRelationAggregateInput
    assignments?: AssignmentOrderByRelationAggregateInput
    clientContractsToClients?: ClientContractToClientOrderByRelationAggregateInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractOrderByRelationAggregateInput
  }

  export type ClientContractWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    dduClientContractPropertiesId?: number
    dkpClientContractPropertiesId?: number
    productId?: number
    AND?: ClientContractWhereInput | ClientContractWhereInput[]
    OR?: ClientContractWhereInput[]
    NOT?: ClientContractWhereInput | ClientContractWhereInput[]
    number?: StringFilter<"ClientContract"> | string
    date?: DateTimeFilter<"ClientContract"> | Date | string
    registrationDate?: DateTimeNullableFilter<"ClientContract"> | Date | string | null
    price?: DecimalFilter<"ClientContract"> | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFilter<"ClientContract"> | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: BoolNullableFilter<"ClientContract"> | boolean | null
    isTransferActDisabled?: BoolNullableFilter<"ClientContract"> | boolean | null
    comment?: StringNullableFilter<"ClientContract"> | string | null
    link?: StringNullableFilter<"ClientContract"> | string | null
    uuContractId?: IntNullableFilter<"ClientContract"> | number | null
    objectId?: IntFilter<"ClientContract"> | number
    realEstateAgentId?: IntNullableFilter<"ClientContract"> | number | null
    managerId?: IntNullableFilter<"ClientContract"> | number | null
    bankId?: IntNullableFilter<"ClientContract"> | number | null
    subsidyId?: IntNullableFilter<"ClientContract"> | number | null
    createdAt?: DateTimeFilter<"ClientContract"> | Date | string
    updatedAt?: DateTimeFilter<"ClientContract"> | Date | string
    transferAct?: XOR<TransferActNullableRelationFilter, TransferActWhereInput> | null
    dduClientContractProperties?: XOR<DduClientContractPropertiesNullableRelationFilter, DduClientContractPropertiesWhereInput> | null
    dkpClientContractProperties?: XOR<DkpClientContractPropertiesNullableRelationFilter, DkpClientContractPropertiesWhereInput> | null
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
    realEstateAgent?: XOR<RealEstateAgentNullableRelationFilter, RealEstateAgentWhereInput> | null
    manager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    bank?: XOR<BankNullableRelationFilter, BankWhereInput> | null
    subsidy?: XOR<SubsidyNullableRelationFilter, SubsidyWhereInput> | null
    scheduledPayments?: ScheduledPaymentListRelationFilter
    actualPayments?: ActualPaymentListRelationFilter
    realEstateAgencyActs?: RealEstateAgencyActListRelationFilter
    assignments?: AssignmentListRelationFilter
    clientContractsToClients?: ClientContractToClientListRelationFilter
    clientContractsToAgencyContracts?: ClientContractToAgencyContractListRelationFilter
  }, "id" | "dduClientContractPropertiesId" | "dkpClientContractPropertiesId" | "productId">

  export type ClientContractOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    registrationDate?: SortOrderInput | SortOrder
    price?: SortOrder
    clientContractType?: SortOrder
    isRealEstateAgencyActDisabled?: SortOrderInput | SortOrder
    isTransferActDisabled?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    uuContractId?: SortOrderInput | SortOrder
    dduClientContractPropertiesId?: SortOrderInput | SortOrder
    dkpClientContractPropertiesId?: SortOrderInput | SortOrder
    productId?: SortOrder
    objectId?: SortOrder
    realEstateAgentId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    bankId?: SortOrderInput | SortOrder
    subsidyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientContractCountOrderByAggregateInput
    _avg?: ClientContractAvgOrderByAggregateInput
    _max?: ClientContractMaxOrderByAggregateInput
    _min?: ClientContractMinOrderByAggregateInput
    _sum?: ClientContractSumOrderByAggregateInput
  }

  export type ClientContractScalarWhereWithAggregatesInput = {
    AND?: ClientContractScalarWhereWithAggregatesInput | ClientContractScalarWhereWithAggregatesInput[]
    OR?: ClientContractScalarWhereWithAggregatesInput[]
    NOT?: ClientContractScalarWhereWithAggregatesInput | ClientContractScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClientContract"> | number
    number?: StringWithAggregatesFilter<"ClientContract"> | string
    date?: DateTimeWithAggregatesFilter<"ClientContract"> | Date | string
    registrationDate?: DateTimeNullableWithAggregatesFilter<"ClientContract"> | Date | string | null
    price?: DecimalWithAggregatesFilter<"ClientContract"> | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeWithAggregatesFilter<"ClientContract"> | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: BoolNullableWithAggregatesFilter<"ClientContract"> | boolean | null
    isTransferActDisabled?: BoolNullableWithAggregatesFilter<"ClientContract"> | boolean | null
    comment?: StringNullableWithAggregatesFilter<"ClientContract"> | string | null
    link?: StringNullableWithAggregatesFilter<"ClientContract"> | string | null
    uuContractId?: IntNullableWithAggregatesFilter<"ClientContract"> | number | null
    dduClientContractPropertiesId?: IntNullableWithAggregatesFilter<"ClientContract"> | number | null
    dkpClientContractPropertiesId?: IntNullableWithAggregatesFilter<"ClientContract"> | number | null
    productId?: IntWithAggregatesFilter<"ClientContract"> | number
    objectId?: IntWithAggregatesFilter<"ClientContract"> | number
    realEstateAgentId?: IntNullableWithAggregatesFilter<"ClientContract"> | number | null
    managerId?: IntNullableWithAggregatesFilter<"ClientContract"> | number | null
    bankId?: IntNullableWithAggregatesFilter<"ClientContract"> | number | null
    subsidyId?: IntNullableWithAggregatesFilter<"ClientContract"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ClientContract"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientContract"> | Date | string
  }

  export type DduClientContractPropertiesWhereInput = {
    AND?: DduClientContractPropertiesWhereInput | DduClientContractPropertiesWhereInput[]
    OR?: DduClientContractPropertiesWhereInput[]
    NOT?: DduClientContractPropertiesWhereInput | DduClientContractPropertiesWhereInput[]
    id?: IntFilter<"DduClientContractProperties"> | number
    dduLink?: StringNullableFilter<"DduClientContractProperties"> | string | null
    returnAccount?: StringNullableFilter<"DduClientContractProperties"> | string | null
    escrowAccountOpeningDate?: DateTimeNullableFilter<"DduClientContractProperties"> | Date | string | null
    escrowPeriod?: DateTimeNullableFilter<"DduClientContractProperties"> | Date | string | null
    escrowAccountNumber?: StringNullableFilter<"DduClientContractProperties"> | string | null
    isEscrowDiscount?: BoolNullableFilter<"DduClientContractProperties"> | boolean | null
    createdAt?: DateTimeFilter<"DduClientContractProperties"> | Date | string
    updatedAt?: DateTimeFilter<"DduClientContractProperties"> | Date | string
    clientContract?: XOR<ClientContractNullableRelationFilter, ClientContractWhereInput> | null
  }

  export type DduClientContractPropertiesOrderByWithRelationInput = {
    id?: SortOrder
    dduLink?: SortOrderInput | SortOrder
    returnAccount?: SortOrderInput | SortOrder
    escrowAccountOpeningDate?: SortOrderInput | SortOrder
    escrowPeriod?: SortOrderInput | SortOrder
    escrowAccountNumber?: SortOrderInput | SortOrder
    isEscrowDiscount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientContract?: ClientContractOrderByWithRelationInput
  }

  export type DduClientContractPropertiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DduClientContractPropertiesWhereInput | DduClientContractPropertiesWhereInput[]
    OR?: DduClientContractPropertiesWhereInput[]
    NOT?: DduClientContractPropertiesWhereInput | DduClientContractPropertiesWhereInput[]
    dduLink?: StringNullableFilter<"DduClientContractProperties"> | string | null
    returnAccount?: StringNullableFilter<"DduClientContractProperties"> | string | null
    escrowAccountOpeningDate?: DateTimeNullableFilter<"DduClientContractProperties"> | Date | string | null
    escrowPeriod?: DateTimeNullableFilter<"DduClientContractProperties"> | Date | string | null
    escrowAccountNumber?: StringNullableFilter<"DduClientContractProperties"> | string | null
    isEscrowDiscount?: BoolNullableFilter<"DduClientContractProperties"> | boolean | null
    createdAt?: DateTimeFilter<"DduClientContractProperties"> | Date | string
    updatedAt?: DateTimeFilter<"DduClientContractProperties"> | Date | string
    clientContract?: XOR<ClientContractNullableRelationFilter, ClientContractWhereInput> | null
  }, "id">

  export type DduClientContractPropertiesOrderByWithAggregationInput = {
    id?: SortOrder
    dduLink?: SortOrderInput | SortOrder
    returnAccount?: SortOrderInput | SortOrder
    escrowAccountOpeningDate?: SortOrderInput | SortOrder
    escrowPeriod?: SortOrderInput | SortOrder
    escrowAccountNumber?: SortOrderInput | SortOrder
    isEscrowDiscount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DduClientContractPropertiesCountOrderByAggregateInput
    _avg?: DduClientContractPropertiesAvgOrderByAggregateInput
    _max?: DduClientContractPropertiesMaxOrderByAggregateInput
    _min?: DduClientContractPropertiesMinOrderByAggregateInput
    _sum?: DduClientContractPropertiesSumOrderByAggregateInput
  }

  export type DduClientContractPropertiesScalarWhereWithAggregatesInput = {
    AND?: DduClientContractPropertiesScalarWhereWithAggregatesInput | DduClientContractPropertiesScalarWhereWithAggregatesInput[]
    OR?: DduClientContractPropertiesScalarWhereWithAggregatesInput[]
    NOT?: DduClientContractPropertiesScalarWhereWithAggregatesInput | DduClientContractPropertiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DduClientContractProperties"> | number
    dduLink?: StringNullableWithAggregatesFilter<"DduClientContractProperties"> | string | null
    returnAccount?: StringNullableWithAggregatesFilter<"DduClientContractProperties"> | string | null
    escrowAccountOpeningDate?: DateTimeNullableWithAggregatesFilter<"DduClientContractProperties"> | Date | string | null
    escrowPeriod?: DateTimeNullableWithAggregatesFilter<"DduClientContractProperties"> | Date | string | null
    escrowAccountNumber?: StringNullableWithAggregatesFilter<"DduClientContractProperties"> | string | null
    isEscrowDiscount?: BoolNullableWithAggregatesFilter<"DduClientContractProperties"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"DduClientContractProperties"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DduClientContractProperties"> | Date | string
  }

  export type DkpClientContractPropertiesWhereInput = {
    AND?: DkpClientContractPropertiesWhereInput | DkpClientContractPropertiesWhereInput[]
    OR?: DkpClientContractPropertiesWhereInput[]
    NOT?: DkpClientContractPropertiesWhereInput | DkpClientContractPropertiesWhereInput[]
    id?: IntFilter<"DkpClientContractProperties"> | number
    dkpLink?: StringNullableFilter<"DkpClientContractProperties"> | string | null
    createdAt?: DateTimeFilter<"DkpClientContractProperties"> | Date | string
    updatedAt?: DateTimeFilter<"DkpClientContractProperties"> | Date | string
    clientContract?: XOR<ClientContractNullableRelationFilter, ClientContractWhereInput> | null
  }

  export type DkpClientContractPropertiesOrderByWithRelationInput = {
    id?: SortOrder
    dkpLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientContract?: ClientContractOrderByWithRelationInput
  }

  export type DkpClientContractPropertiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DkpClientContractPropertiesWhereInput | DkpClientContractPropertiesWhereInput[]
    OR?: DkpClientContractPropertiesWhereInput[]
    NOT?: DkpClientContractPropertiesWhereInput | DkpClientContractPropertiesWhereInput[]
    dkpLink?: StringNullableFilter<"DkpClientContractProperties"> | string | null
    createdAt?: DateTimeFilter<"DkpClientContractProperties"> | Date | string
    updatedAt?: DateTimeFilter<"DkpClientContractProperties"> | Date | string
    clientContract?: XOR<ClientContractNullableRelationFilter, ClientContractWhereInput> | null
  }, "id">

  export type DkpClientContractPropertiesOrderByWithAggregationInput = {
    id?: SortOrder
    dkpLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DkpClientContractPropertiesCountOrderByAggregateInput
    _avg?: DkpClientContractPropertiesAvgOrderByAggregateInput
    _max?: DkpClientContractPropertiesMaxOrderByAggregateInput
    _min?: DkpClientContractPropertiesMinOrderByAggregateInput
    _sum?: DkpClientContractPropertiesSumOrderByAggregateInput
  }

  export type DkpClientContractPropertiesScalarWhereWithAggregatesInput = {
    AND?: DkpClientContractPropertiesScalarWhereWithAggregatesInput | DkpClientContractPropertiesScalarWhereWithAggregatesInput[]
    OR?: DkpClientContractPropertiesScalarWhereWithAggregatesInput[]
    NOT?: DkpClientContractPropertiesScalarWhereWithAggregatesInput | DkpClientContractPropertiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DkpClientContractProperties"> | number
    dkpLink?: StringNullableWithAggregatesFilter<"DkpClientContractProperties"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DkpClientContractProperties"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DkpClientContractProperties"> | Date | string
  }

  export type ClientContractToAgencyContractWhereInput = {
    AND?: ClientContractToAgencyContractWhereInput | ClientContractToAgencyContractWhereInput[]
    OR?: ClientContractToAgencyContractWhereInput[]
    NOT?: ClientContractToAgencyContractWhereInput | ClientContractToAgencyContractWhereInput[]
    clientContractId?: IntFilter<"ClientContractToAgencyContract"> | number
    agencyContractId?: IntFilter<"ClientContractToAgencyContract"> | number
    createdAt?: DateTimeFilter<"ClientContractToAgencyContract"> | Date | string
    updatedAt?: DateTimeFilter<"ClientContractToAgencyContract"> | Date | string
    clientContract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
    agencyContract?: XOR<AgencyContractRelationFilter, AgencyContractWhereInput>
  }

  export type ClientContractToAgencyContractOrderByWithRelationInput = {
    clientContractId?: SortOrder
    agencyContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientContract?: ClientContractOrderByWithRelationInput
    agencyContract?: AgencyContractOrderByWithRelationInput
  }

  export type ClientContractToAgencyContractWhereUniqueInput = Prisma.AtLeast<{
    clientContractId_agencyContractId?: ClientContractToAgencyContractClientContractIdAgencyContractIdCompoundUniqueInput
    AND?: ClientContractToAgencyContractWhereInput | ClientContractToAgencyContractWhereInput[]
    OR?: ClientContractToAgencyContractWhereInput[]
    NOT?: ClientContractToAgencyContractWhereInput | ClientContractToAgencyContractWhereInput[]
    clientContractId?: IntFilter<"ClientContractToAgencyContract"> | number
    agencyContractId?: IntFilter<"ClientContractToAgencyContract"> | number
    createdAt?: DateTimeFilter<"ClientContractToAgencyContract"> | Date | string
    updatedAt?: DateTimeFilter<"ClientContractToAgencyContract"> | Date | string
    clientContract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
    agencyContract?: XOR<AgencyContractRelationFilter, AgencyContractWhereInput>
  }, "clientContractId_agencyContractId">

  export type ClientContractToAgencyContractOrderByWithAggregationInput = {
    clientContractId?: SortOrder
    agencyContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientContractToAgencyContractCountOrderByAggregateInput
    _avg?: ClientContractToAgencyContractAvgOrderByAggregateInput
    _max?: ClientContractToAgencyContractMaxOrderByAggregateInput
    _min?: ClientContractToAgencyContractMinOrderByAggregateInput
    _sum?: ClientContractToAgencyContractSumOrderByAggregateInput
  }

  export type ClientContractToAgencyContractScalarWhereWithAggregatesInput = {
    AND?: ClientContractToAgencyContractScalarWhereWithAggregatesInput | ClientContractToAgencyContractScalarWhereWithAggregatesInput[]
    OR?: ClientContractToAgencyContractScalarWhereWithAggregatesInput[]
    NOT?: ClientContractToAgencyContractScalarWhereWithAggregatesInput | ClientContractToAgencyContractScalarWhereWithAggregatesInput[]
    clientContractId?: IntWithAggregatesFilter<"ClientContractToAgencyContract"> | number
    agencyContractId?: IntWithAggregatesFilter<"ClientContractToAgencyContract"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ClientContractToAgencyContract"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientContractToAgencyContract"> | Date | string
  }

  export type ClientContractToClientWhereInput = {
    AND?: ClientContractToClientWhereInput | ClientContractToClientWhereInput[]
    OR?: ClientContractToClientWhereInput[]
    NOT?: ClientContractToClientWhereInput | ClientContractToClientWhereInput[]
    isMain?: BoolFilter<"ClientContractToClient"> | boolean
    share?: IntFilter<"ClientContractToClient"> | number
    clientContractId?: IntFilter<"ClientContractToClient"> | number
    clientId?: IntFilter<"ClientContractToClient"> | number
    createdAt?: DateTimeFilter<"ClientContractToClient"> | Date | string
    updatedAt?: DateTimeFilter<"ClientContractToClient"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    clientContract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
  }

  export type ClientContractToClientOrderByWithRelationInput = {
    isMain?: SortOrder
    share?: SortOrder
    clientContractId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    clientContract?: ClientContractOrderByWithRelationInput
  }

  export type ClientContractToClientWhereUniqueInput = Prisma.AtLeast<{
    clientContractId_clientId?: ClientContractToClientClientContractIdClientIdCompoundUniqueInput
    AND?: ClientContractToClientWhereInput | ClientContractToClientWhereInput[]
    OR?: ClientContractToClientWhereInput[]
    NOT?: ClientContractToClientWhereInput | ClientContractToClientWhereInput[]
    isMain?: BoolFilter<"ClientContractToClient"> | boolean
    share?: IntFilter<"ClientContractToClient"> | number
    clientContractId?: IntFilter<"ClientContractToClient"> | number
    clientId?: IntFilter<"ClientContractToClient"> | number
    createdAt?: DateTimeFilter<"ClientContractToClient"> | Date | string
    updatedAt?: DateTimeFilter<"ClientContractToClient"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    clientContract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
  }, "clientContractId_clientId">

  export type ClientContractToClientOrderByWithAggregationInput = {
    isMain?: SortOrder
    share?: SortOrder
    clientContractId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientContractToClientCountOrderByAggregateInput
    _avg?: ClientContractToClientAvgOrderByAggregateInput
    _max?: ClientContractToClientMaxOrderByAggregateInput
    _min?: ClientContractToClientMinOrderByAggregateInput
    _sum?: ClientContractToClientSumOrderByAggregateInput
  }

  export type ClientContractToClientScalarWhereWithAggregatesInput = {
    AND?: ClientContractToClientScalarWhereWithAggregatesInput | ClientContractToClientScalarWhereWithAggregatesInput[]
    OR?: ClientContractToClientScalarWhereWithAggregatesInput[]
    NOT?: ClientContractToClientScalarWhereWithAggregatesInput | ClientContractToClientScalarWhereWithAggregatesInput[]
    isMain?: BoolWithAggregatesFilter<"ClientContractToClient"> | boolean
    share?: IntWithAggregatesFilter<"ClientContractToClient"> | number
    clientContractId?: IntWithAggregatesFilter<"ClientContractToClient"> | number
    clientId?: IntWithAggregatesFilter<"ClientContractToClient"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ClientContractToClient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientContractToClient"> | Date | string
  }

  export type ScheduledPaymentWhereInput = {
    AND?: ScheduledPaymentWhereInput | ScheduledPaymentWhereInput[]
    OR?: ScheduledPaymentWhereInput[]
    NOT?: ScheduledPaymentWhereInput | ScheduledPaymentWhereInput[]
    id?: IntFilter<"ScheduledPayment"> | number
    payment?: DecimalFilter<"ScheduledPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"ScheduledPayment"> | Date | string
    scheduledPaymentType?: EnumScheduledPaymentTypeFilter<"ScheduledPayment"> | $Enums.ScheduledPaymentType
    clientContractId?: IntFilter<"ScheduledPayment"> | number
    createdAt?: DateTimeFilter<"ScheduledPayment"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledPayment"> | Date | string
    clientContract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
  }

  export type ScheduledPaymentOrderByWithRelationInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    scheduledPaymentType?: SortOrder
    clientContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientContract?: ClientContractOrderByWithRelationInput
  }

  export type ScheduledPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ScheduledPaymentWhereInput | ScheduledPaymentWhereInput[]
    OR?: ScheduledPaymentWhereInput[]
    NOT?: ScheduledPaymentWhereInput | ScheduledPaymentWhereInput[]
    payment?: DecimalFilter<"ScheduledPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"ScheduledPayment"> | Date | string
    scheduledPaymentType?: EnumScheduledPaymentTypeFilter<"ScheduledPayment"> | $Enums.ScheduledPaymentType
    clientContractId?: IntFilter<"ScheduledPayment"> | number
    createdAt?: DateTimeFilter<"ScheduledPayment"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledPayment"> | Date | string
    clientContract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
  }, "id">

  export type ScheduledPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    scheduledPaymentType?: SortOrder
    clientContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduledPaymentCountOrderByAggregateInput
    _avg?: ScheduledPaymentAvgOrderByAggregateInput
    _max?: ScheduledPaymentMaxOrderByAggregateInput
    _min?: ScheduledPaymentMinOrderByAggregateInput
    _sum?: ScheduledPaymentSumOrderByAggregateInput
  }

  export type ScheduledPaymentScalarWhereWithAggregatesInput = {
    AND?: ScheduledPaymentScalarWhereWithAggregatesInput | ScheduledPaymentScalarWhereWithAggregatesInput[]
    OR?: ScheduledPaymentScalarWhereWithAggregatesInput[]
    NOT?: ScheduledPaymentScalarWhereWithAggregatesInput | ScheduledPaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ScheduledPayment"> | number
    payment?: DecimalWithAggregatesFilter<"ScheduledPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeWithAggregatesFilter<"ScheduledPayment"> | Date | string
    scheduledPaymentType?: EnumScheduledPaymentTypeWithAggregatesFilter<"ScheduledPayment"> | $Enums.ScheduledPaymentType
    clientContractId?: IntWithAggregatesFilter<"ScheduledPayment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ScheduledPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduledPayment"> | Date | string
  }

  export type ActualPaymentWhereInput = {
    AND?: ActualPaymentWhereInput | ActualPaymentWhereInput[]
    OR?: ActualPaymentWhereInput[]
    NOT?: ActualPaymentWhereInput | ActualPaymentWhereInput[]
    id?: IntFilter<"ActualPayment"> | number
    payment?: DecimalFilter<"ActualPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"ActualPayment"> | Date | string
    clientContractId?: IntFilter<"ActualPayment"> | number
    createdAt?: DateTimeFilter<"ActualPayment"> | Date | string
    updatedAt?: DateTimeFilter<"ActualPayment"> | Date | string
    clientContract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
  }

  export type ActualPaymentOrderByWithRelationInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    clientContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientContract?: ClientContractOrderByWithRelationInput
  }

  export type ActualPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ActualPaymentWhereInput | ActualPaymentWhereInput[]
    OR?: ActualPaymentWhereInput[]
    NOT?: ActualPaymentWhereInput | ActualPaymentWhereInput[]
    payment?: DecimalFilter<"ActualPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"ActualPayment"> | Date | string
    clientContractId?: IntFilter<"ActualPayment"> | number
    createdAt?: DateTimeFilter<"ActualPayment"> | Date | string
    updatedAt?: DateTimeFilter<"ActualPayment"> | Date | string
    clientContract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
  }, "id">

  export type ActualPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    clientContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActualPaymentCountOrderByAggregateInput
    _avg?: ActualPaymentAvgOrderByAggregateInput
    _max?: ActualPaymentMaxOrderByAggregateInput
    _min?: ActualPaymentMinOrderByAggregateInput
    _sum?: ActualPaymentSumOrderByAggregateInput
  }

  export type ActualPaymentScalarWhereWithAggregatesInput = {
    AND?: ActualPaymentScalarWhereWithAggregatesInput | ActualPaymentScalarWhereWithAggregatesInput[]
    OR?: ActualPaymentScalarWhereWithAggregatesInput[]
    NOT?: ActualPaymentScalarWhereWithAggregatesInput | ActualPaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActualPayment"> | number
    payment?: DecimalWithAggregatesFilter<"ActualPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeWithAggregatesFilter<"ActualPayment"> | Date | string
    clientContractId?: IntWithAggregatesFilter<"ActualPayment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ActualPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ActualPayment"> | Date | string
  }

  export type ObjectWhereInput = {
    AND?: ObjectWhereInput | ObjectWhereInput[]
    OR?: ObjectWhereInput[]
    NOT?: ObjectWhereInput | ObjectWhereInput[]
    id?: IntFilter<"Object"> | number
    commonDbObjectsId?: IntFilter<"Object"> | number
    name?: StringFilter<"Object"> | string
    dateIn?: DateTimeNullableFilter<"Object"> | Date | string | null
    entityId?: IntFilter<"Object"> | number
    createdAt?: DateTimeFilter<"Object"> | Date | string
    updatedAt?: DateTimeFilter<"Object"> | Date | string
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
    products?: ProductListRelationFilter
    clientContracts?: ClientContractListRelationFilter
    agencyContracts?: AgencyContractListRelationFilter
    transferActs?: TransferActListRelationFilter
  }

  export type ObjectOrderByWithRelationInput = {
    id?: SortOrder
    commonDbObjectsId?: SortOrder
    name?: SortOrder
    dateIn?: SortOrderInput | SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    entity?: EntityOrderByWithRelationInput
    products?: ProductOrderByRelationAggregateInput
    clientContracts?: ClientContractOrderByRelationAggregateInput
    agencyContracts?: AgencyContractOrderByRelationAggregateInput
    transferActs?: TransferActOrderByRelationAggregateInput
  }

  export type ObjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    commonDbObjectsId?: number
    AND?: ObjectWhereInput | ObjectWhereInput[]
    OR?: ObjectWhereInput[]
    NOT?: ObjectWhereInput | ObjectWhereInput[]
    name?: StringFilter<"Object"> | string
    dateIn?: DateTimeNullableFilter<"Object"> | Date | string | null
    entityId?: IntFilter<"Object"> | number
    createdAt?: DateTimeFilter<"Object"> | Date | string
    updatedAt?: DateTimeFilter<"Object"> | Date | string
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
    products?: ProductListRelationFilter
    clientContracts?: ClientContractListRelationFilter
    agencyContracts?: AgencyContractListRelationFilter
    transferActs?: TransferActListRelationFilter
  }, "id" | "commonDbObjectsId">

  export type ObjectOrderByWithAggregationInput = {
    id?: SortOrder
    commonDbObjectsId?: SortOrder
    name?: SortOrder
    dateIn?: SortOrderInput | SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ObjectCountOrderByAggregateInput
    _avg?: ObjectAvgOrderByAggregateInput
    _max?: ObjectMaxOrderByAggregateInput
    _min?: ObjectMinOrderByAggregateInput
    _sum?: ObjectSumOrderByAggregateInput
  }

  export type ObjectScalarWhereWithAggregatesInput = {
    AND?: ObjectScalarWhereWithAggregatesInput | ObjectScalarWhereWithAggregatesInput[]
    OR?: ObjectScalarWhereWithAggregatesInput[]
    NOT?: ObjectScalarWhereWithAggregatesInput | ObjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Object"> | number
    commonDbObjectsId?: IntWithAggregatesFilter<"Object"> | number
    name?: StringWithAggregatesFilter<"Object"> | string
    dateIn?: DateTimeNullableWithAggregatesFilter<"Object"> | Date | string | null
    entityId?: IntWithAggregatesFilter<"Object"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Object"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Object"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    pricingProductsId?: IntFilter<"Product"> | number
    number?: StringFilter<"Product"> | string
    productCategory?: EnumProductCategoryFilter<"Product"> | $Enums.ProductCategory
    objectId?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    transferAct?: XOR<TransferActNullableRelationFilter, TransferActWhereInput> | null
    clientContract?: XOR<ClientContractNullableRelationFilter, ClientContractWhereInput> | null
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    pricingProductsId?: SortOrder
    number?: SortOrder
    productCategory?: SortOrder
    objectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transferAct?: TransferActOrderByWithRelationInput
    clientContract?: ClientContractOrderByWithRelationInput
    object?: ObjectOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    pricingProductsId?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    number?: StringFilter<"Product"> | string
    productCategory?: EnumProductCategoryFilter<"Product"> | $Enums.ProductCategory
    objectId?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    transferAct?: XOR<TransferActNullableRelationFilter, TransferActWhereInput> | null
    clientContract?: XOR<ClientContractNullableRelationFilter, ClientContractWhereInput> | null
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
  }, "id" | "pricingProductsId">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    pricingProductsId?: SortOrder
    number?: SortOrder
    productCategory?: SortOrder
    objectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    pricingProductsId?: IntWithAggregatesFilter<"Product"> | number
    number?: StringWithAggregatesFilter<"Product"> | string
    productCategory?: EnumProductCategoryWithAggregatesFilter<"Product"> | $Enums.ProductCategory
    objectId?: IntWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type AgencyWhereInput = {
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    id?: IntFilter<"Agency"> | number
    commonDbContractorsId?: IntFilter<"Agency"> | number
    name?: StringFilter<"Agency"> | string
    inn?: StringNullableFilter<"Agency"> | string | null
    createdAt?: DateTimeFilter<"Agency"> | Date | string
    updatedAt?: DateTimeFilter<"Agency"> | Date | string
    agencyContracts?: AgencyContractListRelationFilter
    agencyContractSignatory?: AgencyContractSignatoryListRelationFilter
    realEstateAgencyActs?: RealEstateAgencyActListRelationFilter
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentListRelationFilter
  }

  export type AgencyOrderByWithRelationInput = {
    id?: SortOrder
    commonDbContractorsId?: SortOrder
    name?: SortOrder
    inn?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agencyContracts?: AgencyContractOrderByRelationAggregateInput
    agencyContractSignatory?: AgencyContractSignatoryOrderByRelationAggregateInput
    realEstateAgencyActs?: RealEstateAgencyActOrderByRelationAggregateInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentOrderByRelationAggregateInput
  }

  export type AgencyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    commonDbContractorsId?: number
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    name?: StringFilter<"Agency"> | string
    inn?: StringNullableFilter<"Agency"> | string | null
    createdAt?: DateTimeFilter<"Agency"> | Date | string
    updatedAt?: DateTimeFilter<"Agency"> | Date | string
    agencyContracts?: AgencyContractListRelationFilter
    agencyContractSignatory?: AgencyContractSignatoryListRelationFilter
    realEstateAgencyActs?: RealEstateAgencyActListRelationFilter
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentListRelationFilter
  }, "id" | "commonDbContractorsId">

  export type AgencyOrderByWithAggregationInput = {
    id?: SortOrder
    commonDbContractorsId?: SortOrder
    name?: SortOrder
    inn?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgencyCountOrderByAggregateInput
    _avg?: AgencyAvgOrderByAggregateInput
    _max?: AgencyMaxOrderByAggregateInput
    _min?: AgencyMinOrderByAggregateInput
    _sum?: AgencySumOrderByAggregateInput
  }

  export type AgencyScalarWhereWithAggregatesInput = {
    AND?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    OR?: AgencyScalarWhereWithAggregatesInput[]
    NOT?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Agency"> | number
    commonDbContractorsId?: IntWithAggregatesFilter<"Agency"> | number
    name?: StringWithAggregatesFilter<"Agency"> | string
    inn?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
  }

  export type AgencyContractWhereInput = {
    AND?: AgencyContractWhereInput | AgencyContractWhereInput[]
    OR?: AgencyContractWhereInput[]
    NOT?: AgencyContractWhereInput | AgencyContractWhereInput[]
    id?: IntFilter<"AgencyContract"> | number
    number?: StringFilter<"AgencyContract"> | string
    date?: DateTimeFilter<"AgencyContract"> | Date | string
    agencyContractType?: EnumAgencyContractTypeFilter<"AgencyContract"> | $Enums.AgencyContractType
    link?: StringNullableFilter<"AgencyContract"> | string | null
    responsibleUserId?: IntNullableFilter<"AgencyContract"> | number | null
    entityId?: IntFilter<"AgencyContract"> | number
    objectId?: IntFilter<"AgencyContract"> | number
    agencyId?: IntFilter<"AgencyContract"> | number
    agencyContractSignatoryId?: IntNullableFilter<"AgencyContract"> | number | null
    realEstateAgencyContractPropertiesId?: IntNullableFilter<"AgencyContract"> | number | null
    mipAgencyContractPropertiesId?: IntNullableFilter<"AgencyContract"> | number | null
    createdAt?: DateTimeFilter<"AgencyContract"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyContract"> | Date | string
    responsibleUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
    agency?: XOR<AgencyRelationFilter, AgencyWhereInput>
    agencyContractSignatory?: XOR<AgencyContractSignatoryNullableRelationFilter, AgencyContractSignatoryWhereInput> | null
    realEstateAgencyContractProperties?: XOR<RealEstateAgencyContractPropertiesNullableRelationFilter, RealEstateAgencyContractPropertiesWhereInput> | null
    mipAgencyContractProperties?: XOR<MipAgencyContractPropertiesNullableRelationFilter, MipAgencyContractPropertiesWhereInput> | null
    realEstateAgencyAct?: RealEstateAgencyActListRelationFilter
    clientContractsToAgencyContracts?: ClientContractToAgencyContractListRelationFilter
  }

  export type AgencyContractOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    agencyContractType?: SortOrder
    link?: SortOrderInput | SortOrder
    responsibleUserId?: SortOrderInput | SortOrder
    entityId?: SortOrder
    objectId?: SortOrder
    agencyId?: SortOrder
    agencyContractSignatoryId?: SortOrderInput | SortOrder
    realEstateAgencyContractPropertiesId?: SortOrderInput | SortOrder
    mipAgencyContractPropertiesId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    responsibleUser?: UserOrderByWithRelationInput
    entity?: EntityOrderByWithRelationInput
    object?: ObjectOrderByWithRelationInput
    agency?: AgencyOrderByWithRelationInput
    agencyContractSignatory?: AgencyContractSignatoryOrderByWithRelationInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesOrderByWithRelationInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesOrderByWithRelationInput
    realEstateAgencyAct?: RealEstateAgencyActOrderByRelationAggregateInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractOrderByRelationAggregateInput
  }

  export type AgencyContractWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    realEstateAgencyContractPropertiesId?: number
    mipAgencyContractPropertiesId?: number
    AND?: AgencyContractWhereInput | AgencyContractWhereInput[]
    OR?: AgencyContractWhereInput[]
    NOT?: AgencyContractWhereInput | AgencyContractWhereInput[]
    number?: StringFilter<"AgencyContract"> | string
    date?: DateTimeFilter<"AgencyContract"> | Date | string
    agencyContractType?: EnumAgencyContractTypeFilter<"AgencyContract"> | $Enums.AgencyContractType
    link?: StringNullableFilter<"AgencyContract"> | string | null
    responsibleUserId?: IntNullableFilter<"AgencyContract"> | number | null
    entityId?: IntFilter<"AgencyContract"> | number
    objectId?: IntFilter<"AgencyContract"> | number
    agencyId?: IntFilter<"AgencyContract"> | number
    agencyContractSignatoryId?: IntNullableFilter<"AgencyContract"> | number | null
    createdAt?: DateTimeFilter<"AgencyContract"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyContract"> | Date | string
    responsibleUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
    agency?: XOR<AgencyRelationFilter, AgencyWhereInput>
    agencyContractSignatory?: XOR<AgencyContractSignatoryNullableRelationFilter, AgencyContractSignatoryWhereInput> | null
    realEstateAgencyContractProperties?: XOR<RealEstateAgencyContractPropertiesNullableRelationFilter, RealEstateAgencyContractPropertiesWhereInput> | null
    mipAgencyContractProperties?: XOR<MipAgencyContractPropertiesNullableRelationFilter, MipAgencyContractPropertiesWhereInput> | null
    realEstateAgencyAct?: RealEstateAgencyActListRelationFilter
    clientContractsToAgencyContracts?: ClientContractToAgencyContractListRelationFilter
  }, "id" | "realEstateAgencyContractPropertiesId" | "mipAgencyContractPropertiesId">

  export type AgencyContractOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    agencyContractType?: SortOrder
    link?: SortOrderInput | SortOrder
    responsibleUserId?: SortOrderInput | SortOrder
    entityId?: SortOrder
    objectId?: SortOrder
    agencyId?: SortOrder
    agencyContractSignatoryId?: SortOrderInput | SortOrder
    realEstateAgencyContractPropertiesId?: SortOrderInput | SortOrder
    mipAgencyContractPropertiesId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgencyContractCountOrderByAggregateInput
    _avg?: AgencyContractAvgOrderByAggregateInput
    _max?: AgencyContractMaxOrderByAggregateInput
    _min?: AgencyContractMinOrderByAggregateInput
    _sum?: AgencyContractSumOrderByAggregateInput
  }

  export type AgencyContractScalarWhereWithAggregatesInput = {
    AND?: AgencyContractScalarWhereWithAggregatesInput | AgencyContractScalarWhereWithAggregatesInput[]
    OR?: AgencyContractScalarWhereWithAggregatesInput[]
    NOT?: AgencyContractScalarWhereWithAggregatesInput | AgencyContractScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AgencyContract"> | number
    number?: StringWithAggregatesFilter<"AgencyContract"> | string
    date?: DateTimeWithAggregatesFilter<"AgencyContract"> | Date | string
    agencyContractType?: EnumAgencyContractTypeWithAggregatesFilter<"AgencyContract"> | $Enums.AgencyContractType
    link?: StringNullableWithAggregatesFilter<"AgencyContract"> | string | null
    responsibleUserId?: IntNullableWithAggregatesFilter<"AgencyContract"> | number | null
    entityId?: IntWithAggregatesFilter<"AgencyContract"> | number
    objectId?: IntWithAggregatesFilter<"AgencyContract"> | number
    agencyId?: IntWithAggregatesFilter<"AgencyContract"> | number
    agencyContractSignatoryId?: IntNullableWithAggregatesFilter<"AgencyContract"> | number | null
    realEstateAgencyContractPropertiesId?: IntNullableWithAggregatesFilter<"AgencyContract"> | number | null
    mipAgencyContractPropertiesId?: IntNullableWithAggregatesFilter<"AgencyContract"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AgencyContract"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgencyContract"> | Date | string
  }

  export type AgencyContractSignatoryWhereInput = {
    AND?: AgencyContractSignatoryWhereInput | AgencyContractSignatoryWhereInput[]
    OR?: AgencyContractSignatoryWhereInput[]
    NOT?: AgencyContractSignatoryWhereInput | AgencyContractSignatoryWhereInput[]
    id?: IntFilter<"AgencyContractSignatory"> | number
    fullName?: StringFilter<"AgencyContractSignatory"> | string
    basedOn?: StringNullableFilter<"AgencyContractSignatory"> | string | null
    title?: StringNullableFilter<"AgencyContractSignatory"> | string | null
    agencyId?: IntFilter<"AgencyContractSignatory"> | number
    createdAt?: DateTimeFilter<"AgencyContractSignatory"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyContractSignatory"> | Date | string
    agency?: XOR<AgencyRelationFilter, AgencyWhereInput>
    agencyContracts?: AgencyContractListRelationFilter
  }

  export type AgencyContractSignatoryOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    basedOn?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agency?: AgencyOrderByWithRelationInput
    agencyContracts?: AgencyContractOrderByRelationAggregateInput
  }

  export type AgencyContractSignatoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AgencyContractSignatoryWhereInput | AgencyContractSignatoryWhereInput[]
    OR?: AgencyContractSignatoryWhereInput[]
    NOT?: AgencyContractSignatoryWhereInput | AgencyContractSignatoryWhereInput[]
    fullName?: StringFilter<"AgencyContractSignatory"> | string
    basedOn?: StringNullableFilter<"AgencyContractSignatory"> | string | null
    title?: StringNullableFilter<"AgencyContractSignatory"> | string | null
    agencyId?: IntFilter<"AgencyContractSignatory"> | number
    createdAt?: DateTimeFilter<"AgencyContractSignatory"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyContractSignatory"> | Date | string
    agency?: XOR<AgencyRelationFilter, AgencyWhereInput>
    agencyContracts?: AgencyContractListRelationFilter
  }, "id">

  export type AgencyContractSignatoryOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    basedOn?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgencyContractSignatoryCountOrderByAggregateInput
    _avg?: AgencyContractSignatoryAvgOrderByAggregateInput
    _max?: AgencyContractSignatoryMaxOrderByAggregateInput
    _min?: AgencyContractSignatoryMinOrderByAggregateInput
    _sum?: AgencyContractSignatorySumOrderByAggregateInput
  }

  export type AgencyContractSignatoryScalarWhereWithAggregatesInput = {
    AND?: AgencyContractSignatoryScalarWhereWithAggregatesInput | AgencyContractSignatoryScalarWhereWithAggregatesInput[]
    OR?: AgencyContractSignatoryScalarWhereWithAggregatesInput[]
    NOT?: AgencyContractSignatoryScalarWhereWithAggregatesInput | AgencyContractSignatoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AgencyContractSignatory"> | number
    fullName?: StringWithAggregatesFilter<"AgencyContractSignatory"> | string
    basedOn?: StringNullableWithAggregatesFilter<"AgencyContractSignatory"> | string | null
    title?: StringNullableWithAggregatesFilter<"AgencyContractSignatory"> | string | null
    agencyId?: IntWithAggregatesFilter<"AgencyContractSignatory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AgencyContractSignatory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgencyContractSignatory"> | Date | string
  }

  export type RealEstateAgencyContractPropertiesWhereInput = {
    AND?: RealEstateAgencyContractPropertiesWhereInput | RealEstateAgencyContractPropertiesWhereInput[]
    OR?: RealEstateAgencyContractPropertiesWhereInput[]
    NOT?: RealEstateAgencyContractPropertiesWhereInput | RealEstateAgencyContractPropertiesWhereInput[]
    id?: IntFilter<"RealEstateAgencyContractProperties"> | number
    agencyContractCommissionId?: IntFilter<"RealEstateAgencyContractProperties"> | number
    createdAt?: DateTimeFilter<"RealEstateAgencyContractProperties"> | Date | string
    updatedAt?: DateTimeFilter<"RealEstateAgencyContractProperties"> | Date | string
    agencyContract?: XOR<AgencyContractNullableRelationFilter, AgencyContractWhereInput> | null
    agencyContractCommission?: XOR<AgencyContractCommissionRelationFilter, AgencyContractCommissionWhereInput>
  }

  export type RealEstateAgencyContractPropertiesOrderByWithRelationInput = {
    id?: SortOrder
    agencyContractCommissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agencyContract?: AgencyContractOrderByWithRelationInput
    agencyContractCommission?: AgencyContractCommissionOrderByWithRelationInput
  }

  export type RealEstateAgencyContractPropertiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    agencyContractCommissionId?: number
    AND?: RealEstateAgencyContractPropertiesWhereInput | RealEstateAgencyContractPropertiesWhereInput[]
    OR?: RealEstateAgencyContractPropertiesWhereInput[]
    NOT?: RealEstateAgencyContractPropertiesWhereInput | RealEstateAgencyContractPropertiesWhereInput[]
    createdAt?: DateTimeFilter<"RealEstateAgencyContractProperties"> | Date | string
    updatedAt?: DateTimeFilter<"RealEstateAgencyContractProperties"> | Date | string
    agencyContract?: XOR<AgencyContractNullableRelationFilter, AgencyContractWhereInput> | null
    agencyContractCommission?: XOR<AgencyContractCommissionRelationFilter, AgencyContractCommissionWhereInput>
  }, "id" | "agencyContractCommissionId">

  export type RealEstateAgencyContractPropertiesOrderByWithAggregationInput = {
    id?: SortOrder
    agencyContractCommissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RealEstateAgencyContractPropertiesCountOrderByAggregateInput
    _avg?: RealEstateAgencyContractPropertiesAvgOrderByAggregateInput
    _max?: RealEstateAgencyContractPropertiesMaxOrderByAggregateInput
    _min?: RealEstateAgencyContractPropertiesMinOrderByAggregateInput
    _sum?: RealEstateAgencyContractPropertiesSumOrderByAggregateInput
  }

  export type RealEstateAgencyContractPropertiesScalarWhereWithAggregatesInput = {
    AND?: RealEstateAgencyContractPropertiesScalarWhereWithAggregatesInput | RealEstateAgencyContractPropertiesScalarWhereWithAggregatesInput[]
    OR?: RealEstateAgencyContractPropertiesScalarWhereWithAggregatesInput[]
    NOT?: RealEstateAgencyContractPropertiesScalarWhereWithAggregatesInput | RealEstateAgencyContractPropertiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RealEstateAgencyContractProperties"> | number
    agencyContractCommissionId?: IntWithAggregatesFilter<"RealEstateAgencyContractProperties"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RealEstateAgencyContractProperties"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RealEstateAgencyContractProperties"> | Date | string
  }

  export type MipAgencyContractPropertiesWhereInput = {
    AND?: MipAgencyContractPropertiesWhereInput | MipAgencyContractPropertiesWhereInput[]
    OR?: MipAgencyContractPropertiesWhereInput[]
    NOT?: MipAgencyContractPropertiesWhereInput | MipAgencyContractPropertiesWhereInput[]
    id?: IntFilter<"MipAgencyContractProperties"> | number
    agencyContractCommissionId?: IntFilter<"MipAgencyContractProperties"> | number
    createdAt?: DateTimeFilter<"MipAgencyContractProperties"> | Date | string
    updatedAt?: DateTimeFilter<"MipAgencyContractProperties"> | Date | string
    agencyContract?: XOR<AgencyContractNullableRelationFilter, AgencyContractWhereInput> | null
    agencyContractCommission?: XOR<AgencyContractCommissionRelationFilter, AgencyContractCommissionWhereInput>
  }

  export type MipAgencyContractPropertiesOrderByWithRelationInput = {
    id?: SortOrder
    agencyContractCommissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agencyContract?: AgencyContractOrderByWithRelationInput
    agencyContractCommission?: AgencyContractCommissionOrderByWithRelationInput
  }

  export type MipAgencyContractPropertiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    agencyContractCommissionId?: number
    AND?: MipAgencyContractPropertiesWhereInput | MipAgencyContractPropertiesWhereInput[]
    OR?: MipAgencyContractPropertiesWhereInput[]
    NOT?: MipAgencyContractPropertiesWhereInput | MipAgencyContractPropertiesWhereInput[]
    createdAt?: DateTimeFilter<"MipAgencyContractProperties"> | Date | string
    updatedAt?: DateTimeFilter<"MipAgencyContractProperties"> | Date | string
    agencyContract?: XOR<AgencyContractNullableRelationFilter, AgencyContractWhereInput> | null
    agencyContractCommission?: XOR<AgencyContractCommissionRelationFilter, AgencyContractCommissionWhereInput>
  }, "id" | "agencyContractCommissionId">

  export type MipAgencyContractPropertiesOrderByWithAggregationInput = {
    id?: SortOrder
    agencyContractCommissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MipAgencyContractPropertiesCountOrderByAggregateInput
    _avg?: MipAgencyContractPropertiesAvgOrderByAggregateInput
    _max?: MipAgencyContractPropertiesMaxOrderByAggregateInput
    _min?: MipAgencyContractPropertiesMinOrderByAggregateInput
    _sum?: MipAgencyContractPropertiesSumOrderByAggregateInput
  }

  export type MipAgencyContractPropertiesScalarWhereWithAggregatesInput = {
    AND?: MipAgencyContractPropertiesScalarWhereWithAggregatesInput | MipAgencyContractPropertiesScalarWhereWithAggregatesInput[]
    OR?: MipAgencyContractPropertiesScalarWhereWithAggregatesInput[]
    NOT?: MipAgencyContractPropertiesScalarWhereWithAggregatesInput | MipAgencyContractPropertiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MipAgencyContractProperties"> | number
    agencyContractCommissionId?: IntWithAggregatesFilter<"MipAgencyContractProperties"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MipAgencyContractProperties"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MipAgencyContractProperties"> | Date | string
  }

  export type AgencyContractCommissionWhereInput = {
    AND?: AgencyContractCommissionWhereInput | AgencyContractCommissionWhereInput[]
    OR?: AgencyContractCommissionWhereInput[]
    NOT?: AgencyContractCommissionWhereInput | AgencyContractCommissionWhereInput[]
    id?: IntFilter<"AgencyContractCommission"> | number
    percent?: DecimalFilter<"AgencyContractCommission"> | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFilter<"AgencyContractCommission"> | Decimal | DecimalJsLike | number | string
    maxDays?: IntFilter<"AgencyContractCommission"> | number
    createdAt?: DateTimeFilter<"AgencyContractCommission"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyContractCommission"> | Date | string
    realEstateAgencyContractProperties?: XOR<RealEstateAgencyContractPropertiesNullableRelationFilter, RealEstateAgencyContractPropertiesWhereInput> | null
    mipAgencyContractProperties?: XOR<MipAgencyContractPropertiesNullableRelationFilter, MipAgencyContractPropertiesWhereInput> | null
  }

  export type AgencyContractCommissionOrderByWithRelationInput = {
    id?: SortOrder
    percent?: SortOrder
    threshold?: SortOrder
    maxDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesOrderByWithRelationInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesOrderByWithRelationInput
  }

  export type AgencyContractCommissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AgencyContractCommissionWhereInput | AgencyContractCommissionWhereInput[]
    OR?: AgencyContractCommissionWhereInput[]
    NOT?: AgencyContractCommissionWhereInput | AgencyContractCommissionWhereInput[]
    percent?: DecimalFilter<"AgencyContractCommission"> | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFilter<"AgencyContractCommission"> | Decimal | DecimalJsLike | number | string
    maxDays?: IntFilter<"AgencyContractCommission"> | number
    createdAt?: DateTimeFilter<"AgencyContractCommission"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyContractCommission"> | Date | string
    realEstateAgencyContractProperties?: XOR<RealEstateAgencyContractPropertiesNullableRelationFilter, RealEstateAgencyContractPropertiesWhereInput> | null
    mipAgencyContractProperties?: XOR<MipAgencyContractPropertiesNullableRelationFilter, MipAgencyContractPropertiesWhereInput> | null
  }, "id">

  export type AgencyContractCommissionOrderByWithAggregationInput = {
    id?: SortOrder
    percent?: SortOrder
    threshold?: SortOrder
    maxDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgencyContractCommissionCountOrderByAggregateInput
    _avg?: AgencyContractCommissionAvgOrderByAggregateInput
    _max?: AgencyContractCommissionMaxOrderByAggregateInput
    _min?: AgencyContractCommissionMinOrderByAggregateInput
    _sum?: AgencyContractCommissionSumOrderByAggregateInput
  }

  export type AgencyContractCommissionScalarWhereWithAggregatesInput = {
    AND?: AgencyContractCommissionScalarWhereWithAggregatesInput | AgencyContractCommissionScalarWhereWithAggregatesInput[]
    OR?: AgencyContractCommissionScalarWhereWithAggregatesInput[]
    NOT?: AgencyContractCommissionScalarWhereWithAggregatesInput | AgencyContractCommissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AgencyContractCommission"> | number
    percent?: DecimalWithAggregatesFilter<"AgencyContractCommission"> | Decimal | DecimalJsLike | number | string
    threshold?: DecimalWithAggregatesFilter<"AgencyContractCommission"> | Decimal | DecimalJsLike | number | string
    maxDays?: IntWithAggregatesFilter<"AgencyContractCommission"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AgencyContractCommission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgencyContractCommission"> | Date | string
  }

  export type RealEstateAgentWhereInput = {
    AND?: RealEstateAgentWhereInput | RealEstateAgentWhereInput[]
    OR?: RealEstateAgentWhereInput[]
    NOT?: RealEstateAgentWhereInput | RealEstateAgentWhereInput[]
    id?: IntFilter<"RealEstateAgent"> | number
    fullName?: StringFilter<"RealEstateAgent"> | string
    phone?: StringNullableFilter<"RealEstateAgent"> | string | null
    oneGtId?: IntNullableFilter<"RealEstateAgent"> | number | null
    createdAt?: DateTimeFilter<"RealEstateAgent"> | Date | string
    updatedAt?: DateTimeFilter<"RealEstateAgent"> | Date | string
    clientContracts?: ClientContractListRelationFilter
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentListRelationFilter
  }

  export type RealEstateAgentOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrderInput | SortOrder
    oneGtId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientContracts?: ClientContractOrderByRelationAggregateInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentOrderByRelationAggregateInput
  }

  export type RealEstateAgentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    oneGtId?: number
    AND?: RealEstateAgentWhereInput | RealEstateAgentWhereInput[]
    OR?: RealEstateAgentWhereInput[]
    NOT?: RealEstateAgentWhereInput | RealEstateAgentWhereInput[]
    fullName?: StringFilter<"RealEstateAgent"> | string
    phone?: StringNullableFilter<"RealEstateAgent"> | string | null
    createdAt?: DateTimeFilter<"RealEstateAgent"> | Date | string
    updatedAt?: DateTimeFilter<"RealEstateAgent"> | Date | string
    clientContracts?: ClientContractListRelationFilter
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentListRelationFilter
  }, "id" | "oneGtId">

  export type RealEstateAgentOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrderInput | SortOrder
    oneGtId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RealEstateAgentCountOrderByAggregateInput
    _avg?: RealEstateAgentAvgOrderByAggregateInput
    _max?: RealEstateAgentMaxOrderByAggregateInput
    _min?: RealEstateAgentMinOrderByAggregateInput
    _sum?: RealEstateAgentSumOrderByAggregateInput
  }

  export type RealEstateAgentScalarWhereWithAggregatesInput = {
    AND?: RealEstateAgentScalarWhereWithAggregatesInput | RealEstateAgentScalarWhereWithAggregatesInput[]
    OR?: RealEstateAgentScalarWhereWithAggregatesInput[]
    NOT?: RealEstateAgentScalarWhereWithAggregatesInput | RealEstateAgentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RealEstateAgent"> | number
    fullName?: StringWithAggregatesFilter<"RealEstateAgent"> | string
    phone?: StringNullableWithAggregatesFilter<"RealEstateAgent"> | string | null
    oneGtId?: IntNullableWithAggregatesFilter<"RealEstateAgent"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"RealEstateAgent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RealEstateAgent"> | Date | string
  }

  export type AgencyToRealEstateAgentWhereInput = {
    AND?: AgencyToRealEstateAgentWhereInput | AgencyToRealEstateAgentWhereInput[]
    OR?: AgencyToRealEstateAgentWhereInput[]
    NOT?: AgencyToRealEstateAgentWhereInput | AgencyToRealEstateAgentWhereInput[]
    agencyId?: IntFilter<"AgencyToRealEstateAgent"> | number
    realEstateAgentId?: IntFilter<"AgencyToRealEstateAgent"> | number
    createdAt?: DateTimeFilter<"AgencyToRealEstateAgent"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyToRealEstateAgent"> | Date | string
    agency?: XOR<AgencyRelationFilter, AgencyWhereInput>
    realEstateAgent?: XOR<RealEstateAgentRelationFilter, RealEstateAgentWhereInput>
  }

  export type AgencyToRealEstateAgentOrderByWithRelationInput = {
    agencyId?: SortOrder
    realEstateAgentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agency?: AgencyOrderByWithRelationInput
    realEstateAgent?: RealEstateAgentOrderByWithRelationInput
  }

  export type AgencyToRealEstateAgentWhereUniqueInput = Prisma.AtLeast<{
    agencyId_realEstateAgentId?: AgencyToRealEstateAgentAgencyIdRealEstateAgentIdCompoundUniqueInput
    AND?: AgencyToRealEstateAgentWhereInput | AgencyToRealEstateAgentWhereInput[]
    OR?: AgencyToRealEstateAgentWhereInput[]
    NOT?: AgencyToRealEstateAgentWhereInput | AgencyToRealEstateAgentWhereInput[]
    agencyId?: IntFilter<"AgencyToRealEstateAgent"> | number
    realEstateAgentId?: IntFilter<"AgencyToRealEstateAgent"> | number
    createdAt?: DateTimeFilter<"AgencyToRealEstateAgent"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyToRealEstateAgent"> | Date | string
    agency?: XOR<AgencyRelationFilter, AgencyWhereInput>
    realEstateAgent?: XOR<RealEstateAgentRelationFilter, RealEstateAgentWhereInput>
  }, "agencyId_realEstateAgentId">

  export type AgencyToRealEstateAgentOrderByWithAggregationInput = {
    agencyId?: SortOrder
    realEstateAgentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgencyToRealEstateAgentCountOrderByAggregateInput
    _avg?: AgencyToRealEstateAgentAvgOrderByAggregateInput
    _max?: AgencyToRealEstateAgentMaxOrderByAggregateInput
    _min?: AgencyToRealEstateAgentMinOrderByAggregateInput
    _sum?: AgencyToRealEstateAgentSumOrderByAggregateInput
  }

  export type AgencyToRealEstateAgentScalarWhereWithAggregatesInput = {
    AND?: AgencyToRealEstateAgentScalarWhereWithAggregatesInput | AgencyToRealEstateAgentScalarWhereWithAggregatesInput[]
    OR?: AgencyToRealEstateAgentScalarWhereWithAggregatesInput[]
    NOT?: AgencyToRealEstateAgentScalarWhereWithAggregatesInput | AgencyToRealEstateAgentScalarWhereWithAggregatesInput[]
    agencyId?: IntWithAggregatesFilter<"AgencyToRealEstateAgent"> | number
    realEstateAgentId?: IntWithAggregatesFilter<"AgencyToRealEstateAgent"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AgencyToRealEstateAgent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgencyToRealEstateAgent"> | Date | string
  }

  export type EntityWhereInput = {
    AND?: EntityWhereInput | EntityWhereInput[]
    OR?: EntityWhereInput[]
    NOT?: EntityWhereInput | EntityWhereInput[]
    id?: IntFilter<"Entity"> | number
    commonDbEntitiesId?: IntFilter<"Entity"> | number
    commonContractorId?: IntNullableFilter<"Entity"> | number | null
    name?: StringFilter<"Entity"> | string
    website?: StringNullableFilter<"Entity"> | string | null
    createdAt?: DateTimeFilter<"Entity"> | Date | string
    updatedAt?: DateTimeFilter<"Entity"> | Date | string
    agencyContracts?: AgencyContractListRelationFilter
    objects?: ObjectListRelationFilter
    entityForbiddenWebsites?: EntityForbiddenWebsiteListRelationFilter
    entityForbiddenBrands?: EntityForbiddenBrandListRelationFilter
  }

  export type EntityOrderByWithRelationInput = {
    id?: SortOrder
    commonDbEntitiesId?: SortOrder
    commonContractorId?: SortOrderInput | SortOrder
    name?: SortOrder
    website?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agencyContracts?: AgencyContractOrderByRelationAggregateInput
    objects?: ObjectOrderByRelationAggregateInput
    entityForbiddenWebsites?: EntityForbiddenWebsiteOrderByRelationAggregateInput
    entityForbiddenBrands?: EntityForbiddenBrandOrderByRelationAggregateInput
  }

  export type EntityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    commonDbEntitiesId?: number
    AND?: EntityWhereInput | EntityWhereInput[]
    OR?: EntityWhereInput[]
    NOT?: EntityWhereInput | EntityWhereInput[]
    commonContractorId?: IntNullableFilter<"Entity"> | number | null
    name?: StringFilter<"Entity"> | string
    website?: StringNullableFilter<"Entity"> | string | null
    createdAt?: DateTimeFilter<"Entity"> | Date | string
    updatedAt?: DateTimeFilter<"Entity"> | Date | string
    agencyContracts?: AgencyContractListRelationFilter
    objects?: ObjectListRelationFilter
    entityForbiddenWebsites?: EntityForbiddenWebsiteListRelationFilter
    entityForbiddenBrands?: EntityForbiddenBrandListRelationFilter
  }, "id" | "commonDbEntitiesId">

  export type EntityOrderByWithAggregationInput = {
    id?: SortOrder
    commonDbEntitiesId?: SortOrder
    commonContractorId?: SortOrderInput | SortOrder
    name?: SortOrder
    website?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EntityCountOrderByAggregateInput
    _avg?: EntityAvgOrderByAggregateInput
    _max?: EntityMaxOrderByAggregateInput
    _min?: EntityMinOrderByAggregateInput
    _sum?: EntitySumOrderByAggregateInput
  }

  export type EntityScalarWhereWithAggregatesInput = {
    AND?: EntityScalarWhereWithAggregatesInput | EntityScalarWhereWithAggregatesInput[]
    OR?: EntityScalarWhereWithAggregatesInput[]
    NOT?: EntityScalarWhereWithAggregatesInput | EntityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Entity"> | number
    commonDbEntitiesId?: IntWithAggregatesFilter<"Entity"> | number
    commonContractorId?: IntNullableWithAggregatesFilter<"Entity"> | number | null
    name?: StringWithAggregatesFilter<"Entity"> | string
    website?: StringNullableWithAggregatesFilter<"Entity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Entity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Entity"> | Date | string
  }

  export type EntityForbiddenWebsiteWhereInput = {
    AND?: EntityForbiddenWebsiteWhereInput | EntityForbiddenWebsiteWhereInput[]
    OR?: EntityForbiddenWebsiteWhereInput[]
    NOT?: EntityForbiddenWebsiteWhereInput | EntityForbiddenWebsiteWhereInput[]
    id?: IntFilter<"EntityForbiddenWebsite"> | number
    name?: StringFilter<"EntityForbiddenWebsite"> | string
    entityId?: IntFilter<"EntityForbiddenWebsite"> | number
    createdAt?: DateTimeFilter<"EntityForbiddenWebsite"> | Date | string
    updatedAt?: DateTimeFilter<"EntityForbiddenWebsite"> | Date | string
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
  }

  export type EntityForbiddenWebsiteOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    entity?: EntityOrderByWithRelationInput
  }

  export type EntityForbiddenWebsiteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EntityForbiddenWebsiteWhereInput | EntityForbiddenWebsiteWhereInput[]
    OR?: EntityForbiddenWebsiteWhereInput[]
    NOT?: EntityForbiddenWebsiteWhereInput | EntityForbiddenWebsiteWhereInput[]
    name?: StringFilter<"EntityForbiddenWebsite"> | string
    entityId?: IntFilter<"EntityForbiddenWebsite"> | number
    createdAt?: DateTimeFilter<"EntityForbiddenWebsite"> | Date | string
    updatedAt?: DateTimeFilter<"EntityForbiddenWebsite"> | Date | string
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
  }, "id">

  export type EntityForbiddenWebsiteOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EntityForbiddenWebsiteCountOrderByAggregateInput
    _avg?: EntityForbiddenWebsiteAvgOrderByAggregateInput
    _max?: EntityForbiddenWebsiteMaxOrderByAggregateInput
    _min?: EntityForbiddenWebsiteMinOrderByAggregateInput
    _sum?: EntityForbiddenWebsiteSumOrderByAggregateInput
  }

  export type EntityForbiddenWebsiteScalarWhereWithAggregatesInput = {
    AND?: EntityForbiddenWebsiteScalarWhereWithAggregatesInput | EntityForbiddenWebsiteScalarWhereWithAggregatesInput[]
    OR?: EntityForbiddenWebsiteScalarWhereWithAggregatesInput[]
    NOT?: EntityForbiddenWebsiteScalarWhereWithAggregatesInput | EntityForbiddenWebsiteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EntityForbiddenWebsite"> | number
    name?: StringWithAggregatesFilter<"EntityForbiddenWebsite"> | string
    entityId?: IntWithAggregatesFilter<"EntityForbiddenWebsite"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EntityForbiddenWebsite"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EntityForbiddenWebsite"> | Date | string
  }

  export type EntityForbiddenBrandWhereInput = {
    AND?: EntityForbiddenBrandWhereInput | EntityForbiddenBrandWhereInput[]
    OR?: EntityForbiddenBrandWhereInput[]
    NOT?: EntityForbiddenBrandWhereInput | EntityForbiddenBrandWhereInput[]
    id?: IntFilter<"EntityForbiddenBrand"> | number
    name?: StringFilter<"EntityForbiddenBrand"> | string
    entityId?: IntFilter<"EntityForbiddenBrand"> | number
    createdAt?: DateTimeFilter<"EntityForbiddenBrand"> | Date | string
    updatedAt?: DateTimeFilter<"EntityForbiddenBrand"> | Date | string
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
  }

  export type EntityForbiddenBrandOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    entity?: EntityOrderByWithRelationInput
  }

  export type EntityForbiddenBrandWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EntityForbiddenBrandWhereInput | EntityForbiddenBrandWhereInput[]
    OR?: EntityForbiddenBrandWhereInput[]
    NOT?: EntityForbiddenBrandWhereInput | EntityForbiddenBrandWhereInput[]
    name?: StringFilter<"EntityForbiddenBrand"> | string
    entityId?: IntFilter<"EntityForbiddenBrand"> | number
    createdAt?: DateTimeFilter<"EntityForbiddenBrand"> | Date | string
    updatedAt?: DateTimeFilter<"EntityForbiddenBrand"> | Date | string
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
  }, "id">

  export type EntityForbiddenBrandOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EntityForbiddenBrandCountOrderByAggregateInput
    _avg?: EntityForbiddenBrandAvgOrderByAggregateInput
    _max?: EntityForbiddenBrandMaxOrderByAggregateInput
    _min?: EntityForbiddenBrandMinOrderByAggregateInput
    _sum?: EntityForbiddenBrandSumOrderByAggregateInput
  }

  export type EntityForbiddenBrandScalarWhereWithAggregatesInput = {
    AND?: EntityForbiddenBrandScalarWhereWithAggregatesInput | EntityForbiddenBrandScalarWhereWithAggregatesInput[]
    OR?: EntityForbiddenBrandScalarWhereWithAggregatesInput[]
    NOT?: EntityForbiddenBrandScalarWhereWithAggregatesInput | EntityForbiddenBrandScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EntityForbiddenBrand"> | number
    name?: StringWithAggregatesFilter<"EntityForbiddenBrand"> | string
    entityId?: IntWithAggregatesFilter<"EntityForbiddenBrand"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EntityForbiddenBrand"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EntityForbiddenBrand"> | Date | string
  }

  export type BankWhereInput = {
    AND?: BankWhereInput | BankWhereInput[]
    OR?: BankWhereInput[]
    NOT?: BankWhereInput | BankWhereInput[]
    id?: IntFilter<"Bank"> | number
    name?: StringFilter<"Bank"> | string
    isVisible?: BoolFilter<"Bank"> | boolean
    createdAt?: DateTimeFilter<"Bank"> | Date | string
    updatedAt?: DateTimeFilter<"Bank"> | Date | string
    clientContracts?: ClientContractListRelationFilter
  }

  export type BankOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isVisible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientContracts?: ClientContractOrderByRelationAggregateInput
  }

  export type BankWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BankWhereInput | BankWhereInput[]
    OR?: BankWhereInput[]
    NOT?: BankWhereInput | BankWhereInput[]
    name?: StringFilter<"Bank"> | string
    isVisible?: BoolFilter<"Bank"> | boolean
    createdAt?: DateTimeFilter<"Bank"> | Date | string
    updatedAt?: DateTimeFilter<"Bank"> | Date | string
    clientContracts?: ClientContractListRelationFilter
  }, "id">

  export type BankOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isVisible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankCountOrderByAggregateInput
    _avg?: BankAvgOrderByAggregateInput
    _max?: BankMaxOrderByAggregateInput
    _min?: BankMinOrderByAggregateInput
    _sum?: BankSumOrderByAggregateInput
  }

  export type BankScalarWhereWithAggregatesInput = {
    AND?: BankScalarWhereWithAggregatesInput | BankScalarWhereWithAggregatesInput[]
    OR?: BankScalarWhereWithAggregatesInput[]
    NOT?: BankScalarWhereWithAggregatesInput | BankScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bank"> | number
    name?: StringWithAggregatesFilter<"Bank"> | string
    isVisible?: BoolWithAggregatesFilter<"Bank"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Bank"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bank"> | Date | string
  }

  export type EscrowAccountHistoryWhereInput = {
    AND?: EscrowAccountHistoryWhereInput | EscrowAccountHistoryWhereInput[]
    OR?: EscrowAccountHistoryWhereInput[]
    NOT?: EscrowAccountHistoryWhereInput | EscrowAccountHistoryWhereInput[]
    id?: IntFilter<"EscrowAccountHistory"> | number
    status?: EnumEscrowAccountStatusFilter<"EscrowAccountHistory"> | $Enums.EscrowAccountStatus
    number?: StringFilter<"EscrowAccountHistory"> | string
    openingDate?: DateTimeFilter<"EscrowAccountHistory"> | Date | string
    depositedAmount?: DecimalFilter<"EscrowAccountHistory"> | Decimal | DecimalJsLike | number | string
    incomingBalance?: DecimalFilter<"EscrowAccountHistory"> | Decimal | DecimalJsLike | number | string
    dateOfTransaction?: DateTimeFilter<"EscrowAccountHistory"> | Date | string
    transactionAmount?: DecimalFilter<"EscrowAccountHistory"> | Decimal | DecimalJsLike | number | string
    outgoingBalance?: DecimalFilter<"EscrowAccountHistory"> | Decimal | DecimalJsLike | number | string
    expirationDate?: DateTimeFilter<"EscrowAccountHistory"> | Date | string
    depositor?: StringFilter<"EscrowAccountHistory"> | string
    depositorInn?: StringNullableFilter<"EscrowAccountHistory"> | string | null
    dduNumber?: StringFilter<"EscrowAccountHistory"> | string
    dduDate?: DateTimeFilter<"EscrowAccountHistory"> | Date | string
    loanAgreementNumber?: StringNullableFilter<"EscrowAccountHistory"> | string | null
    loanAgreementDate?: DateTimeNullableFilter<"EscrowAccountHistory"> | Date | string | null
    closingDate?: DateTimeNullableFilter<"EscrowAccountHistory"> | Date | string | null
    builderInn?: StringFilter<"EscrowAccountHistory"> | string
    createdAt?: DateTimeFilter<"EscrowAccountHistory"> | Date | string
    updatedAt?: DateTimeFilter<"EscrowAccountHistory"> | Date | string
  }

  export type EscrowAccountHistoryOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    number?: SortOrder
    openingDate?: SortOrder
    depositedAmount?: SortOrder
    incomingBalance?: SortOrder
    dateOfTransaction?: SortOrder
    transactionAmount?: SortOrder
    outgoingBalance?: SortOrder
    expirationDate?: SortOrder
    depositor?: SortOrder
    depositorInn?: SortOrderInput | SortOrder
    dduNumber?: SortOrder
    dduDate?: SortOrder
    loanAgreementNumber?: SortOrderInput | SortOrder
    loanAgreementDate?: SortOrderInput | SortOrder
    closingDate?: SortOrderInput | SortOrder
    builderInn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EscrowAccountHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EscrowAccountHistoryWhereInput | EscrowAccountHistoryWhereInput[]
    OR?: EscrowAccountHistoryWhereInput[]
    NOT?: EscrowAccountHistoryWhereInput | EscrowAccountHistoryWhereInput[]
    status?: EnumEscrowAccountStatusFilter<"EscrowAccountHistory"> | $Enums.EscrowAccountStatus
    number?: StringFilter<"EscrowAccountHistory"> | string
    openingDate?: DateTimeFilter<"EscrowAccountHistory"> | Date | string
    depositedAmount?: DecimalFilter<"EscrowAccountHistory"> | Decimal | DecimalJsLike | number | string
    incomingBalance?: DecimalFilter<"EscrowAccountHistory"> | Decimal | DecimalJsLike | number | string
    dateOfTransaction?: DateTimeFilter<"EscrowAccountHistory"> | Date | string
    transactionAmount?: DecimalFilter<"EscrowAccountHistory"> | Decimal | DecimalJsLike | number | string
    outgoingBalance?: DecimalFilter<"EscrowAccountHistory"> | Decimal | DecimalJsLike | number | string
    expirationDate?: DateTimeFilter<"EscrowAccountHistory"> | Date | string
    depositor?: StringFilter<"EscrowAccountHistory"> | string
    depositorInn?: StringNullableFilter<"EscrowAccountHistory"> | string | null
    dduNumber?: StringFilter<"EscrowAccountHistory"> | string
    dduDate?: DateTimeFilter<"EscrowAccountHistory"> | Date | string
    loanAgreementNumber?: StringNullableFilter<"EscrowAccountHistory"> | string | null
    loanAgreementDate?: DateTimeNullableFilter<"EscrowAccountHistory"> | Date | string | null
    closingDate?: DateTimeNullableFilter<"EscrowAccountHistory"> | Date | string | null
    builderInn?: StringFilter<"EscrowAccountHistory"> | string
    createdAt?: DateTimeFilter<"EscrowAccountHistory"> | Date | string
    updatedAt?: DateTimeFilter<"EscrowAccountHistory"> | Date | string
  }, "id">

  export type EscrowAccountHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    number?: SortOrder
    openingDate?: SortOrder
    depositedAmount?: SortOrder
    incomingBalance?: SortOrder
    dateOfTransaction?: SortOrder
    transactionAmount?: SortOrder
    outgoingBalance?: SortOrder
    expirationDate?: SortOrder
    depositor?: SortOrder
    depositorInn?: SortOrderInput | SortOrder
    dduNumber?: SortOrder
    dduDate?: SortOrder
    loanAgreementNumber?: SortOrderInput | SortOrder
    loanAgreementDate?: SortOrderInput | SortOrder
    closingDate?: SortOrderInput | SortOrder
    builderInn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EscrowAccountHistoryCountOrderByAggregateInput
    _avg?: EscrowAccountHistoryAvgOrderByAggregateInput
    _max?: EscrowAccountHistoryMaxOrderByAggregateInput
    _min?: EscrowAccountHistoryMinOrderByAggregateInput
    _sum?: EscrowAccountHistorySumOrderByAggregateInput
  }

  export type EscrowAccountHistoryScalarWhereWithAggregatesInput = {
    AND?: EscrowAccountHistoryScalarWhereWithAggregatesInput | EscrowAccountHistoryScalarWhereWithAggregatesInput[]
    OR?: EscrowAccountHistoryScalarWhereWithAggregatesInput[]
    NOT?: EscrowAccountHistoryScalarWhereWithAggregatesInput | EscrowAccountHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EscrowAccountHistory"> | number
    status?: EnumEscrowAccountStatusWithAggregatesFilter<"EscrowAccountHistory"> | $Enums.EscrowAccountStatus
    number?: StringWithAggregatesFilter<"EscrowAccountHistory"> | string
    openingDate?: DateTimeWithAggregatesFilter<"EscrowAccountHistory"> | Date | string
    depositedAmount?: DecimalWithAggregatesFilter<"EscrowAccountHistory"> | Decimal | DecimalJsLike | number | string
    incomingBalance?: DecimalWithAggregatesFilter<"EscrowAccountHistory"> | Decimal | DecimalJsLike | number | string
    dateOfTransaction?: DateTimeWithAggregatesFilter<"EscrowAccountHistory"> | Date | string
    transactionAmount?: DecimalWithAggregatesFilter<"EscrowAccountHistory"> | Decimal | DecimalJsLike | number | string
    outgoingBalance?: DecimalWithAggregatesFilter<"EscrowAccountHistory"> | Decimal | DecimalJsLike | number | string
    expirationDate?: DateTimeWithAggregatesFilter<"EscrowAccountHistory"> | Date | string
    depositor?: StringWithAggregatesFilter<"EscrowAccountHistory"> | string
    depositorInn?: StringNullableWithAggregatesFilter<"EscrowAccountHistory"> | string | null
    dduNumber?: StringWithAggregatesFilter<"EscrowAccountHistory"> | string
    dduDate?: DateTimeWithAggregatesFilter<"EscrowAccountHistory"> | Date | string
    loanAgreementNumber?: StringNullableWithAggregatesFilter<"EscrowAccountHistory"> | string | null
    loanAgreementDate?: DateTimeNullableWithAggregatesFilter<"EscrowAccountHistory"> | Date | string | null
    closingDate?: DateTimeNullableWithAggregatesFilter<"EscrowAccountHistory"> | Date | string | null
    builderInn?: StringWithAggregatesFilter<"EscrowAccountHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EscrowAccountHistory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EscrowAccountHistory"> | Date | string
  }

  export type RealEstateAgencyActWhereInput = {
    AND?: RealEstateAgencyActWhereInput | RealEstateAgencyActWhereInput[]
    OR?: RealEstateAgencyActWhereInput[]
    NOT?: RealEstateAgencyActWhereInput | RealEstateAgencyActWhereInput[]
    id?: IntFilter<"RealEstateAgencyAct"> | number
    number?: StringFilter<"RealEstateAgencyAct"> | string
    date?: DateTimeFilter<"RealEstateAgencyAct"> | Date | string
    amount?: DecimalFilter<"RealEstateAgencyAct"> | Decimal | DecimalJsLike | number | string
    retention?: DecimalNullableFilter<"RealEstateAgencyAct"> | Decimal | DecimalJsLike | number | string | null
    note?: StringNullableFilter<"RealEstateAgencyAct"> | string | null
    link?: StringNullableFilter<"RealEstateAgencyAct"> | string | null
    clientContractId?: IntFilter<"RealEstateAgencyAct"> | number
    agencyId?: IntFilter<"RealEstateAgencyAct"> | number
    agencyContractId?: IntFilter<"RealEstateAgencyAct"> | number
    createdAt?: DateTimeFilter<"RealEstateAgencyAct"> | Date | string
    updatedAt?: DateTimeFilter<"RealEstateAgencyAct"> | Date | string
    clientContract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
    agency?: XOR<AgencyRelationFilter, AgencyWhereInput>
    agencyContract?: XOR<AgencyContractRelationFilter, AgencyContractWhereInput>
  }

  export type RealEstateAgencyActOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    retention?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    clientContractId?: SortOrder
    agencyId?: SortOrder
    agencyContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientContract?: ClientContractOrderByWithRelationInput
    agency?: AgencyOrderByWithRelationInput
    agencyContract?: AgencyContractOrderByWithRelationInput
  }

  export type RealEstateAgencyActWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RealEstateAgencyActWhereInput | RealEstateAgencyActWhereInput[]
    OR?: RealEstateAgencyActWhereInput[]
    NOT?: RealEstateAgencyActWhereInput | RealEstateAgencyActWhereInput[]
    number?: StringFilter<"RealEstateAgencyAct"> | string
    date?: DateTimeFilter<"RealEstateAgencyAct"> | Date | string
    amount?: DecimalFilter<"RealEstateAgencyAct"> | Decimal | DecimalJsLike | number | string
    retention?: DecimalNullableFilter<"RealEstateAgencyAct"> | Decimal | DecimalJsLike | number | string | null
    note?: StringNullableFilter<"RealEstateAgencyAct"> | string | null
    link?: StringNullableFilter<"RealEstateAgencyAct"> | string | null
    clientContractId?: IntFilter<"RealEstateAgencyAct"> | number
    agencyId?: IntFilter<"RealEstateAgencyAct"> | number
    agencyContractId?: IntFilter<"RealEstateAgencyAct"> | number
    createdAt?: DateTimeFilter<"RealEstateAgencyAct"> | Date | string
    updatedAt?: DateTimeFilter<"RealEstateAgencyAct"> | Date | string
    clientContract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
    agency?: XOR<AgencyRelationFilter, AgencyWhereInput>
    agencyContract?: XOR<AgencyContractRelationFilter, AgencyContractWhereInput>
  }, "id">

  export type RealEstateAgencyActOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    retention?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    clientContractId?: SortOrder
    agencyId?: SortOrder
    agencyContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RealEstateAgencyActCountOrderByAggregateInput
    _avg?: RealEstateAgencyActAvgOrderByAggregateInput
    _max?: RealEstateAgencyActMaxOrderByAggregateInput
    _min?: RealEstateAgencyActMinOrderByAggregateInput
    _sum?: RealEstateAgencyActSumOrderByAggregateInput
  }

  export type RealEstateAgencyActScalarWhereWithAggregatesInput = {
    AND?: RealEstateAgencyActScalarWhereWithAggregatesInput | RealEstateAgencyActScalarWhereWithAggregatesInput[]
    OR?: RealEstateAgencyActScalarWhereWithAggregatesInput[]
    NOT?: RealEstateAgencyActScalarWhereWithAggregatesInput | RealEstateAgencyActScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RealEstateAgencyAct"> | number
    number?: StringWithAggregatesFilter<"RealEstateAgencyAct"> | string
    date?: DateTimeWithAggregatesFilter<"RealEstateAgencyAct"> | Date | string
    amount?: DecimalWithAggregatesFilter<"RealEstateAgencyAct"> | Decimal | DecimalJsLike | number | string
    retention?: DecimalNullableWithAggregatesFilter<"RealEstateAgencyAct"> | Decimal | DecimalJsLike | number | string | null
    note?: StringNullableWithAggregatesFilter<"RealEstateAgencyAct"> | string | null
    link?: StringNullableWithAggregatesFilter<"RealEstateAgencyAct"> | string | null
    clientContractId?: IntWithAggregatesFilter<"RealEstateAgencyAct"> | number
    agencyId?: IntWithAggregatesFilter<"RealEstateAgencyAct"> | number
    agencyContractId?: IntWithAggregatesFilter<"RealEstateAgencyAct"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RealEstateAgencyAct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RealEstateAgencyAct"> | Date | string
  }

  export type SubsidyWhereInput = {
    AND?: SubsidyWhereInput | SubsidyWhereInput[]
    OR?: SubsidyWhereInput[]
    NOT?: SubsidyWhereInput | SubsidyWhereInput[]
    id?: IntFilter<"Subsidy"> | number
    name?: StringFilter<"Subsidy"> | string
    isVisible?: BoolFilter<"Subsidy"> | boolean
    createdAt?: DateTimeFilter<"Subsidy"> | Date | string
    updatedAt?: DateTimeFilter<"Subsidy"> | Date | string
    clientContracts?: ClientContractListRelationFilter
  }

  export type SubsidyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isVisible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientContracts?: ClientContractOrderByRelationAggregateInput
  }

  export type SubsidyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SubsidyWhereInput | SubsidyWhereInput[]
    OR?: SubsidyWhereInput[]
    NOT?: SubsidyWhereInput | SubsidyWhereInput[]
    name?: StringFilter<"Subsidy"> | string
    isVisible?: BoolFilter<"Subsidy"> | boolean
    createdAt?: DateTimeFilter<"Subsidy"> | Date | string
    updatedAt?: DateTimeFilter<"Subsidy"> | Date | string
    clientContracts?: ClientContractListRelationFilter
  }, "id">

  export type SubsidyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isVisible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubsidyCountOrderByAggregateInput
    _avg?: SubsidyAvgOrderByAggregateInput
    _max?: SubsidyMaxOrderByAggregateInput
    _min?: SubsidyMinOrderByAggregateInput
    _sum?: SubsidySumOrderByAggregateInput
  }

  export type SubsidyScalarWhereWithAggregatesInput = {
    AND?: SubsidyScalarWhereWithAggregatesInput | SubsidyScalarWhereWithAggregatesInput[]
    OR?: SubsidyScalarWhereWithAggregatesInput[]
    NOT?: SubsidyScalarWhereWithAggregatesInput | SubsidyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subsidy"> | number
    name?: StringWithAggregatesFilter<"Subsidy"> | string
    isVisible?: BoolWithAggregatesFilter<"Subsidy"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Subsidy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subsidy"> | Date | string
  }

  export type AssignmentWhereInput = {
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    id?: IntFilter<"Assignment"> | number
    order?: IntFilter<"Assignment"> | number
    clientContractId?: IntFilter<"Assignment"> | number
    clientId?: IntFilter<"Assignment"> | number
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
    clientContract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
    client?: XOR<ClientRelationFilter, ClientWhereInput>
  }

  export type AssignmentOrderByWithRelationInput = {
    id?: SortOrder
    order?: SortOrder
    clientContractId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientContract?: ClientContractOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
  }

  export type AssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    order?: IntFilter<"Assignment"> | number
    clientContractId?: IntFilter<"Assignment"> | number
    clientId?: IntFilter<"Assignment"> | number
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
    clientContract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
    client?: XOR<ClientRelationFilter, ClientWhereInput>
  }, "id">

  export type AssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    order?: SortOrder
    clientContractId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssignmentCountOrderByAggregateInput
    _avg?: AssignmentAvgOrderByAggregateInput
    _max?: AssignmentMaxOrderByAggregateInput
    _min?: AssignmentMinOrderByAggregateInput
    _sum?: AssignmentSumOrderByAggregateInput
  }

  export type AssignmentScalarWhereWithAggregatesInput = {
    AND?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    OR?: AssignmentScalarWhereWithAggregatesInput[]
    NOT?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Assignment"> | number
    order?: IntWithAggregatesFilter<"Assignment"> | number
    clientContractId?: IntWithAggregatesFilter<"Assignment"> | number
    clientId?: IntWithAggregatesFilter<"Assignment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
  }

  export type TransferActWhereInput = {
    AND?: TransferActWhereInput | TransferActWhereInput[]
    OR?: TransferActWhereInput[]
    NOT?: TransferActWhereInput | TransferActWhereInput[]
    id?: IntFilter<"TransferAct"> | number
    number?: StringFilter<"TransferAct"> | string
    date?: DateTimeFilter<"TransferAct"> | Date | string
    link?: StringNullableFilter<"TransferAct"> | string | null
    clientContractId?: IntFilter<"TransferAct"> | number
    objectId?: IntFilter<"TransferAct"> | number
    productId?: IntFilter<"TransferAct"> | number
    createdAt?: DateTimeFilter<"TransferAct"> | Date | string
    updatedAt?: DateTimeFilter<"TransferAct"> | Date | string
    clientContract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    transferActsToRepresentatives?: TransferActToRepresentativeListRelationFilter
  }

  export type TransferActOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    link?: SortOrderInput | SortOrder
    clientContractId?: SortOrder
    objectId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientContract?: ClientContractOrderByWithRelationInput
    object?: ObjectOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    transferActsToRepresentatives?: TransferActToRepresentativeOrderByRelationAggregateInput
  }

  export type TransferActWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    clientContractId?: number
    productId?: number
    AND?: TransferActWhereInput | TransferActWhereInput[]
    OR?: TransferActWhereInput[]
    NOT?: TransferActWhereInput | TransferActWhereInput[]
    number?: StringFilter<"TransferAct"> | string
    date?: DateTimeFilter<"TransferAct"> | Date | string
    link?: StringNullableFilter<"TransferAct"> | string | null
    objectId?: IntFilter<"TransferAct"> | number
    createdAt?: DateTimeFilter<"TransferAct"> | Date | string
    updatedAt?: DateTimeFilter<"TransferAct"> | Date | string
    clientContract?: XOR<ClientContractRelationFilter, ClientContractWhereInput>
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    transferActsToRepresentatives?: TransferActToRepresentativeListRelationFilter
  }, "id" | "clientContractId" | "productId">

  export type TransferActOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    link?: SortOrderInput | SortOrder
    clientContractId?: SortOrder
    objectId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransferActCountOrderByAggregateInput
    _avg?: TransferActAvgOrderByAggregateInput
    _max?: TransferActMaxOrderByAggregateInput
    _min?: TransferActMinOrderByAggregateInput
    _sum?: TransferActSumOrderByAggregateInput
  }

  export type TransferActScalarWhereWithAggregatesInput = {
    AND?: TransferActScalarWhereWithAggregatesInput | TransferActScalarWhereWithAggregatesInput[]
    OR?: TransferActScalarWhereWithAggregatesInput[]
    NOT?: TransferActScalarWhereWithAggregatesInput | TransferActScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TransferAct"> | number
    number?: StringWithAggregatesFilter<"TransferAct"> | string
    date?: DateTimeWithAggregatesFilter<"TransferAct"> | Date | string
    link?: StringNullableWithAggregatesFilter<"TransferAct"> | string | null
    clientContractId?: IntWithAggregatesFilter<"TransferAct"> | number
    objectId?: IntWithAggregatesFilter<"TransferAct"> | number
    productId?: IntWithAggregatesFilter<"TransferAct"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TransferAct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransferAct"> | Date | string
  }

  export type RepresentativeWhereInput = {
    AND?: RepresentativeWhereInput | RepresentativeWhereInput[]
    OR?: RepresentativeWhereInput[]
    NOT?: RepresentativeWhereInput | RepresentativeWhereInput[]
    id?: IntFilter<"Representative"> | number
    fullName?: StringFilter<"Representative"> | string
    attorneyNumber?: StringNullableFilter<"Representative"> | string | null
    attorneyDate?: DateTimeNullableFilter<"Representative"> | Date | string | null
    authorizedBy?: StringNullableFilter<"Representative"> | string | null
    authorizedRole?: StringNullableFilter<"Representative"> | string | null
    clientId?: IntFilter<"Representative"> | number
    createdAt?: DateTimeFilter<"Representative"> | Date | string
    updatedAt?: DateTimeFilter<"Representative"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    transferActsToRepresentatives?: TransferActToRepresentativeListRelationFilter
  }

  export type RepresentativeOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    attorneyNumber?: SortOrderInput | SortOrder
    attorneyDate?: SortOrderInput | SortOrder
    authorizedBy?: SortOrderInput | SortOrder
    authorizedRole?: SortOrderInput | SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    transferActsToRepresentatives?: TransferActToRepresentativeOrderByRelationAggregateInput
  }

  export type RepresentativeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RepresentativeWhereInput | RepresentativeWhereInput[]
    OR?: RepresentativeWhereInput[]
    NOT?: RepresentativeWhereInput | RepresentativeWhereInput[]
    fullName?: StringFilter<"Representative"> | string
    attorneyNumber?: StringNullableFilter<"Representative"> | string | null
    attorneyDate?: DateTimeNullableFilter<"Representative"> | Date | string | null
    authorizedBy?: StringNullableFilter<"Representative"> | string | null
    authorizedRole?: StringNullableFilter<"Representative"> | string | null
    clientId?: IntFilter<"Representative"> | number
    createdAt?: DateTimeFilter<"Representative"> | Date | string
    updatedAt?: DateTimeFilter<"Representative"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    transferActsToRepresentatives?: TransferActToRepresentativeListRelationFilter
  }, "id">

  export type RepresentativeOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    attorneyNumber?: SortOrderInput | SortOrder
    attorneyDate?: SortOrderInput | SortOrder
    authorizedBy?: SortOrderInput | SortOrder
    authorizedRole?: SortOrderInput | SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RepresentativeCountOrderByAggregateInput
    _avg?: RepresentativeAvgOrderByAggregateInput
    _max?: RepresentativeMaxOrderByAggregateInput
    _min?: RepresentativeMinOrderByAggregateInput
    _sum?: RepresentativeSumOrderByAggregateInput
  }

  export type RepresentativeScalarWhereWithAggregatesInput = {
    AND?: RepresentativeScalarWhereWithAggregatesInput | RepresentativeScalarWhereWithAggregatesInput[]
    OR?: RepresentativeScalarWhereWithAggregatesInput[]
    NOT?: RepresentativeScalarWhereWithAggregatesInput | RepresentativeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Representative"> | number
    fullName?: StringWithAggregatesFilter<"Representative"> | string
    attorneyNumber?: StringNullableWithAggregatesFilter<"Representative"> | string | null
    attorneyDate?: DateTimeNullableWithAggregatesFilter<"Representative"> | Date | string | null
    authorizedBy?: StringNullableWithAggregatesFilter<"Representative"> | string | null
    authorizedRole?: StringNullableWithAggregatesFilter<"Representative"> | string | null
    clientId?: IntWithAggregatesFilter<"Representative"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Representative"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Representative"> | Date | string
  }

  export type TransferActToRepresentativeWhereInput = {
    AND?: TransferActToRepresentativeWhereInput | TransferActToRepresentativeWhereInput[]
    OR?: TransferActToRepresentativeWhereInput[]
    NOT?: TransferActToRepresentativeWhereInput | TransferActToRepresentativeWhereInput[]
    transferActId?: IntFilter<"TransferActToRepresentative"> | number
    representativeId?: IntFilter<"TransferActToRepresentative"> | number
    createdAt?: DateTimeFilter<"TransferActToRepresentative"> | Date | string
    updatedAt?: DateTimeFilter<"TransferActToRepresentative"> | Date | string
    transferAct?: XOR<TransferActRelationFilter, TransferActWhereInput>
    representative?: XOR<RepresentativeRelationFilter, RepresentativeWhereInput>
  }

  export type TransferActToRepresentativeOrderByWithRelationInput = {
    transferActId?: SortOrder
    representativeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transferAct?: TransferActOrderByWithRelationInput
    representative?: RepresentativeOrderByWithRelationInput
  }

  export type TransferActToRepresentativeWhereUniqueInput = Prisma.AtLeast<{
    transferActId_representativeId?: TransferActToRepresentativeTransferActIdRepresentativeIdCompoundUniqueInput
    AND?: TransferActToRepresentativeWhereInput | TransferActToRepresentativeWhereInput[]
    OR?: TransferActToRepresentativeWhereInput[]
    NOT?: TransferActToRepresentativeWhereInput | TransferActToRepresentativeWhereInput[]
    transferActId?: IntFilter<"TransferActToRepresentative"> | number
    representativeId?: IntFilter<"TransferActToRepresentative"> | number
    createdAt?: DateTimeFilter<"TransferActToRepresentative"> | Date | string
    updatedAt?: DateTimeFilter<"TransferActToRepresentative"> | Date | string
    transferAct?: XOR<TransferActRelationFilter, TransferActWhereInput>
    representative?: XOR<RepresentativeRelationFilter, RepresentativeWhereInput>
  }, "transferActId_representativeId">

  export type TransferActToRepresentativeOrderByWithAggregationInput = {
    transferActId?: SortOrder
    representativeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransferActToRepresentativeCountOrderByAggregateInput
    _avg?: TransferActToRepresentativeAvgOrderByAggregateInput
    _max?: TransferActToRepresentativeMaxOrderByAggregateInput
    _min?: TransferActToRepresentativeMinOrderByAggregateInput
    _sum?: TransferActToRepresentativeSumOrderByAggregateInput
  }

  export type TransferActToRepresentativeScalarWhereWithAggregatesInput = {
    AND?: TransferActToRepresentativeScalarWhereWithAggregatesInput | TransferActToRepresentativeScalarWhereWithAggregatesInput[]
    OR?: TransferActToRepresentativeScalarWhereWithAggregatesInput[]
    NOT?: TransferActToRepresentativeScalarWhereWithAggregatesInput | TransferActToRepresentativeScalarWhereWithAggregatesInput[]
    transferActId?: IntWithAggregatesFilter<"TransferActToRepresentative"> | number
    representativeId?: IntWithAggregatesFilter<"TransferActToRepresentative"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TransferActToRepresentative"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransferActToRepresentative"> | Date | string
  }

  export type UserCreateInput = {
    fullName: string
    email: string
    phone?: string | null
    isManager?: boolean
    isStaff?: boolean
    userRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContracts?: ClientContractCreateNestedManyWithoutManagerInput
    agencyContracts?: AgencyContractCreateNestedManyWithoutResponsibleUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    fullName: string
    email: string
    phone?: string | null
    isManager?: boolean
    isStaff?: boolean
    userRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContracts?: ClientContractUncheckedCreateNestedManyWithoutManagerInput
    agencyContracts?: AgencyContractUncheckedCreateNestedManyWithoutResponsibleUserInput
  }

  export type UserUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    userRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContracts?: ClientContractUpdateManyWithoutManagerNestedInput
    agencyContracts?: AgencyContractUpdateManyWithoutResponsibleUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    userRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContracts?: ClientContractUncheckedUpdateManyWithoutManagerNestedInput
    agencyContracts?: AgencyContractUncheckedUpdateManyWithoutResponsibleUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    fullName: string
    email: string
    phone?: string | null
    isManager?: boolean
    isStaff?: boolean
    userRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    userRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    userRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    fullName: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    clientCategory: $Enums.ClientCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    clientIndividualProperties?: ClientIndividualPropertiesCreateNestedOneWithoutClientInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesCreateNestedOneWithoutClientInput
    clientEntityProperties?: ClientEntityPropertiesCreateNestedOneWithoutClientInput
    assignments?: AssignmentCreateNestedManyWithoutClientInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClientInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientInput
    representatives?: RepresentativeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: number
    fullName: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    clientCategory: $Enums.ClientCategory
    clientIndividualPropertiesId?: number | null
    clientIndividualMinorPropertiesId?: number | null
    clientEntityPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClientInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    clientCategory?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientIndividualProperties?: ClientIndividualPropertiesUpdateOneWithoutClientNestedInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesUpdateOneWithoutClientNestedInput
    clientEntityProperties?: ClientEntityPropertiesUpdateOneWithoutClientNestedInput
    assignments?: AssignmentUpdateManyWithoutClientNestedInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUpdateManyWithoutClientNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientNestedInput
    representatives?: RepresentativeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    clientCategory?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    clientIndividualPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    clientIndividualMinorPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    clientEntityPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutClientNestedInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: number
    fullName: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    clientCategory: $Enums.ClientCategory
    clientIndividualPropertiesId?: number | null
    clientIndividualMinorPropertiesId?: number | null
    clientEntityPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    clientCategory?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    clientCategory?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    clientIndividualPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    clientIndividualMinorPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    clientEntityPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientIndividualPropertiesCreateInput = {
    dob?: Date | string | null
    snils?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutClientIndividualPropertiesInput
    clientPassport?: ClientPassportCreateNestedOneWithoutClientIndividualPropertiesInput
  }

  export type ClientIndividualPropertiesUncheckedCreateInput = {
    id?: number
    dob?: Date | string | null
    snils?: string | null
    clientPassportId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientUncheckedCreateNestedOneWithoutClientIndividualPropertiesInput
  }

  export type ClientIndividualPropertiesUpdateInput = {
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutClientIndividualPropertiesNestedInput
    clientPassport?: ClientPassportUpdateOneWithoutClientIndividualPropertiesNestedInput
  }

  export type ClientIndividualPropertiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    clientPassportId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUncheckedUpdateOneWithoutClientIndividualPropertiesNestedInput
  }

  export type ClientIndividualPropertiesCreateManyInput = {
    id?: number
    dob?: Date | string | null
    snils?: string | null
    clientPassportId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientIndividualPropertiesUpdateManyMutationInput = {
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientIndividualPropertiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    clientPassportId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientIndividualMinorPropertiesCreateInput = {
    dob?: Date | string | null
    snils?: string | null
    birthCertificate?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutClientIndividualMinorPropertiesInput
    clientPassport?: ClientPassportCreateNestedOneWithoutClientIndividualMinorPropertiesInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClientIndividualMinorPropertiesInput
  }

  export type ClientIndividualMinorPropertiesUncheckedCreateInput = {
    id?: number
    dob?: Date | string | null
    snils?: string | null
    birthCertificate?: string | null
    clientPassportId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientUncheckedCreateNestedOneWithoutClientIndividualMinorPropertiesInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClientIndividualMinorPropertiesInput
  }

  export type ClientIndividualMinorPropertiesUpdateInput = {
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birthCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutClientIndividualMinorPropertiesNestedInput
    clientPassport?: ClientPassportUpdateOneWithoutClientIndividualMinorPropertiesNestedInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUpdateManyWithoutClientIndividualMinorPropertiesNestedInput
  }

  export type ClientIndividualMinorPropertiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birthCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    clientPassportId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUncheckedUpdateOneWithoutClientIndividualMinorPropertiesNestedInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientIndividualMinorPropertiesNestedInput
  }

  export type ClientIndividualMinorPropertiesCreateManyInput = {
    id?: number
    dob?: Date | string | null
    snils?: string | null
    birthCertificate?: string | null
    clientPassportId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientIndividualMinorPropertiesUpdateManyMutationInput = {
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birthCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientIndividualMinorPropertiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birthCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    clientPassportId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEntityPropertiesCreateInput = {
    kpp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutClientEntityPropertiesInput
  }

  export type ClientEntityPropertiesUncheckedCreateInput = {
    id?: number
    kpp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientUncheckedCreateNestedOneWithoutClientEntityPropertiesInput
  }

  export type ClientEntityPropertiesUpdateInput = {
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutClientEntityPropertiesNestedInput
  }

  export type ClientEntityPropertiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUncheckedUpdateOneWithoutClientEntityPropertiesNestedInput
  }

  export type ClientEntityPropertiesCreateManyInput = {
    id?: number
    kpp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientEntityPropertiesUpdateManyMutationInput = {
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEntityPropertiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientToClientIndividualMinorPropertiesCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutClientsToClientIndividualMinorPropertiesInput
    clientIndividualMinorProperties: ClientIndividualMinorPropertiesCreateNestedOneWithoutClientsToClientIndividualMinorPropertiesInput
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedCreateInput = {
    clientId: number
    clientIndividualMinorPropertiesId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientToClientIndividualMinorPropertiesUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutClientsToClientIndividualMinorPropertiesNestedInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesUpdateOneRequiredWithoutClientsToClientIndividualMinorPropertiesNestedInput
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedUpdateInput = {
    clientId?: IntFieldUpdateOperationsInput | number
    clientIndividualMinorPropertiesId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientToClientIndividualMinorPropertiesCreateManyInput = {
    clientId: number
    clientIndividualMinorPropertiesId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientToClientIndividualMinorPropertiesUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedUpdateManyInput = {
    clientId?: IntFieldUpdateOperationsInput | number
    clientIndividualMinorPropertiesId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientPassportCreateInput = {
    number?: string | null
    issued?: string | null
    code?: string | null
    placeOfBirth?: string | null
    registrationAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientIndividualProperties?: ClientIndividualPropertiesCreateNestedOneWithoutClientPassportInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesCreateNestedOneWithoutClientPassportInput
  }

  export type ClientPassportUncheckedCreateInput = {
    id?: number
    number?: string | null
    issued?: string | null
    code?: string | null
    placeOfBirth?: string | null
    registrationAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientIndividualProperties?: ClientIndividualPropertiesUncheckedCreateNestedOneWithoutClientPassportInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesUncheckedCreateNestedOneWithoutClientPassportInput
  }

  export type ClientPassportUpdateInput = {
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issued?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    registrationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientIndividualProperties?: ClientIndividualPropertiesUpdateOneWithoutClientPassportNestedInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesUpdateOneWithoutClientPassportNestedInput
  }

  export type ClientPassportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issued?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    registrationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientIndividualProperties?: ClientIndividualPropertiesUncheckedUpdateOneWithoutClientPassportNestedInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesUncheckedUpdateOneWithoutClientPassportNestedInput
  }

  export type ClientPassportCreateManyInput = {
    id?: number
    number?: string | null
    issued?: string | null
    code?: string | null
    placeOfBirth?: string | null
    registrationAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientPassportUpdateManyMutationInput = {
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issued?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    registrationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientPassportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issued?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    registrationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractCreateInput = {
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActCreateNestedOneWithoutClientContractInput
    dduClientContractProperties?: DduClientContractPropertiesCreateNestedOneWithoutClientContractInput
    dkpClientContractProperties?: DkpClientContractPropertiesCreateNestedOneWithoutClientContractInput
    product: ProductCreateNestedOneWithoutClientContractInput
    object: ObjectCreateNestedOneWithoutClientContractsInput
    realEstateAgent?: RealEstateAgentCreateNestedOneWithoutClientContractsInput
    manager?: UserCreateNestedOneWithoutClientContractsInput
    bank?: BankCreateNestedOneWithoutClientContractsInput
    subsidy?: SubsidyCreateNestedOneWithoutClientContractsInput
    scheduledPayments?: ScheduledPaymentCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractUncheckedCreateInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    realEstateAgentId?: number | null
    managerId?: number | null
    bankId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActUncheckedCreateNestedOneWithoutClientContractInput
    scheduledPayments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentUncheckedCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractUpdateInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneWithoutClientContractNestedInput
    dduClientContractProperties?: DduClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    dkpClientContractProperties?: DkpClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    product?: ProductUpdateOneRequiredWithoutClientContractNestedInput
    object?: ObjectUpdateOneRequiredWithoutClientContractsNestedInput
    realEstateAgent?: RealEstateAgentUpdateOneWithoutClientContractsNestedInput
    manager?: UserUpdateOneWithoutClientContractsNestedInput
    bank?: BankUpdateOneWithoutClientContractsNestedInput
    subsidy?: SubsidyUpdateOneWithoutClientContractsNestedInput
    scheduledPayments?: ScheduledPaymentUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUncheckedUpdateOneWithoutClientContractNestedInput
    scheduledPayments?: ScheduledPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractCreateManyInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    realEstateAgentId?: number | null
    managerId?: number | null
    bankId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientContractUpdateManyMutationInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DduClientContractPropertiesCreateInput = {
    dduLink?: string | null
    returnAccount?: string | null
    escrowAccountOpeningDate?: Date | string | null
    escrowPeriod?: Date | string | null
    escrowAccountNumber?: string | null
    isEscrowDiscount?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract?: ClientContractCreateNestedOneWithoutDduClientContractPropertiesInput
  }

  export type DduClientContractPropertiesUncheckedCreateInput = {
    id?: number
    dduLink?: string | null
    returnAccount?: string | null
    escrowAccountOpeningDate?: Date | string | null
    escrowPeriod?: Date | string | null
    escrowAccountNumber?: string | null
    isEscrowDiscount?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract?: ClientContractUncheckedCreateNestedOneWithoutDduClientContractPropertiesInput
  }

  export type DduClientContractPropertiesUpdateInput = {
    dduLink?: NullableStringFieldUpdateOperationsInput | string | null
    returnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    escrowAccountOpeningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrowPeriod?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrowAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isEscrowDiscount?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUpdateOneWithoutDduClientContractPropertiesNestedInput
  }

  export type DduClientContractPropertiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dduLink?: NullableStringFieldUpdateOperationsInput | string | null
    returnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    escrowAccountOpeningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrowPeriod?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrowAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isEscrowDiscount?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUncheckedUpdateOneWithoutDduClientContractPropertiesNestedInput
  }

  export type DduClientContractPropertiesCreateManyInput = {
    id?: number
    dduLink?: string | null
    returnAccount?: string | null
    escrowAccountOpeningDate?: Date | string | null
    escrowPeriod?: Date | string | null
    escrowAccountNumber?: string | null
    isEscrowDiscount?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DduClientContractPropertiesUpdateManyMutationInput = {
    dduLink?: NullableStringFieldUpdateOperationsInput | string | null
    returnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    escrowAccountOpeningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrowPeriod?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrowAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isEscrowDiscount?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DduClientContractPropertiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dduLink?: NullableStringFieldUpdateOperationsInput | string | null
    returnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    escrowAccountOpeningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrowPeriod?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrowAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isEscrowDiscount?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DkpClientContractPropertiesCreateInput = {
    dkpLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract?: ClientContractCreateNestedOneWithoutDkpClientContractPropertiesInput
  }

  export type DkpClientContractPropertiesUncheckedCreateInput = {
    id?: number
    dkpLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract?: ClientContractUncheckedCreateNestedOneWithoutDkpClientContractPropertiesInput
  }

  export type DkpClientContractPropertiesUpdateInput = {
    dkpLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUpdateOneWithoutDkpClientContractPropertiesNestedInput
  }

  export type DkpClientContractPropertiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dkpLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUncheckedUpdateOneWithoutDkpClientContractPropertiesNestedInput
  }

  export type DkpClientContractPropertiesCreateManyInput = {
    id?: number
    dkpLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DkpClientContractPropertiesUpdateManyMutationInput = {
    dkpLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DkpClientContractPropertiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dkpLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToAgencyContractCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract: ClientContractCreateNestedOneWithoutClientContractsToAgencyContractsInput
    agencyContract: AgencyContractCreateNestedOneWithoutClientContractsToAgencyContractsInput
  }

  export type ClientContractToAgencyContractUncheckedCreateInput = {
    clientContractId: number
    agencyContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientContractToAgencyContractUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUpdateOneRequiredWithoutClientContractsToAgencyContractsNestedInput
    agencyContract?: AgencyContractUpdateOneRequiredWithoutClientContractsToAgencyContractsNestedInput
  }

  export type ClientContractToAgencyContractUncheckedUpdateInput = {
    clientContractId?: IntFieldUpdateOperationsInput | number
    agencyContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToAgencyContractCreateManyInput = {
    clientContractId: number
    agencyContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientContractToAgencyContractUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToAgencyContractUncheckedUpdateManyInput = {
    clientContractId?: IntFieldUpdateOperationsInput | number
    agencyContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToClientCreateInput = {
    isMain: boolean
    share: number
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutClientContractsToClientsInput
    clientContract: ClientContractCreateNestedOneWithoutClientContractsToClientsInput
  }

  export type ClientContractToClientUncheckedCreateInput = {
    isMain: boolean
    share: number
    clientContractId: number
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientContractToClientUpdateInput = {
    isMain?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutClientContractsToClientsNestedInput
    clientContract?: ClientContractUpdateOneRequiredWithoutClientContractsToClientsNestedInput
  }

  export type ClientContractToClientUncheckedUpdateInput = {
    isMain?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    clientContractId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToClientCreateManyInput = {
    isMain: boolean
    share: number
    clientContractId: number
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientContractToClientUpdateManyMutationInput = {
    isMain?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToClientUncheckedUpdateManyInput = {
    isMain?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    clientContractId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPaymentCreateInput = {
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    scheduledPaymentType: $Enums.ScheduledPaymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract: ClientContractCreateNestedOneWithoutScheduledPaymentsInput
  }

  export type ScheduledPaymentUncheckedCreateInput = {
    id?: number
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    scheduledPaymentType: $Enums.ScheduledPaymentType
    clientContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledPaymentUpdateInput = {
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledPaymentType?: EnumScheduledPaymentTypeFieldUpdateOperationsInput | $Enums.ScheduledPaymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUpdateOneRequiredWithoutScheduledPaymentsNestedInput
  }

  export type ScheduledPaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledPaymentType?: EnumScheduledPaymentTypeFieldUpdateOperationsInput | $Enums.ScheduledPaymentType
    clientContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPaymentCreateManyInput = {
    id?: number
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    scheduledPaymentType: $Enums.ScheduledPaymentType
    clientContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledPaymentUpdateManyMutationInput = {
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledPaymentType?: EnumScheduledPaymentTypeFieldUpdateOperationsInput | $Enums.ScheduledPaymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledPaymentType?: EnumScheduledPaymentTypeFieldUpdateOperationsInput | $Enums.ScheduledPaymentType
    clientContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActualPaymentCreateInput = {
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract: ClientContractCreateNestedOneWithoutActualPaymentsInput
  }

  export type ActualPaymentUncheckedCreateInput = {
    id?: number
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    clientContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActualPaymentUpdateInput = {
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUpdateOneRequiredWithoutActualPaymentsNestedInput
  }

  export type ActualPaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActualPaymentCreateManyInput = {
    id?: number
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    clientContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActualPaymentUpdateManyMutationInput = {
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActualPaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObjectCreateInput = {
    commonDbObjectsId: number
    name: string
    dateIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entity: EntityCreateNestedOneWithoutObjectsInput
    products?: ProductCreateNestedManyWithoutObjectInput
    clientContracts?: ClientContractCreateNestedManyWithoutObjectInput
    agencyContracts?: AgencyContractCreateNestedManyWithoutObjectInput
    transferActs?: TransferActCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateInput = {
    id?: number
    commonDbObjectsId: number
    name: string
    dateIn?: Date | string | null
    entityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutObjectInput
    clientContracts?: ClientContractUncheckedCreateNestedManyWithoutObjectInput
    agencyContracts?: AgencyContractUncheckedCreateNestedManyWithoutObjectInput
    transferActs?: TransferActUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectUpdateInput = {
    commonDbObjectsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: EntityUpdateOneRequiredWithoutObjectsNestedInput
    products?: ProductUpdateManyWithoutObjectNestedInput
    clientContracts?: ClientContractUpdateManyWithoutObjectNestedInput
    agencyContracts?: AgencyContractUpdateManyWithoutObjectNestedInput
    transferActs?: TransferActUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbObjectsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutObjectNestedInput
    clientContracts?: ClientContractUncheckedUpdateManyWithoutObjectNestedInput
    agencyContracts?: AgencyContractUncheckedUpdateManyWithoutObjectNestedInput
    transferActs?: TransferActUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type ObjectCreateManyInput = {
    id?: number
    commonDbObjectsId: number
    name: string
    dateIn?: Date | string | null
    entityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ObjectUpdateManyMutationInput = {
    commonDbObjectsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbObjectsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    pricingProductsId: number
    number: string
    productCategory: $Enums.ProductCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActCreateNestedOneWithoutProductInput
    clientContract?: ClientContractCreateNestedOneWithoutProductInput
    object: ObjectCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    pricingProductsId: number
    number: string
    productCategory: $Enums.ProductCategory
    objectId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActUncheckedCreateNestedOneWithoutProductInput
    clientContract?: ClientContractUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductUpdateInput = {
    pricingProductsId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    productCategory?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneWithoutProductNestedInput
    clientContract?: ClientContractUpdateOneWithoutProductNestedInput
    object?: ObjectUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pricingProductsId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    productCategory?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    objectId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUncheckedUpdateOneWithoutProductNestedInput
    clientContract?: ClientContractUncheckedUpdateOneWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    pricingProductsId: number
    number: string
    productCategory: $Enums.ProductCategory
    objectId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    pricingProductsId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    productCategory?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pricingProductsId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    productCategory?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    objectId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyCreateInput = {
    commonDbContractorsId: number
    name: string
    inn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractCreateNestedManyWithoutAgencyInput
    agencyContractSignatory?: AgencyContractSignatoryCreateNestedManyWithoutAgencyInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutAgencyInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateInput = {
    id?: number
    commonDbContractorsId: number
    name: string
    inn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractUncheckedCreateNestedManyWithoutAgencyInput
    agencyContractSignatory?: AgencyContractSignatoryUncheckedCreateNestedManyWithoutAgencyInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutAgencyInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUpdateInput = {
    commonDbContractorsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUpdateManyWithoutAgencyNestedInput
    agencyContractSignatory?: AgencyContractSignatoryUpdateManyWithoutAgencyNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutAgencyNestedInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbContractorsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUncheckedUpdateManyWithoutAgencyNestedInput
    agencyContractSignatory?: AgencyContractSignatoryUncheckedUpdateManyWithoutAgencyNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutAgencyNestedInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyCreateManyInput = {
    id?: number
    commonDbContractorsId: number
    name: string
    inn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyUpdateManyMutationInput = {
    commonDbContractorsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbContractorsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyContractCreateInput = {
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responsibleUser?: UserCreateNestedOneWithoutAgencyContractsInput
    entity: EntityCreateNestedOneWithoutAgencyContractsInput
    object: ObjectCreateNestedOneWithoutAgencyContractsInput
    agency: AgencyCreateNestedOneWithoutAgencyContractsInput
    agencyContractSignatory?: AgencyContractSignatoryCreateNestedOneWithoutAgencyContractsInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput
    realEstateAgencyAct?: RealEstateAgencyActCreateNestedManyWithoutAgencyContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractUncheckedCreateInput = {
    id?: number
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    responsibleUserId?: number | null
    entityId: number
    objectId: number
    agencyId: number
    agencyContractSignatoryId?: number | null
    realEstateAgencyContractPropertiesId?: number | null
    mipAgencyContractPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    realEstateAgencyAct?: RealEstateAgencyActUncheckedCreateNestedManyWithoutAgencyContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractUpdateInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUser?: UserUpdateOneWithoutAgencyContractsNestedInput
    entity?: EntityUpdateOneRequiredWithoutAgencyContractsNestedInput
    object?: ObjectUpdateOneRequiredWithoutAgencyContractsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgencyContractsNestedInput
    agencyContractSignatory?: AgencyContractSignatoryUpdateOneWithoutAgencyContractsNestedInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput
    realEstateAgencyAct?: RealEstateAgencyActUpdateManyWithoutAgencyContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutAgencyContractNestedInput
  }

  export type AgencyContractUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    entityId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    agencyContractSignatoryId?: NullableIntFieldUpdateOperationsInput | number | null
    realEstateAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    mipAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstateAgencyAct?: RealEstateAgencyActUncheckedUpdateManyWithoutAgencyContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutAgencyContractNestedInput
  }

  export type AgencyContractCreateManyInput = {
    id?: number
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    responsibleUserId?: number | null
    entityId: number
    objectId: number
    agencyId: number
    agencyContractSignatoryId?: number | null
    realEstateAgencyContractPropertiesId?: number | null
    mipAgencyContractPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyContractUpdateManyMutationInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyContractUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    entityId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    agencyContractSignatoryId?: NullableIntFieldUpdateOperationsInput | number | null
    realEstateAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    mipAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyContractSignatoryCreateInput = {
    fullName: string
    basedOn?: string | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutAgencyContractSignatoryInput
    agencyContracts?: AgencyContractCreateNestedManyWithoutAgencyContractSignatoryInput
  }

  export type AgencyContractSignatoryUncheckedCreateInput = {
    id?: number
    fullName: string
    basedOn?: string | null
    title?: string | null
    agencyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractUncheckedCreateNestedManyWithoutAgencyContractSignatoryInput
  }

  export type AgencyContractSignatoryUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    basedOn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutAgencyContractSignatoryNestedInput
    agencyContracts?: AgencyContractUpdateManyWithoutAgencyContractSignatoryNestedInput
  }

  export type AgencyContractSignatoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    basedOn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUncheckedUpdateManyWithoutAgencyContractSignatoryNestedInput
  }

  export type AgencyContractSignatoryCreateManyInput = {
    id?: number
    fullName: string
    basedOn?: string | null
    title?: string | null
    agencyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyContractSignatoryUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    basedOn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyContractSignatoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    basedOn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealEstateAgencyContractPropertiesCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContract?: AgencyContractCreateNestedOneWithoutRealEstateAgencyContractPropertiesInput
    agencyContractCommission: AgencyContractCommissionCreateNestedOneWithoutRealEstateAgencyContractPropertiesInput
  }

  export type RealEstateAgencyContractPropertiesUncheckedCreateInput = {
    id?: number
    agencyContractCommissionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContract?: AgencyContractUncheckedCreateNestedOneWithoutRealEstateAgencyContractPropertiesInput
  }

  export type RealEstateAgencyContractPropertiesUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContract?: AgencyContractUpdateOneWithoutRealEstateAgencyContractPropertiesNestedInput
    agencyContractCommission?: AgencyContractCommissionUpdateOneRequiredWithoutRealEstateAgencyContractPropertiesNestedInput
  }

  export type RealEstateAgencyContractPropertiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    agencyContractCommissionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContract?: AgencyContractUncheckedUpdateOneWithoutRealEstateAgencyContractPropertiesNestedInput
  }

  export type RealEstateAgencyContractPropertiesCreateManyInput = {
    id?: number
    agencyContractCommissionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RealEstateAgencyContractPropertiesUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealEstateAgencyContractPropertiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    agencyContractCommissionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MipAgencyContractPropertiesCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContract?: AgencyContractCreateNestedOneWithoutMipAgencyContractPropertiesInput
    agencyContractCommission: AgencyContractCommissionCreateNestedOneWithoutMipAgencyContractPropertiesInput
  }

  export type MipAgencyContractPropertiesUncheckedCreateInput = {
    id?: number
    agencyContractCommissionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContract?: AgencyContractUncheckedCreateNestedOneWithoutMipAgencyContractPropertiesInput
  }

  export type MipAgencyContractPropertiesUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContract?: AgencyContractUpdateOneWithoutMipAgencyContractPropertiesNestedInput
    agencyContractCommission?: AgencyContractCommissionUpdateOneRequiredWithoutMipAgencyContractPropertiesNestedInput
  }

  export type MipAgencyContractPropertiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    agencyContractCommissionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContract?: AgencyContractUncheckedUpdateOneWithoutMipAgencyContractPropertiesNestedInput
  }

  export type MipAgencyContractPropertiesCreateManyInput = {
    id?: number
    agencyContractCommissionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MipAgencyContractPropertiesUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MipAgencyContractPropertiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    agencyContractCommissionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyContractCommissionCreateInput = {
    percent: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    maxDays: number
    createdAt?: Date | string
    updatedAt?: Date | string
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgencyContractCommissionInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesCreateNestedOneWithoutAgencyContractCommissionInput
  }

  export type AgencyContractCommissionUncheckedCreateInput = {
    id?: number
    percent: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    maxDays: number
    createdAt?: Date | string
    updatedAt?: Date | string
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesUncheckedCreateNestedOneWithoutAgencyContractCommissionInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesUncheckedCreateNestedOneWithoutAgencyContractCommissionInput
  }

  export type AgencyContractCommissionUpdateInput = {
    percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgencyContractCommissionNestedInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesUpdateOneWithoutAgencyContractCommissionNestedInput
  }

  export type AgencyContractCommissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesUncheckedUpdateOneWithoutAgencyContractCommissionNestedInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesUncheckedUpdateOneWithoutAgencyContractCommissionNestedInput
  }

  export type AgencyContractCommissionCreateManyInput = {
    id?: number
    percent: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    maxDays: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyContractCommissionUpdateManyMutationInput = {
    percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyContractCommissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealEstateAgentCreateInput = {
    fullName: string
    phone?: string | null
    oneGtId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContracts?: ClientContractCreateNestedManyWithoutRealEstateAgentInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentCreateNestedManyWithoutRealEstateAgentInput
  }

  export type RealEstateAgentUncheckedCreateInput = {
    id?: number
    fullName: string
    phone?: string | null
    oneGtId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContracts?: ClientContractUncheckedCreateNestedManyWithoutRealEstateAgentInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentUncheckedCreateNestedManyWithoutRealEstateAgentInput
  }

  export type RealEstateAgentUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    oneGtId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContracts?: ClientContractUpdateManyWithoutRealEstateAgentNestedInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentUpdateManyWithoutRealEstateAgentNestedInput
  }

  export type RealEstateAgentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    oneGtId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContracts?: ClientContractUncheckedUpdateManyWithoutRealEstateAgentNestedInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentUncheckedUpdateManyWithoutRealEstateAgentNestedInput
  }

  export type RealEstateAgentCreateManyInput = {
    id?: number
    fullName: string
    phone?: string | null
    oneGtId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RealEstateAgentUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    oneGtId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealEstateAgentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    oneGtId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyToRealEstateAgentCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutAgenciesToRealEstateAgentsInput
    realEstateAgent: RealEstateAgentCreateNestedOneWithoutAgenciesToRealEstateAgentsInput
  }

  export type AgencyToRealEstateAgentUncheckedCreateInput = {
    agencyId: number
    realEstateAgentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyToRealEstateAgentUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutAgenciesToRealEstateAgentsNestedInput
    realEstateAgent?: RealEstateAgentUpdateOneRequiredWithoutAgenciesToRealEstateAgentsNestedInput
  }

  export type AgencyToRealEstateAgentUncheckedUpdateInput = {
    agencyId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyToRealEstateAgentCreateManyInput = {
    agencyId: number
    realEstateAgentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyToRealEstateAgentUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyToRealEstateAgentUncheckedUpdateManyInput = {
    agencyId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityCreateInput = {
    commonDbEntitiesId: number
    commonContractorId?: number | null
    name: string
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractCreateNestedManyWithoutEntityInput
    objects?: ObjectCreateNestedManyWithoutEntityInput
    entityForbiddenWebsites?: EntityForbiddenWebsiteCreateNestedManyWithoutEntityInput
    entityForbiddenBrands?: EntityForbiddenBrandCreateNestedManyWithoutEntityInput
  }

  export type EntityUncheckedCreateInput = {
    id?: number
    commonDbEntitiesId: number
    commonContractorId?: number | null
    name: string
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractUncheckedCreateNestedManyWithoutEntityInput
    objects?: ObjectUncheckedCreateNestedManyWithoutEntityInput
    entityForbiddenWebsites?: EntityForbiddenWebsiteUncheckedCreateNestedManyWithoutEntityInput
    entityForbiddenBrands?: EntityForbiddenBrandUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityUpdateInput = {
    commonDbEntitiesId?: IntFieldUpdateOperationsInput | number
    commonContractorId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUpdateManyWithoutEntityNestedInput
    objects?: ObjectUpdateManyWithoutEntityNestedInput
    entityForbiddenWebsites?: EntityForbiddenWebsiteUpdateManyWithoutEntityNestedInput
    entityForbiddenBrands?: EntityForbiddenBrandUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbEntitiesId?: IntFieldUpdateOperationsInput | number
    commonContractorId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUncheckedUpdateManyWithoutEntityNestedInput
    objects?: ObjectUncheckedUpdateManyWithoutEntityNestedInput
    entityForbiddenWebsites?: EntityForbiddenWebsiteUncheckedUpdateManyWithoutEntityNestedInput
    entityForbiddenBrands?: EntityForbiddenBrandUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type EntityCreateManyInput = {
    id?: number
    commonDbEntitiesId: number
    commonContractorId?: number | null
    name: string
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EntityUpdateManyMutationInput = {
    commonDbEntitiesId?: IntFieldUpdateOperationsInput | number
    commonContractorId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbEntitiesId?: IntFieldUpdateOperationsInput | number
    commonContractorId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenWebsiteCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entity: EntityCreateNestedOneWithoutEntityForbiddenWebsitesInput
  }

  export type EntityForbiddenWebsiteUncheckedCreateInput = {
    id?: number
    name: string
    entityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EntityForbiddenWebsiteUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: EntityUpdateOneRequiredWithoutEntityForbiddenWebsitesNestedInput
  }

  export type EntityForbiddenWebsiteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenWebsiteCreateManyInput = {
    id?: number
    name: string
    entityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EntityForbiddenWebsiteUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenWebsiteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenBrandCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entity: EntityCreateNestedOneWithoutEntityForbiddenBrandsInput
  }

  export type EntityForbiddenBrandUncheckedCreateInput = {
    id?: number
    name: string
    entityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EntityForbiddenBrandUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: EntityUpdateOneRequiredWithoutEntityForbiddenBrandsNestedInput
  }

  export type EntityForbiddenBrandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenBrandCreateManyInput = {
    id?: number
    name: string
    entityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EntityForbiddenBrandUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenBrandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankCreateInput = {
    name: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContracts?: ClientContractCreateNestedManyWithoutBankInput
  }

  export type BankUncheckedCreateInput = {
    id?: number
    name: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContracts?: ClientContractUncheckedCreateNestedManyWithoutBankInput
  }

  export type BankUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContracts?: ClientContractUpdateManyWithoutBankNestedInput
  }

  export type BankUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContracts?: ClientContractUncheckedUpdateManyWithoutBankNestedInput
  }

  export type BankCreateManyInput = {
    id?: number
    name: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowAccountHistoryCreateInput = {
    status: $Enums.EscrowAccountStatus
    number: string
    openingDate: Date | string
    depositedAmount: Decimal | DecimalJsLike | number | string
    incomingBalance: Decimal | DecimalJsLike | number | string
    dateOfTransaction: Date | string
    transactionAmount: Decimal | DecimalJsLike | number | string
    outgoingBalance: Decimal | DecimalJsLike | number | string
    expirationDate: Date | string
    depositor: string
    depositorInn?: string | null
    dduNumber: string
    dduDate: Date | string
    loanAgreementNumber?: string | null
    loanAgreementDate?: Date | string | null
    closingDate?: Date | string | null
    builderInn: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EscrowAccountHistoryUncheckedCreateInput = {
    id?: number
    status: $Enums.EscrowAccountStatus
    number: string
    openingDate: Date | string
    depositedAmount: Decimal | DecimalJsLike | number | string
    incomingBalance: Decimal | DecimalJsLike | number | string
    dateOfTransaction: Date | string
    transactionAmount: Decimal | DecimalJsLike | number | string
    outgoingBalance: Decimal | DecimalJsLike | number | string
    expirationDate: Date | string
    depositor: string
    depositorInn?: string | null
    dduNumber: string
    dduDate: Date | string
    loanAgreementNumber?: string | null
    loanAgreementDate?: Date | string | null
    closingDate?: Date | string | null
    builderInn: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EscrowAccountHistoryUpdateInput = {
    status?: EnumEscrowAccountStatusFieldUpdateOperationsInput | $Enums.EscrowAccountStatus
    number?: StringFieldUpdateOperationsInput | string
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    depositedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateOfTransaction?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outgoingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    depositor?: StringFieldUpdateOperationsInput | string
    depositorInn?: NullableStringFieldUpdateOperationsInput | string | null
    dduNumber?: StringFieldUpdateOperationsInput | string
    dduDate?: DateTimeFieldUpdateOperationsInput | Date | string
    loanAgreementNumber?: NullableStringFieldUpdateOperationsInput | string | null
    loanAgreementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    builderInn?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowAccountHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumEscrowAccountStatusFieldUpdateOperationsInput | $Enums.EscrowAccountStatus
    number?: StringFieldUpdateOperationsInput | string
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    depositedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateOfTransaction?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outgoingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    depositor?: StringFieldUpdateOperationsInput | string
    depositorInn?: NullableStringFieldUpdateOperationsInput | string | null
    dduNumber?: StringFieldUpdateOperationsInput | string
    dduDate?: DateTimeFieldUpdateOperationsInput | Date | string
    loanAgreementNumber?: NullableStringFieldUpdateOperationsInput | string | null
    loanAgreementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    builderInn?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowAccountHistoryCreateManyInput = {
    id?: number
    status: $Enums.EscrowAccountStatus
    number: string
    openingDate: Date | string
    depositedAmount: Decimal | DecimalJsLike | number | string
    incomingBalance: Decimal | DecimalJsLike | number | string
    dateOfTransaction: Date | string
    transactionAmount: Decimal | DecimalJsLike | number | string
    outgoingBalance: Decimal | DecimalJsLike | number | string
    expirationDate: Date | string
    depositor: string
    depositorInn?: string | null
    dduNumber: string
    dduDate: Date | string
    loanAgreementNumber?: string | null
    loanAgreementDate?: Date | string | null
    closingDate?: Date | string | null
    builderInn: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EscrowAccountHistoryUpdateManyMutationInput = {
    status?: EnumEscrowAccountStatusFieldUpdateOperationsInput | $Enums.EscrowAccountStatus
    number?: StringFieldUpdateOperationsInput | string
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    depositedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateOfTransaction?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outgoingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    depositor?: StringFieldUpdateOperationsInput | string
    depositorInn?: NullableStringFieldUpdateOperationsInput | string | null
    dduNumber?: StringFieldUpdateOperationsInput | string
    dduDate?: DateTimeFieldUpdateOperationsInput | Date | string
    loanAgreementNumber?: NullableStringFieldUpdateOperationsInput | string | null
    loanAgreementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    builderInn?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowAccountHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumEscrowAccountStatusFieldUpdateOperationsInput | $Enums.EscrowAccountStatus
    number?: StringFieldUpdateOperationsInput | string
    openingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    depositedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateOfTransaction?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outgoingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    depositor?: StringFieldUpdateOperationsInput | string
    depositorInn?: NullableStringFieldUpdateOperationsInput | string | null
    dduNumber?: StringFieldUpdateOperationsInput | string
    dduDate?: DateTimeFieldUpdateOperationsInput | Date | string
    loanAgreementNumber?: NullableStringFieldUpdateOperationsInput | string | null
    loanAgreementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    builderInn?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealEstateAgencyActCreateInput = {
    number: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    retention?: Decimal | DecimalJsLike | number | string | null
    note?: string | null
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract: ClientContractCreateNestedOneWithoutRealEstateAgencyActsInput
    agency: AgencyCreateNestedOneWithoutRealEstateAgencyActsInput
    agencyContract: AgencyContractCreateNestedOneWithoutRealEstateAgencyActInput
  }

  export type RealEstateAgencyActUncheckedCreateInput = {
    id?: number
    number: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    retention?: Decimal | DecimalJsLike | number | string | null
    note?: string | null
    link?: string | null
    clientContractId: number
    agencyId: number
    agencyContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RealEstateAgencyActUpdateInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retention?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUpdateOneRequiredWithoutRealEstateAgencyActsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutRealEstateAgencyActsNestedInput
    agencyContract?: AgencyContractUpdateOneRequiredWithoutRealEstateAgencyActNestedInput
  }

  export type RealEstateAgencyActUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retention?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    clientContractId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    agencyContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealEstateAgencyActCreateManyInput = {
    id?: number
    number: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    retention?: Decimal | DecimalJsLike | number | string | null
    note?: string | null
    link?: string | null
    clientContractId: number
    agencyId: number
    agencyContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RealEstateAgencyActUpdateManyMutationInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retention?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealEstateAgencyActUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retention?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    clientContractId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    agencyContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubsidyCreateInput = {
    name: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContracts?: ClientContractCreateNestedManyWithoutSubsidyInput
  }

  export type SubsidyUncheckedCreateInput = {
    id?: number
    name: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContracts?: ClientContractUncheckedCreateNestedManyWithoutSubsidyInput
  }

  export type SubsidyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContracts?: ClientContractUpdateManyWithoutSubsidyNestedInput
  }

  export type SubsidyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContracts?: ClientContractUncheckedUpdateManyWithoutSubsidyNestedInput
  }

  export type SubsidyCreateManyInput = {
    id?: number
    name: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubsidyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubsidyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentCreateInput = {
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract: ClientContractCreateNestedOneWithoutAssignmentsInput
    client: ClientCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentUncheckedCreateInput = {
    id?: number
    order: number
    clientContractId: number
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentUpdateInput = {
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUpdateOneRequiredWithoutAssignmentsNestedInput
    client?: ClientUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    clientContractId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentCreateManyInput = {
    id?: number
    order: number
    clientContractId: number
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentUpdateManyMutationInput = {
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    clientContractId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferActCreateInput = {
    number: string
    date: Date | string
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract: ClientContractCreateNestedOneWithoutTransferActInput
    object: ObjectCreateNestedOneWithoutTransferActsInput
    product: ProductCreateNestedOneWithoutTransferActInput
    transferActsToRepresentatives?: TransferActToRepresentativeCreateNestedManyWithoutTransferActInput
  }

  export type TransferActUncheckedCreateInput = {
    id?: number
    number: string
    date: Date | string
    link?: string | null
    clientContractId: number
    objectId: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transferActsToRepresentatives?: TransferActToRepresentativeUncheckedCreateNestedManyWithoutTransferActInput
  }

  export type TransferActUpdateInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUpdateOneRequiredWithoutTransferActNestedInput
    object?: ObjectUpdateOneRequiredWithoutTransferActsNestedInput
    product?: ProductUpdateOneRequiredWithoutTransferActNestedInput
    transferActsToRepresentatives?: TransferActToRepresentativeUpdateManyWithoutTransferActNestedInput
  }

  export type TransferActUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    clientContractId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferActsToRepresentatives?: TransferActToRepresentativeUncheckedUpdateManyWithoutTransferActNestedInput
  }

  export type TransferActCreateManyInput = {
    id?: number
    number: string
    date: Date | string
    link?: string | null
    clientContractId: number
    objectId: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferActUpdateManyMutationInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferActUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    clientContractId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepresentativeCreateInput = {
    fullName: string
    attorneyNumber?: string | null
    attorneyDate?: Date | string | null
    authorizedBy?: string | null
    authorizedRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutRepresentativesInput
    transferActsToRepresentatives?: TransferActToRepresentativeCreateNestedManyWithoutRepresentativeInput
  }

  export type RepresentativeUncheckedCreateInput = {
    id?: number
    fullName: string
    attorneyNumber?: string | null
    attorneyDate?: Date | string | null
    authorizedBy?: string | null
    authorizedRole?: string | null
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transferActsToRepresentatives?: TransferActToRepresentativeUncheckedCreateNestedManyWithoutRepresentativeInput
  }

  export type RepresentativeUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    attorneyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    attorneyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizedBy?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutRepresentativesNestedInput
    transferActsToRepresentatives?: TransferActToRepresentativeUpdateManyWithoutRepresentativeNestedInput
  }

  export type RepresentativeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    attorneyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    attorneyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizedBy?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedRole?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferActsToRepresentatives?: TransferActToRepresentativeUncheckedUpdateManyWithoutRepresentativeNestedInput
  }

  export type RepresentativeCreateManyInput = {
    id?: number
    fullName: string
    attorneyNumber?: string | null
    attorneyDate?: Date | string | null
    authorizedBy?: string | null
    authorizedRole?: string | null
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RepresentativeUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    attorneyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    attorneyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizedBy?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepresentativeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    attorneyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    attorneyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizedBy?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedRole?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferActToRepresentativeCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct: TransferActCreateNestedOneWithoutTransferActsToRepresentativesInput
    representative: RepresentativeCreateNestedOneWithoutTransferActsToRepresentativesInput
  }

  export type TransferActToRepresentativeUncheckedCreateInput = {
    transferActId: number
    representativeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferActToRepresentativeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneRequiredWithoutTransferActsToRepresentativesNestedInput
    representative?: RepresentativeUpdateOneRequiredWithoutTransferActsToRepresentativesNestedInput
  }

  export type TransferActToRepresentativeUncheckedUpdateInput = {
    transferActId?: IntFieldUpdateOperationsInput | number
    representativeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferActToRepresentativeCreateManyInput = {
    transferActId: number
    representativeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferActToRepresentativeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferActToRepresentativeUncheckedUpdateManyInput = {
    transferActId?: IntFieldUpdateOperationsInput | number
    representativeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ClientContractListRelationFilter = {
    every?: ClientContractWhereInput
    some?: ClientContractWhereInput
    none?: ClientContractWhereInput
  }

  export type AgencyContractListRelationFilter = {
    every?: AgencyContractWhereInput
    some?: AgencyContractWhereInput
    none?: AgencyContractWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ClientContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    isManager?: SortOrder
    isStaff?: SortOrder
    userRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    isManager?: SortOrder
    isStaff?: SortOrder
    userRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    isManager?: SortOrder
    isStaff?: SortOrder
    userRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumClientCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientCategory | EnumClientCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ClientCategory[]
    notIn?: $Enums.ClientCategory[]
    not?: NestedEnumClientCategoryFilter<$PrismaModel> | $Enums.ClientCategory
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ClientIndividualPropertiesNullableRelationFilter = {
    is?: ClientIndividualPropertiesWhereInput | null
    isNot?: ClientIndividualPropertiesWhereInput | null
  }

  export type ClientIndividualMinorPropertiesNullableRelationFilter = {
    is?: ClientIndividualMinorPropertiesWhereInput | null
    isNot?: ClientIndividualMinorPropertiesWhereInput | null
  }

  export type ClientEntityPropertiesNullableRelationFilter = {
    is?: ClientEntityPropertiesWhereInput | null
    isNot?: ClientEntityPropertiesWhereInput | null
  }

  export type AssignmentListRelationFilter = {
    every?: AssignmentWhereInput
    some?: AssignmentWhereInput
    none?: AssignmentWhereInput
  }

  export type ClientToClientIndividualMinorPropertiesListRelationFilter = {
    every?: ClientToClientIndividualMinorPropertiesWhereInput
    some?: ClientToClientIndividualMinorPropertiesWhereInput
    none?: ClientToClientIndividualMinorPropertiesWhereInput
  }

  export type ClientContractToClientListRelationFilter = {
    every?: ClientContractToClientWhereInput
    some?: ClientContractToClientWhereInput
    none?: ClientContractToClientWhereInput
  }

  export type RepresentativeListRelationFilter = {
    every?: RepresentativeWhereInput
    some?: RepresentativeWhereInput
    none?: RepresentativeWhereInput
  }

  export type AssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientToClientIndividualMinorPropertiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientContractToClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RepresentativeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    inn?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    clientCategory?: SortOrder
    clientIndividualPropertiesId?: SortOrder
    clientIndividualMinorPropertiesId?: SortOrder
    clientEntityPropertiesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    id?: SortOrder
    clientIndividualPropertiesId?: SortOrder
    clientIndividualMinorPropertiesId?: SortOrder
    clientEntityPropertiesId?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    inn?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    clientCategory?: SortOrder
    clientIndividualPropertiesId?: SortOrder
    clientIndividualMinorPropertiesId?: SortOrder
    clientEntityPropertiesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    inn?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    clientCategory?: SortOrder
    clientIndividualPropertiesId?: SortOrder
    clientIndividualMinorPropertiesId?: SortOrder
    clientEntityPropertiesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    id?: SortOrder
    clientIndividualPropertiesId?: SortOrder
    clientIndividualMinorPropertiesId?: SortOrder
    clientEntityPropertiesId?: SortOrder
  }

  export type EnumClientCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientCategory | EnumClientCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ClientCategory[]
    notIn?: $Enums.ClientCategory[]
    not?: NestedEnumClientCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ClientCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientCategoryFilter<$PrismaModel>
    _max?: NestedEnumClientCategoryFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ClientNullableRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type ClientPassportNullableRelationFilter = {
    is?: ClientPassportWhereInput | null
    isNot?: ClientPassportWhereInput | null
  }

  export type ClientIndividualPropertiesCountOrderByAggregateInput = {
    id?: SortOrder
    dob?: SortOrder
    snils?: SortOrder
    clientPassportId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientIndividualPropertiesAvgOrderByAggregateInput = {
    id?: SortOrder
    clientPassportId?: SortOrder
  }

  export type ClientIndividualPropertiesMaxOrderByAggregateInput = {
    id?: SortOrder
    dob?: SortOrder
    snils?: SortOrder
    clientPassportId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientIndividualPropertiesMinOrderByAggregateInput = {
    id?: SortOrder
    dob?: SortOrder
    snils?: SortOrder
    clientPassportId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientIndividualPropertiesSumOrderByAggregateInput = {
    id?: SortOrder
    clientPassportId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ClientIndividualMinorPropertiesCountOrderByAggregateInput = {
    id?: SortOrder
    dob?: SortOrder
    snils?: SortOrder
    birthCertificate?: SortOrder
    clientPassportId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientIndividualMinorPropertiesAvgOrderByAggregateInput = {
    id?: SortOrder
    clientPassportId?: SortOrder
  }

  export type ClientIndividualMinorPropertiesMaxOrderByAggregateInput = {
    id?: SortOrder
    dob?: SortOrder
    snils?: SortOrder
    birthCertificate?: SortOrder
    clientPassportId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientIndividualMinorPropertiesMinOrderByAggregateInput = {
    id?: SortOrder
    dob?: SortOrder
    snils?: SortOrder
    birthCertificate?: SortOrder
    clientPassportId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientIndividualMinorPropertiesSumOrderByAggregateInput = {
    id?: SortOrder
    clientPassportId?: SortOrder
  }

  export type ClientEntityPropertiesCountOrderByAggregateInput = {
    id?: SortOrder
    kpp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientEntityPropertiesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClientEntityPropertiesMaxOrderByAggregateInput = {
    id?: SortOrder
    kpp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientEntityPropertiesMinOrderByAggregateInput = {
    id?: SortOrder
    kpp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientEntityPropertiesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClientRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type ClientIndividualMinorPropertiesRelationFilter = {
    is?: ClientIndividualMinorPropertiesWhereInput
    isNot?: ClientIndividualMinorPropertiesWhereInput
  }

  export type ClientToClientIndividualMinorPropertiesClientIdClientIndividualMinorPropertiesIdCompoundUniqueInput = {
    clientId: number
    clientIndividualMinorPropertiesId: number
  }

  export type ClientToClientIndividualMinorPropertiesCountOrderByAggregateInput = {
    clientId?: SortOrder
    clientIndividualMinorPropertiesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientToClientIndividualMinorPropertiesAvgOrderByAggregateInput = {
    clientId?: SortOrder
    clientIndividualMinorPropertiesId?: SortOrder
  }

  export type ClientToClientIndividualMinorPropertiesMaxOrderByAggregateInput = {
    clientId?: SortOrder
    clientIndividualMinorPropertiesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientToClientIndividualMinorPropertiesMinOrderByAggregateInput = {
    clientId?: SortOrder
    clientIndividualMinorPropertiesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientToClientIndividualMinorPropertiesSumOrderByAggregateInput = {
    clientId?: SortOrder
    clientIndividualMinorPropertiesId?: SortOrder
  }

  export type ClientPassportCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    issued?: SortOrder
    code?: SortOrder
    placeOfBirth?: SortOrder
    registrationAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientPassportAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClientPassportMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    issued?: SortOrder
    code?: SortOrder
    placeOfBirth?: SortOrder
    registrationAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientPassportMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    issued?: SortOrder
    code?: SortOrder
    placeOfBirth?: SortOrder
    registrationAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientPassportSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumClientContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientContractType | EnumClientContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientContractType[]
    notIn?: $Enums.ClientContractType[]
    not?: NestedEnumClientContractTypeFilter<$PrismaModel> | $Enums.ClientContractType
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type TransferActNullableRelationFilter = {
    is?: TransferActWhereInput | null
    isNot?: TransferActWhereInput | null
  }

  export type DduClientContractPropertiesNullableRelationFilter = {
    is?: DduClientContractPropertiesWhereInput | null
    isNot?: DduClientContractPropertiesWhereInput | null
  }

  export type DkpClientContractPropertiesNullableRelationFilter = {
    is?: DkpClientContractPropertiesWhereInput | null
    isNot?: DkpClientContractPropertiesWhereInput | null
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ObjectRelationFilter = {
    is?: ObjectWhereInput
    isNot?: ObjectWhereInput
  }

  export type RealEstateAgentNullableRelationFilter = {
    is?: RealEstateAgentWhereInput | null
    isNot?: RealEstateAgentWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type BankNullableRelationFilter = {
    is?: BankWhereInput | null
    isNot?: BankWhereInput | null
  }

  export type SubsidyNullableRelationFilter = {
    is?: SubsidyWhereInput | null
    isNot?: SubsidyWhereInput | null
  }

  export type ScheduledPaymentListRelationFilter = {
    every?: ScheduledPaymentWhereInput
    some?: ScheduledPaymentWhereInput
    none?: ScheduledPaymentWhereInput
  }

  export type ActualPaymentListRelationFilter = {
    every?: ActualPaymentWhereInput
    some?: ActualPaymentWhereInput
    none?: ActualPaymentWhereInput
  }

  export type RealEstateAgencyActListRelationFilter = {
    every?: RealEstateAgencyActWhereInput
    some?: RealEstateAgencyActWhereInput
    none?: RealEstateAgencyActWhereInput
  }

  export type ClientContractToAgencyContractListRelationFilter = {
    every?: ClientContractToAgencyContractWhereInput
    some?: ClientContractToAgencyContractWhereInput
    none?: ClientContractToAgencyContractWhereInput
  }

  export type ScheduledPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActualPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RealEstateAgencyActOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientContractToAgencyContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientContractCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    registrationDate?: SortOrder
    price?: SortOrder
    clientContractType?: SortOrder
    isRealEstateAgencyActDisabled?: SortOrder
    isTransferActDisabled?: SortOrder
    comment?: SortOrder
    link?: SortOrder
    uuContractId?: SortOrder
    dduClientContractPropertiesId?: SortOrder
    dkpClientContractPropertiesId?: SortOrder
    productId?: SortOrder
    objectId?: SortOrder
    realEstateAgentId?: SortOrder
    managerId?: SortOrder
    bankId?: SortOrder
    subsidyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientContractAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    uuContractId?: SortOrder
    dduClientContractPropertiesId?: SortOrder
    dkpClientContractPropertiesId?: SortOrder
    productId?: SortOrder
    objectId?: SortOrder
    realEstateAgentId?: SortOrder
    managerId?: SortOrder
    bankId?: SortOrder
    subsidyId?: SortOrder
  }

  export type ClientContractMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    registrationDate?: SortOrder
    price?: SortOrder
    clientContractType?: SortOrder
    isRealEstateAgencyActDisabled?: SortOrder
    isTransferActDisabled?: SortOrder
    comment?: SortOrder
    link?: SortOrder
    uuContractId?: SortOrder
    dduClientContractPropertiesId?: SortOrder
    dkpClientContractPropertiesId?: SortOrder
    productId?: SortOrder
    objectId?: SortOrder
    realEstateAgentId?: SortOrder
    managerId?: SortOrder
    bankId?: SortOrder
    subsidyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientContractMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    registrationDate?: SortOrder
    price?: SortOrder
    clientContractType?: SortOrder
    isRealEstateAgencyActDisabled?: SortOrder
    isTransferActDisabled?: SortOrder
    comment?: SortOrder
    link?: SortOrder
    uuContractId?: SortOrder
    dduClientContractPropertiesId?: SortOrder
    dkpClientContractPropertiesId?: SortOrder
    productId?: SortOrder
    objectId?: SortOrder
    realEstateAgentId?: SortOrder
    managerId?: SortOrder
    bankId?: SortOrder
    subsidyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientContractSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    uuContractId?: SortOrder
    dduClientContractPropertiesId?: SortOrder
    dkpClientContractPropertiesId?: SortOrder
    productId?: SortOrder
    objectId?: SortOrder
    realEstateAgentId?: SortOrder
    managerId?: SortOrder
    bankId?: SortOrder
    subsidyId?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumClientContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientContractType | EnumClientContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientContractType[]
    notIn?: $Enums.ClientContractType[]
    not?: NestedEnumClientContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientContractTypeFilter<$PrismaModel>
    _max?: NestedEnumClientContractTypeFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ClientContractNullableRelationFilter = {
    is?: ClientContractWhereInput | null
    isNot?: ClientContractWhereInput | null
  }

  export type DduClientContractPropertiesCountOrderByAggregateInput = {
    id?: SortOrder
    dduLink?: SortOrder
    returnAccount?: SortOrder
    escrowAccountOpeningDate?: SortOrder
    escrowPeriod?: SortOrder
    escrowAccountNumber?: SortOrder
    isEscrowDiscount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DduClientContractPropertiesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DduClientContractPropertiesMaxOrderByAggregateInput = {
    id?: SortOrder
    dduLink?: SortOrder
    returnAccount?: SortOrder
    escrowAccountOpeningDate?: SortOrder
    escrowPeriod?: SortOrder
    escrowAccountNumber?: SortOrder
    isEscrowDiscount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DduClientContractPropertiesMinOrderByAggregateInput = {
    id?: SortOrder
    dduLink?: SortOrder
    returnAccount?: SortOrder
    escrowAccountOpeningDate?: SortOrder
    escrowPeriod?: SortOrder
    escrowAccountNumber?: SortOrder
    isEscrowDiscount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DduClientContractPropertiesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DkpClientContractPropertiesCountOrderByAggregateInput = {
    id?: SortOrder
    dkpLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DkpClientContractPropertiesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DkpClientContractPropertiesMaxOrderByAggregateInput = {
    id?: SortOrder
    dkpLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DkpClientContractPropertiesMinOrderByAggregateInput = {
    id?: SortOrder
    dkpLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DkpClientContractPropertiesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClientContractRelationFilter = {
    is?: ClientContractWhereInput
    isNot?: ClientContractWhereInput
  }

  export type AgencyContractRelationFilter = {
    is?: AgencyContractWhereInput
    isNot?: AgencyContractWhereInput
  }

  export type ClientContractToAgencyContractClientContractIdAgencyContractIdCompoundUniqueInput = {
    clientContractId: number
    agencyContractId: number
  }

  export type ClientContractToAgencyContractCountOrderByAggregateInput = {
    clientContractId?: SortOrder
    agencyContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientContractToAgencyContractAvgOrderByAggregateInput = {
    clientContractId?: SortOrder
    agencyContractId?: SortOrder
  }

  export type ClientContractToAgencyContractMaxOrderByAggregateInput = {
    clientContractId?: SortOrder
    agencyContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientContractToAgencyContractMinOrderByAggregateInput = {
    clientContractId?: SortOrder
    agencyContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientContractToAgencyContractSumOrderByAggregateInput = {
    clientContractId?: SortOrder
    agencyContractId?: SortOrder
  }

  export type ClientContractToClientClientContractIdClientIdCompoundUniqueInput = {
    clientContractId: number
    clientId: number
  }

  export type ClientContractToClientCountOrderByAggregateInput = {
    isMain?: SortOrder
    share?: SortOrder
    clientContractId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientContractToClientAvgOrderByAggregateInput = {
    share?: SortOrder
    clientContractId?: SortOrder
    clientId?: SortOrder
  }

  export type ClientContractToClientMaxOrderByAggregateInput = {
    isMain?: SortOrder
    share?: SortOrder
    clientContractId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientContractToClientMinOrderByAggregateInput = {
    isMain?: SortOrder
    share?: SortOrder
    clientContractId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientContractToClientSumOrderByAggregateInput = {
    share?: SortOrder
    clientContractId?: SortOrder
    clientId?: SortOrder
  }

  export type EnumScheduledPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledPaymentType | EnumScheduledPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledPaymentType[]
    notIn?: $Enums.ScheduledPaymentType[]
    not?: NestedEnumScheduledPaymentTypeFilter<$PrismaModel> | $Enums.ScheduledPaymentType
  }

  export type ScheduledPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    scheduledPaymentType?: SortOrder
    clientContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledPaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    clientContractId?: SortOrder
  }

  export type ScheduledPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    scheduledPaymentType?: SortOrder
    clientContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    scheduledPaymentType?: SortOrder
    clientContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledPaymentSumOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    clientContractId?: SortOrder
  }

  export type EnumScheduledPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledPaymentType | EnumScheduledPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledPaymentType[]
    notIn?: $Enums.ScheduledPaymentType[]
    not?: NestedEnumScheduledPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScheduledPaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduledPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumScheduledPaymentTypeFilter<$PrismaModel>
  }

  export type ActualPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    clientContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActualPaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    clientContractId?: SortOrder
  }

  export type ActualPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    clientContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActualPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    date?: SortOrder
    clientContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActualPaymentSumOrderByAggregateInput = {
    id?: SortOrder
    payment?: SortOrder
    clientContractId?: SortOrder
  }

  export type EntityRelationFilter = {
    is?: EntityWhereInput
    isNot?: EntityWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type TransferActListRelationFilter = {
    every?: TransferActWhereInput
    some?: TransferActWhereInput
    none?: TransferActWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferActOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObjectCountOrderByAggregateInput = {
    id?: SortOrder
    commonDbObjectsId?: SortOrder
    name?: SortOrder
    dateIn?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ObjectAvgOrderByAggregateInput = {
    id?: SortOrder
    commonDbObjectsId?: SortOrder
    entityId?: SortOrder
  }

  export type ObjectMaxOrderByAggregateInput = {
    id?: SortOrder
    commonDbObjectsId?: SortOrder
    name?: SortOrder
    dateIn?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ObjectMinOrderByAggregateInput = {
    id?: SortOrder
    commonDbObjectsId?: SortOrder
    name?: SortOrder
    dateIn?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ObjectSumOrderByAggregateInput = {
    id?: SortOrder
    commonDbObjectsId?: SortOrder
    entityId?: SortOrder
  }

  export type EnumProductCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCategory | EnumProductCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCategory[]
    notIn?: $Enums.ProductCategory[]
    not?: NestedEnumProductCategoryFilter<$PrismaModel> | $Enums.ProductCategory
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    pricingProductsId?: SortOrder
    number?: SortOrder
    productCategory?: SortOrder
    objectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    pricingProductsId?: SortOrder
    objectId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    pricingProductsId?: SortOrder
    number?: SortOrder
    productCategory?: SortOrder
    objectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    pricingProductsId?: SortOrder
    number?: SortOrder
    productCategory?: SortOrder
    objectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    pricingProductsId?: SortOrder
    objectId?: SortOrder
  }

  export type EnumProductCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCategory | EnumProductCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCategory[]
    notIn?: $Enums.ProductCategory[]
    not?: NestedEnumProductCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ProductCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductCategoryFilter<$PrismaModel>
    _max?: NestedEnumProductCategoryFilter<$PrismaModel>
  }

  export type AgencyContractSignatoryListRelationFilter = {
    every?: AgencyContractSignatoryWhereInput
    some?: AgencyContractSignatoryWhereInput
    none?: AgencyContractSignatoryWhereInput
  }

  export type AgencyToRealEstateAgentListRelationFilter = {
    every?: AgencyToRealEstateAgentWhereInput
    some?: AgencyToRealEstateAgentWhereInput
    none?: AgencyToRealEstateAgentWhereInput
  }

  export type AgencyContractSignatoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyToRealEstateAgentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyCountOrderByAggregateInput = {
    id?: SortOrder
    commonDbContractorsId?: SortOrder
    name?: SortOrder
    inn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyAvgOrderByAggregateInput = {
    id?: SortOrder
    commonDbContractorsId?: SortOrder
  }

  export type AgencyMaxOrderByAggregateInput = {
    id?: SortOrder
    commonDbContractorsId?: SortOrder
    name?: SortOrder
    inn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyMinOrderByAggregateInput = {
    id?: SortOrder
    commonDbContractorsId?: SortOrder
    name?: SortOrder
    inn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencySumOrderByAggregateInput = {
    id?: SortOrder
    commonDbContractorsId?: SortOrder
  }

  export type EnumAgencyContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyContractType | EnumAgencyContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyContractType[]
    notIn?: $Enums.AgencyContractType[]
    not?: NestedEnumAgencyContractTypeFilter<$PrismaModel> | $Enums.AgencyContractType
  }

  export type AgencyRelationFilter = {
    is?: AgencyWhereInput
    isNot?: AgencyWhereInput
  }

  export type AgencyContractSignatoryNullableRelationFilter = {
    is?: AgencyContractSignatoryWhereInput | null
    isNot?: AgencyContractSignatoryWhereInput | null
  }

  export type RealEstateAgencyContractPropertiesNullableRelationFilter = {
    is?: RealEstateAgencyContractPropertiesWhereInput | null
    isNot?: RealEstateAgencyContractPropertiesWhereInput | null
  }

  export type MipAgencyContractPropertiesNullableRelationFilter = {
    is?: MipAgencyContractPropertiesWhereInput | null
    isNot?: MipAgencyContractPropertiesWhereInput | null
  }

  export type AgencyContractCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    agencyContractType?: SortOrder
    link?: SortOrder
    responsibleUserId?: SortOrder
    entityId?: SortOrder
    objectId?: SortOrder
    agencyId?: SortOrder
    agencyContractSignatoryId?: SortOrder
    realEstateAgencyContractPropertiesId?: SortOrder
    mipAgencyContractPropertiesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyContractAvgOrderByAggregateInput = {
    id?: SortOrder
    responsibleUserId?: SortOrder
    entityId?: SortOrder
    objectId?: SortOrder
    agencyId?: SortOrder
    agencyContractSignatoryId?: SortOrder
    realEstateAgencyContractPropertiesId?: SortOrder
    mipAgencyContractPropertiesId?: SortOrder
  }

  export type AgencyContractMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    agencyContractType?: SortOrder
    link?: SortOrder
    responsibleUserId?: SortOrder
    entityId?: SortOrder
    objectId?: SortOrder
    agencyId?: SortOrder
    agencyContractSignatoryId?: SortOrder
    realEstateAgencyContractPropertiesId?: SortOrder
    mipAgencyContractPropertiesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyContractMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    agencyContractType?: SortOrder
    link?: SortOrder
    responsibleUserId?: SortOrder
    entityId?: SortOrder
    objectId?: SortOrder
    agencyId?: SortOrder
    agencyContractSignatoryId?: SortOrder
    realEstateAgencyContractPropertiesId?: SortOrder
    mipAgencyContractPropertiesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyContractSumOrderByAggregateInput = {
    id?: SortOrder
    responsibleUserId?: SortOrder
    entityId?: SortOrder
    objectId?: SortOrder
    agencyId?: SortOrder
    agencyContractSignatoryId?: SortOrder
    realEstateAgencyContractPropertiesId?: SortOrder
    mipAgencyContractPropertiesId?: SortOrder
  }

  export type EnumAgencyContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyContractType | EnumAgencyContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyContractType[]
    notIn?: $Enums.AgencyContractType[]
    not?: NestedEnumAgencyContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.AgencyContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgencyContractTypeFilter<$PrismaModel>
    _max?: NestedEnumAgencyContractTypeFilter<$PrismaModel>
  }

  export type AgencyContractSignatoryCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    basedOn?: SortOrder
    title?: SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyContractSignatoryAvgOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
  }

  export type AgencyContractSignatoryMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    basedOn?: SortOrder
    title?: SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyContractSignatoryMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    basedOn?: SortOrder
    title?: SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyContractSignatorySumOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
  }

  export type AgencyContractNullableRelationFilter = {
    is?: AgencyContractWhereInput | null
    isNot?: AgencyContractWhereInput | null
  }

  export type AgencyContractCommissionRelationFilter = {
    is?: AgencyContractCommissionWhereInput
    isNot?: AgencyContractCommissionWhereInput
  }

  export type RealEstateAgencyContractPropertiesCountOrderByAggregateInput = {
    id?: SortOrder
    agencyContractCommissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RealEstateAgencyContractPropertiesAvgOrderByAggregateInput = {
    id?: SortOrder
    agencyContractCommissionId?: SortOrder
  }

  export type RealEstateAgencyContractPropertiesMaxOrderByAggregateInput = {
    id?: SortOrder
    agencyContractCommissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RealEstateAgencyContractPropertiesMinOrderByAggregateInput = {
    id?: SortOrder
    agencyContractCommissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RealEstateAgencyContractPropertiesSumOrderByAggregateInput = {
    id?: SortOrder
    agencyContractCommissionId?: SortOrder
  }

  export type MipAgencyContractPropertiesCountOrderByAggregateInput = {
    id?: SortOrder
    agencyContractCommissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MipAgencyContractPropertiesAvgOrderByAggregateInput = {
    id?: SortOrder
    agencyContractCommissionId?: SortOrder
  }

  export type MipAgencyContractPropertiesMaxOrderByAggregateInput = {
    id?: SortOrder
    agencyContractCommissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MipAgencyContractPropertiesMinOrderByAggregateInput = {
    id?: SortOrder
    agencyContractCommissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MipAgencyContractPropertiesSumOrderByAggregateInput = {
    id?: SortOrder
    agencyContractCommissionId?: SortOrder
  }

  export type AgencyContractCommissionCountOrderByAggregateInput = {
    id?: SortOrder
    percent?: SortOrder
    threshold?: SortOrder
    maxDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyContractCommissionAvgOrderByAggregateInput = {
    id?: SortOrder
    percent?: SortOrder
    threshold?: SortOrder
    maxDays?: SortOrder
  }

  export type AgencyContractCommissionMaxOrderByAggregateInput = {
    id?: SortOrder
    percent?: SortOrder
    threshold?: SortOrder
    maxDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyContractCommissionMinOrderByAggregateInput = {
    id?: SortOrder
    percent?: SortOrder
    threshold?: SortOrder
    maxDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyContractCommissionSumOrderByAggregateInput = {
    id?: SortOrder
    percent?: SortOrder
    threshold?: SortOrder
    maxDays?: SortOrder
  }

  export type RealEstateAgentCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    oneGtId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RealEstateAgentAvgOrderByAggregateInput = {
    id?: SortOrder
    oneGtId?: SortOrder
  }

  export type RealEstateAgentMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    oneGtId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RealEstateAgentMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    oneGtId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RealEstateAgentSumOrderByAggregateInput = {
    id?: SortOrder
    oneGtId?: SortOrder
  }

  export type RealEstateAgentRelationFilter = {
    is?: RealEstateAgentWhereInput
    isNot?: RealEstateAgentWhereInput
  }

  export type AgencyToRealEstateAgentAgencyIdRealEstateAgentIdCompoundUniqueInput = {
    agencyId: number
    realEstateAgentId: number
  }

  export type AgencyToRealEstateAgentCountOrderByAggregateInput = {
    agencyId?: SortOrder
    realEstateAgentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyToRealEstateAgentAvgOrderByAggregateInput = {
    agencyId?: SortOrder
    realEstateAgentId?: SortOrder
  }

  export type AgencyToRealEstateAgentMaxOrderByAggregateInput = {
    agencyId?: SortOrder
    realEstateAgentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyToRealEstateAgentMinOrderByAggregateInput = {
    agencyId?: SortOrder
    realEstateAgentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyToRealEstateAgentSumOrderByAggregateInput = {
    agencyId?: SortOrder
    realEstateAgentId?: SortOrder
  }

  export type ObjectListRelationFilter = {
    every?: ObjectWhereInput
    some?: ObjectWhereInput
    none?: ObjectWhereInput
  }

  export type EntityForbiddenWebsiteListRelationFilter = {
    every?: EntityForbiddenWebsiteWhereInput
    some?: EntityForbiddenWebsiteWhereInput
    none?: EntityForbiddenWebsiteWhereInput
  }

  export type EntityForbiddenBrandListRelationFilter = {
    every?: EntityForbiddenBrandWhereInput
    some?: EntityForbiddenBrandWhereInput
    none?: EntityForbiddenBrandWhereInput
  }

  export type ObjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntityForbiddenWebsiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntityForbiddenBrandOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntityCountOrderByAggregateInput = {
    id?: SortOrder
    commonDbEntitiesId?: SortOrder
    commonContractorId?: SortOrder
    name?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EntityAvgOrderByAggregateInput = {
    id?: SortOrder
    commonDbEntitiesId?: SortOrder
    commonContractorId?: SortOrder
  }

  export type EntityMaxOrderByAggregateInput = {
    id?: SortOrder
    commonDbEntitiesId?: SortOrder
    commonContractorId?: SortOrder
    name?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EntityMinOrderByAggregateInput = {
    id?: SortOrder
    commonDbEntitiesId?: SortOrder
    commonContractorId?: SortOrder
    name?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EntitySumOrderByAggregateInput = {
    id?: SortOrder
    commonDbEntitiesId?: SortOrder
    commonContractorId?: SortOrder
  }

  export type EntityForbiddenWebsiteCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EntityForbiddenWebsiteAvgOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
  }

  export type EntityForbiddenWebsiteMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EntityForbiddenWebsiteMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EntityForbiddenWebsiteSumOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
  }

  export type EntityForbiddenBrandCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EntityForbiddenBrandAvgOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
  }

  export type EntityForbiddenBrandMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EntityForbiddenBrandMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EntityForbiddenBrandSumOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
  }

  export type BankCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isVisible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BankMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isVisible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isVisible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumEscrowAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EscrowAccountStatus | EnumEscrowAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EscrowAccountStatus[]
    notIn?: $Enums.EscrowAccountStatus[]
    not?: NestedEnumEscrowAccountStatusFilter<$PrismaModel> | $Enums.EscrowAccountStatus
  }

  export type EscrowAccountHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    number?: SortOrder
    openingDate?: SortOrder
    depositedAmount?: SortOrder
    incomingBalance?: SortOrder
    dateOfTransaction?: SortOrder
    transactionAmount?: SortOrder
    outgoingBalance?: SortOrder
    expirationDate?: SortOrder
    depositor?: SortOrder
    depositorInn?: SortOrder
    dduNumber?: SortOrder
    dduDate?: SortOrder
    loanAgreementNumber?: SortOrder
    loanAgreementDate?: SortOrder
    closingDate?: SortOrder
    builderInn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EscrowAccountHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    depositedAmount?: SortOrder
    incomingBalance?: SortOrder
    transactionAmount?: SortOrder
    outgoingBalance?: SortOrder
  }

  export type EscrowAccountHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    number?: SortOrder
    openingDate?: SortOrder
    depositedAmount?: SortOrder
    incomingBalance?: SortOrder
    dateOfTransaction?: SortOrder
    transactionAmount?: SortOrder
    outgoingBalance?: SortOrder
    expirationDate?: SortOrder
    depositor?: SortOrder
    depositorInn?: SortOrder
    dduNumber?: SortOrder
    dduDate?: SortOrder
    loanAgreementNumber?: SortOrder
    loanAgreementDate?: SortOrder
    closingDate?: SortOrder
    builderInn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EscrowAccountHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    number?: SortOrder
    openingDate?: SortOrder
    depositedAmount?: SortOrder
    incomingBalance?: SortOrder
    dateOfTransaction?: SortOrder
    transactionAmount?: SortOrder
    outgoingBalance?: SortOrder
    expirationDate?: SortOrder
    depositor?: SortOrder
    depositorInn?: SortOrder
    dduNumber?: SortOrder
    dduDate?: SortOrder
    loanAgreementNumber?: SortOrder
    loanAgreementDate?: SortOrder
    closingDate?: SortOrder
    builderInn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EscrowAccountHistorySumOrderByAggregateInput = {
    id?: SortOrder
    depositedAmount?: SortOrder
    incomingBalance?: SortOrder
    transactionAmount?: SortOrder
    outgoingBalance?: SortOrder
  }

  export type EnumEscrowAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EscrowAccountStatus | EnumEscrowAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EscrowAccountStatus[]
    notIn?: $Enums.EscrowAccountStatus[]
    not?: NestedEnumEscrowAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.EscrowAccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEscrowAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumEscrowAccountStatusFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type RealEstateAgencyActCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    retention?: SortOrder
    note?: SortOrder
    link?: SortOrder
    clientContractId?: SortOrder
    agencyId?: SortOrder
    agencyContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RealEstateAgencyActAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    retention?: SortOrder
    clientContractId?: SortOrder
    agencyId?: SortOrder
    agencyContractId?: SortOrder
  }

  export type RealEstateAgencyActMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    retention?: SortOrder
    note?: SortOrder
    link?: SortOrder
    clientContractId?: SortOrder
    agencyId?: SortOrder
    agencyContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RealEstateAgencyActMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    retention?: SortOrder
    note?: SortOrder
    link?: SortOrder
    clientContractId?: SortOrder
    agencyId?: SortOrder
    agencyContractId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RealEstateAgencyActSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    retention?: SortOrder
    clientContractId?: SortOrder
    agencyId?: SortOrder
    agencyContractId?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type SubsidyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isVisible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubsidyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SubsidyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isVisible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubsidyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isVisible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubsidySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    clientContractId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    clientContractId?: SortOrder
    clientId?: SortOrder
  }

  export type AssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    clientContractId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    clientContractId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    clientContractId?: SortOrder
    clientId?: SortOrder
  }

  export type TransferActToRepresentativeListRelationFilter = {
    every?: TransferActToRepresentativeWhereInput
    some?: TransferActToRepresentativeWhereInput
    none?: TransferActToRepresentativeWhereInput
  }

  export type TransferActToRepresentativeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferActCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    link?: SortOrder
    clientContractId?: SortOrder
    objectId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferActAvgOrderByAggregateInput = {
    id?: SortOrder
    clientContractId?: SortOrder
    objectId?: SortOrder
    productId?: SortOrder
  }

  export type TransferActMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    link?: SortOrder
    clientContractId?: SortOrder
    objectId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferActMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    link?: SortOrder
    clientContractId?: SortOrder
    objectId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferActSumOrderByAggregateInput = {
    id?: SortOrder
    clientContractId?: SortOrder
    objectId?: SortOrder
    productId?: SortOrder
  }

  export type RepresentativeCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    attorneyNumber?: SortOrder
    attorneyDate?: SortOrder
    authorizedBy?: SortOrder
    authorizedRole?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RepresentativeAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type RepresentativeMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    attorneyNumber?: SortOrder
    attorneyDate?: SortOrder
    authorizedBy?: SortOrder
    authorizedRole?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RepresentativeMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    attorneyNumber?: SortOrder
    attorneyDate?: SortOrder
    authorizedBy?: SortOrder
    authorizedRole?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RepresentativeSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type TransferActRelationFilter = {
    is?: TransferActWhereInput
    isNot?: TransferActWhereInput
  }

  export type RepresentativeRelationFilter = {
    is?: RepresentativeWhereInput
    isNot?: RepresentativeWhereInput
  }

  export type TransferActToRepresentativeTransferActIdRepresentativeIdCompoundUniqueInput = {
    transferActId: number
    representativeId: number
  }

  export type TransferActToRepresentativeCountOrderByAggregateInput = {
    transferActId?: SortOrder
    representativeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferActToRepresentativeAvgOrderByAggregateInput = {
    transferActId?: SortOrder
    representativeId?: SortOrder
  }

  export type TransferActToRepresentativeMaxOrderByAggregateInput = {
    transferActId?: SortOrder
    representativeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferActToRepresentativeMinOrderByAggregateInput = {
    transferActId?: SortOrder
    representativeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferActToRepresentativeSumOrderByAggregateInput = {
    transferActId?: SortOrder
    representativeId?: SortOrder
  }

  export type ClientContractCreateNestedManyWithoutManagerInput = {
    create?: XOR<ClientContractCreateWithoutManagerInput, ClientContractUncheckedCreateWithoutManagerInput> | ClientContractCreateWithoutManagerInput[] | ClientContractUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutManagerInput | ClientContractCreateOrConnectWithoutManagerInput[]
    createMany?: ClientContractCreateManyManagerInputEnvelope
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
  }

  export type AgencyContractCreateNestedManyWithoutResponsibleUserInput = {
    create?: XOR<AgencyContractCreateWithoutResponsibleUserInput, AgencyContractUncheckedCreateWithoutResponsibleUserInput> | AgencyContractCreateWithoutResponsibleUserInput[] | AgencyContractUncheckedCreateWithoutResponsibleUserInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutResponsibleUserInput | AgencyContractCreateOrConnectWithoutResponsibleUserInput[]
    createMany?: AgencyContractCreateManyResponsibleUserInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type ClientContractUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<ClientContractCreateWithoutManagerInput, ClientContractUncheckedCreateWithoutManagerInput> | ClientContractCreateWithoutManagerInput[] | ClientContractUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutManagerInput | ClientContractCreateOrConnectWithoutManagerInput[]
    createMany?: ClientContractCreateManyManagerInputEnvelope
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
  }

  export type AgencyContractUncheckedCreateNestedManyWithoutResponsibleUserInput = {
    create?: XOR<AgencyContractCreateWithoutResponsibleUserInput, AgencyContractUncheckedCreateWithoutResponsibleUserInput> | AgencyContractCreateWithoutResponsibleUserInput[] | AgencyContractUncheckedCreateWithoutResponsibleUserInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutResponsibleUserInput | AgencyContractCreateOrConnectWithoutResponsibleUserInput[]
    createMany?: AgencyContractCreateManyResponsibleUserInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ClientContractUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ClientContractCreateWithoutManagerInput, ClientContractUncheckedCreateWithoutManagerInput> | ClientContractCreateWithoutManagerInput[] | ClientContractUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutManagerInput | ClientContractCreateOrConnectWithoutManagerInput[]
    upsert?: ClientContractUpsertWithWhereUniqueWithoutManagerInput | ClientContractUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ClientContractCreateManyManagerInputEnvelope
    set?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    disconnect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    delete?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    update?: ClientContractUpdateWithWhereUniqueWithoutManagerInput | ClientContractUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ClientContractUpdateManyWithWhereWithoutManagerInput | ClientContractUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
  }

  export type AgencyContractUpdateManyWithoutResponsibleUserNestedInput = {
    create?: XOR<AgencyContractCreateWithoutResponsibleUserInput, AgencyContractUncheckedCreateWithoutResponsibleUserInput> | AgencyContractCreateWithoutResponsibleUserInput[] | AgencyContractUncheckedCreateWithoutResponsibleUserInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutResponsibleUserInput | AgencyContractCreateOrConnectWithoutResponsibleUserInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutResponsibleUserInput | AgencyContractUpsertWithWhereUniqueWithoutResponsibleUserInput[]
    createMany?: AgencyContractCreateManyResponsibleUserInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutResponsibleUserInput | AgencyContractUpdateWithWhereUniqueWithoutResponsibleUserInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutResponsibleUserInput | AgencyContractUpdateManyWithWhereWithoutResponsibleUserInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClientContractUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ClientContractCreateWithoutManagerInput, ClientContractUncheckedCreateWithoutManagerInput> | ClientContractCreateWithoutManagerInput[] | ClientContractUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutManagerInput | ClientContractCreateOrConnectWithoutManagerInput[]
    upsert?: ClientContractUpsertWithWhereUniqueWithoutManagerInput | ClientContractUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ClientContractCreateManyManagerInputEnvelope
    set?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    disconnect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    delete?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    update?: ClientContractUpdateWithWhereUniqueWithoutManagerInput | ClientContractUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ClientContractUpdateManyWithWhereWithoutManagerInput | ClientContractUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
  }

  export type AgencyContractUncheckedUpdateManyWithoutResponsibleUserNestedInput = {
    create?: XOR<AgencyContractCreateWithoutResponsibleUserInput, AgencyContractUncheckedCreateWithoutResponsibleUserInput> | AgencyContractCreateWithoutResponsibleUserInput[] | AgencyContractUncheckedCreateWithoutResponsibleUserInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutResponsibleUserInput | AgencyContractCreateOrConnectWithoutResponsibleUserInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutResponsibleUserInput | AgencyContractUpsertWithWhereUniqueWithoutResponsibleUserInput[]
    createMany?: AgencyContractCreateManyResponsibleUserInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutResponsibleUserInput | AgencyContractUpdateWithWhereUniqueWithoutResponsibleUserInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutResponsibleUserInput | AgencyContractUpdateManyWithWhereWithoutResponsibleUserInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type ClientIndividualPropertiesCreateNestedOneWithoutClientInput = {
    create?: XOR<ClientIndividualPropertiesCreateWithoutClientInput, ClientIndividualPropertiesUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientIndividualPropertiesCreateOrConnectWithoutClientInput
    connect?: ClientIndividualPropertiesWhereUniqueInput
  }

  export type ClientIndividualMinorPropertiesCreateNestedOneWithoutClientInput = {
    create?: XOR<ClientIndividualMinorPropertiesCreateWithoutClientInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput
    connect?: ClientIndividualMinorPropertiesWhereUniqueInput
  }

  export type ClientEntityPropertiesCreateNestedOneWithoutClientInput = {
    create?: XOR<ClientEntityPropertiesCreateWithoutClientInput, ClientEntityPropertiesUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientEntityPropertiesCreateOrConnectWithoutClientInput
    connect?: ClientEntityPropertiesWhereUniqueInput
  }

  export type AssignmentCreateNestedManyWithoutClientInput = {
    create?: XOR<AssignmentCreateWithoutClientInput, AssignmentUncheckedCreateWithoutClientInput> | AssignmentCreateWithoutClientInput[] | AssignmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClientInput | AssignmentCreateOrConnectWithoutClientInput[]
    createMany?: AssignmentCreateManyClientInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClientInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput> | ClientToClientIndividualMinorPropertiesCreateWithoutClientInput[] | ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput | ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput[]
    createMany?: ClientToClientIndividualMinorPropertiesCreateManyClientInputEnvelope
    connect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
  }

  export type ClientContractToClientCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientContractToClientCreateWithoutClientInput, ClientContractToClientUncheckedCreateWithoutClientInput> | ClientContractToClientCreateWithoutClientInput[] | ClientContractToClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientContractToClientCreateOrConnectWithoutClientInput | ClientContractToClientCreateOrConnectWithoutClientInput[]
    createMany?: ClientContractToClientCreateManyClientInputEnvelope
    connect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
  }

  export type RepresentativeCreateNestedManyWithoutClientInput = {
    create?: XOR<RepresentativeCreateWithoutClientInput, RepresentativeUncheckedCreateWithoutClientInput> | RepresentativeCreateWithoutClientInput[] | RepresentativeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RepresentativeCreateOrConnectWithoutClientInput | RepresentativeCreateOrConnectWithoutClientInput[]
    createMany?: RepresentativeCreateManyClientInputEnvelope
    connect?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<AssignmentCreateWithoutClientInput, AssignmentUncheckedCreateWithoutClientInput> | AssignmentCreateWithoutClientInput[] | AssignmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClientInput | AssignmentCreateOrConnectWithoutClientInput[]
    createMany?: AssignmentCreateManyClientInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClientInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput> | ClientToClientIndividualMinorPropertiesCreateWithoutClientInput[] | ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput | ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput[]
    createMany?: ClientToClientIndividualMinorPropertiesCreateManyClientInputEnvelope
    connect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
  }

  export type ClientContractToClientUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientContractToClientCreateWithoutClientInput, ClientContractToClientUncheckedCreateWithoutClientInput> | ClientContractToClientCreateWithoutClientInput[] | ClientContractToClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientContractToClientCreateOrConnectWithoutClientInput | ClientContractToClientCreateOrConnectWithoutClientInput[]
    createMany?: ClientContractToClientCreateManyClientInputEnvelope
    connect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
  }

  export type RepresentativeUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<RepresentativeCreateWithoutClientInput, RepresentativeUncheckedCreateWithoutClientInput> | RepresentativeCreateWithoutClientInput[] | RepresentativeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RepresentativeCreateOrConnectWithoutClientInput | RepresentativeCreateOrConnectWithoutClientInput[]
    createMany?: RepresentativeCreateManyClientInputEnvelope
    connect?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
  }

  export type EnumClientCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ClientCategory
  }

  export type ClientIndividualPropertiesUpdateOneWithoutClientNestedInput = {
    create?: XOR<ClientIndividualPropertiesCreateWithoutClientInput, ClientIndividualPropertiesUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientIndividualPropertiesCreateOrConnectWithoutClientInput
    upsert?: ClientIndividualPropertiesUpsertWithoutClientInput
    disconnect?: ClientIndividualPropertiesWhereInput | boolean
    delete?: ClientIndividualPropertiesWhereInput | boolean
    connect?: ClientIndividualPropertiesWhereUniqueInput
    update?: XOR<XOR<ClientIndividualPropertiesUpdateToOneWithWhereWithoutClientInput, ClientIndividualPropertiesUpdateWithoutClientInput>, ClientIndividualPropertiesUncheckedUpdateWithoutClientInput>
  }

  export type ClientIndividualMinorPropertiesUpdateOneWithoutClientNestedInput = {
    create?: XOR<ClientIndividualMinorPropertiesCreateWithoutClientInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput
    upsert?: ClientIndividualMinorPropertiesUpsertWithoutClientInput
    disconnect?: ClientIndividualMinorPropertiesWhereInput | boolean
    delete?: ClientIndividualMinorPropertiesWhereInput | boolean
    connect?: ClientIndividualMinorPropertiesWhereUniqueInput
    update?: XOR<XOR<ClientIndividualMinorPropertiesUpdateToOneWithWhereWithoutClientInput, ClientIndividualMinorPropertiesUpdateWithoutClientInput>, ClientIndividualMinorPropertiesUncheckedUpdateWithoutClientInput>
  }

  export type ClientEntityPropertiesUpdateOneWithoutClientNestedInput = {
    create?: XOR<ClientEntityPropertiesCreateWithoutClientInput, ClientEntityPropertiesUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientEntityPropertiesCreateOrConnectWithoutClientInput
    upsert?: ClientEntityPropertiesUpsertWithoutClientInput
    disconnect?: ClientEntityPropertiesWhereInput | boolean
    delete?: ClientEntityPropertiesWhereInput | boolean
    connect?: ClientEntityPropertiesWhereUniqueInput
    update?: XOR<XOR<ClientEntityPropertiesUpdateToOneWithWhereWithoutClientInput, ClientEntityPropertiesUpdateWithoutClientInput>, ClientEntityPropertiesUncheckedUpdateWithoutClientInput>
  }

  export type AssignmentUpdateManyWithoutClientNestedInput = {
    create?: XOR<AssignmentCreateWithoutClientInput, AssignmentUncheckedCreateWithoutClientInput> | AssignmentCreateWithoutClientInput[] | AssignmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClientInput | AssignmentCreateOrConnectWithoutClientInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutClientInput | AssignmentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AssignmentCreateManyClientInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutClientInput | AssignmentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutClientInput | AssignmentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type ClientToClientIndividualMinorPropertiesUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClientInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput> | ClientToClientIndividualMinorPropertiesCreateWithoutClientInput[] | ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput | ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput[]
    upsert?: ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClientInput | ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientToClientIndividualMinorPropertiesCreateManyClientInputEnvelope
    set?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    disconnect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    delete?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    connect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    update?: ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClientInput | ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClientInput | ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientToClientIndividualMinorPropertiesScalarWhereInput | ClientToClientIndividualMinorPropertiesScalarWhereInput[]
  }

  export type ClientContractToClientUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientContractToClientCreateWithoutClientInput, ClientContractToClientUncheckedCreateWithoutClientInput> | ClientContractToClientCreateWithoutClientInput[] | ClientContractToClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientContractToClientCreateOrConnectWithoutClientInput | ClientContractToClientCreateOrConnectWithoutClientInput[]
    upsert?: ClientContractToClientUpsertWithWhereUniqueWithoutClientInput | ClientContractToClientUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientContractToClientCreateManyClientInputEnvelope
    set?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    disconnect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    delete?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    connect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    update?: ClientContractToClientUpdateWithWhereUniqueWithoutClientInput | ClientContractToClientUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientContractToClientUpdateManyWithWhereWithoutClientInput | ClientContractToClientUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientContractToClientScalarWhereInput | ClientContractToClientScalarWhereInput[]
  }

  export type RepresentativeUpdateManyWithoutClientNestedInput = {
    create?: XOR<RepresentativeCreateWithoutClientInput, RepresentativeUncheckedCreateWithoutClientInput> | RepresentativeCreateWithoutClientInput[] | RepresentativeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RepresentativeCreateOrConnectWithoutClientInput | RepresentativeCreateOrConnectWithoutClientInput[]
    upsert?: RepresentativeUpsertWithWhereUniqueWithoutClientInput | RepresentativeUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: RepresentativeCreateManyClientInputEnvelope
    set?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
    disconnect?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
    delete?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
    connect?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
    update?: RepresentativeUpdateWithWhereUniqueWithoutClientInput | RepresentativeUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: RepresentativeUpdateManyWithWhereWithoutClientInput | RepresentativeUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: RepresentativeScalarWhereInput | RepresentativeScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AssignmentUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<AssignmentCreateWithoutClientInput, AssignmentUncheckedCreateWithoutClientInput> | AssignmentCreateWithoutClientInput[] | AssignmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClientInput | AssignmentCreateOrConnectWithoutClientInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutClientInput | AssignmentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AssignmentCreateManyClientInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutClientInput | AssignmentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutClientInput | AssignmentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClientInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput> | ClientToClientIndividualMinorPropertiesCreateWithoutClientInput[] | ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput | ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput[]
    upsert?: ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClientInput | ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientToClientIndividualMinorPropertiesCreateManyClientInputEnvelope
    set?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    disconnect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    delete?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    connect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    update?: ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClientInput | ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClientInput | ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientToClientIndividualMinorPropertiesScalarWhereInput | ClientToClientIndividualMinorPropertiesScalarWhereInput[]
  }

  export type ClientContractToClientUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientContractToClientCreateWithoutClientInput, ClientContractToClientUncheckedCreateWithoutClientInput> | ClientContractToClientCreateWithoutClientInput[] | ClientContractToClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientContractToClientCreateOrConnectWithoutClientInput | ClientContractToClientCreateOrConnectWithoutClientInput[]
    upsert?: ClientContractToClientUpsertWithWhereUniqueWithoutClientInput | ClientContractToClientUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientContractToClientCreateManyClientInputEnvelope
    set?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    disconnect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    delete?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    connect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    update?: ClientContractToClientUpdateWithWhereUniqueWithoutClientInput | ClientContractToClientUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientContractToClientUpdateManyWithWhereWithoutClientInput | ClientContractToClientUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientContractToClientScalarWhereInput | ClientContractToClientScalarWhereInput[]
  }

  export type RepresentativeUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<RepresentativeCreateWithoutClientInput, RepresentativeUncheckedCreateWithoutClientInput> | RepresentativeCreateWithoutClientInput[] | RepresentativeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RepresentativeCreateOrConnectWithoutClientInput | RepresentativeCreateOrConnectWithoutClientInput[]
    upsert?: RepresentativeUpsertWithWhereUniqueWithoutClientInput | RepresentativeUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: RepresentativeCreateManyClientInputEnvelope
    set?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
    disconnect?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
    delete?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
    connect?: RepresentativeWhereUniqueInput | RepresentativeWhereUniqueInput[]
    update?: RepresentativeUpdateWithWhereUniqueWithoutClientInput | RepresentativeUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: RepresentativeUpdateManyWithWhereWithoutClientInput | RepresentativeUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: RepresentativeScalarWhereInput | RepresentativeScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutClientIndividualPropertiesInput = {
    create?: XOR<ClientCreateWithoutClientIndividualPropertiesInput, ClientUncheckedCreateWithoutClientIndividualPropertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientIndividualPropertiesInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientPassportCreateNestedOneWithoutClientIndividualPropertiesInput = {
    create?: XOR<ClientPassportCreateWithoutClientIndividualPropertiesInput, ClientPassportUncheckedCreateWithoutClientIndividualPropertiesInput>
    connectOrCreate?: ClientPassportCreateOrConnectWithoutClientIndividualPropertiesInput
    connect?: ClientPassportWhereUniqueInput
  }

  export type ClientUncheckedCreateNestedOneWithoutClientIndividualPropertiesInput = {
    create?: XOR<ClientCreateWithoutClientIndividualPropertiesInput, ClientUncheckedCreateWithoutClientIndividualPropertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientIndividualPropertiesInput
    connect?: ClientWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ClientUpdateOneWithoutClientIndividualPropertiesNestedInput = {
    create?: XOR<ClientCreateWithoutClientIndividualPropertiesInput, ClientUncheckedCreateWithoutClientIndividualPropertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientIndividualPropertiesInput
    upsert?: ClientUpsertWithoutClientIndividualPropertiesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClientIndividualPropertiesInput, ClientUpdateWithoutClientIndividualPropertiesInput>, ClientUncheckedUpdateWithoutClientIndividualPropertiesInput>
  }

  export type ClientPassportUpdateOneWithoutClientIndividualPropertiesNestedInput = {
    create?: XOR<ClientPassportCreateWithoutClientIndividualPropertiesInput, ClientPassportUncheckedCreateWithoutClientIndividualPropertiesInput>
    connectOrCreate?: ClientPassportCreateOrConnectWithoutClientIndividualPropertiesInput
    upsert?: ClientPassportUpsertWithoutClientIndividualPropertiesInput
    disconnect?: ClientPassportWhereInput | boolean
    delete?: ClientPassportWhereInput | boolean
    connect?: ClientPassportWhereUniqueInput
    update?: XOR<XOR<ClientPassportUpdateToOneWithWhereWithoutClientIndividualPropertiesInput, ClientPassportUpdateWithoutClientIndividualPropertiesInput>, ClientPassportUncheckedUpdateWithoutClientIndividualPropertiesInput>
  }

  export type ClientUncheckedUpdateOneWithoutClientIndividualPropertiesNestedInput = {
    create?: XOR<ClientCreateWithoutClientIndividualPropertiesInput, ClientUncheckedCreateWithoutClientIndividualPropertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientIndividualPropertiesInput
    upsert?: ClientUpsertWithoutClientIndividualPropertiesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClientIndividualPropertiesInput, ClientUpdateWithoutClientIndividualPropertiesInput>, ClientUncheckedUpdateWithoutClientIndividualPropertiesInput>
  }

  export type ClientCreateNestedOneWithoutClientIndividualMinorPropertiesInput = {
    create?: XOR<ClientCreateWithoutClientIndividualMinorPropertiesInput, ClientUncheckedCreateWithoutClientIndividualMinorPropertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientIndividualMinorPropertiesInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientPassportCreateNestedOneWithoutClientIndividualMinorPropertiesInput = {
    create?: XOR<ClientPassportCreateWithoutClientIndividualMinorPropertiesInput, ClientPassportUncheckedCreateWithoutClientIndividualMinorPropertiesInput>
    connectOrCreate?: ClientPassportCreateOrConnectWithoutClientIndividualMinorPropertiesInput
    connect?: ClientPassportWhereUniqueInput
  }

  export type ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClientIndividualMinorPropertiesInput = {
    create?: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClientIndividualMinorPropertiesInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientIndividualMinorPropertiesInput> | ClientToClientIndividualMinorPropertiesCreateWithoutClientIndividualMinorPropertiesInput[] | ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientIndividualMinorPropertiesInput[]
    connectOrCreate?: ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientIndividualMinorPropertiesInput | ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientIndividualMinorPropertiesInput[]
    createMany?: ClientToClientIndividualMinorPropertiesCreateManyClientIndividualMinorPropertiesInputEnvelope
    connect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedOneWithoutClientIndividualMinorPropertiesInput = {
    create?: XOR<ClientCreateWithoutClientIndividualMinorPropertiesInput, ClientUncheckedCreateWithoutClientIndividualMinorPropertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientIndividualMinorPropertiesInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClientIndividualMinorPropertiesInput = {
    create?: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClientIndividualMinorPropertiesInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientIndividualMinorPropertiesInput> | ClientToClientIndividualMinorPropertiesCreateWithoutClientIndividualMinorPropertiesInput[] | ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientIndividualMinorPropertiesInput[]
    connectOrCreate?: ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientIndividualMinorPropertiesInput | ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientIndividualMinorPropertiesInput[]
    createMany?: ClientToClientIndividualMinorPropertiesCreateManyClientIndividualMinorPropertiesInputEnvelope
    connect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
  }

  export type ClientUpdateOneWithoutClientIndividualMinorPropertiesNestedInput = {
    create?: XOR<ClientCreateWithoutClientIndividualMinorPropertiesInput, ClientUncheckedCreateWithoutClientIndividualMinorPropertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientIndividualMinorPropertiesInput
    upsert?: ClientUpsertWithoutClientIndividualMinorPropertiesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClientIndividualMinorPropertiesInput, ClientUpdateWithoutClientIndividualMinorPropertiesInput>, ClientUncheckedUpdateWithoutClientIndividualMinorPropertiesInput>
  }

  export type ClientPassportUpdateOneWithoutClientIndividualMinorPropertiesNestedInput = {
    create?: XOR<ClientPassportCreateWithoutClientIndividualMinorPropertiesInput, ClientPassportUncheckedCreateWithoutClientIndividualMinorPropertiesInput>
    connectOrCreate?: ClientPassportCreateOrConnectWithoutClientIndividualMinorPropertiesInput
    upsert?: ClientPassportUpsertWithoutClientIndividualMinorPropertiesInput
    disconnect?: ClientPassportWhereInput | boolean
    delete?: ClientPassportWhereInput | boolean
    connect?: ClientPassportWhereUniqueInput
    update?: XOR<XOR<ClientPassportUpdateToOneWithWhereWithoutClientIndividualMinorPropertiesInput, ClientPassportUpdateWithoutClientIndividualMinorPropertiesInput>, ClientPassportUncheckedUpdateWithoutClientIndividualMinorPropertiesInput>
  }

  export type ClientToClientIndividualMinorPropertiesUpdateManyWithoutClientIndividualMinorPropertiesNestedInput = {
    create?: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClientIndividualMinorPropertiesInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientIndividualMinorPropertiesInput> | ClientToClientIndividualMinorPropertiesCreateWithoutClientIndividualMinorPropertiesInput[] | ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientIndividualMinorPropertiesInput[]
    connectOrCreate?: ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientIndividualMinorPropertiesInput | ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientIndividualMinorPropertiesInput[]
    upsert?: ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClientIndividualMinorPropertiesInput | ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClientIndividualMinorPropertiesInput[]
    createMany?: ClientToClientIndividualMinorPropertiesCreateManyClientIndividualMinorPropertiesInputEnvelope
    set?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    disconnect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    delete?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    connect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    update?: ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClientIndividualMinorPropertiesInput | ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClientIndividualMinorPropertiesInput[]
    updateMany?: ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClientIndividualMinorPropertiesInput | ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClientIndividualMinorPropertiesInput[]
    deleteMany?: ClientToClientIndividualMinorPropertiesScalarWhereInput | ClientToClientIndividualMinorPropertiesScalarWhereInput[]
  }

  export type ClientUncheckedUpdateOneWithoutClientIndividualMinorPropertiesNestedInput = {
    create?: XOR<ClientCreateWithoutClientIndividualMinorPropertiesInput, ClientUncheckedCreateWithoutClientIndividualMinorPropertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientIndividualMinorPropertiesInput
    upsert?: ClientUpsertWithoutClientIndividualMinorPropertiesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClientIndividualMinorPropertiesInput, ClientUpdateWithoutClientIndividualMinorPropertiesInput>, ClientUncheckedUpdateWithoutClientIndividualMinorPropertiesInput>
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientIndividualMinorPropertiesNestedInput = {
    create?: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClientIndividualMinorPropertiesInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientIndividualMinorPropertiesInput> | ClientToClientIndividualMinorPropertiesCreateWithoutClientIndividualMinorPropertiesInput[] | ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientIndividualMinorPropertiesInput[]
    connectOrCreate?: ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientIndividualMinorPropertiesInput | ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientIndividualMinorPropertiesInput[]
    upsert?: ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClientIndividualMinorPropertiesInput | ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClientIndividualMinorPropertiesInput[]
    createMany?: ClientToClientIndividualMinorPropertiesCreateManyClientIndividualMinorPropertiesInputEnvelope
    set?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    disconnect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    delete?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    connect?: ClientToClientIndividualMinorPropertiesWhereUniqueInput | ClientToClientIndividualMinorPropertiesWhereUniqueInput[]
    update?: ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClientIndividualMinorPropertiesInput | ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClientIndividualMinorPropertiesInput[]
    updateMany?: ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClientIndividualMinorPropertiesInput | ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClientIndividualMinorPropertiesInput[]
    deleteMany?: ClientToClientIndividualMinorPropertiesScalarWhereInput | ClientToClientIndividualMinorPropertiesScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutClientEntityPropertiesInput = {
    create?: XOR<ClientCreateWithoutClientEntityPropertiesInput, ClientUncheckedCreateWithoutClientEntityPropertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientEntityPropertiesInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUncheckedCreateNestedOneWithoutClientEntityPropertiesInput = {
    create?: XOR<ClientCreateWithoutClientEntityPropertiesInput, ClientUncheckedCreateWithoutClientEntityPropertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientEntityPropertiesInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUpdateOneWithoutClientEntityPropertiesNestedInput = {
    create?: XOR<ClientCreateWithoutClientEntityPropertiesInput, ClientUncheckedCreateWithoutClientEntityPropertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientEntityPropertiesInput
    upsert?: ClientUpsertWithoutClientEntityPropertiesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClientEntityPropertiesInput, ClientUpdateWithoutClientEntityPropertiesInput>, ClientUncheckedUpdateWithoutClientEntityPropertiesInput>
  }

  export type ClientUncheckedUpdateOneWithoutClientEntityPropertiesNestedInput = {
    create?: XOR<ClientCreateWithoutClientEntityPropertiesInput, ClientUncheckedCreateWithoutClientEntityPropertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientEntityPropertiesInput
    upsert?: ClientUpsertWithoutClientEntityPropertiesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClientEntityPropertiesInput, ClientUpdateWithoutClientEntityPropertiesInput>, ClientUncheckedUpdateWithoutClientEntityPropertiesInput>
  }

  export type ClientCreateNestedOneWithoutClientsToClientIndividualMinorPropertiesInput = {
    create?: XOR<ClientCreateWithoutClientsToClientIndividualMinorPropertiesInput, ClientUncheckedCreateWithoutClientsToClientIndividualMinorPropertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientsToClientIndividualMinorPropertiesInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientIndividualMinorPropertiesCreateNestedOneWithoutClientsToClientIndividualMinorPropertiesInput = {
    create?: XOR<ClientIndividualMinorPropertiesCreateWithoutClientsToClientIndividualMinorPropertiesInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClientsToClientIndividualMinorPropertiesInput>
    connectOrCreate?: ClientIndividualMinorPropertiesCreateOrConnectWithoutClientsToClientIndividualMinorPropertiesInput
    connect?: ClientIndividualMinorPropertiesWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutClientsToClientIndividualMinorPropertiesNestedInput = {
    create?: XOR<ClientCreateWithoutClientsToClientIndividualMinorPropertiesInput, ClientUncheckedCreateWithoutClientsToClientIndividualMinorPropertiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientsToClientIndividualMinorPropertiesInput
    upsert?: ClientUpsertWithoutClientsToClientIndividualMinorPropertiesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClientsToClientIndividualMinorPropertiesInput, ClientUpdateWithoutClientsToClientIndividualMinorPropertiesInput>, ClientUncheckedUpdateWithoutClientsToClientIndividualMinorPropertiesInput>
  }

  export type ClientIndividualMinorPropertiesUpdateOneRequiredWithoutClientsToClientIndividualMinorPropertiesNestedInput = {
    create?: XOR<ClientIndividualMinorPropertiesCreateWithoutClientsToClientIndividualMinorPropertiesInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClientsToClientIndividualMinorPropertiesInput>
    connectOrCreate?: ClientIndividualMinorPropertiesCreateOrConnectWithoutClientsToClientIndividualMinorPropertiesInput
    upsert?: ClientIndividualMinorPropertiesUpsertWithoutClientsToClientIndividualMinorPropertiesInput
    connect?: ClientIndividualMinorPropertiesWhereUniqueInput
    update?: XOR<XOR<ClientIndividualMinorPropertiesUpdateToOneWithWhereWithoutClientsToClientIndividualMinorPropertiesInput, ClientIndividualMinorPropertiesUpdateWithoutClientsToClientIndividualMinorPropertiesInput>, ClientIndividualMinorPropertiesUncheckedUpdateWithoutClientsToClientIndividualMinorPropertiesInput>
  }

  export type ClientIndividualPropertiesCreateNestedOneWithoutClientPassportInput = {
    create?: XOR<ClientIndividualPropertiesCreateWithoutClientPassportInput, ClientIndividualPropertiesUncheckedCreateWithoutClientPassportInput>
    connectOrCreate?: ClientIndividualPropertiesCreateOrConnectWithoutClientPassportInput
    connect?: ClientIndividualPropertiesWhereUniqueInput
  }

  export type ClientIndividualMinorPropertiesCreateNestedOneWithoutClientPassportInput = {
    create?: XOR<ClientIndividualMinorPropertiesCreateWithoutClientPassportInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClientPassportInput>
    connectOrCreate?: ClientIndividualMinorPropertiesCreateOrConnectWithoutClientPassportInput
    connect?: ClientIndividualMinorPropertiesWhereUniqueInput
  }

  export type ClientIndividualPropertiesUncheckedCreateNestedOneWithoutClientPassportInput = {
    create?: XOR<ClientIndividualPropertiesCreateWithoutClientPassportInput, ClientIndividualPropertiesUncheckedCreateWithoutClientPassportInput>
    connectOrCreate?: ClientIndividualPropertiesCreateOrConnectWithoutClientPassportInput
    connect?: ClientIndividualPropertiesWhereUniqueInput
  }

  export type ClientIndividualMinorPropertiesUncheckedCreateNestedOneWithoutClientPassportInput = {
    create?: XOR<ClientIndividualMinorPropertiesCreateWithoutClientPassportInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClientPassportInput>
    connectOrCreate?: ClientIndividualMinorPropertiesCreateOrConnectWithoutClientPassportInput
    connect?: ClientIndividualMinorPropertiesWhereUniqueInput
  }

  export type ClientIndividualPropertiesUpdateOneWithoutClientPassportNestedInput = {
    create?: XOR<ClientIndividualPropertiesCreateWithoutClientPassportInput, ClientIndividualPropertiesUncheckedCreateWithoutClientPassportInput>
    connectOrCreate?: ClientIndividualPropertiesCreateOrConnectWithoutClientPassportInput
    upsert?: ClientIndividualPropertiesUpsertWithoutClientPassportInput
    disconnect?: ClientIndividualPropertiesWhereInput | boolean
    delete?: ClientIndividualPropertiesWhereInput | boolean
    connect?: ClientIndividualPropertiesWhereUniqueInput
    update?: XOR<XOR<ClientIndividualPropertiesUpdateToOneWithWhereWithoutClientPassportInput, ClientIndividualPropertiesUpdateWithoutClientPassportInput>, ClientIndividualPropertiesUncheckedUpdateWithoutClientPassportInput>
  }

  export type ClientIndividualMinorPropertiesUpdateOneWithoutClientPassportNestedInput = {
    create?: XOR<ClientIndividualMinorPropertiesCreateWithoutClientPassportInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClientPassportInput>
    connectOrCreate?: ClientIndividualMinorPropertiesCreateOrConnectWithoutClientPassportInput
    upsert?: ClientIndividualMinorPropertiesUpsertWithoutClientPassportInput
    disconnect?: ClientIndividualMinorPropertiesWhereInput | boolean
    delete?: ClientIndividualMinorPropertiesWhereInput | boolean
    connect?: ClientIndividualMinorPropertiesWhereUniqueInput
    update?: XOR<XOR<ClientIndividualMinorPropertiesUpdateToOneWithWhereWithoutClientPassportInput, ClientIndividualMinorPropertiesUpdateWithoutClientPassportInput>, ClientIndividualMinorPropertiesUncheckedUpdateWithoutClientPassportInput>
  }

  export type ClientIndividualPropertiesUncheckedUpdateOneWithoutClientPassportNestedInput = {
    create?: XOR<ClientIndividualPropertiesCreateWithoutClientPassportInput, ClientIndividualPropertiesUncheckedCreateWithoutClientPassportInput>
    connectOrCreate?: ClientIndividualPropertiesCreateOrConnectWithoutClientPassportInput
    upsert?: ClientIndividualPropertiesUpsertWithoutClientPassportInput
    disconnect?: ClientIndividualPropertiesWhereInput | boolean
    delete?: ClientIndividualPropertiesWhereInput | boolean
    connect?: ClientIndividualPropertiesWhereUniqueInput
    update?: XOR<XOR<ClientIndividualPropertiesUpdateToOneWithWhereWithoutClientPassportInput, ClientIndividualPropertiesUpdateWithoutClientPassportInput>, ClientIndividualPropertiesUncheckedUpdateWithoutClientPassportInput>
  }

  export type ClientIndividualMinorPropertiesUncheckedUpdateOneWithoutClientPassportNestedInput = {
    create?: XOR<ClientIndividualMinorPropertiesCreateWithoutClientPassportInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClientPassportInput>
    connectOrCreate?: ClientIndividualMinorPropertiesCreateOrConnectWithoutClientPassportInput
    upsert?: ClientIndividualMinorPropertiesUpsertWithoutClientPassportInput
    disconnect?: ClientIndividualMinorPropertiesWhereInput | boolean
    delete?: ClientIndividualMinorPropertiesWhereInput | boolean
    connect?: ClientIndividualMinorPropertiesWhereUniqueInput
    update?: XOR<XOR<ClientIndividualMinorPropertiesUpdateToOneWithWhereWithoutClientPassportInput, ClientIndividualMinorPropertiesUpdateWithoutClientPassportInput>, ClientIndividualMinorPropertiesUncheckedUpdateWithoutClientPassportInput>
  }

  export type TransferActCreateNestedOneWithoutClientContractInput = {
    create?: XOR<TransferActCreateWithoutClientContractInput, TransferActUncheckedCreateWithoutClientContractInput>
    connectOrCreate?: TransferActCreateOrConnectWithoutClientContractInput
    connect?: TransferActWhereUniqueInput
  }

  export type DduClientContractPropertiesCreateNestedOneWithoutClientContractInput = {
    create?: XOR<DduClientContractPropertiesCreateWithoutClientContractInput, DduClientContractPropertiesUncheckedCreateWithoutClientContractInput>
    connectOrCreate?: DduClientContractPropertiesCreateOrConnectWithoutClientContractInput
    connect?: DduClientContractPropertiesWhereUniqueInput
  }

  export type DkpClientContractPropertiesCreateNestedOneWithoutClientContractInput = {
    create?: XOR<DkpClientContractPropertiesCreateWithoutClientContractInput, DkpClientContractPropertiesUncheckedCreateWithoutClientContractInput>
    connectOrCreate?: DkpClientContractPropertiesCreateOrConnectWithoutClientContractInput
    connect?: DkpClientContractPropertiesWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutClientContractInput = {
    create?: XOR<ProductCreateWithoutClientContractInput, ProductUncheckedCreateWithoutClientContractInput>
    connectOrCreate?: ProductCreateOrConnectWithoutClientContractInput
    connect?: ProductWhereUniqueInput
  }

  export type ObjectCreateNestedOneWithoutClientContractsInput = {
    create?: XOR<ObjectCreateWithoutClientContractsInput, ObjectUncheckedCreateWithoutClientContractsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutClientContractsInput
    connect?: ObjectWhereUniqueInput
  }

  export type RealEstateAgentCreateNestedOneWithoutClientContractsInput = {
    create?: XOR<RealEstateAgentCreateWithoutClientContractsInput, RealEstateAgentUncheckedCreateWithoutClientContractsInput>
    connectOrCreate?: RealEstateAgentCreateOrConnectWithoutClientContractsInput
    connect?: RealEstateAgentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClientContractsInput = {
    create?: XOR<UserCreateWithoutClientContractsInput, UserUncheckedCreateWithoutClientContractsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientContractsInput
    connect?: UserWhereUniqueInput
  }

  export type BankCreateNestedOneWithoutClientContractsInput = {
    create?: XOR<BankCreateWithoutClientContractsInput, BankUncheckedCreateWithoutClientContractsInput>
    connectOrCreate?: BankCreateOrConnectWithoutClientContractsInput
    connect?: BankWhereUniqueInput
  }

  export type SubsidyCreateNestedOneWithoutClientContractsInput = {
    create?: XOR<SubsidyCreateWithoutClientContractsInput, SubsidyUncheckedCreateWithoutClientContractsInput>
    connectOrCreate?: SubsidyCreateOrConnectWithoutClientContractsInput
    connect?: SubsidyWhereUniqueInput
  }

  export type ScheduledPaymentCreateNestedManyWithoutClientContractInput = {
    create?: XOR<ScheduledPaymentCreateWithoutClientContractInput, ScheduledPaymentUncheckedCreateWithoutClientContractInput> | ScheduledPaymentCreateWithoutClientContractInput[] | ScheduledPaymentUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: ScheduledPaymentCreateOrConnectWithoutClientContractInput | ScheduledPaymentCreateOrConnectWithoutClientContractInput[]
    createMany?: ScheduledPaymentCreateManyClientContractInputEnvelope
    connect?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
  }

  export type ActualPaymentCreateNestedManyWithoutClientContractInput = {
    create?: XOR<ActualPaymentCreateWithoutClientContractInput, ActualPaymentUncheckedCreateWithoutClientContractInput> | ActualPaymentCreateWithoutClientContractInput[] | ActualPaymentUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: ActualPaymentCreateOrConnectWithoutClientContractInput | ActualPaymentCreateOrConnectWithoutClientContractInput[]
    createMany?: ActualPaymentCreateManyClientContractInputEnvelope
    connect?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
  }

  export type RealEstateAgencyActCreateNestedManyWithoutClientContractInput = {
    create?: XOR<RealEstateAgencyActCreateWithoutClientContractInput, RealEstateAgencyActUncheckedCreateWithoutClientContractInput> | RealEstateAgencyActCreateWithoutClientContractInput[] | RealEstateAgencyActUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: RealEstateAgencyActCreateOrConnectWithoutClientContractInput | RealEstateAgencyActCreateOrConnectWithoutClientContractInput[]
    createMany?: RealEstateAgencyActCreateManyClientContractInputEnvelope
    connect?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
  }

  export type AssignmentCreateNestedManyWithoutClientContractInput = {
    create?: XOR<AssignmentCreateWithoutClientContractInput, AssignmentUncheckedCreateWithoutClientContractInput> | AssignmentCreateWithoutClientContractInput[] | AssignmentUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClientContractInput | AssignmentCreateOrConnectWithoutClientContractInput[]
    createMany?: AssignmentCreateManyClientContractInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type ClientContractToClientCreateNestedManyWithoutClientContractInput = {
    create?: XOR<ClientContractToClientCreateWithoutClientContractInput, ClientContractToClientUncheckedCreateWithoutClientContractInput> | ClientContractToClientCreateWithoutClientContractInput[] | ClientContractToClientUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: ClientContractToClientCreateOrConnectWithoutClientContractInput | ClientContractToClientCreateOrConnectWithoutClientContractInput[]
    createMany?: ClientContractToClientCreateManyClientContractInputEnvelope
    connect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
  }

  export type ClientContractToAgencyContractCreateNestedManyWithoutClientContractInput = {
    create?: XOR<ClientContractToAgencyContractCreateWithoutClientContractInput, ClientContractToAgencyContractUncheckedCreateWithoutClientContractInput> | ClientContractToAgencyContractCreateWithoutClientContractInput[] | ClientContractToAgencyContractUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: ClientContractToAgencyContractCreateOrConnectWithoutClientContractInput | ClientContractToAgencyContractCreateOrConnectWithoutClientContractInput[]
    createMany?: ClientContractToAgencyContractCreateManyClientContractInputEnvelope
    connect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
  }

  export type TransferActUncheckedCreateNestedOneWithoutClientContractInput = {
    create?: XOR<TransferActCreateWithoutClientContractInput, TransferActUncheckedCreateWithoutClientContractInput>
    connectOrCreate?: TransferActCreateOrConnectWithoutClientContractInput
    connect?: TransferActWhereUniqueInput
  }

  export type ScheduledPaymentUncheckedCreateNestedManyWithoutClientContractInput = {
    create?: XOR<ScheduledPaymentCreateWithoutClientContractInput, ScheduledPaymentUncheckedCreateWithoutClientContractInput> | ScheduledPaymentCreateWithoutClientContractInput[] | ScheduledPaymentUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: ScheduledPaymentCreateOrConnectWithoutClientContractInput | ScheduledPaymentCreateOrConnectWithoutClientContractInput[]
    createMany?: ScheduledPaymentCreateManyClientContractInputEnvelope
    connect?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
  }

  export type ActualPaymentUncheckedCreateNestedManyWithoutClientContractInput = {
    create?: XOR<ActualPaymentCreateWithoutClientContractInput, ActualPaymentUncheckedCreateWithoutClientContractInput> | ActualPaymentCreateWithoutClientContractInput[] | ActualPaymentUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: ActualPaymentCreateOrConnectWithoutClientContractInput | ActualPaymentCreateOrConnectWithoutClientContractInput[]
    createMany?: ActualPaymentCreateManyClientContractInputEnvelope
    connect?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
  }

  export type RealEstateAgencyActUncheckedCreateNestedManyWithoutClientContractInput = {
    create?: XOR<RealEstateAgencyActCreateWithoutClientContractInput, RealEstateAgencyActUncheckedCreateWithoutClientContractInput> | RealEstateAgencyActCreateWithoutClientContractInput[] | RealEstateAgencyActUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: RealEstateAgencyActCreateOrConnectWithoutClientContractInput | RealEstateAgencyActCreateOrConnectWithoutClientContractInput[]
    createMany?: RealEstateAgencyActCreateManyClientContractInputEnvelope
    connect?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutClientContractInput = {
    create?: XOR<AssignmentCreateWithoutClientContractInput, AssignmentUncheckedCreateWithoutClientContractInput> | AssignmentCreateWithoutClientContractInput[] | AssignmentUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClientContractInput | AssignmentCreateOrConnectWithoutClientContractInput[]
    createMany?: AssignmentCreateManyClientContractInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type ClientContractToClientUncheckedCreateNestedManyWithoutClientContractInput = {
    create?: XOR<ClientContractToClientCreateWithoutClientContractInput, ClientContractToClientUncheckedCreateWithoutClientContractInput> | ClientContractToClientCreateWithoutClientContractInput[] | ClientContractToClientUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: ClientContractToClientCreateOrConnectWithoutClientContractInput | ClientContractToClientCreateOrConnectWithoutClientContractInput[]
    createMany?: ClientContractToClientCreateManyClientContractInputEnvelope
    connect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
  }

  export type ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClientContractInput = {
    create?: XOR<ClientContractToAgencyContractCreateWithoutClientContractInput, ClientContractToAgencyContractUncheckedCreateWithoutClientContractInput> | ClientContractToAgencyContractCreateWithoutClientContractInput[] | ClientContractToAgencyContractUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: ClientContractToAgencyContractCreateOrConnectWithoutClientContractInput | ClientContractToAgencyContractCreateOrConnectWithoutClientContractInput[]
    createMany?: ClientContractToAgencyContractCreateManyClientContractInputEnvelope
    connect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumClientContractTypeFieldUpdateOperationsInput = {
    set?: $Enums.ClientContractType
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type TransferActUpdateOneWithoutClientContractNestedInput = {
    create?: XOR<TransferActCreateWithoutClientContractInput, TransferActUncheckedCreateWithoutClientContractInput>
    connectOrCreate?: TransferActCreateOrConnectWithoutClientContractInput
    upsert?: TransferActUpsertWithoutClientContractInput
    disconnect?: TransferActWhereInput | boolean
    delete?: TransferActWhereInput | boolean
    connect?: TransferActWhereUniqueInput
    update?: XOR<XOR<TransferActUpdateToOneWithWhereWithoutClientContractInput, TransferActUpdateWithoutClientContractInput>, TransferActUncheckedUpdateWithoutClientContractInput>
  }

  export type DduClientContractPropertiesUpdateOneWithoutClientContractNestedInput = {
    create?: XOR<DduClientContractPropertiesCreateWithoutClientContractInput, DduClientContractPropertiesUncheckedCreateWithoutClientContractInput>
    connectOrCreate?: DduClientContractPropertiesCreateOrConnectWithoutClientContractInput
    upsert?: DduClientContractPropertiesUpsertWithoutClientContractInput
    disconnect?: DduClientContractPropertiesWhereInput | boolean
    delete?: DduClientContractPropertiesWhereInput | boolean
    connect?: DduClientContractPropertiesWhereUniqueInput
    update?: XOR<XOR<DduClientContractPropertiesUpdateToOneWithWhereWithoutClientContractInput, DduClientContractPropertiesUpdateWithoutClientContractInput>, DduClientContractPropertiesUncheckedUpdateWithoutClientContractInput>
  }

  export type DkpClientContractPropertiesUpdateOneWithoutClientContractNestedInput = {
    create?: XOR<DkpClientContractPropertiesCreateWithoutClientContractInput, DkpClientContractPropertiesUncheckedCreateWithoutClientContractInput>
    connectOrCreate?: DkpClientContractPropertiesCreateOrConnectWithoutClientContractInput
    upsert?: DkpClientContractPropertiesUpsertWithoutClientContractInput
    disconnect?: DkpClientContractPropertiesWhereInput | boolean
    delete?: DkpClientContractPropertiesWhereInput | boolean
    connect?: DkpClientContractPropertiesWhereUniqueInput
    update?: XOR<XOR<DkpClientContractPropertiesUpdateToOneWithWhereWithoutClientContractInput, DkpClientContractPropertiesUpdateWithoutClientContractInput>, DkpClientContractPropertiesUncheckedUpdateWithoutClientContractInput>
  }

  export type ProductUpdateOneRequiredWithoutClientContractNestedInput = {
    create?: XOR<ProductCreateWithoutClientContractInput, ProductUncheckedCreateWithoutClientContractInput>
    connectOrCreate?: ProductCreateOrConnectWithoutClientContractInput
    upsert?: ProductUpsertWithoutClientContractInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutClientContractInput, ProductUpdateWithoutClientContractInput>, ProductUncheckedUpdateWithoutClientContractInput>
  }

  export type ObjectUpdateOneRequiredWithoutClientContractsNestedInput = {
    create?: XOR<ObjectCreateWithoutClientContractsInput, ObjectUncheckedCreateWithoutClientContractsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutClientContractsInput
    upsert?: ObjectUpsertWithoutClientContractsInput
    connect?: ObjectWhereUniqueInput
    update?: XOR<XOR<ObjectUpdateToOneWithWhereWithoutClientContractsInput, ObjectUpdateWithoutClientContractsInput>, ObjectUncheckedUpdateWithoutClientContractsInput>
  }

  export type RealEstateAgentUpdateOneWithoutClientContractsNestedInput = {
    create?: XOR<RealEstateAgentCreateWithoutClientContractsInput, RealEstateAgentUncheckedCreateWithoutClientContractsInput>
    connectOrCreate?: RealEstateAgentCreateOrConnectWithoutClientContractsInput
    upsert?: RealEstateAgentUpsertWithoutClientContractsInput
    disconnect?: RealEstateAgentWhereInput | boolean
    delete?: RealEstateAgentWhereInput | boolean
    connect?: RealEstateAgentWhereUniqueInput
    update?: XOR<XOR<RealEstateAgentUpdateToOneWithWhereWithoutClientContractsInput, RealEstateAgentUpdateWithoutClientContractsInput>, RealEstateAgentUncheckedUpdateWithoutClientContractsInput>
  }

  export type UserUpdateOneWithoutClientContractsNestedInput = {
    create?: XOR<UserCreateWithoutClientContractsInput, UserUncheckedCreateWithoutClientContractsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientContractsInput
    upsert?: UserUpsertWithoutClientContractsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientContractsInput, UserUpdateWithoutClientContractsInput>, UserUncheckedUpdateWithoutClientContractsInput>
  }

  export type BankUpdateOneWithoutClientContractsNestedInput = {
    create?: XOR<BankCreateWithoutClientContractsInput, BankUncheckedCreateWithoutClientContractsInput>
    connectOrCreate?: BankCreateOrConnectWithoutClientContractsInput
    upsert?: BankUpsertWithoutClientContractsInput
    disconnect?: BankWhereInput | boolean
    delete?: BankWhereInput | boolean
    connect?: BankWhereUniqueInput
    update?: XOR<XOR<BankUpdateToOneWithWhereWithoutClientContractsInput, BankUpdateWithoutClientContractsInput>, BankUncheckedUpdateWithoutClientContractsInput>
  }

  export type SubsidyUpdateOneWithoutClientContractsNestedInput = {
    create?: XOR<SubsidyCreateWithoutClientContractsInput, SubsidyUncheckedCreateWithoutClientContractsInput>
    connectOrCreate?: SubsidyCreateOrConnectWithoutClientContractsInput
    upsert?: SubsidyUpsertWithoutClientContractsInput
    disconnect?: SubsidyWhereInput | boolean
    delete?: SubsidyWhereInput | boolean
    connect?: SubsidyWhereUniqueInput
    update?: XOR<XOR<SubsidyUpdateToOneWithWhereWithoutClientContractsInput, SubsidyUpdateWithoutClientContractsInput>, SubsidyUncheckedUpdateWithoutClientContractsInput>
  }

  export type ScheduledPaymentUpdateManyWithoutClientContractNestedInput = {
    create?: XOR<ScheduledPaymentCreateWithoutClientContractInput, ScheduledPaymentUncheckedCreateWithoutClientContractInput> | ScheduledPaymentCreateWithoutClientContractInput[] | ScheduledPaymentUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: ScheduledPaymentCreateOrConnectWithoutClientContractInput | ScheduledPaymentCreateOrConnectWithoutClientContractInput[]
    upsert?: ScheduledPaymentUpsertWithWhereUniqueWithoutClientContractInput | ScheduledPaymentUpsertWithWhereUniqueWithoutClientContractInput[]
    createMany?: ScheduledPaymentCreateManyClientContractInputEnvelope
    set?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
    disconnect?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
    delete?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
    connect?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
    update?: ScheduledPaymentUpdateWithWhereUniqueWithoutClientContractInput | ScheduledPaymentUpdateWithWhereUniqueWithoutClientContractInput[]
    updateMany?: ScheduledPaymentUpdateManyWithWhereWithoutClientContractInput | ScheduledPaymentUpdateManyWithWhereWithoutClientContractInput[]
    deleteMany?: ScheduledPaymentScalarWhereInput | ScheduledPaymentScalarWhereInput[]
  }

  export type ActualPaymentUpdateManyWithoutClientContractNestedInput = {
    create?: XOR<ActualPaymentCreateWithoutClientContractInput, ActualPaymentUncheckedCreateWithoutClientContractInput> | ActualPaymentCreateWithoutClientContractInput[] | ActualPaymentUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: ActualPaymentCreateOrConnectWithoutClientContractInput | ActualPaymentCreateOrConnectWithoutClientContractInput[]
    upsert?: ActualPaymentUpsertWithWhereUniqueWithoutClientContractInput | ActualPaymentUpsertWithWhereUniqueWithoutClientContractInput[]
    createMany?: ActualPaymentCreateManyClientContractInputEnvelope
    set?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
    disconnect?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
    delete?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
    connect?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
    update?: ActualPaymentUpdateWithWhereUniqueWithoutClientContractInput | ActualPaymentUpdateWithWhereUniqueWithoutClientContractInput[]
    updateMany?: ActualPaymentUpdateManyWithWhereWithoutClientContractInput | ActualPaymentUpdateManyWithWhereWithoutClientContractInput[]
    deleteMany?: ActualPaymentScalarWhereInput | ActualPaymentScalarWhereInput[]
  }

  export type RealEstateAgencyActUpdateManyWithoutClientContractNestedInput = {
    create?: XOR<RealEstateAgencyActCreateWithoutClientContractInput, RealEstateAgencyActUncheckedCreateWithoutClientContractInput> | RealEstateAgencyActCreateWithoutClientContractInput[] | RealEstateAgencyActUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: RealEstateAgencyActCreateOrConnectWithoutClientContractInput | RealEstateAgencyActCreateOrConnectWithoutClientContractInput[]
    upsert?: RealEstateAgencyActUpsertWithWhereUniqueWithoutClientContractInput | RealEstateAgencyActUpsertWithWhereUniqueWithoutClientContractInput[]
    createMany?: RealEstateAgencyActCreateManyClientContractInputEnvelope
    set?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    disconnect?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    delete?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    connect?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    update?: RealEstateAgencyActUpdateWithWhereUniqueWithoutClientContractInput | RealEstateAgencyActUpdateWithWhereUniqueWithoutClientContractInput[]
    updateMany?: RealEstateAgencyActUpdateManyWithWhereWithoutClientContractInput | RealEstateAgencyActUpdateManyWithWhereWithoutClientContractInput[]
    deleteMany?: RealEstateAgencyActScalarWhereInput | RealEstateAgencyActScalarWhereInput[]
  }

  export type AssignmentUpdateManyWithoutClientContractNestedInput = {
    create?: XOR<AssignmentCreateWithoutClientContractInput, AssignmentUncheckedCreateWithoutClientContractInput> | AssignmentCreateWithoutClientContractInput[] | AssignmentUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClientContractInput | AssignmentCreateOrConnectWithoutClientContractInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutClientContractInput | AssignmentUpsertWithWhereUniqueWithoutClientContractInput[]
    createMany?: AssignmentCreateManyClientContractInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutClientContractInput | AssignmentUpdateWithWhereUniqueWithoutClientContractInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutClientContractInput | AssignmentUpdateManyWithWhereWithoutClientContractInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type ClientContractToClientUpdateManyWithoutClientContractNestedInput = {
    create?: XOR<ClientContractToClientCreateWithoutClientContractInput, ClientContractToClientUncheckedCreateWithoutClientContractInput> | ClientContractToClientCreateWithoutClientContractInput[] | ClientContractToClientUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: ClientContractToClientCreateOrConnectWithoutClientContractInput | ClientContractToClientCreateOrConnectWithoutClientContractInput[]
    upsert?: ClientContractToClientUpsertWithWhereUniqueWithoutClientContractInput | ClientContractToClientUpsertWithWhereUniqueWithoutClientContractInput[]
    createMany?: ClientContractToClientCreateManyClientContractInputEnvelope
    set?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    disconnect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    delete?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    connect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    update?: ClientContractToClientUpdateWithWhereUniqueWithoutClientContractInput | ClientContractToClientUpdateWithWhereUniqueWithoutClientContractInput[]
    updateMany?: ClientContractToClientUpdateManyWithWhereWithoutClientContractInput | ClientContractToClientUpdateManyWithWhereWithoutClientContractInput[]
    deleteMany?: ClientContractToClientScalarWhereInput | ClientContractToClientScalarWhereInput[]
  }

  export type ClientContractToAgencyContractUpdateManyWithoutClientContractNestedInput = {
    create?: XOR<ClientContractToAgencyContractCreateWithoutClientContractInput, ClientContractToAgencyContractUncheckedCreateWithoutClientContractInput> | ClientContractToAgencyContractCreateWithoutClientContractInput[] | ClientContractToAgencyContractUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: ClientContractToAgencyContractCreateOrConnectWithoutClientContractInput | ClientContractToAgencyContractCreateOrConnectWithoutClientContractInput[]
    upsert?: ClientContractToAgencyContractUpsertWithWhereUniqueWithoutClientContractInput | ClientContractToAgencyContractUpsertWithWhereUniqueWithoutClientContractInput[]
    createMany?: ClientContractToAgencyContractCreateManyClientContractInputEnvelope
    set?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    disconnect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    delete?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    connect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    update?: ClientContractToAgencyContractUpdateWithWhereUniqueWithoutClientContractInput | ClientContractToAgencyContractUpdateWithWhereUniqueWithoutClientContractInput[]
    updateMany?: ClientContractToAgencyContractUpdateManyWithWhereWithoutClientContractInput | ClientContractToAgencyContractUpdateManyWithWhereWithoutClientContractInput[]
    deleteMany?: ClientContractToAgencyContractScalarWhereInput | ClientContractToAgencyContractScalarWhereInput[]
  }

  export type TransferActUncheckedUpdateOneWithoutClientContractNestedInput = {
    create?: XOR<TransferActCreateWithoutClientContractInput, TransferActUncheckedCreateWithoutClientContractInput>
    connectOrCreate?: TransferActCreateOrConnectWithoutClientContractInput
    upsert?: TransferActUpsertWithoutClientContractInput
    disconnect?: TransferActWhereInput | boolean
    delete?: TransferActWhereInput | boolean
    connect?: TransferActWhereUniqueInput
    update?: XOR<XOR<TransferActUpdateToOneWithWhereWithoutClientContractInput, TransferActUpdateWithoutClientContractInput>, TransferActUncheckedUpdateWithoutClientContractInput>
  }

  export type ScheduledPaymentUncheckedUpdateManyWithoutClientContractNestedInput = {
    create?: XOR<ScheduledPaymentCreateWithoutClientContractInput, ScheduledPaymentUncheckedCreateWithoutClientContractInput> | ScheduledPaymentCreateWithoutClientContractInput[] | ScheduledPaymentUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: ScheduledPaymentCreateOrConnectWithoutClientContractInput | ScheduledPaymentCreateOrConnectWithoutClientContractInput[]
    upsert?: ScheduledPaymentUpsertWithWhereUniqueWithoutClientContractInput | ScheduledPaymentUpsertWithWhereUniqueWithoutClientContractInput[]
    createMany?: ScheduledPaymentCreateManyClientContractInputEnvelope
    set?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
    disconnect?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
    delete?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
    connect?: ScheduledPaymentWhereUniqueInput | ScheduledPaymentWhereUniqueInput[]
    update?: ScheduledPaymentUpdateWithWhereUniqueWithoutClientContractInput | ScheduledPaymentUpdateWithWhereUniqueWithoutClientContractInput[]
    updateMany?: ScheduledPaymentUpdateManyWithWhereWithoutClientContractInput | ScheduledPaymentUpdateManyWithWhereWithoutClientContractInput[]
    deleteMany?: ScheduledPaymentScalarWhereInput | ScheduledPaymentScalarWhereInput[]
  }

  export type ActualPaymentUncheckedUpdateManyWithoutClientContractNestedInput = {
    create?: XOR<ActualPaymentCreateWithoutClientContractInput, ActualPaymentUncheckedCreateWithoutClientContractInput> | ActualPaymentCreateWithoutClientContractInput[] | ActualPaymentUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: ActualPaymentCreateOrConnectWithoutClientContractInput | ActualPaymentCreateOrConnectWithoutClientContractInput[]
    upsert?: ActualPaymentUpsertWithWhereUniqueWithoutClientContractInput | ActualPaymentUpsertWithWhereUniqueWithoutClientContractInput[]
    createMany?: ActualPaymentCreateManyClientContractInputEnvelope
    set?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
    disconnect?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
    delete?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
    connect?: ActualPaymentWhereUniqueInput | ActualPaymentWhereUniqueInput[]
    update?: ActualPaymentUpdateWithWhereUniqueWithoutClientContractInput | ActualPaymentUpdateWithWhereUniqueWithoutClientContractInput[]
    updateMany?: ActualPaymentUpdateManyWithWhereWithoutClientContractInput | ActualPaymentUpdateManyWithWhereWithoutClientContractInput[]
    deleteMany?: ActualPaymentScalarWhereInput | ActualPaymentScalarWhereInput[]
  }

  export type RealEstateAgencyActUncheckedUpdateManyWithoutClientContractNestedInput = {
    create?: XOR<RealEstateAgencyActCreateWithoutClientContractInput, RealEstateAgencyActUncheckedCreateWithoutClientContractInput> | RealEstateAgencyActCreateWithoutClientContractInput[] | RealEstateAgencyActUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: RealEstateAgencyActCreateOrConnectWithoutClientContractInput | RealEstateAgencyActCreateOrConnectWithoutClientContractInput[]
    upsert?: RealEstateAgencyActUpsertWithWhereUniqueWithoutClientContractInput | RealEstateAgencyActUpsertWithWhereUniqueWithoutClientContractInput[]
    createMany?: RealEstateAgencyActCreateManyClientContractInputEnvelope
    set?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    disconnect?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    delete?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    connect?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    update?: RealEstateAgencyActUpdateWithWhereUniqueWithoutClientContractInput | RealEstateAgencyActUpdateWithWhereUniqueWithoutClientContractInput[]
    updateMany?: RealEstateAgencyActUpdateManyWithWhereWithoutClientContractInput | RealEstateAgencyActUpdateManyWithWhereWithoutClientContractInput[]
    deleteMany?: RealEstateAgencyActScalarWhereInput | RealEstateAgencyActScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutClientContractNestedInput = {
    create?: XOR<AssignmentCreateWithoutClientContractInput, AssignmentUncheckedCreateWithoutClientContractInput> | AssignmentCreateWithoutClientContractInput[] | AssignmentUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClientContractInput | AssignmentCreateOrConnectWithoutClientContractInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutClientContractInput | AssignmentUpsertWithWhereUniqueWithoutClientContractInput[]
    createMany?: AssignmentCreateManyClientContractInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutClientContractInput | AssignmentUpdateWithWhereUniqueWithoutClientContractInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutClientContractInput | AssignmentUpdateManyWithWhereWithoutClientContractInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type ClientContractToClientUncheckedUpdateManyWithoutClientContractNestedInput = {
    create?: XOR<ClientContractToClientCreateWithoutClientContractInput, ClientContractToClientUncheckedCreateWithoutClientContractInput> | ClientContractToClientCreateWithoutClientContractInput[] | ClientContractToClientUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: ClientContractToClientCreateOrConnectWithoutClientContractInput | ClientContractToClientCreateOrConnectWithoutClientContractInput[]
    upsert?: ClientContractToClientUpsertWithWhereUniqueWithoutClientContractInput | ClientContractToClientUpsertWithWhereUniqueWithoutClientContractInput[]
    createMany?: ClientContractToClientCreateManyClientContractInputEnvelope
    set?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    disconnect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    delete?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    connect?: ClientContractToClientWhereUniqueInput | ClientContractToClientWhereUniqueInput[]
    update?: ClientContractToClientUpdateWithWhereUniqueWithoutClientContractInput | ClientContractToClientUpdateWithWhereUniqueWithoutClientContractInput[]
    updateMany?: ClientContractToClientUpdateManyWithWhereWithoutClientContractInput | ClientContractToClientUpdateManyWithWhereWithoutClientContractInput[]
    deleteMany?: ClientContractToClientScalarWhereInput | ClientContractToClientScalarWhereInput[]
  }

  export type ClientContractToAgencyContractUncheckedUpdateManyWithoutClientContractNestedInput = {
    create?: XOR<ClientContractToAgencyContractCreateWithoutClientContractInput, ClientContractToAgencyContractUncheckedCreateWithoutClientContractInput> | ClientContractToAgencyContractCreateWithoutClientContractInput[] | ClientContractToAgencyContractUncheckedCreateWithoutClientContractInput[]
    connectOrCreate?: ClientContractToAgencyContractCreateOrConnectWithoutClientContractInput | ClientContractToAgencyContractCreateOrConnectWithoutClientContractInput[]
    upsert?: ClientContractToAgencyContractUpsertWithWhereUniqueWithoutClientContractInput | ClientContractToAgencyContractUpsertWithWhereUniqueWithoutClientContractInput[]
    createMany?: ClientContractToAgencyContractCreateManyClientContractInputEnvelope
    set?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    disconnect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    delete?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    connect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    update?: ClientContractToAgencyContractUpdateWithWhereUniqueWithoutClientContractInput | ClientContractToAgencyContractUpdateWithWhereUniqueWithoutClientContractInput[]
    updateMany?: ClientContractToAgencyContractUpdateManyWithWhereWithoutClientContractInput | ClientContractToAgencyContractUpdateManyWithWhereWithoutClientContractInput[]
    deleteMany?: ClientContractToAgencyContractScalarWhereInput | ClientContractToAgencyContractScalarWhereInput[]
  }

  export type ClientContractCreateNestedOneWithoutDduClientContractPropertiesInput = {
    create?: XOR<ClientContractCreateWithoutDduClientContractPropertiesInput, ClientContractUncheckedCreateWithoutDduClientContractPropertiesInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutDduClientContractPropertiesInput
    connect?: ClientContractWhereUniqueInput
  }

  export type ClientContractUncheckedCreateNestedOneWithoutDduClientContractPropertiesInput = {
    create?: XOR<ClientContractCreateWithoutDduClientContractPropertiesInput, ClientContractUncheckedCreateWithoutDduClientContractPropertiesInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutDduClientContractPropertiesInput
    connect?: ClientContractWhereUniqueInput
  }

  export type ClientContractUpdateOneWithoutDduClientContractPropertiesNestedInput = {
    create?: XOR<ClientContractCreateWithoutDduClientContractPropertiesInput, ClientContractUncheckedCreateWithoutDduClientContractPropertiesInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutDduClientContractPropertiesInput
    upsert?: ClientContractUpsertWithoutDduClientContractPropertiesInput
    disconnect?: ClientContractWhereInput | boolean
    delete?: ClientContractWhereInput | boolean
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutDduClientContractPropertiesInput, ClientContractUpdateWithoutDduClientContractPropertiesInput>, ClientContractUncheckedUpdateWithoutDduClientContractPropertiesInput>
  }

  export type ClientContractUncheckedUpdateOneWithoutDduClientContractPropertiesNestedInput = {
    create?: XOR<ClientContractCreateWithoutDduClientContractPropertiesInput, ClientContractUncheckedCreateWithoutDduClientContractPropertiesInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutDduClientContractPropertiesInput
    upsert?: ClientContractUpsertWithoutDduClientContractPropertiesInput
    disconnect?: ClientContractWhereInput | boolean
    delete?: ClientContractWhereInput | boolean
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutDduClientContractPropertiesInput, ClientContractUpdateWithoutDduClientContractPropertiesInput>, ClientContractUncheckedUpdateWithoutDduClientContractPropertiesInput>
  }

  export type ClientContractCreateNestedOneWithoutDkpClientContractPropertiesInput = {
    create?: XOR<ClientContractCreateWithoutDkpClientContractPropertiesInput, ClientContractUncheckedCreateWithoutDkpClientContractPropertiesInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutDkpClientContractPropertiesInput
    connect?: ClientContractWhereUniqueInput
  }

  export type ClientContractUncheckedCreateNestedOneWithoutDkpClientContractPropertiesInput = {
    create?: XOR<ClientContractCreateWithoutDkpClientContractPropertiesInput, ClientContractUncheckedCreateWithoutDkpClientContractPropertiesInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutDkpClientContractPropertiesInput
    connect?: ClientContractWhereUniqueInput
  }

  export type ClientContractUpdateOneWithoutDkpClientContractPropertiesNestedInput = {
    create?: XOR<ClientContractCreateWithoutDkpClientContractPropertiesInput, ClientContractUncheckedCreateWithoutDkpClientContractPropertiesInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutDkpClientContractPropertiesInput
    upsert?: ClientContractUpsertWithoutDkpClientContractPropertiesInput
    disconnect?: ClientContractWhereInput | boolean
    delete?: ClientContractWhereInput | boolean
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutDkpClientContractPropertiesInput, ClientContractUpdateWithoutDkpClientContractPropertiesInput>, ClientContractUncheckedUpdateWithoutDkpClientContractPropertiesInput>
  }

  export type ClientContractUncheckedUpdateOneWithoutDkpClientContractPropertiesNestedInput = {
    create?: XOR<ClientContractCreateWithoutDkpClientContractPropertiesInput, ClientContractUncheckedCreateWithoutDkpClientContractPropertiesInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutDkpClientContractPropertiesInput
    upsert?: ClientContractUpsertWithoutDkpClientContractPropertiesInput
    disconnect?: ClientContractWhereInput | boolean
    delete?: ClientContractWhereInput | boolean
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutDkpClientContractPropertiesInput, ClientContractUpdateWithoutDkpClientContractPropertiesInput>, ClientContractUncheckedUpdateWithoutDkpClientContractPropertiesInput>
  }

  export type ClientContractCreateNestedOneWithoutClientContractsToAgencyContractsInput = {
    create?: XOR<ClientContractCreateWithoutClientContractsToAgencyContractsInput, ClientContractUncheckedCreateWithoutClientContractsToAgencyContractsInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutClientContractsToAgencyContractsInput
    connect?: ClientContractWhereUniqueInput
  }

  export type AgencyContractCreateNestedOneWithoutClientContractsToAgencyContractsInput = {
    create?: XOR<AgencyContractCreateWithoutClientContractsToAgencyContractsInput, AgencyContractUncheckedCreateWithoutClientContractsToAgencyContractsInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutClientContractsToAgencyContractsInput
    connect?: AgencyContractWhereUniqueInput
  }

  export type ClientContractUpdateOneRequiredWithoutClientContractsToAgencyContractsNestedInput = {
    create?: XOR<ClientContractCreateWithoutClientContractsToAgencyContractsInput, ClientContractUncheckedCreateWithoutClientContractsToAgencyContractsInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutClientContractsToAgencyContractsInput
    upsert?: ClientContractUpsertWithoutClientContractsToAgencyContractsInput
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutClientContractsToAgencyContractsInput, ClientContractUpdateWithoutClientContractsToAgencyContractsInput>, ClientContractUncheckedUpdateWithoutClientContractsToAgencyContractsInput>
  }

  export type AgencyContractUpdateOneRequiredWithoutClientContractsToAgencyContractsNestedInput = {
    create?: XOR<AgencyContractCreateWithoutClientContractsToAgencyContractsInput, AgencyContractUncheckedCreateWithoutClientContractsToAgencyContractsInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutClientContractsToAgencyContractsInput
    upsert?: AgencyContractUpsertWithoutClientContractsToAgencyContractsInput
    connect?: AgencyContractWhereUniqueInput
    update?: XOR<XOR<AgencyContractUpdateToOneWithWhereWithoutClientContractsToAgencyContractsInput, AgencyContractUpdateWithoutClientContractsToAgencyContractsInput>, AgencyContractUncheckedUpdateWithoutClientContractsToAgencyContractsInput>
  }

  export type ClientCreateNestedOneWithoutClientContractsToClientsInput = {
    create?: XOR<ClientCreateWithoutClientContractsToClientsInput, ClientUncheckedCreateWithoutClientContractsToClientsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientContractsToClientsInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientContractCreateNestedOneWithoutClientContractsToClientsInput = {
    create?: XOR<ClientContractCreateWithoutClientContractsToClientsInput, ClientContractUncheckedCreateWithoutClientContractsToClientsInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutClientContractsToClientsInput
    connect?: ClientContractWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutClientContractsToClientsNestedInput = {
    create?: XOR<ClientCreateWithoutClientContractsToClientsInput, ClientUncheckedCreateWithoutClientContractsToClientsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientContractsToClientsInput
    upsert?: ClientUpsertWithoutClientContractsToClientsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClientContractsToClientsInput, ClientUpdateWithoutClientContractsToClientsInput>, ClientUncheckedUpdateWithoutClientContractsToClientsInput>
  }

  export type ClientContractUpdateOneRequiredWithoutClientContractsToClientsNestedInput = {
    create?: XOR<ClientContractCreateWithoutClientContractsToClientsInput, ClientContractUncheckedCreateWithoutClientContractsToClientsInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutClientContractsToClientsInput
    upsert?: ClientContractUpsertWithoutClientContractsToClientsInput
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutClientContractsToClientsInput, ClientContractUpdateWithoutClientContractsToClientsInput>, ClientContractUncheckedUpdateWithoutClientContractsToClientsInput>
  }

  export type ClientContractCreateNestedOneWithoutScheduledPaymentsInput = {
    create?: XOR<ClientContractCreateWithoutScheduledPaymentsInput, ClientContractUncheckedCreateWithoutScheduledPaymentsInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutScheduledPaymentsInput
    connect?: ClientContractWhereUniqueInput
  }

  export type EnumScheduledPaymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ScheduledPaymentType
  }

  export type ClientContractUpdateOneRequiredWithoutScheduledPaymentsNestedInput = {
    create?: XOR<ClientContractCreateWithoutScheduledPaymentsInput, ClientContractUncheckedCreateWithoutScheduledPaymentsInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutScheduledPaymentsInput
    upsert?: ClientContractUpsertWithoutScheduledPaymentsInput
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutScheduledPaymentsInput, ClientContractUpdateWithoutScheduledPaymentsInput>, ClientContractUncheckedUpdateWithoutScheduledPaymentsInput>
  }

  export type ClientContractCreateNestedOneWithoutActualPaymentsInput = {
    create?: XOR<ClientContractCreateWithoutActualPaymentsInput, ClientContractUncheckedCreateWithoutActualPaymentsInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutActualPaymentsInput
    connect?: ClientContractWhereUniqueInput
  }

  export type ClientContractUpdateOneRequiredWithoutActualPaymentsNestedInput = {
    create?: XOR<ClientContractCreateWithoutActualPaymentsInput, ClientContractUncheckedCreateWithoutActualPaymentsInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutActualPaymentsInput
    upsert?: ClientContractUpsertWithoutActualPaymentsInput
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutActualPaymentsInput, ClientContractUpdateWithoutActualPaymentsInput>, ClientContractUncheckedUpdateWithoutActualPaymentsInput>
  }

  export type EntityCreateNestedOneWithoutObjectsInput = {
    create?: XOR<EntityCreateWithoutObjectsInput, EntityUncheckedCreateWithoutObjectsInput>
    connectOrCreate?: EntityCreateOrConnectWithoutObjectsInput
    connect?: EntityWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutObjectInput = {
    create?: XOR<ProductCreateWithoutObjectInput, ProductUncheckedCreateWithoutObjectInput> | ProductCreateWithoutObjectInput[] | ProductUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutObjectInput | ProductCreateOrConnectWithoutObjectInput[]
    createMany?: ProductCreateManyObjectInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ClientContractCreateNestedManyWithoutObjectInput = {
    create?: XOR<ClientContractCreateWithoutObjectInput, ClientContractUncheckedCreateWithoutObjectInput> | ClientContractCreateWithoutObjectInput[] | ClientContractUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutObjectInput | ClientContractCreateOrConnectWithoutObjectInput[]
    createMany?: ClientContractCreateManyObjectInputEnvelope
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
  }

  export type AgencyContractCreateNestedManyWithoutObjectInput = {
    create?: XOR<AgencyContractCreateWithoutObjectInput, AgencyContractUncheckedCreateWithoutObjectInput> | AgencyContractCreateWithoutObjectInput[] | AgencyContractUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutObjectInput | AgencyContractCreateOrConnectWithoutObjectInput[]
    createMany?: AgencyContractCreateManyObjectInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type TransferActCreateNestedManyWithoutObjectInput = {
    create?: XOR<TransferActCreateWithoutObjectInput, TransferActUncheckedCreateWithoutObjectInput> | TransferActCreateWithoutObjectInput[] | TransferActUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: TransferActCreateOrConnectWithoutObjectInput | TransferActCreateOrConnectWithoutObjectInput[]
    createMany?: TransferActCreateManyObjectInputEnvelope
    connect?: TransferActWhereUniqueInput | TransferActWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutObjectInput = {
    create?: XOR<ProductCreateWithoutObjectInput, ProductUncheckedCreateWithoutObjectInput> | ProductCreateWithoutObjectInput[] | ProductUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutObjectInput | ProductCreateOrConnectWithoutObjectInput[]
    createMany?: ProductCreateManyObjectInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ClientContractUncheckedCreateNestedManyWithoutObjectInput = {
    create?: XOR<ClientContractCreateWithoutObjectInput, ClientContractUncheckedCreateWithoutObjectInput> | ClientContractCreateWithoutObjectInput[] | ClientContractUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutObjectInput | ClientContractCreateOrConnectWithoutObjectInput[]
    createMany?: ClientContractCreateManyObjectInputEnvelope
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
  }

  export type AgencyContractUncheckedCreateNestedManyWithoutObjectInput = {
    create?: XOR<AgencyContractCreateWithoutObjectInput, AgencyContractUncheckedCreateWithoutObjectInput> | AgencyContractCreateWithoutObjectInput[] | AgencyContractUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutObjectInput | AgencyContractCreateOrConnectWithoutObjectInput[]
    createMany?: AgencyContractCreateManyObjectInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type TransferActUncheckedCreateNestedManyWithoutObjectInput = {
    create?: XOR<TransferActCreateWithoutObjectInput, TransferActUncheckedCreateWithoutObjectInput> | TransferActCreateWithoutObjectInput[] | TransferActUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: TransferActCreateOrConnectWithoutObjectInput | TransferActCreateOrConnectWithoutObjectInput[]
    createMany?: TransferActCreateManyObjectInputEnvelope
    connect?: TransferActWhereUniqueInput | TransferActWhereUniqueInput[]
  }

  export type EntityUpdateOneRequiredWithoutObjectsNestedInput = {
    create?: XOR<EntityCreateWithoutObjectsInput, EntityUncheckedCreateWithoutObjectsInput>
    connectOrCreate?: EntityCreateOrConnectWithoutObjectsInput
    upsert?: EntityUpsertWithoutObjectsInput
    connect?: EntityWhereUniqueInput
    update?: XOR<XOR<EntityUpdateToOneWithWhereWithoutObjectsInput, EntityUpdateWithoutObjectsInput>, EntityUncheckedUpdateWithoutObjectsInput>
  }

  export type ProductUpdateManyWithoutObjectNestedInput = {
    create?: XOR<ProductCreateWithoutObjectInput, ProductUncheckedCreateWithoutObjectInput> | ProductCreateWithoutObjectInput[] | ProductUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutObjectInput | ProductCreateOrConnectWithoutObjectInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutObjectInput | ProductUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: ProductCreateManyObjectInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutObjectInput | ProductUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutObjectInput | ProductUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ClientContractUpdateManyWithoutObjectNestedInput = {
    create?: XOR<ClientContractCreateWithoutObjectInput, ClientContractUncheckedCreateWithoutObjectInput> | ClientContractCreateWithoutObjectInput[] | ClientContractUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutObjectInput | ClientContractCreateOrConnectWithoutObjectInput[]
    upsert?: ClientContractUpsertWithWhereUniqueWithoutObjectInput | ClientContractUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: ClientContractCreateManyObjectInputEnvelope
    set?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    disconnect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    delete?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    update?: ClientContractUpdateWithWhereUniqueWithoutObjectInput | ClientContractUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: ClientContractUpdateManyWithWhereWithoutObjectInput | ClientContractUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
  }

  export type AgencyContractUpdateManyWithoutObjectNestedInput = {
    create?: XOR<AgencyContractCreateWithoutObjectInput, AgencyContractUncheckedCreateWithoutObjectInput> | AgencyContractCreateWithoutObjectInput[] | AgencyContractUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutObjectInput | AgencyContractCreateOrConnectWithoutObjectInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutObjectInput | AgencyContractUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: AgencyContractCreateManyObjectInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutObjectInput | AgencyContractUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutObjectInput | AgencyContractUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type TransferActUpdateManyWithoutObjectNestedInput = {
    create?: XOR<TransferActCreateWithoutObjectInput, TransferActUncheckedCreateWithoutObjectInput> | TransferActCreateWithoutObjectInput[] | TransferActUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: TransferActCreateOrConnectWithoutObjectInput | TransferActCreateOrConnectWithoutObjectInput[]
    upsert?: TransferActUpsertWithWhereUniqueWithoutObjectInput | TransferActUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: TransferActCreateManyObjectInputEnvelope
    set?: TransferActWhereUniqueInput | TransferActWhereUniqueInput[]
    disconnect?: TransferActWhereUniqueInput | TransferActWhereUniqueInput[]
    delete?: TransferActWhereUniqueInput | TransferActWhereUniqueInput[]
    connect?: TransferActWhereUniqueInput | TransferActWhereUniqueInput[]
    update?: TransferActUpdateWithWhereUniqueWithoutObjectInput | TransferActUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: TransferActUpdateManyWithWhereWithoutObjectInput | TransferActUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: TransferActScalarWhereInput | TransferActScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutObjectNestedInput = {
    create?: XOR<ProductCreateWithoutObjectInput, ProductUncheckedCreateWithoutObjectInput> | ProductCreateWithoutObjectInput[] | ProductUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutObjectInput | ProductCreateOrConnectWithoutObjectInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutObjectInput | ProductUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: ProductCreateManyObjectInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutObjectInput | ProductUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutObjectInput | ProductUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ClientContractUncheckedUpdateManyWithoutObjectNestedInput = {
    create?: XOR<ClientContractCreateWithoutObjectInput, ClientContractUncheckedCreateWithoutObjectInput> | ClientContractCreateWithoutObjectInput[] | ClientContractUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutObjectInput | ClientContractCreateOrConnectWithoutObjectInput[]
    upsert?: ClientContractUpsertWithWhereUniqueWithoutObjectInput | ClientContractUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: ClientContractCreateManyObjectInputEnvelope
    set?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    disconnect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    delete?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    update?: ClientContractUpdateWithWhereUniqueWithoutObjectInput | ClientContractUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: ClientContractUpdateManyWithWhereWithoutObjectInput | ClientContractUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
  }

  export type AgencyContractUncheckedUpdateManyWithoutObjectNestedInput = {
    create?: XOR<AgencyContractCreateWithoutObjectInput, AgencyContractUncheckedCreateWithoutObjectInput> | AgencyContractCreateWithoutObjectInput[] | AgencyContractUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutObjectInput | AgencyContractCreateOrConnectWithoutObjectInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutObjectInput | AgencyContractUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: AgencyContractCreateManyObjectInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutObjectInput | AgencyContractUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutObjectInput | AgencyContractUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type TransferActUncheckedUpdateManyWithoutObjectNestedInput = {
    create?: XOR<TransferActCreateWithoutObjectInput, TransferActUncheckedCreateWithoutObjectInput> | TransferActCreateWithoutObjectInput[] | TransferActUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: TransferActCreateOrConnectWithoutObjectInput | TransferActCreateOrConnectWithoutObjectInput[]
    upsert?: TransferActUpsertWithWhereUniqueWithoutObjectInput | TransferActUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: TransferActCreateManyObjectInputEnvelope
    set?: TransferActWhereUniqueInput | TransferActWhereUniqueInput[]
    disconnect?: TransferActWhereUniqueInput | TransferActWhereUniqueInput[]
    delete?: TransferActWhereUniqueInput | TransferActWhereUniqueInput[]
    connect?: TransferActWhereUniqueInput | TransferActWhereUniqueInput[]
    update?: TransferActUpdateWithWhereUniqueWithoutObjectInput | TransferActUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: TransferActUpdateManyWithWhereWithoutObjectInput | TransferActUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: TransferActScalarWhereInput | TransferActScalarWhereInput[]
  }

  export type TransferActCreateNestedOneWithoutProductInput = {
    create?: XOR<TransferActCreateWithoutProductInput, TransferActUncheckedCreateWithoutProductInput>
    connectOrCreate?: TransferActCreateOrConnectWithoutProductInput
    connect?: TransferActWhereUniqueInput
  }

  export type ClientContractCreateNestedOneWithoutProductInput = {
    create?: XOR<ClientContractCreateWithoutProductInput, ClientContractUncheckedCreateWithoutProductInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutProductInput
    connect?: ClientContractWhereUniqueInput
  }

  export type ObjectCreateNestedOneWithoutProductsInput = {
    create?: XOR<ObjectCreateWithoutProductsInput, ObjectUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutProductsInput
    connect?: ObjectWhereUniqueInput
  }

  export type TransferActUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<TransferActCreateWithoutProductInput, TransferActUncheckedCreateWithoutProductInput>
    connectOrCreate?: TransferActCreateOrConnectWithoutProductInput
    connect?: TransferActWhereUniqueInput
  }

  export type ClientContractUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<ClientContractCreateWithoutProductInput, ClientContractUncheckedCreateWithoutProductInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutProductInput
    connect?: ClientContractWhereUniqueInput
  }

  export type EnumProductCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ProductCategory
  }

  export type TransferActUpdateOneWithoutProductNestedInput = {
    create?: XOR<TransferActCreateWithoutProductInput, TransferActUncheckedCreateWithoutProductInput>
    connectOrCreate?: TransferActCreateOrConnectWithoutProductInput
    upsert?: TransferActUpsertWithoutProductInput
    disconnect?: TransferActWhereInput | boolean
    delete?: TransferActWhereInput | boolean
    connect?: TransferActWhereUniqueInput
    update?: XOR<XOR<TransferActUpdateToOneWithWhereWithoutProductInput, TransferActUpdateWithoutProductInput>, TransferActUncheckedUpdateWithoutProductInput>
  }

  export type ClientContractUpdateOneWithoutProductNestedInput = {
    create?: XOR<ClientContractCreateWithoutProductInput, ClientContractUncheckedCreateWithoutProductInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutProductInput
    upsert?: ClientContractUpsertWithoutProductInput
    disconnect?: ClientContractWhereInput | boolean
    delete?: ClientContractWhereInput | boolean
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutProductInput, ClientContractUpdateWithoutProductInput>, ClientContractUncheckedUpdateWithoutProductInput>
  }

  export type ObjectUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<ObjectCreateWithoutProductsInput, ObjectUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutProductsInput
    upsert?: ObjectUpsertWithoutProductsInput
    connect?: ObjectWhereUniqueInput
    update?: XOR<XOR<ObjectUpdateToOneWithWhereWithoutProductsInput, ObjectUpdateWithoutProductsInput>, ObjectUncheckedUpdateWithoutProductsInput>
  }

  export type TransferActUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<TransferActCreateWithoutProductInput, TransferActUncheckedCreateWithoutProductInput>
    connectOrCreate?: TransferActCreateOrConnectWithoutProductInput
    upsert?: TransferActUpsertWithoutProductInput
    disconnect?: TransferActWhereInput | boolean
    delete?: TransferActWhereInput | boolean
    connect?: TransferActWhereUniqueInput
    update?: XOR<XOR<TransferActUpdateToOneWithWhereWithoutProductInput, TransferActUpdateWithoutProductInput>, TransferActUncheckedUpdateWithoutProductInput>
  }

  export type ClientContractUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<ClientContractCreateWithoutProductInput, ClientContractUncheckedCreateWithoutProductInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutProductInput
    upsert?: ClientContractUpsertWithoutProductInput
    disconnect?: ClientContractWhereInput | boolean
    delete?: ClientContractWhereInput | boolean
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutProductInput, ClientContractUpdateWithoutProductInput>, ClientContractUncheckedUpdateWithoutProductInput>
  }

  export type AgencyContractCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyContractCreateWithoutAgencyInput, AgencyContractUncheckedCreateWithoutAgencyInput> | AgencyContractCreateWithoutAgencyInput[] | AgencyContractUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutAgencyInput | AgencyContractCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyContractCreateManyAgencyInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type AgencyContractSignatoryCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyContractSignatoryCreateWithoutAgencyInput, AgencyContractSignatoryUncheckedCreateWithoutAgencyInput> | AgencyContractSignatoryCreateWithoutAgencyInput[] | AgencyContractSignatoryUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyContractSignatoryCreateOrConnectWithoutAgencyInput | AgencyContractSignatoryCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyContractSignatoryCreateManyAgencyInputEnvelope
    connect?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
  }

  export type RealEstateAgencyActCreateNestedManyWithoutAgencyInput = {
    create?: XOR<RealEstateAgencyActCreateWithoutAgencyInput, RealEstateAgencyActUncheckedCreateWithoutAgencyInput> | RealEstateAgencyActCreateWithoutAgencyInput[] | RealEstateAgencyActUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: RealEstateAgencyActCreateOrConnectWithoutAgencyInput | RealEstateAgencyActCreateOrConnectWithoutAgencyInput[]
    createMany?: RealEstateAgencyActCreateManyAgencyInputEnvelope
    connect?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
  }

  export type AgencyToRealEstateAgentCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyToRealEstateAgentCreateWithoutAgencyInput, AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput> | AgencyToRealEstateAgentCreateWithoutAgencyInput[] | AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyToRealEstateAgentCreateOrConnectWithoutAgencyInput | AgencyToRealEstateAgentCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyToRealEstateAgentCreateManyAgencyInputEnvelope
    connect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
  }

  export type AgencyContractUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyContractCreateWithoutAgencyInput, AgencyContractUncheckedCreateWithoutAgencyInput> | AgencyContractCreateWithoutAgencyInput[] | AgencyContractUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutAgencyInput | AgencyContractCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyContractCreateManyAgencyInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type AgencyContractSignatoryUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyContractSignatoryCreateWithoutAgencyInput, AgencyContractSignatoryUncheckedCreateWithoutAgencyInput> | AgencyContractSignatoryCreateWithoutAgencyInput[] | AgencyContractSignatoryUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyContractSignatoryCreateOrConnectWithoutAgencyInput | AgencyContractSignatoryCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyContractSignatoryCreateManyAgencyInputEnvelope
    connect?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
  }

  export type RealEstateAgencyActUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<RealEstateAgencyActCreateWithoutAgencyInput, RealEstateAgencyActUncheckedCreateWithoutAgencyInput> | RealEstateAgencyActCreateWithoutAgencyInput[] | RealEstateAgencyActUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: RealEstateAgencyActCreateOrConnectWithoutAgencyInput | RealEstateAgencyActCreateOrConnectWithoutAgencyInput[]
    createMany?: RealEstateAgencyActCreateManyAgencyInputEnvelope
    connect?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
  }

  export type AgencyToRealEstateAgentUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyToRealEstateAgentCreateWithoutAgencyInput, AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput> | AgencyToRealEstateAgentCreateWithoutAgencyInput[] | AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyToRealEstateAgentCreateOrConnectWithoutAgencyInput | AgencyToRealEstateAgentCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyToRealEstateAgentCreateManyAgencyInputEnvelope
    connect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
  }

  export type AgencyContractUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyContractCreateWithoutAgencyInput, AgencyContractUncheckedCreateWithoutAgencyInput> | AgencyContractCreateWithoutAgencyInput[] | AgencyContractUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutAgencyInput | AgencyContractCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutAgencyInput | AgencyContractUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyContractCreateManyAgencyInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutAgencyInput | AgencyContractUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutAgencyInput | AgencyContractUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type AgencyContractSignatoryUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyContractSignatoryCreateWithoutAgencyInput, AgencyContractSignatoryUncheckedCreateWithoutAgencyInput> | AgencyContractSignatoryCreateWithoutAgencyInput[] | AgencyContractSignatoryUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyContractSignatoryCreateOrConnectWithoutAgencyInput | AgencyContractSignatoryCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyContractSignatoryUpsertWithWhereUniqueWithoutAgencyInput | AgencyContractSignatoryUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyContractSignatoryCreateManyAgencyInputEnvelope
    set?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
    disconnect?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
    delete?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
    connect?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
    update?: AgencyContractSignatoryUpdateWithWhereUniqueWithoutAgencyInput | AgencyContractSignatoryUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyContractSignatoryUpdateManyWithWhereWithoutAgencyInput | AgencyContractSignatoryUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyContractSignatoryScalarWhereInput | AgencyContractSignatoryScalarWhereInput[]
  }

  export type RealEstateAgencyActUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<RealEstateAgencyActCreateWithoutAgencyInput, RealEstateAgencyActUncheckedCreateWithoutAgencyInput> | RealEstateAgencyActCreateWithoutAgencyInput[] | RealEstateAgencyActUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: RealEstateAgencyActCreateOrConnectWithoutAgencyInput | RealEstateAgencyActCreateOrConnectWithoutAgencyInput[]
    upsert?: RealEstateAgencyActUpsertWithWhereUniqueWithoutAgencyInput | RealEstateAgencyActUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: RealEstateAgencyActCreateManyAgencyInputEnvelope
    set?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    disconnect?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    delete?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    connect?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    update?: RealEstateAgencyActUpdateWithWhereUniqueWithoutAgencyInput | RealEstateAgencyActUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: RealEstateAgencyActUpdateManyWithWhereWithoutAgencyInput | RealEstateAgencyActUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: RealEstateAgencyActScalarWhereInput | RealEstateAgencyActScalarWhereInput[]
  }

  export type AgencyToRealEstateAgentUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyToRealEstateAgentCreateWithoutAgencyInput, AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput> | AgencyToRealEstateAgentCreateWithoutAgencyInput[] | AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyToRealEstateAgentCreateOrConnectWithoutAgencyInput | AgencyToRealEstateAgentCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutAgencyInput | AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyToRealEstateAgentCreateManyAgencyInputEnvelope
    set?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    disconnect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    delete?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    connect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    update?: AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutAgencyInput | AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyToRealEstateAgentUpdateManyWithWhereWithoutAgencyInput | AgencyToRealEstateAgentUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyToRealEstateAgentScalarWhereInput | AgencyToRealEstateAgentScalarWhereInput[]
  }

  export type AgencyContractUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyContractCreateWithoutAgencyInput, AgencyContractUncheckedCreateWithoutAgencyInput> | AgencyContractCreateWithoutAgencyInput[] | AgencyContractUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutAgencyInput | AgencyContractCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutAgencyInput | AgencyContractUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyContractCreateManyAgencyInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutAgencyInput | AgencyContractUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutAgencyInput | AgencyContractUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type AgencyContractSignatoryUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyContractSignatoryCreateWithoutAgencyInput, AgencyContractSignatoryUncheckedCreateWithoutAgencyInput> | AgencyContractSignatoryCreateWithoutAgencyInput[] | AgencyContractSignatoryUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyContractSignatoryCreateOrConnectWithoutAgencyInput | AgencyContractSignatoryCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyContractSignatoryUpsertWithWhereUniqueWithoutAgencyInput | AgencyContractSignatoryUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyContractSignatoryCreateManyAgencyInputEnvelope
    set?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
    disconnect?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
    delete?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
    connect?: AgencyContractSignatoryWhereUniqueInput | AgencyContractSignatoryWhereUniqueInput[]
    update?: AgencyContractSignatoryUpdateWithWhereUniqueWithoutAgencyInput | AgencyContractSignatoryUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyContractSignatoryUpdateManyWithWhereWithoutAgencyInput | AgencyContractSignatoryUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyContractSignatoryScalarWhereInput | AgencyContractSignatoryScalarWhereInput[]
  }

  export type RealEstateAgencyActUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<RealEstateAgencyActCreateWithoutAgencyInput, RealEstateAgencyActUncheckedCreateWithoutAgencyInput> | RealEstateAgencyActCreateWithoutAgencyInput[] | RealEstateAgencyActUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: RealEstateAgencyActCreateOrConnectWithoutAgencyInput | RealEstateAgencyActCreateOrConnectWithoutAgencyInput[]
    upsert?: RealEstateAgencyActUpsertWithWhereUniqueWithoutAgencyInput | RealEstateAgencyActUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: RealEstateAgencyActCreateManyAgencyInputEnvelope
    set?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    disconnect?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    delete?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    connect?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    update?: RealEstateAgencyActUpdateWithWhereUniqueWithoutAgencyInput | RealEstateAgencyActUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: RealEstateAgencyActUpdateManyWithWhereWithoutAgencyInput | RealEstateAgencyActUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: RealEstateAgencyActScalarWhereInput | RealEstateAgencyActScalarWhereInput[]
  }

  export type AgencyToRealEstateAgentUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyToRealEstateAgentCreateWithoutAgencyInput, AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput> | AgencyToRealEstateAgentCreateWithoutAgencyInput[] | AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyToRealEstateAgentCreateOrConnectWithoutAgencyInput | AgencyToRealEstateAgentCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutAgencyInput | AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyToRealEstateAgentCreateManyAgencyInputEnvelope
    set?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    disconnect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    delete?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    connect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    update?: AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutAgencyInput | AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyToRealEstateAgentUpdateManyWithWhereWithoutAgencyInput | AgencyToRealEstateAgentUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyToRealEstateAgentScalarWhereInput | AgencyToRealEstateAgentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAgencyContractsInput = {
    create?: XOR<UserCreateWithoutAgencyContractsInput, UserUncheckedCreateWithoutAgencyContractsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgencyContractsInput
    connect?: UserWhereUniqueInput
  }

  export type EntityCreateNestedOneWithoutAgencyContractsInput = {
    create?: XOR<EntityCreateWithoutAgencyContractsInput, EntityUncheckedCreateWithoutAgencyContractsInput>
    connectOrCreate?: EntityCreateOrConnectWithoutAgencyContractsInput
    connect?: EntityWhereUniqueInput
  }

  export type ObjectCreateNestedOneWithoutAgencyContractsInput = {
    create?: XOR<ObjectCreateWithoutAgencyContractsInput, ObjectUncheckedCreateWithoutAgencyContractsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutAgencyContractsInput
    connect?: ObjectWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutAgencyContractsInput = {
    create?: XOR<AgencyCreateWithoutAgencyContractsInput, AgencyUncheckedCreateWithoutAgencyContractsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyContractsInput
    connect?: AgencyWhereUniqueInput
  }

  export type AgencyContractSignatoryCreateNestedOneWithoutAgencyContractsInput = {
    create?: XOR<AgencyContractSignatoryCreateWithoutAgencyContractsInput, AgencyContractSignatoryUncheckedCreateWithoutAgencyContractsInput>
    connectOrCreate?: AgencyContractSignatoryCreateOrConnectWithoutAgencyContractsInput
    connect?: AgencyContractSignatoryWhereUniqueInput
  }

  export type RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput = {
    create?: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgencyContractInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgencyContractInput>
    connectOrCreate?: RealEstateAgencyContractPropertiesCreateOrConnectWithoutAgencyContractInput
    connect?: RealEstateAgencyContractPropertiesWhereUniqueInput
  }

  export type MipAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput = {
    create?: XOR<MipAgencyContractPropertiesCreateWithoutAgencyContractInput, MipAgencyContractPropertiesUncheckedCreateWithoutAgencyContractInput>
    connectOrCreate?: MipAgencyContractPropertiesCreateOrConnectWithoutAgencyContractInput
    connect?: MipAgencyContractPropertiesWhereUniqueInput
  }

  export type RealEstateAgencyActCreateNestedManyWithoutAgencyContractInput = {
    create?: XOR<RealEstateAgencyActCreateWithoutAgencyContractInput, RealEstateAgencyActUncheckedCreateWithoutAgencyContractInput> | RealEstateAgencyActCreateWithoutAgencyContractInput[] | RealEstateAgencyActUncheckedCreateWithoutAgencyContractInput[]
    connectOrCreate?: RealEstateAgencyActCreateOrConnectWithoutAgencyContractInput | RealEstateAgencyActCreateOrConnectWithoutAgencyContractInput[]
    createMany?: RealEstateAgencyActCreateManyAgencyContractInputEnvelope
    connect?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
  }

  export type ClientContractToAgencyContractCreateNestedManyWithoutAgencyContractInput = {
    create?: XOR<ClientContractToAgencyContractCreateWithoutAgencyContractInput, ClientContractToAgencyContractUncheckedCreateWithoutAgencyContractInput> | ClientContractToAgencyContractCreateWithoutAgencyContractInput[] | ClientContractToAgencyContractUncheckedCreateWithoutAgencyContractInput[]
    connectOrCreate?: ClientContractToAgencyContractCreateOrConnectWithoutAgencyContractInput | ClientContractToAgencyContractCreateOrConnectWithoutAgencyContractInput[]
    createMany?: ClientContractToAgencyContractCreateManyAgencyContractInputEnvelope
    connect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
  }

  export type RealEstateAgencyActUncheckedCreateNestedManyWithoutAgencyContractInput = {
    create?: XOR<RealEstateAgencyActCreateWithoutAgencyContractInput, RealEstateAgencyActUncheckedCreateWithoutAgencyContractInput> | RealEstateAgencyActCreateWithoutAgencyContractInput[] | RealEstateAgencyActUncheckedCreateWithoutAgencyContractInput[]
    connectOrCreate?: RealEstateAgencyActCreateOrConnectWithoutAgencyContractInput | RealEstateAgencyActCreateOrConnectWithoutAgencyContractInput[]
    createMany?: RealEstateAgencyActCreateManyAgencyContractInputEnvelope
    connect?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
  }

  export type ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgencyContractInput = {
    create?: XOR<ClientContractToAgencyContractCreateWithoutAgencyContractInput, ClientContractToAgencyContractUncheckedCreateWithoutAgencyContractInput> | ClientContractToAgencyContractCreateWithoutAgencyContractInput[] | ClientContractToAgencyContractUncheckedCreateWithoutAgencyContractInput[]
    connectOrCreate?: ClientContractToAgencyContractCreateOrConnectWithoutAgencyContractInput | ClientContractToAgencyContractCreateOrConnectWithoutAgencyContractInput[]
    createMany?: ClientContractToAgencyContractCreateManyAgencyContractInputEnvelope
    connect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
  }

  export type EnumAgencyContractTypeFieldUpdateOperationsInput = {
    set?: $Enums.AgencyContractType
  }

  export type UserUpdateOneWithoutAgencyContractsNestedInput = {
    create?: XOR<UserCreateWithoutAgencyContractsInput, UserUncheckedCreateWithoutAgencyContractsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgencyContractsInput
    upsert?: UserUpsertWithoutAgencyContractsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgencyContractsInput, UserUpdateWithoutAgencyContractsInput>, UserUncheckedUpdateWithoutAgencyContractsInput>
  }

  export type EntityUpdateOneRequiredWithoutAgencyContractsNestedInput = {
    create?: XOR<EntityCreateWithoutAgencyContractsInput, EntityUncheckedCreateWithoutAgencyContractsInput>
    connectOrCreate?: EntityCreateOrConnectWithoutAgencyContractsInput
    upsert?: EntityUpsertWithoutAgencyContractsInput
    connect?: EntityWhereUniqueInput
    update?: XOR<XOR<EntityUpdateToOneWithWhereWithoutAgencyContractsInput, EntityUpdateWithoutAgencyContractsInput>, EntityUncheckedUpdateWithoutAgencyContractsInput>
  }

  export type ObjectUpdateOneRequiredWithoutAgencyContractsNestedInput = {
    create?: XOR<ObjectCreateWithoutAgencyContractsInput, ObjectUncheckedCreateWithoutAgencyContractsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutAgencyContractsInput
    upsert?: ObjectUpsertWithoutAgencyContractsInput
    connect?: ObjectWhereUniqueInput
    update?: XOR<XOR<ObjectUpdateToOneWithWhereWithoutAgencyContractsInput, ObjectUpdateWithoutAgencyContractsInput>, ObjectUncheckedUpdateWithoutAgencyContractsInput>
  }

  export type AgencyUpdateOneRequiredWithoutAgencyContractsNestedInput = {
    create?: XOR<AgencyCreateWithoutAgencyContractsInput, AgencyUncheckedCreateWithoutAgencyContractsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyContractsInput
    upsert?: AgencyUpsertWithoutAgencyContractsInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAgencyContractsInput, AgencyUpdateWithoutAgencyContractsInput>, AgencyUncheckedUpdateWithoutAgencyContractsInput>
  }

  export type AgencyContractSignatoryUpdateOneWithoutAgencyContractsNestedInput = {
    create?: XOR<AgencyContractSignatoryCreateWithoutAgencyContractsInput, AgencyContractSignatoryUncheckedCreateWithoutAgencyContractsInput>
    connectOrCreate?: AgencyContractSignatoryCreateOrConnectWithoutAgencyContractsInput
    upsert?: AgencyContractSignatoryUpsertWithoutAgencyContractsInput
    disconnect?: AgencyContractSignatoryWhereInput | boolean
    delete?: AgencyContractSignatoryWhereInput | boolean
    connect?: AgencyContractSignatoryWhereUniqueInput
    update?: XOR<XOR<AgencyContractSignatoryUpdateToOneWithWhereWithoutAgencyContractsInput, AgencyContractSignatoryUpdateWithoutAgencyContractsInput>, AgencyContractSignatoryUncheckedUpdateWithoutAgencyContractsInput>
  }

  export type RealEstateAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput = {
    create?: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgencyContractInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgencyContractInput>
    connectOrCreate?: RealEstateAgencyContractPropertiesCreateOrConnectWithoutAgencyContractInput
    upsert?: RealEstateAgencyContractPropertiesUpsertWithoutAgencyContractInput
    disconnect?: RealEstateAgencyContractPropertiesWhereInput | boolean
    delete?: RealEstateAgencyContractPropertiesWhereInput | boolean
    connect?: RealEstateAgencyContractPropertiesWhereUniqueInput
    update?: XOR<XOR<RealEstateAgencyContractPropertiesUpdateToOneWithWhereWithoutAgencyContractInput, RealEstateAgencyContractPropertiesUpdateWithoutAgencyContractInput>, RealEstateAgencyContractPropertiesUncheckedUpdateWithoutAgencyContractInput>
  }

  export type MipAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput = {
    create?: XOR<MipAgencyContractPropertiesCreateWithoutAgencyContractInput, MipAgencyContractPropertiesUncheckedCreateWithoutAgencyContractInput>
    connectOrCreate?: MipAgencyContractPropertiesCreateOrConnectWithoutAgencyContractInput
    upsert?: MipAgencyContractPropertiesUpsertWithoutAgencyContractInput
    disconnect?: MipAgencyContractPropertiesWhereInput | boolean
    delete?: MipAgencyContractPropertiesWhereInput | boolean
    connect?: MipAgencyContractPropertiesWhereUniqueInput
    update?: XOR<XOR<MipAgencyContractPropertiesUpdateToOneWithWhereWithoutAgencyContractInput, MipAgencyContractPropertiesUpdateWithoutAgencyContractInput>, MipAgencyContractPropertiesUncheckedUpdateWithoutAgencyContractInput>
  }

  export type RealEstateAgencyActUpdateManyWithoutAgencyContractNestedInput = {
    create?: XOR<RealEstateAgencyActCreateWithoutAgencyContractInput, RealEstateAgencyActUncheckedCreateWithoutAgencyContractInput> | RealEstateAgencyActCreateWithoutAgencyContractInput[] | RealEstateAgencyActUncheckedCreateWithoutAgencyContractInput[]
    connectOrCreate?: RealEstateAgencyActCreateOrConnectWithoutAgencyContractInput | RealEstateAgencyActCreateOrConnectWithoutAgencyContractInput[]
    upsert?: RealEstateAgencyActUpsertWithWhereUniqueWithoutAgencyContractInput | RealEstateAgencyActUpsertWithWhereUniqueWithoutAgencyContractInput[]
    createMany?: RealEstateAgencyActCreateManyAgencyContractInputEnvelope
    set?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    disconnect?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    delete?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    connect?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    update?: RealEstateAgencyActUpdateWithWhereUniqueWithoutAgencyContractInput | RealEstateAgencyActUpdateWithWhereUniqueWithoutAgencyContractInput[]
    updateMany?: RealEstateAgencyActUpdateManyWithWhereWithoutAgencyContractInput | RealEstateAgencyActUpdateManyWithWhereWithoutAgencyContractInput[]
    deleteMany?: RealEstateAgencyActScalarWhereInput | RealEstateAgencyActScalarWhereInput[]
  }

  export type ClientContractToAgencyContractUpdateManyWithoutAgencyContractNestedInput = {
    create?: XOR<ClientContractToAgencyContractCreateWithoutAgencyContractInput, ClientContractToAgencyContractUncheckedCreateWithoutAgencyContractInput> | ClientContractToAgencyContractCreateWithoutAgencyContractInput[] | ClientContractToAgencyContractUncheckedCreateWithoutAgencyContractInput[]
    connectOrCreate?: ClientContractToAgencyContractCreateOrConnectWithoutAgencyContractInput | ClientContractToAgencyContractCreateOrConnectWithoutAgencyContractInput[]
    upsert?: ClientContractToAgencyContractUpsertWithWhereUniqueWithoutAgencyContractInput | ClientContractToAgencyContractUpsertWithWhereUniqueWithoutAgencyContractInput[]
    createMany?: ClientContractToAgencyContractCreateManyAgencyContractInputEnvelope
    set?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    disconnect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    delete?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    connect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    update?: ClientContractToAgencyContractUpdateWithWhereUniqueWithoutAgencyContractInput | ClientContractToAgencyContractUpdateWithWhereUniqueWithoutAgencyContractInput[]
    updateMany?: ClientContractToAgencyContractUpdateManyWithWhereWithoutAgencyContractInput | ClientContractToAgencyContractUpdateManyWithWhereWithoutAgencyContractInput[]
    deleteMany?: ClientContractToAgencyContractScalarWhereInput | ClientContractToAgencyContractScalarWhereInput[]
  }

  export type RealEstateAgencyActUncheckedUpdateManyWithoutAgencyContractNestedInput = {
    create?: XOR<RealEstateAgencyActCreateWithoutAgencyContractInput, RealEstateAgencyActUncheckedCreateWithoutAgencyContractInput> | RealEstateAgencyActCreateWithoutAgencyContractInput[] | RealEstateAgencyActUncheckedCreateWithoutAgencyContractInput[]
    connectOrCreate?: RealEstateAgencyActCreateOrConnectWithoutAgencyContractInput | RealEstateAgencyActCreateOrConnectWithoutAgencyContractInput[]
    upsert?: RealEstateAgencyActUpsertWithWhereUniqueWithoutAgencyContractInput | RealEstateAgencyActUpsertWithWhereUniqueWithoutAgencyContractInput[]
    createMany?: RealEstateAgencyActCreateManyAgencyContractInputEnvelope
    set?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    disconnect?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    delete?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    connect?: RealEstateAgencyActWhereUniqueInput | RealEstateAgencyActWhereUniqueInput[]
    update?: RealEstateAgencyActUpdateWithWhereUniqueWithoutAgencyContractInput | RealEstateAgencyActUpdateWithWhereUniqueWithoutAgencyContractInput[]
    updateMany?: RealEstateAgencyActUpdateManyWithWhereWithoutAgencyContractInput | RealEstateAgencyActUpdateManyWithWhereWithoutAgencyContractInput[]
    deleteMany?: RealEstateAgencyActScalarWhereInput | RealEstateAgencyActScalarWhereInput[]
  }

  export type ClientContractToAgencyContractUncheckedUpdateManyWithoutAgencyContractNestedInput = {
    create?: XOR<ClientContractToAgencyContractCreateWithoutAgencyContractInput, ClientContractToAgencyContractUncheckedCreateWithoutAgencyContractInput> | ClientContractToAgencyContractCreateWithoutAgencyContractInput[] | ClientContractToAgencyContractUncheckedCreateWithoutAgencyContractInput[]
    connectOrCreate?: ClientContractToAgencyContractCreateOrConnectWithoutAgencyContractInput | ClientContractToAgencyContractCreateOrConnectWithoutAgencyContractInput[]
    upsert?: ClientContractToAgencyContractUpsertWithWhereUniqueWithoutAgencyContractInput | ClientContractToAgencyContractUpsertWithWhereUniqueWithoutAgencyContractInput[]
    createMany?: ClientContractToAgencyContractCreateManyAgencyContractInputEnvelope
    set?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    disconnect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    delete?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    connect?: ClientContractToAgencyContractWhereUniqueInput | ClientContractToAgencyContractWhereUniqueInput[]
    update?: ClientContractToAgencyContractUpdateWithWhereUniqueWithoutAgencyContractInput | ClientContractToAgencyContractUpdateWithWhereUniqueWithoutAgencyContractInput[]
    updateMany?: ClientContractToAgencyContractUpdateManyWithWhereWithoutAgencyContractInput | ClientContractToAgencyContractUpdateManyWithWhereWithoutAgencyContractInput[]
    deleteMany?: ClientContractToAgencyContractScalarWhereInput | ClientContractToAgencyContractScalarWhereInput[]
  }

  export type AgencyCreateNestedOneWithoutAgencyContractSignatoryInput = {
    create?: XOR<AgencyCreateWithoutAgencyContractSignatoryInput, AgencyUncheckedCreateWithoutAgencyContractSignatoryInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyContractSignatoryInput
    connect?: AgencyWhereUniqueInput
  }

  export type AgencyContractCreateNestedManyWithoutAgencyContractSignatoryInput = {
    create?: XOR<AgencyContractCreateWithoutAgencyContractSignatoryInput, AgencyContractUncheckedCreateWithoutAgencyContractSignatoryInput> | AgencyContractCreateWithoutAgencyContractSignatoryInput[] | AgencyContractUncheckedCreateWithoutAgencyContractSignatoryInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutAgencyContractSignatoryInput | AgencyContractCreateOrConnectWithoutAgencyContractSignatoryInput[]
    createMany?: AgencyContractCreateManyAgencyContractSignatoryInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type AgencyContractUncheckedCreateNestedManyWithoutAgencyContractSignatoryInput = {
    create?: XOR<AgencyContractCreateWithoutAgencyContractSignatoryInput, AgencyContractUncheckedCreateWithoutAgencyContractSignatoryInput> | AgencyContractCreateWithoutAgencyContractSignatoryInput[] | AgencyContractUncheckedCreateWithoutAgencyContractSignatoryInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutAgencyContractSignatoryInput | AgencyContractCreateOrConnectWithoutAgencyContractSignatoryInput[]
    createMany?: AgencyContractCreateManyAgencyContractSignatoryInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type AgencyUpdateOneRequiredWithoutAgencyContractSignatoryNestedInput = {
    create?: XOR<AgencyCreateWithoutAgencyContractSignatoryInput, AgencyUncheckedCreateWithoutAgencyContractSignatoryInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyContractSignatoryInput
    upsert?: AgencyUpsertWithoutAgencyContractSignatoryInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAgencyContractSignatoryInput, AgencyUpdateWithoutAgencyContractSignatoryInput>, AgencyUncheckedUpdateWithoutAgencyContractSignatoryInput>
  }

  export type AgencyContractUpdateManyWithoutAgencyContractSignatoryNestedInput = {
    create?: XOR<AgencyContractCreateWithoutAgencyContractSignatoryInput, AgencyContractUncheckedCreateWithoutAgencyContractSignatoryInput> | AgencyContractCreateWithoutAgencyContractSignatoryInput[] | AgencyContractUncheckedCreateWithoutAgencyContractSignatoryInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutAgencyContractSignatoryInput | AgencyContractCreateOrConnectWithoutAgencyContractSignatoryInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutAgencyContractSignatoryInput | AgencyContractUpsertWithWhereUniqueWithoutAgencyContractSignatoryInput[]
    createMany?: AgencyContractCreateManyAgencyContractSignatoryInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutAgencyContractSignatoryInput | AgencyContractUpdateWithWhereUniqueWithoutAgencyContractSignatoryInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutAgencyContractSignatoryInput | AgencyContractUpdateManyWithWhereWithoutAgencyContractSignatoryInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type AgencyContractUncheckedUpdateManyWithoutAgencyContractSignatoryNestedInput = {
    create?: XOR<AgencyContractCreateWithoutAgencyContractSignatoryInput, AgencyContractUncheckedCreateWithoutAgencyContractSignatoryInput> | AgencyContractCreateWithoutAgencyContractSignatoryInput[] | AgencyContractUncheckedCreateWithoutAgencyContractSignatoryInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutAgencyContractSignatoryInput | AgencyContractCreateOrConnectWithoutAgencyContractSignatoryInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutAgencyContractSignatoryInput | AgencyContractUpsertWithWhereUniqueWithoutAgencyContractSignatoryInput[]
    createMany?: AgencyContractCreateManyAgencyContractSignatoryInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutAgencyContractSignatoryInput | AgencyContractUpdateWithWhereUniqueWithoutAgencyContractSignatoryInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutAgencyContractSignatoryInput | AgencyContractUpdateManyWithWhereWithoutAgencyContractSignatoryInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type AgencyContractCreateNestedOneWithoutRealEstateAgencyContractPropertiesInput = {
    create?: XOR<AgencyContractCreateWithoutRealEstateAgencyContractPropertiesInput, AgencyContractUncheckedCreateWithoutRealEstateAgencyContractPropertiesInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutRealEstateAgencyContractPropertiesInput
    connect?: AgencyContractWhereUniqueInput
  }

  export type AgencyContractCommissionCreateNestedOneWithoutRealEstateAgencyContractPropertiesInput = {
    create?: XOR<AgencyContractCommissionCreateWithoutRealEstateAgencyContractPropertiesInput, AgencyContractCommissionUncheckedCreateWithoutRealEstateAgencyContractPropertiesInput>
    connectOrCreate?: AgencyContractCommissionCreateOrConnectWithoutRealEstateAgencyContractPropertiesInput
    connect?: AgencyContractCommissionWhereUniqueInput
  }

  export type AgencyContractUncheckedCreateNestedOneWithoutRealEstateAgencyContractPropertiesInput = {
    create?: XOR<AgencyContractCreateWithoutRealEstateAgencyContractPropertiesInput, AgencyContractUncheckedCreateWithoutRealEstateAgencyContractPropertiesInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutRealEstateAgencyContractPropertiesInput
    connect?: AgencyContractWhereUniqueInput
  }

  export type AgencyContractUpdateOneWithoutRealEstateAgencyContractPropertiesNestedInput = {
    create?: XOR<AgencyContractCreateWithoutRealEstateAgencyContractPropertiesInput, AgencyContractUncheckedCreateWithoutRealEstateAgencyContractPropertiesInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutRealEstateAgencyContractPropertiesInput
    upsert?: AgencyContractUpsertWithoutRealEstateAgencyContractPropertiesInput
    disconnect?: AgencyContractWhereInput | boolean
    delete?: AgencyContractWhereInput | boolean
    connect?: AgencyContractWhereUniqueInput
    update?: XOR<XOR<AgencyContractUpdateToOneWithWhereWithoutRealEstateAgencyContractPropertiesInput, AgencyContractUpdateWithoutRealEstateAgencyContractPropertiesInput>, AgencyContractUncheckedUpdateWithoutRealEstateAgencyContractPropertiesInput>
  }

  export type AgencyContractCommissionUpdateOneRequiredWithoutRealEstateAgencyContractPropertiesNestedInput = {
    create?: XOR<AgencyContractCommissionCreateWithoutRealEstateAgencyContractPropertiesInput, AgencyContractCommissionUncheckedCreateWithoutRealEstateAgencyContractPropertiesInput>
    connectOrCreate?: AgencyContractCommissionCreateOrConnectWithoutRealEstateAgencyContractPropertiesInput
    upsert?: AgencyContractCommissionUpsertWithoutRealEstateAgencyContractPropertiesInput
    connect?: AgencyContractCommissionWhereUniqueInput
    update?: XOR<XOR<AgencyContractCommissionUpdateToOneWithWhereWithoutRealEstateAgencyContractPropertiesInput, AgencyContractCommissionUpdateWithoutRealEstateAgencyContractPropertiesInput>, AgencyContractCommissionUncheckedUpdateWithoutRealEstateAgencyContractPropertiesInput>
  }

  export type AgencyContractUncheckedUpdateOneWithoutRealEstateAgencyContractPropertiesNestedInput = {
    create?: XOR<AgencyContractCreateWithoutRealEstateAgencyContractPropertiesInput, AgencyContractUncheckedCreateWithoutRealEstateAgencyContractPropertiesInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutRealEstateAgencyContractPropertiesInput
    upsert?: AgencyContractUpsertWithoutRealEstateAgencyContractPropertiesInput
    disconnect?: AgencyContractWhereInput | boolean
    delete?: AgencyContractWhereInput | boolean
    connect?: AgencyContractWhereUniqueInput
    update?: XOR<XOR<AgencyContractUpdateToOneWithWhereWithoutRealEstateAgencyContractPropertiesInput, AgencyContractUpdateWithoutRealEstateAgencyContractPropertiesInput>, AgencyContractUncheckedUpdateWithoutRealEstateAgencyContractPropertiesInput>
  }

  export type AgencyContractCreateNestedOneWithoutMipAgencyContractPropertiesInput = {
    create?: XOR<AgencyContractCreateWithoutMipAgencyContractPropertiesInput, AgencyContractUncheckedCreateWithoutMipAgencyContractPropertiesInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutMipAgencyContractPropertiesInput
    connect?: AgencyContractWhereUniqueInput
  }

  export type AgencyContractCommissionCreateNestedOneWithoutMipAgencyContractPropertiesInput = {
    create?: XOR<AgencyContractCommissionCreateWithoutMipAgencyContractPropertiesInput, AgencyContractCommissionUncheckedCreateWithoutMipAgencyContractPropertiesInput>
    connectOrCreate?: AgencyContractCommissionCreateOrConnectWithoutMipAgencyContractPropertiesInput
    connect?: AgencyContractCommissionWhereUniqueInput
  }

  export type AgencyContractUncheckedCreateNestedOneWithoutMipAgencyContractPropertiesInput = {
    create?: XOR<AgencyContractCreateWithoutMipAgencyContractPropertiesInput, AgencyContractUncheckedCreateWithoutMipAgencyContractPropertiesInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutMipAgencyContractPropertiesInput
    connect?: AgencyContractWhereUniqueInput
  }

  export type AgencyContractUpdateOneWithoutMipAgencyContractPropertiesNestedInput = {
    create?: XOR<AgencyContractCreateWithoutMipAgencyContractPropertiesInput, AgencyContractUncheckedCreateWithoutMipAgencyContractPropertiesInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutMipAgencyContractPropertiesInput
    upsert?: AgencyContractUpsertWithoutMipAgencyContractPropertiesInput
    disconnect?: AgencyContractWhereInput | boolean
    delete?: AgencyContractWhereInput | boolean
    connect?: AgencyContractWhereUniqueInput
    update?: XOR<XOR<AgencyContractUpdateToOneWithWhereWithoutMipAgencyContractPropertiesInput, AgencyContractUpdateWithoutMipAgencyContractPropertiesInput>, AgencyContractUncheckedUpdateWithoutMipAgencyContractPropertiesInput>
  }

  export type AgencyContractCommissionUpdateOneRequiredWithoutMipAgencyContractPropertiesNestedInput = {
    create?: XOR<AgencyContractCommissionCreateWithoutMipAgencyContractPropertiesInput, AgencyContractCommissionUncheckedCreateWithoutMipAgencyContractPropertiesInput>
    connectOrCreate?: AgencyContractCommissionCreateOrConnectWithoutMipAgencyContractPropertiesInput
    upsert?: AgencyContractCommissionUpsertWithoutMipAgencyContractPropertiesInput
    connect?: AgencyContractCommissionWhereUniqueInput
    update?: XOR<XOR<AgencyContractCommissionUpdateToOneWithWhereWithoutMipAgencyContractPropertiesInput, AgencyContractCommissionUpdateWithoutMipAgencyContractPropertiesInput>, AgencyContractCommissionUncheckedUpdateWithoutMipAgencyContractPropertiesInput>
  }

  export type AgencyContractUncheckedUpdateOneWithoutMipAgencyContractPropertiesNestedInput = {
    create?: XOR<AgencyContractCreateWithoutMipAgencyContractPropertiesInput, AgencyContractUncheckedCreateWithoutMipAgencyContractPropertiesInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutMipAgencyContractPropertiesInput
    upsert?: AgencyContractUpsertWithoutMipAgencyContractPropertiesInput
    disconnect?: AgencyContractWhereInput | boolean
    delete?: AgencyContractWhereInput | boolean
    connect?: AgencyContractWhereUniqueInput
    update?: XOR<XOR<AgencyContractUpdateToOneWithWhereWithoutMipAgencyContractPropertiesInput, AgencyContractUpdateWithoutMipAgencyContractPropertiesInput>, AgencyContractUncheckedUpdateWithoutMipAgencyContractPropertiesInput>
  }

  export type RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgencyContractCommissionInput = {
    create?: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgencyContractCommissionInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgencyContractCommissionInput>
    connectOrCreate?: RealEstateAgencyContractPropertiesCreateOrConnectWithoutAgencyContractCommissionInput
    connect?: RealEstateAgencyContractPropertiesWhereUniqueInput
  }

  export type MipAgencyContractPropertiesCreateNestedOneWithoutAgencyContractCommissionInput = {
    create?: XOR<MipAgencyContractPropertiesCreateWithoutAgencyContractCommissionInput, MipAgencyContractPropertiesUncheckedCreateWithoutAgencyContractCommissionInput>
    connectOrCreate?: MipAgencyContractPropertiesCreateOrConnectWithoutAgencyContractCommissionInput
    connect?: MipAgencyContractPropertiesWhereUniqueInput
  }

  export type RealEstateAgencyContractPropertiesUncheckedCreateNestedOneWithoutAgencyContractCommissionInput = {
    create?: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgencyContractCommissionInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgencyContractCommissionInput>
    connectOrCreate?: RealEstateAgencyContractPropertiesCreateOrConnectWithoutAgencyContractCommissionInput
    connect?: RealEstateAgencyContractPropertiesWhereUniqueInput
  }

  export type MipAgencyContractPropertiesUncheckedCreateNestedOneWithoutAgencyContractCommissionInput = {
    create?: XOR<MipAgencyContractPropertiesCreateWithoutAgencyContractCommissionInput, MipAgencyContractPropertiesUncheckedCreateWithoutAgencyContractCommissionInput>
    connectOrCreate?: MipAgencyContractPropertiesCreateOrConnectWithoutAgencyContractCommissionInput
    connect?: MipAgencyContractPropertiesWhereUniqueInput
  }

  export type RealEstateAgencyContractPropertiesUpdateOneWithoutAgencyContractCommissionNestedInput = {
    create?: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgencyContractCommissionInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgencyContractCommissionInput>
    connectOrCreate?: RealEstateAgencyContractPropertiesCreateOrConnectWithoutAgencyContractCommissionInput
    upsert?: RealEstateAgencyContractPropertiesUpsertWithoutAgencyContractCommissionInput
    disconnect?: RealEstateAgencyContractPropertiesWhereInput | boolean
    delete?: RealEstateAgencyContractPropertiesWhereInput | boolean
    connect?: RealEstateAgencyContractPropertiesWhereUniqueInput
    update?: XOR<XOR<RealEstateAgencyContractPropertiesUpdateToOneWithWhereWithoutAgencyContractCommissionInput, RealEstateAgencyContractPropertiesUpdateWithoutAgencyContractCommissionInput>, RealEstateAgencyContractPropertiesUncheckedUpdateWithoutAgencyContractCommissionInput>
  }

  export type MipAgencyContractPropertiesUpdateOneWithoutAgencyContractCommissionNestedInput = {
    create?: XOR<MipAgencyContractPropertiesCreateWithoutAgencyContractCommissionInput, MipAgencyContractPropertiesUncheckedCreateWithoutAgencyContractCommissionInput>
    connectOrCreate?: MipAgencyContractPropertiesCreateOrConnectWithoutAgencyContractCommissionInput
    upsert?: MipAgencyContractPropertiesUpsertWithoutAgencyContractCommissionInput
    disconnect?: MipAgencyContractPropertiesWhereInput | boolean
    delete?: MipAgencyContractPropertiesWhereInput | boolean
    connect?: MipAgencyContractPropertiesWhereUniqueInput
    update?: XOR<XOR<MipAgencyContractPropertiesUpdateToOneWithWhereWithoutAgencyContractCommissionInput, MipAgencyContractPropertiesUpdateWithoutAgencyContractCommissionInput>, MipAgencyContractPropertiesUncheckedUpdateWithoutAgencyContractCommissionInput>
  }

  export type RealEstateAgencyContractPropertiesUncheckedUpdateOneWithoutAgencyContractCommissionNestedInput = {
    create?: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgencyContractCommissionInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgencyContractCommissionInput>
    connectOrCreate?: RealEstateAgencyContractPropertiesCreateOrConnectWithoutAgencyContractCommissionInput
    upsert?: RealEstateAgencyContractPropertiesUpsertWithoutAgencyContractCommissionInput
    disconnect?: RealEstateAgencyContractPropertiesWhereInput | boolean
    delete?: RealEstateAgencyContractPropertiesWhereInput | boolean
    connect?: RealEstateAgencyContractPropertiesWhereUniqueInput
    update?: XOR<XOR<RealEstateAgencyContractPropertiesUpdateToOneWithWhereWithoutAgencyContractCommissionInput, RealEstateAgencyContractPropertiesUpdateWithoutAgencyContractCommissionInput>, RealEstateAgencyContractPropertiesUncheckedUpdateWithoutAgencyContractCommissionInput>
  }

  export type MipAgencyContractPropertiesUncheckedUpdateOneWithoutAgencyContractCommissionNestedInput = {
    create?: XOR<MipAgencyContractPropertiesCreateWithoutAgencyContractCommissionInput, MipAgencyContractPropertiesUncheckedCreateWithoutAgencyContractCommissionInput>
    connectOrCreate?: MipAgencyContractPropertiesCreateOrConnectWithoutAgencyContractCommissionInput
    upsert?: MipAgencyContractPropertiesUpsertWithoutAgencyContractCommissionInput
    disconnect?: MipAgencyContractPropertiesWhereInput | boolean
    delete?: MipAgencyContractPropertiesWhereInput | boolean
    connect?: MipAgencyContractPropertiesWhereUniqueInput
    update?: XOR<XOR<MipAgencyContractPropertiesUpdateToOneWithWhereWithoutAgencyContractCommissionInput, MipAgencyContractPropertiesUpdateWithoutAgencyContractCommissionInput>, MipAgencyContractPropertiesUncheckedUpdateWithoutAgencyContractCommissionInput>
  }

  export type ClientContractCreateNestedManyWithoutRealEstateAgentInput = {
    create?: XOR<ClientContractCreateWithoutRealEstateAgentInput, ClientContractUncheckedCreateWithoutRealEstateAgentInput> | ClientContractCreateWithoutRealEstateAgentInput[] | ClientContractUncheckedCreateWithoutRealEstateAgentInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutRealEstateAgentInput | ClientContractCreateOrConnectWithoutRealEstateAgentInput[]
    createMany?: ClientContractCreateManyRealEstateAgentInputEnvelope
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
  }

  export type AgencyToRealEstateAgentCreateNestedManyWithoutRealEstateAgentInput = {
    create?: XOR<AgencyToRealEstateAgentCreateWithoutRealEstateAgentInput, AgencyToRealEstateAgentUncheckedCreateWithoutRealEstateAgentInput> | AgencyToRealEstateAgentCreateWithoutRealEstateAgentInput[] | AgencyToRealEstateAgentUncheckedCreateWithoutRealEstateAgentInput[]
    connectOrCreate?: AgencyToRealEstateAgentCreateOrConnectWithoutRealEstateAgentInput | AgencyToRealEstateAgentCreateOrConnectWithoutRealEstateAgentInput[]
    createMany?: AgencyToRealEstateAgentCreateManyRealEstateAgentInputEnvelope
    connect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
  }

  export type ClientContractUncheckedCreateNestedManyWithoutRealEstateAgentInput = {
    create?: XOR<ClientContractCreateWithoutRealEstateAgentInput, ClientContractUncheckedCreateWithoutRealEstateAgentInput> | ClientContractCreateWithoutRealEstateAgentInput[] | ClientContractUncheckedCreateWithoutRealEstateAgentInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutRealEstateAgentInput | ClientContractCreateOrConnectWithoutRealEstateAgentInput[]
    createMany?: ClientContractCreateManyRealEstateAgentInputEnvelope
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
  }

  export type AgencyToRealEstateAgentUncheckedCreateNestedManyWithoutRealEstateAgentInput = {
    create?: XOR<AgencyToRealEstateAgentCreateWithoutRealEstateAgentInput, AgencyToRealEstateAgentUncheckedCreateWithoutRealEstateAgentInput> | AgencyToRealEstateAgentCreateWithoutRealEstateAgentInput[] | AgencyToRealEstateAgentUncheckedCreateWithoutRealEstateAgentInput[]
    connectOrCreate?: AgencyToRealEstateAgentCreateOrConnectWithoutRealEstateAgentInput | AgencyToRealEstateAgentCreateOrConnectWithoutRealEstateAgentInput[]
    createMany?: AgencyToRealEstateAgentCreateManyRealEstateAgentInputEnvelope
    connect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
  }

  export type ClientContractUpdateManyWithoutRealEstateAgentNestedInput = {
    create?: XOR<ClientContractCreateWithoutRealEstateAgentInput, ClientContractUncheckedCreateWithoutRealEstateAgentInput> | ClientContractCreateWithoutRealEstateAgentInput[] | ClientContractUncheckedCreateWithoutRealEstateAgentInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutRealEstateAgentInput | ClientContractCreateOrConnectWithoutRealEstateAgentInput[]
    upsert?: ClientContractUpsertWithWhereUniqueWithoutRealEstateAgentInput | ClientContractUpsertWithWhereUniqueWithoutRealEstateAgentInput[]
    createMany?: ClientContractCreateManyRealEstateAgentInputEnvelope
    set?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    disconnect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    delete?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    update?: ClientContractUpdateWithWhereUniqueWithoutRealEstateAgentInput | ClientContractUpdateWithWhereUniqueWithoutRealEstateAgentInput[]
    updateMany?: ClientContractUpdateManyWithWhereWithoutRealEstateAgentInput | ClientContractUpdateManyWithWhereWithoutRealEstateAgentInput[]
    deleteMany?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
  }

  export type AgencyToRealEstateAgentUpdateManyWithoutRealEstateAgentNestedInput = {
    create?: XOR<AgencyToRealEstateAgentCreateWithoutRealEstateAgentInput, AgencyToRealEstateAgentUncheckedCreateWithoutRealEstateAgentInput> | AgencyToRealEstateAgentCreateWithoutRealEstateAgentInput[] | AgencyToRealEstateAgentUncheckedCreateWithoutRealEstateAgentInput[]
    connectOrCreate?: AgencyToRealEstateAgentCreateOrConnectWithoutRealEstateAgentInput | AgencyToRealEstateAgentCreateOrConnectWithoutRealEstateAgentInput[]
    upsert?: AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutRealEstateAgentInput | AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutRealEstateAgentInput[]
    createMany?: AgencyToRealEstateAgentCreateManyRealEstateAgentInputEnvelope
    set?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    disconnect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    delete?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    connect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    update?: AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutRealEstateAgentInput | AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutRealEstateAgentInput[]
    updateMany?: AgencyToRealEstateAgentUpdateManyWithWhereWithoutRealEstateAgentInput | AgencyToRealEstateAgentUpdateManyWithWhereWithoutRealEstateAgentInput[]
    deleteMany?: AgencyToRealEstateAgentScalarWhereInput | AgencyToRealEstateAgentScalarWhereInput[]
  }

  export type ClientContractUncheckedUpdateManyWithoutRealEstateAgentNestedInput = {
    create?: XOR<ClientContractCreateWithoutRealEstateAgentInput, ClientContractUncheckedCreateWithoutRealEstateAgentInput> | ClientContractCreateWithoutRealEstateAgentInput[] | ClientContractUncheckedCreateWithoutRealEstateAgentInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutRealEstateAgentInput | ClientContractCreateOrConnectWithoutRealEstateAgentInput[]
    upsert?: ClientContractUpsertWithWhereUniqueWithoutRealEstateAgentInput | ClientContractUpsertWithWhereUniqueWithoutRealEstateAgentInput[]
    createMany?: ClientContractCreateManyRealEstateAgentInputEnvelope
    set?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    disconnect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    delete?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    update?: ClientContractUpdateWithWhereUniqueWithoutRealEstateAgentInput | ClientContractUpdateWithWhereUniqueWithoutRealEstateAgentInput[]
    updateMany?: ClientContractUpdateManyWithWhereWithoutRealEstateAgentInput | ClientContractUpdateManyWithWhereWithoutRealEstateAgentInput[]
    deleteMany?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
  }

  export type AgencyToRealEstateAgentUncheckedUpdateManyWithoutRealEstateAgentNestedInput = {
    create?: XOR<AgencyToRealEstateAgentCreateWithoutRealEstateAgentInput, AgencyToRealEstateAgentUncheckedCreateWithoutRealEstateAgentInput> | AgencyToRealEstateAgentCreateWithoutRealEstateAgentInput[] | AgencyToRealEstateAgentUncheckedCreateWithoutRealEstateAgentInput[]
    connectOrCreate?: AgencyToRealEstateAgentCreateOrConnectWithoutRealEstateAgentInput | AgencyToRealEstateAgentCreateOrConnectWithoutRealEstateAgentInput[]
    upsert?: AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutRealEstateAgentInput | AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutRealEstateAgentInput[]
    createMany?: AgencyToRealEstateAgentCreateManyRealEstateAgentInputEnvelope
    set?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    disconnect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    delete?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    connect?: AgencyToRealEstateAgentWhereUniqueInput | AgencyToRealEstateAgentWhereUniqueInput[]
    update?: AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutRealEstateAgentInput | AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutRealEstateAgentInput[]
    updateMany?: AgencyToRealEstateAgentUpdateManyWithWhereWithoutRealEstateAgentInput | AgencyToRealEstateAgentUpdateManyWithWhereWithoutRealEstateAgentInput[]
    deleteMany?: AgencyToRealEstateAgentScalarWhereInput | AgencyToRealEstateAgentScalarWhereInput[]
  }

  export type AgencyCreateNestedOneWithoutAgenciesToRealEstateAgentsInput = {
    create?: XOR<AgencyCreateWithoutAgenciesToRealEstateAgentsInput, AgencyUncheckedCreateWithoutAgenciesToRealEstateAgentsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgenciesToRealEstateAgentsInput
    connect?: AgencyWhereUniqueInput
  }

  export type RealEstateAgentCreateNestedOneWithoutAgenciesToRealEstateAgentsInput = {
    create?: XOR<RealEstateAgentCreateWithoutAgenciesToRealEstateAgentsInput, RealEstateAgentUncheckedCreateWithoutAgenciesToRealEstateAgentsInput>
    connectOrCreate?: RealEstateAgentCreateOrConnectWithoutAgenciesToRealEstateAgentsInput
    connect?: RealEstateAgentWhereUniqueInput
  }

  export type AgencyUpdateOneRequiredWithoutAgenciesToRealEstateAgentsNestedInput = {
    create?: XOR<AgencyCreateWithoutAgenciesToRealEstateAgentsInput, AgencyUncheckedCreateWithoutAgenciesToRealEstateAgentsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgenciesToRealEstateAgentsInput
    upsert?: AgencyUpsertWithoutAgenciesToRealEstateAgentsInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAgenciesToRealEstateAgentsInput, AgencyUpdateWithoutAgenciesToRealEstateAgentsInput>, AgencyUncheckedUpdateWithoutAgenciesToRealEstateAgentsInput>
  }

  export type RealEstateAgentUpdateOneRequiredWithoutAgenciesToRealEstateAgentsNestedInput = {
    create?: XOR<RealEstateAgentCreateWithoutAgenciesToRealEstateAgentsInput, RealEstateAgentUncheckedCreateWithoutAgenciesToRealEstateAgentsInput>
    connectOrCreate?: RealEstateAgentCreateOrConnectWithoutAgenciesToRealEstateAgentsInput
    upsert?: RealEstateAgentUpsertWithoutAgenciesToRealEstateAgentsInput
    connect?: RealEstateAgentWhereUniqueInput
    update?: XOR<XOR<RealEstateAgentUpdateToOneWithWhereWithoutAgenciesToRealEstateAgentsInput, RealEstateAgentUpdateWithoutAgenciesToRealEstateAgentsInput>, RealEstateAgentUncheckedUpdateWithoutAgenciesToRealEstateAgentsInput>
  }

  export type AgencyContractCreateNestedManyWithoutEntityInput = {
    create?: XOR<AgencyContractCreateWithoutEntityInput, AgencyContractUncheckedCreateWithoutEntityInput> | AgencyContractCreateWithoutEntityInput[] | AgencyContractUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutEntityInput | AgencyContractCreateOrConnectWithoutEntityInput[]
    createMany?: AgencyContractCreateManyEntityInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type ObjectCreateNestedManyWithoutEntityInput = {
    create?: XOR<ObjectCreateWithoutEntityInput, ObjectUncheckedCreateWithoutEntityInput> | ObjectCreateWithoutEntityInput[] | ObjectUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutEntityInput | ObjectCreateOrConnectWithoutEntityInput[]
    createMany?: ObjectCreateManyEntityInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type EntityForbiddenWebsiteCreateNestedManyWithoutEntityInput = {
    create?: XOR<EntityForbiddenWebsiteCreateWithoutEntityInput, EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput> | EntityForbiddenWebsiteCreateWithoutEntityInput[] | EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: EntityForbiddenWebsiteCreateOrConnectWithoutEntityInput | EntityForbiddenWebsiteCreateOrConnectWithoutEntityInput[]
    createMany?: EntityForbiddenWebsiteCreateManyEntityInputEnvelope
    connect?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
  }

  export type EntityForbiddenBrandCreateNestedManyWithoutEntityInput = {
    create?: XOR<EntityForbiddenBrandCreateWithoutEntityInput, EntityForbiddenBrandUncheckedCreateWithoutEntityInput> | EntityForbiddenBrandCreateWithoutEntityInput[] | EntityForbiddenBrandUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: EntityForbiddenBrandCreateOrConnectWithoutEntityInput | EntityForbiddenBrandCreateOrConnectWithoutEntityInput[]
    createMany?: EntityForbiddenBrandCreateManyEntityInputEnvelope
    connect?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
  }

  export type AgencyContractUncheckedCreateNestedManyWithoutEntityInput = {
    create?: XOR<AgencyContractCreateWithoutEntityInput, AgencyContractUncheckedCreateWithoutEntityInput> | AgencyContractCreateWithoutEntityInput[] | AgencyContractUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutEntityInput | AgencyContractCreateOrConnectWithoutEntityInput[]
    createMany?: AgencyContractCreateManyEntityInputEnvelope
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
  }

  export type ObjectUncheckedCreateNestedManyWithoutEntityInput = {
    create?: XOR<ObjectCreateWithoutEntityInput, ObjectUncheckedCreateWithoutEntityInput> | ObjectCreateWithoutEntityInput[] | ObjectUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutEntityInput | ObjectCreateOrConnectWithoutEntityInput[]
    createMany?: ObjectCreateManyEntityInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type EntityForbiddenWebsiteUncheckedCreateNestedManyWithoutEntityInput = {
    create?: XOR<EntityForbiddenWebsiteCreateWithoutEntityInput, EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput> | EntityForbiddenWebsiteCreateWithoutEntityInput[] | EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: EntityForbiddenWebsiteCreateOrConnectWithoutEntityInput | EntityForbiddenWebsiteCreateOrConnectWithoutEntityInput[]
    createMany?: EntityForbiddenWebsiteCreateManyEntityInputEnvelope
    connect?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
  }

  export type EntityForbiddenBrandUncheckedCreateNestedManyWithoutEntityInput = {
    create?: XOR<EntityForbiddenBrandCreateWithoutEntityInput, EntityForbiddenBrandUncheckedCreateWithoutEntityInput> | EntityForbiddenBrandCreateWithoutEntityInput[] | EntityForbiddenBrandUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: EntityForbiddenBrandCreateOrConnectWithoutEntityInput | EntityForbiddenBrandCreateOrConnectWithoutEntityInput[]
    createMany?: EntityForbiddenBrandCreateManyEntityInputEnvelope
    connect?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
  }

  export type AgencyContractUpdateManyWithoutEntityNestedInput = {
    create?: XOR<AgencyContractCreateWithoutEntityInput, AgencyContractUncheckedCreateWithoutEntityInput> | AgencyContractCreateWithoutEntityInput[] | AgencyContractUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutEntityInput | AgencyContractCreateOrConnectWithoutEntityInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutEntityInput | AgencyContractUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: AgencyContractCreateManyEntityInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutEntityInput | AgencyContractUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutEntityInput | AgencyContractUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type ObjectUpdateManyWithoutEntityNestedInput = {
    create?: XOR<ObjectCreateWithoutEntityInput, ObjectUncheckedCreateWithoutEntityInput> | ObjectCreateWithoutEntityInput[] | ObjectUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutEntityInput | ObjectCreateOrConnectWithoutEntityInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutEntityInput | ObjectUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: ObjectCreateManyEntityInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutEntityInput | ObjectUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutEntityInput | ObjectUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type EntityForbiddenWebsiteUpdateManyWithoutEntityNestedInput = {
    create?: XOR<EntityForbiddenWebsiteCreateWithoutEntityInput, EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput> | EntityForbiddenWebsiteCreateWithoutEntityInput[] | EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: EntityForbiddenWebsiteCreateOrConnectWithoutEntityInput | EntityForbiddenWebsiteCreateOrConnectWithoutEntityInput[]
    upsert?: EntityForbiddenWebsiteUpsertWithWhereUniqueWithoutEntityInput | EntityForbiddenWebsiteUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: EntityForbiddenWebsiteCreateManyEntityInputEnvelope
    set?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
    disconnect?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
    delete?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
    connect?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
    update?: EntityForbiddenWebsiteUpdateWithWhereUniqueWithoutEntityInput | EntityForbiddenWebsiteUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: EntityForbiddenWebsiteUpdateManyWithWhereWithoutEntityInput | EntityForbiddenWebsiteUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: EntityForbiddenWebsiteScalarWhereInput | EntityForbiddenWebsiteScalarWhereInput[]
  }

  export type EntityForbiddenBrandUpdateManyWithoutEntityNestedInput = {
    create?: XOR<EntityForbiddenBrandCreateWithoutEntityInput, EntityForbiddenBrandUncheckedCreateWithoutEntityInput> | EntityForbiddenBrandCreateWithoutEntityInput[] | EntityForbiddenBrandUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: EntityForbiddenBrandCreateOrConnectWithoutEntityInput | EntityForbiddenBrandCreateOrConnectWithoutEntityInput[]
    upsert?: EntityForbiddenBrandUpsertWithWhereUniqueWithoutEntityInput | EntityForbiddenBrandUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: EntityForbiddenBrandCreateManyEntityInputEnvelope
    set?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
    disconnect?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
    delete?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
    connect?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
    update?: EntityForbiddenBrandUpdateWithWhereUniqueWithoutEntityInput | EntityForbiddenBrandUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: EntityForbiddenBrandUpdateManyWithWhereWithoutEntityInput | EntityForbiddenBrandUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: EntityForbiddenBrandScalarWhereInput | EntityForbiddenBrandScalarWhereInput[]
  }

  export type AgencyContractUncheckedUpdateManyWithoutEntityNestedInput = {
    create?: XOR<AgencyContractCreateWithoutEntityInput, AgencyContractUncheckedCreateWithoutEntityInput> | AgencyContractCreateWithoutEntityInput[] | AgencyContractUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: AgencyContractCreateOrConnectWithoutEntityInput | AgencyContractCreateOrConnectWithoutEntityInput[]
    upsert?: AgencyContractUpsertWithWhereUniqueWithoutEntityInput | AgencyContractUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: AgencyContractCreateManyEntityInputEnvelope
    set?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    disconnect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    delete?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    connect?: AgencyContractWhereUniqueInput | AgencyContractWhereUniqueInput[]
    update?: AgencyContractUpdateWithWhereUniqueWithoutEntityInput | AgencyContractUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: AgencyContractUpdateManyWithWhereWithoutEntityInput | AgencyContractUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
  }

  export type ObjectUncheckedUpdateManyWithoutEntityNestedInput = {
    create?: XOR<ObjectCreateWithoutEntityInput, ObjectUncheckedCreateWithoutEntityInput> | ObjectCreateWithoutEntityInput[] | ObjectUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutEntityInput | ObjectCreateOrConnectWithoutEntityInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutEntityInput | ObjectUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: ObjectCreateManyEntityInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutEntityInput | ObjectUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutEntityInput | ObjectUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type EntityForbiddenWebsiteUncheckedUpdateManyWithoutEntityNestedInput = {
    create?: XOR<EntityForbiddenWebsiteCreateWithoutEntityInput, EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput> | EntityForbiddenWebsiteCreateWithoutEntityInput[] | EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: EntityForbiddenWebsiteCreateOrConnectWithoutEntityInput | EntityForbiddenWebsiteCreateOrConnectWithoutEntityInput[]
    upsert?: EntityForbiddenWebsiteUpsertWithWhereUniqueWithoutEntityInput | EntityForbiddenWebsiteUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: EntityForbiddenWebsiteCreateManyEntityInputEnvelope
    set?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
    disconnect?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
    delete?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
    connect?: EntityForbiddenWebsiteWhereUniqueInput | EntityForbiddenWebsiteWhereUniqueInput[]
    update?: EntityForbiddenWebsiteUpdateWithWhereUniqueWithoutEntityInput | EntityForbiddenWebsiteUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: EntityForbiddenWebsiteUpdateManyWithWhereWithoutEntityInput | EntityForbiddenWebsiteUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: EntityForbiddenWebsiteScalarWhereInput | EntityForbiddenWebsiteScalarWhereInput[]
  }

  export type EntityForbiddenBrandUncheckedUpdateManyWithoutEntityNestedInput = {
    create?: XOR<EntityForbiddenBrandCreateWithoutEntityInput, EntityForbiddenBrandUncheckedCreateWithoutEntityInput> | EntityForbiddenBrandCreateWithoutEntityInput[] | EntityForbiddenBrandUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: EntityForbiddenBrandCreateOrConnectWithoutEntityInput | EntityForbiddenBrandCreateOrConnectWithoutEntityInput[]
    upsert?: EntityForbiddenBrandUpsertWithWhereUniqueWithoutEntityInput | EntityForbiddenBrandUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: EntityForbiddenBrandCreateManyEntityInputEnvelope
    set?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
    disconnect?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
    delete?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
    connect?: EntityForbiddenBrandWhereUniqueInput | EntityForbiddenBrandWhereUniqueInput[]
    update?: EntityForbiddenBrandUpdateWithWhereUniqueWithoutEntityInput | EntityForbiddenBrandUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: EntityForbiddenBrandUpdateManyWithWhereWithoutEntityInput | EntityForbiddenBrandUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: EntityForbiddenBrandScalarWhereInput | EntityForbiddenBrandScalarWhereInput[]
  }

  export type EntityCreateNestedOneWithoutEntityForbiddenWebsitesInput = {
    create?: XOR<EntityCreateWithoutEntityForbiddenWebsitesInput, EntityUncheckedCreateWithoutEntityForbiddenWebsitesInput>
    connectOrCreate?: EntityCreateOrConnectWithoutEntityForbiddenWebsitesInput
    connect?: EntityWhereUniqueInput
  }

  export type EntityUpdateOneRequiredWithoutEntityForbiddenWebsitesNestedInput = {
    create?: XOR<EntityCreateWithoutEntityForbiddenWebsitesInput, EntityUncheckedCreateWithoutEntityForbiddenWebsitesInput>
    connectOrCreate?: EntityCreateOrConnectWithoutEntityForbiddenWebsitesInput
    upsert?: EntityUpsertWithoutEntityForbiddenWebsitesInput
    connect?: EntityWhereUniqueInput
    update?: XOR<XOR<EntityUpdateToOneWithWhereWithoutEntityForbiddenWebsitesInput, EntityUpdateWithoutEntityForbiddenWebsitesInput>, EntityUncheckedUpdateWithoutEntityForbiddenWebsitesInput>
  }

  export type EntityCreateNestedOneWithoutEntityForbiddenBrandsInput = {
    create?: XOR<EntityCreateWithoutEntityForbiddenBrandsInput, EntityUncheckedCreateWithoutEntityForbiddenBrandsInput>
    connectOrCreate?: EntityCreateOrConnectWithoutEntityForbiddenBrandsInput
    connect?: EntityWhereUniqueInput
  }

  export type EntityUpdateOneRequiredWithoutEntityForbiddenBrandsNestedInput = {
    create?: XOR<EntityCreateWithoutEntityForbiddenBrandsInput, EntityUncheckedCreateWithoutEntityForbiddenBrandsInput>
    connectOrCreate?: EntityCreateOrConnectWithoutEntityForbiddenBrandsInput
    upsert?: EntityUpsertWithoutEntityForbiddenBrandsInput
    connect?: EntityWhereUniqueInput
    update?: XOR<XOR<EntityUpdateToOneWithWhereWithoutEntityForbiddenBrandsInput, EntityUpdateWithoutEntityForbiddenBrandsInput>, EntityUncheckedUpdateWithoutEntityForbiddenBrandsInput>
  }

  export type ClientContractCreateNestedManyWithoutBankInput = {
    create?: XOR<ClientContractCreateWithoutBankInput, ClientContractUncheckedCreateWithoutBankInput> | ClientContractCreateWithoutBankInput[] | ClientContractUncheckedCreateWithoutBankInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutBankInput | ClientContractCreateOrConnectWithoutBankInput[]
    createMany?: ClientContractCreateManyBankInputEnvelope
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
  }

  export type ClientContractUncheckedCreateNestedManyWithoutBankInput = {
    create?: XOR<ClientContractCreateWithoutBankInput, ClientContractUncheckedCreateWithoutBankInput> | ClientContractCreateWithoutBankInput[] | ClientContractUncheckedCreateWithoutBankInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutBankInput | ClientContractCreateOrConnectWithoutBankInput[]
    createMany?: ClientContractCreateManyBankInputEnvelope
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
  }

  export type ClientContractUpdateManyWithoutBankNestedInput = {
    create?: XOR<ClientContractCreateWithoutBankInput, ClientContractUncheckedCreateWithoutBankInput> | ClientContractCreateWithoutBankInput[] | ClientContractUncheckedCreateWithoutBankInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutBankInput | ClientContractCreateOrConnectWithoutBankInput[]
    upsert?: ClientContractUpsertWithWhereUniqueWithoutBankInput | ClientContractUpsertWithWhereUniqueWithoutBankInput[]
    createMany?: ClientContractCreateManyBankInputEnvelope
    set?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    disconnect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    delete?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    update?: ClientContractUpdateWithWhereUniqueWithoutBankInput | ClientContractUpdateWithWhereUniqueWithoutBankInput[]
    updateMany?: ClientContractUpdateManyWithWhereWithoutBankInput | ClientContractUpdateManyWithWhereWithoutBankInput[]
    deleteMany?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
  }

  export type ClientContractUncheckedUpdateManyWithoutBankNestedInput = {
    create?: XOR<ClientContractCreateWithoutBankInput, ClientContractUncheckedCreateWithoutBankInput> | ClientContractCreateWithoutBankInput[] | ClientContractUncheckedCreateWithoutBankInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutBankInput | ClientContractCreateOrConnectWithoutBankInput[]
    upsert?: ClientContractUpsertWithWhereUniqueWithoutBankInput | ClientContractUpsertWithWhereUniqueWithoutBankInput[]
    createMany?: ClientContractCreateManyBankInputEnvelope
    set?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    disconnect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    delete?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    update?: ClientContractUpdateWithWhereUniqueWithoutBankInput | ClientContractUpdateWithWhereUniqueWithoutBankInput[]
    updateMany?: ClientContractUpdateManyWithWhereWithoutBankInput | ClientContractUpdateManyWithWhereWithoutBankInput[]
    deleteMany?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
  }

  export type EnumEscrowAccountStatusFieldUpdateOperationsInput = {
    set?: $Enums.EscrowAccountStatus
  }

  export type ClientContractCreateNestedOneWithoutRealEstateAgencyActsInput = {
    create?: XOR<ClientContractCreateWithoutRealEstateAgencyActsInput, ClientContractUncheckedCreateWithoutRealEstateAgencyActsInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutRealEstateAgencyActsInput
    connect?: ClientContractWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutRealEstateAgencyActsInput = {
    create?: XOR<AgencyCreateWithoutRealEstateAgencyActsInput, AgencyUncheckedCreateWithoutRealEstateAgencyActsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutRealEstateAgencyActsInput
    connect?: AgencyWhereUniqueInput
  }

  export type AgencyContractCreateNestedOneWithoutRealEstateAgencyActInput = {
    create?: XOR<AgencyContractCreateWithoutRealEstateAgencyActInput, AgencyContractUncheckedCreateWithoutRealEstateAgencyActInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutRealEstateAgencyActInput
    connect?: AgencyContractWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ClientContractUpdateOneRequiredWithoutRealEstateAgencyActsNestedInput = {
    create?: XOR<ClientContractCreateWithoutRealEstateAgencyActsInput, ClientContractUncheckedCreateWithoutRealEstateAgencyActsInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutRealEstateAgencyActsInput
    upsert?: ClientContractUpsertWithoutRealEstateAgencyActsInput
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutRealEstateAgencyActsInput, ClientContractUpdateWithoutRealEstateAgencyActsInput>, ClientContractUncheckedUpdateWithoutRealEstateAgencyActsInput>
  }

  export type AgencyUpdateOneRequiredWithoutRealEstateAgencyActsNestedInput = {
    create?: XOR<AgencyCreateWithoutRealEstateAgencyActsInput, AgencyUncheckedCreateWithoutRealEstateAgencyActsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutRealEstateAgencyActsInput
    upsert?: AgencyUpsertWithoutRealEstateAgencyActsInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutRealEstateAgencyActsInput, AgencyUpdateWithoutRealEstateAgencyActsInput>, AgencyUncheckedUpdateWithoutRealEstateAgencyActsInput>
  }

  export type AgencyContractUpdateOneRequiredWithoutRealEstateAgencyActNestedInput = {
    create?: XOR<AgencyContractCreateWithoutRealEstateAgencyActInput, AgencyContractUncheckedCreateWithoutRealEstateAgencyActInput>
    connectOrCreate?: AgencyContractCreateOrConnectWithoutRealEstateAgencyActInput
    upsert?: AgencyContractUpsertWithoutRealEstateAgencyActInput
    connect?: AgencyContractWhereUniqueInput
    update?: XOR<XOR<AgencyContractUpdateToOneWithWhereWithoutRealEstateAgencyActInput, AgencyContractUpdateWithoutRealEstateAgencyActInput>, AgencyContractUncheckedUpdateWithoutRealEstateAgencyActInput>
  }

  export type ClientContractCreateNestedManyWithoutSubsidyInput = {
    create?: XOR<ClientContractCreateWithoutSubsidyInput, ClientContractUncheckedCreateWithoutSubsidyInput> | ClientContractCreateWithoutSubsidyInput[] | ClientContractUncheckedCreateWithoutSubsidyInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutSubsidyInput | ClientContractCreateOrConnectWithoutSubsidyInput[]
    createMany?: ClientContractCreateManySubsidyInputEnvelope
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
  }

  export type ClientContractUncheckedCreateNestedManyWithoutSubsidyInput = {
    create?: XOR<ClientContractCreateWithoutSubsidyInput, ClientContractUncheckedCreateWithoutSubsidyInput> | ClientContractCreateWithoutSubsidyInput[] | ClientContractUncheckedCreateWithoutSubsidyInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutSubsidyInput | ClientContractCreateOrConnectWithoutSubsidyInput[]
    createMany?: ClientContractCreateManySubsidyInputEnvelope
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
  }

  export type ClientContractUpdateManyWithoutSubsidyNestedInput = {
    create?: XOR<ClientContractCreateWithoutSubsidyInput, ClientContractUncheckedCreateWithoutSubsidyInput> | ClientContractCreateWithoutSubsidyInput[] | ClientContractUncheckedCreateWithoutSubsidyInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutSubsidyInput | ClientContractCreateOrConnectWithoutSubsidyInput[]
    upsert?: ClientContractUpsertWithWhereUniqueWithoutSubsidyInput | ClientContractUpsertWithWhereUniqueWithoutSubsidyInput[]
    createMany?: ClientContractCreateManySubsidyInputEnvelope
    set?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    disconnect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    delete?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    update?: ClientContractUpdateWithWhereUniqueWithoutSubsidyInput | ClientContractUpdateWithWhereUniqueWithoutSubsidyInput[]
    updateMany?: ClientContractUpdateManyWithWhereWithoutSubsidyInput | ClientContractUpdateManyWithWhereWithoutSubsidyInput[]
    deleteMany?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
  }

  export type ClientContractUncheckedUpdateManyWithoutSubsidyNestedInput = {
    create?: XOR<ClientContractCreateWithoutSubsidyInput, ClientContractUncheckedCreateWithoutSubsidyInput> | ClientContractCreateWithoutSubsidyInput[] | ClientContractUncheckedCreateWithoutSubsidyInput[]
    connectOrCreate?: ClientContractCreateOrConnectWithoutSubsidyInput | ClientContractCreateOrConnectWithoutSubsidyInput[]
    upsert?: ClientContractUpsertWithWhereUniqueWithoutSubsidyInput | ClientContractUpsertWithWhereUniqueWithoutSubsidyInput[]
    createMany?: ClientContractCreateManySubsidyInputEnvelope
    set?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    disconnect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    delete?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    connect?: ClientContractWhereUniqueInput | ClientContractWhereUniqueInput[]
    update?: ClientContractUpdateWithWhereUniqueWithoutSubsidyInput | ClientContractUpdateWithWhereUniqueWithoutSubsidyInput[]
    updateMany?: ClientContractUpdateManyWithWhereWithoutSubsidyInput | ClientContractUpdateManyWithWhereWithoutSubsidyInput[]
    deleteMany?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
  }

  export type ClientContractCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<ClientContractCreateWithoutAssignmentsInput, ClientContractUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutAssignmentsInput
    connect?: ClientContractWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<ClientCreateWithoutAssignmentsInput, ClientUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAssignmentsInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientContractUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<ClientContractCreateWithoutAssignmentsInput, ClientContractUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutAssignmentsInput
    upsert?: ClientContractUpsertWithoutAssignmentsInput
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutAssignmentsInput, ClientContractUpdateWithoutAssignmentsInput>, ClientContractUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ClientUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<ClientCreateWithoutAssignmentsInput, ClientUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAssignmentsInput
    upsert?: ClientUpsertWithoutAssignmentsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutAssignmentsInput, ClientUpdateWithoutAssignmentsInput>, ClientUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ClientContractCreateNestedOneWithoutTransferActInput = {
    create?: XOR<ClientContractCreateWithoutTransferActInput, ClientContractUncheckedCreateWithoutTransferActInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutTransferActInput
    connect?: ClientContractWhereUniqueInput
  }

  export type ObjectCreateNestedOneWithoutTransferActsInput = {
    create?: XOR<ObjectCreateWithoutTransferActsInput, ObjectUncheckedCreateWithoutTransferActsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutTransferActsInput
    connect?: ObjectWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutTransferActInput = {
    create?: XOR<ProductCreateWithoutTransferActInput, ProductUncheckedCreateWithoutTransferActInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransferActInput
    connect?: ProductWhereUniqueInput
  }

  export type TransferActToRepresentativeCreateNestedManyWithoutTransferActInput = {
    create?: XOR<TransferActToRepresentativeCreateWithoutTransferActInput, TransferActToRepresentativeUncheckedCreateWithoutTransferActInput> | TransferActToRepresentativeCreateWithoutTransferActInput[] | TransferActToRepresentativeUncheckedCreateWithoutTransferActInput[]
    connectOrCreate?: TransferActToRepresentativeCreateOrConnectWithoutTransferActInput | TransferActToRepresentativeCreateOrConnectWithoutTransferActInput[]
    createMany?: TransferActToRepresentativeCreateManyTransferActInputEnvelope
    connect?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
  }

  export type TransferActToRepresentativeUncheckedCreateNestedManyWithoutTransferActInput = {
    create?: XOR<TransferActToRepresentativeCreateWithoutTransferActInput, TransferActToRepresentativeUncheckedCreateWithoutTransferActInput> | TransferActToRepresentativeCreateWithoutTransferActInput[] | TransferActToRepresentativeUncheckedCreateWithoutTransferActInput[]
    connectOrCreate?: TransferActToRepresentativeCreateOrConnectWithoutTransferActInput | TransferActToRepresentativeCreateOrConnectWithoutTransferActInput[]
    createMany?: TransferActToRepresentativeCreateManyTransferActInputEnvelope
    connect?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
  }

  export type ClientContractUpdateOneRequiredWithoutTransferActNestedInput = {
    create?: XOR<ClientContractCreateWithoutTransferActInput, ClientContractUncheckedCreateWithoutTransferActInput>
    connectOrCreate?: ClientContractCreateOrConnectWithoutTransferActInput
    upsert?: ClientContractUpsertWithoutTransferActInput
    connect?: ClientContractWhereUniqueInput
    update?: XOR<XOR<ClientContractUpdateToOneWithWhereWithoutTransferActInput, ClientContractUpdateWithoutTransferActInput>, ClientContractUncheckedUpdateWithoutTransferActInput>
  }

  export type ObjectUpdateOneRequiredWithoutTransferActsNestedInput = {
    create?: XOR<ObjectCreateWithoutTransferActsInput, ObjectUncheckedCreateWithoutTransferActsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutTransferActsInput
    upsert?: ObjectUpsertWithoutTransferActsInput
    connect?: ObjectWhereUniqueInput
    update?: XOR<XOR<ObjectUpdateToOneWithWhereWithoutTransferActsInput, ObjectUpdateWithoutTransferActsInput>, ObjectUncheckedUpdateWithoutTransferActsInput>
  }

  export type ProductUpdateOneRequiredWithoutTransferActNestedInput = {
    create?: XOR<ProductCreateWithoutTransferActInput, ProductUncheckedCreateWithoutTransferActInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransferActInput
    upsert?: ProductUpsertWithoutTransferActInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutTransferActInput, ProductUpdateWithoutTransferActInput>, ProductUncheckedUpdateWithoutTransferActInput>
  }

  export type TransferActToRepresentativeUpdateManyWithoutTransferActNestedInput = {
    create?: XOR<TransferActToRepresentativeCreateWithoutTransferActInput, TransferActToRepresentativeUncheckedCreateWithoutTransferActInput> | TransferActToRepresentativeCreateWithoutTransferActInput[] | TransferActToRepresentativeUncheckedCreateWithoutTransferActInput[]
    connectOrCreate?: TransferActToRepresentativeCreateOrConnectWithoutTransferActInput | TransferActToRepresentativeCreateOrConnectWithoutTransferActInput[]
    upsert?: TransferActToRepresentativeUpsertWithWhereUniqueWithoutTransferActInput | TransferActToRepresentativeUpsertWithWhereUniqueWithoutTransferActInput[]
    createMany?: TransferActToRepresentativeCreateManyTransferActInputEnvelope
    set?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
    disconnect?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
    delete?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
    connect?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
    update?: TransferActToRepresentativeUpdateWithWhereUniqueWithoutTransferActInput | TransferActToRepresentativeUpdateWithWhereUniqueWithoutTransferActInput[]
    updateMany?: TransferActToRepresentativeUpdateManyWithWhereWithoutTransferActInput | TransferActToRepresentativeUpdateManyWithWhereWithoutTransferActInput[]
    deleteMany?: TransferActToRepresentativeScalarWhereInput | TransferActToRepresentativeScalarWhereInput[]
  }

  export type TransferActToRepresentativeUncheckedUpdateManyWithoutTransferActNestedInput = {
    create?: XOR<TransferActToRepresentativeCreateWithoutTransferActInput, TransferActToRepresentativeUncheckedCreateWithoutTransferActInput> | TransferActToRepresentativeCreateWithoutTransferActInput[] | TransferActToRepresentativeUncheckedCreateWithoutTransferActInput[]
    connectOrCreate?: TransferActToRepresentativeCreateOrConnectWithoutTransferActInput | TransferActToRepresentativeCreateOrConnectWithoutTransferActInput[]
    upsert?: TransferActToRepresentativeUpsertWithWhereUniqueWithoutTransferActInput | TransferActToRepresentativeUpsertWithWhereUniqueWithoutTransferActInput[]
    createMany?: TransferActToRepresentativeCreateManyTransferActInputEnvelope
    set?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
    disconnect?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
    delete?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
    connect?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
    update?: TransferActToRepresentativeUpdateWithWhereUniqueWithoutTransferActInput | TransferActToRepresentativeUpdateWithWhereUniqueWithoutTransferActInput[]
    updateMany?: TransferActToRepresentativeUpdateManyWithWhereWithoutTransferActInput | TransferActToRepresentativeUpdateManyWithWhereWithoutTransferActInput[]
    deleteMany?: TransferActToRepresentativeScalarWhereInput | TransferActToRepresentativeScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutRepresentativesInput = {
    create?: XOR<ClientCreateWithoutRepresentativesInput, ClientUncheckedCreateWithoutRepresentativesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutRepresentativesInput
    connect?: ClientWhereUniqueInput
  }

  export type TransferActToRepresentativeCreateNestedManyWithoutRepresentativeInput = {
    create?: XOR<TransferActToRepresentativeCreateWithoutRepresentativeInput, TransferActToRepresentativeUncheckedCreateWithoutRepresentativeInput> | TransferActToRepresentativeCreateWithoutRepresentativeInput[] | TransferActToRepresentativeUncheckedCreateWithoutRepresentativeInput[]
    connectOrCreate?: TransferActToRepresentativeCreateOrConnectWithoutRepresentativeInput | TransferActToRepresentativeCreateOrConnectWithoutRepresentativeInput[]
    createMany?: TransferActToRepresentativeCreateManyRepresentativeInputEnvelope
    connect?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
  }

  export type TransferActToRepresentativeUncheckedCreateNestedManyWithoutRepresentativeInput = {
    create?: XOR<TransferActToRepresentativeCreateWithoutRepresentativeInput, TransferActToRepresentativeUncheckedCreateWithoutRepresentativeInput> | TransferActToRepresentativeCreateWithoutRepresentativeInput[] | TransferActToRepresentativeUncheckedCreateWithoutRepresentativeInput[]
    connectOrCreate?: TransferActToRepresentativeCreateOrConnectWithoutRepresentativeInput | TransferActToRepresentativeCreateOrConnectWithoutRepresentativeInput[]
    createMany?: TransferActToRepresentativeCreateManyRepresentativeInputEnvelope
    connect?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
  }

  export type ClientUpdateOneRequiredWithoutRepresentativesNestedInput = {
    create?: XOR<ClientCreateWithoutRepresentativesInput, ClientUncheckedCreateWithoutRepresentativesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutRepresentativesInput
    upsert?: ClientUpsertWithoutRepresentativesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutRepresentativesInput, ClientUpdateWithoutRepresentativesInput>, ClientUncheckedUpdateWithoutRepresentativesInput>
  }

  export type TransferActToRepresentativeUpdateManyWithoutRepresentativeNestedInput = {
    create?: XOR<TransferActToRepresentativeCreateWithoutRepresentativeInput, TransferActToRepresentativeUncheckedCreateWithoutRepresentativeInput> | TransferActToRepresentativeCreateWithoutRepresentativeInput[] | TransferActToRepresentativeUncheckedCreateWithoutRepresentativeInput[]
    connectOrCreate?: TransferActToRepresentativeCreateOrConnectWithoutRepresentativeInput | TransferActToRepresentativeCreateOrConnectWithoutRepresentativeInput[]
    upsert?: TransferActToRepresentativeUpsertWithWhereUniqueWithoutRepresentativeInput | TransferActToRepresentativeUpsertWithWhereUniqueWithoutRepresentativeInput[]
    createMany?: TransferActToRepresentativeCreateManyRepresentativeInputEnvelope
    set?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
    disconnect?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
    delete?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
    connect?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
    update?: TransferActToRepresentativeUpdateWithWhereUniqueWithoutRepresentativeInput | TransferActToRepresentativeUpdateWithWhereUniqueWithoutRepresentativeInput[]
    updateMany?: TransferActToRepresentativeUpdateManyWithWhereWithoutRepresentativeInput | TransferActToRepresentativeUpdateManyWithWhereWithoutRepresentativeInput[]
    deleteMany?: TransferActToRepresentativeScalarWhereInput | TransferActToRepresentativeScalarWhereInput[]
  }

  export type TransferActToRepresentativeUncheckedUpdateManyWithoutRepresentativeNestedInput = {
    create?: XOR<TransferActToRepresentativeCreateWithoutRepresentativeInput, TransferActToRepresentativeUncheckedCreateWithoutRepresentativeInput> | TransferActToRepresentativeCreateWithoutRepresentativeInput[] | TransferActToRepresentativeUncheckedCreateWithoutRepresentativeInput[]
    connectOrCreate?: TransferActToRepresentativeCreateOrConnectWithoutRepresentativeInput | TransferActToRepresentativeCreateOrConnectWithoutRepresentativeInput[]
    upsert?: TransferActToRepresentativeUpsertWithWhereUniqueWithoutRepresentativeInput | TransferActToRepresentativeUpsertWithWhereUniqueWithoutRepresentativeInput[]
    createMany?: TransferActToRepresentativeCreateManyRepresentativeInputEnvelope
    set?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
    disconnect?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
    delete?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
    connect?: TransferActToRepresentativeWhereUniqueInput | TransferActToRepresentativeWhereUniqueInput[]
    update?: TransferActToRepresentativeUpdateWithWhereUniqueWithoutRepresentativeInput | TransferActToRepresentativeUpdateWithWhereUniqueWithoutRepresentativeInput[]
    updateMany?: TransferActToRepresentativeUpdateManyWithWhereWithoutRepresentativeInput | TransferActToRepresentativeUpdateManyWithWhereWithoutRepresentativeInput[]
    deleteMany?: TransferActToRepresentativeScalarWhereInput | TransferActToRepresentativeScalarWhereInput[]
  }

  export type TransferActCreateNestedOneWithoutTransferActsToRepresentativesInput = {
    create?: XOR<TransferActCreateWithoutTransferActsToRepresentativesInput, TransferActUncheckedCreateWithoutTransferActsToRepresentativesInput>
    connectOrCreate?: TransferActCreateOrConnectWithoutTransferActsToRepresentativesInput
    connect?: TransferActWhereUniqueInput
  }

  export type RepresentativeCreateNestedOneWithoutTransferActsToRepresentativesInput = {
    create?: XOR<RepresentativeCreateWithoutTransferActsToRepresentativesInput, RepresentativeUncheckedCreateWithoutTransferActsToRepresentativesInput>
    connectOrCreate?: RepresentativeCreateOrConnectWithoutTransferActsToRepresentativesInput
    connect?: RepresentativeWhereUniqueInput
  }

  export type TransferActUpdateOneRequiredWithoutTransferActsToRepresentativesNestedInput = {
    create?: XOR<TransferActCreateWithoutTransferActsToRepresentativesInput, TransferActUncheckedCreateWithoutTransferActsToRepresentativesInput>
    connectOrCreate?: TransferActCreateOrConnectWithoutTransferActsToRepresentativesInput
    upsert?: TransferActUpsertWithoutTransferActsToRepresentativesInput
    connect?: TransferActWhereUniqueInput
    update?: XOR<XOR<TransferActUpdateToOneWithWhereWithoutTransferActsToRepresentativesInput, TransferActUpdateWithoutTransferActsToRepresentativesInput>, TransferActUncheckedUpdateWithoutTransferActsToRepresentativesInput>
  }

  export type RepresentativeUpdateOneRequiredWithoutTransferActsToRepresentativesNestedInput = {
    create?: XOR<RepresentativeCreateWithoutTransferActsToRepresentativesInput, RepresentativeUncheckedCreateWithoutTransferActsToRepresentativesInput>
    connectOrCreate?: RepresentativeCreateOrConnectWithoutTransferActsToRepresentativesInput
    upsert?: RepresentativeUpsertWithoutTransferActsToRepresentativesInput
    connect?: RepresentativeWhereUniqueInput
    update?: XOR<XOR<RepresentativeUpdateToOneWithWhereWithoutTransferActsToRepresentativesInput, RepresentativeUpdateWithoutTransferActsToRepresentativesInput>, RepresentativeUncheckedUpdateWithoutTransferActsToRepresentativesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumClientCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientCategory | EnumClientCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ClientCategory[]
    notIn?: $Enums.ClientCategory[]
    not?: NestedEnumClientCategoryFilter<$PrismaModel> | $Enums.ClientCategory
  }

  export type NestedEnumClientCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientCategory | EnumClientCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ClientCategory[]
    notIn?: $Enums.ClientCategory[]
    not?: NestedEnumClientCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ClientCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientCategoryFilter<$PrismaModel>
    _max?: NestedEnumClientCategoryFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumClientContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientContractType | EnumClientContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientContractType[]
    notIn?: $Enums.ClientContractType[]
    not?: NestedEnumClientContractTypeFilter<$PrismaModel> | $Enums.ClientContractType
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumClientContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientContractType | EnumClientContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientContractType[]
    notIn?: $Enums.ClientContractType[]
    not?: NestedEnumClientContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientContractTypeFilter<$PrismaModel>
    _max?: NestedEnumClientContractTypeFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumScheduledPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledPaymentType | EnumScheduledPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledPaymentType[]
    notIn?: $Enums.ScheduledPaymentType[]
    not?: NestedEnumScheduledPaymentTypeFilter<$PrismaModel> | $Enums.ScheduledPaymentType
  }

  export type NestedEnumScheduledPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledPaymentType | EnumScheduledPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledPaymentType[]
    notIn?: $Enums.ScheduledPaymentType[]
    not?: NestedEnumScheduledPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScheduledPaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduledPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumScheduledPaymentTypeFilter<$PrismaModel>
  }

  export type NestedEnumProductCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCategory | EnumProductCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCategory[]
    notIn?: $Enums.ProductCategory[]
    not?: NestedEnumProductCategoryFilter<$PrismaModel> | $Enums.ProductCategory
  }

  export type NestedEnumProductCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCategory | EnumProductCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCategory[]
    notIn?: $Enums.ProductCategory[]
    not?: NestedEnumProductCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ProductCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductCategoryFilter<$PrismaModel>
    _max?: NestedEnumProductCategoryFilter<$PrismaModel>
  }

  export type NestedEnumAgencyContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyContractType | EnumAgencyContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyContractType[]
    notIn?: $Enums.AgencyContractType[]
    not?: NestedEnumAgencyContractTypeFilter<$PrismaModel> | $Enums.AgencyContractType
  }

  export type NestedEnumAgencyContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyContractType | EnumAgencyContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyContractType[]
    notIn?: $Enums.AgencyContractType[]
    not?: NestedEnumAgencyContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.AgencyContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgencyContractTypeFilter<$PrismaModel>
    _max?: NestedEnumAgencyContractTypeFilter<$PrismaModel>
  }

  export type NestedEnumEscrowAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EscrowAccountStatus | EnumEscrowAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EscrowAccountStatus[]
    notIn?: $Enums.EscrowAccountStatus[]
    not?: NestedEnumEscrowAccountStatusFilter<$PrismaModel> | $Enums.EscrowAccountStatus
  }

  export type NestedEnumEscrowAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EscrowAccountStatus | EnumEscrowAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EscrowAccountStatus[]
    notIn?: $Enums.EscrowAccountStatus[]
    not?: NestedEnumEscrowAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.EscrowAccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEscrowAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumEscrowAccountStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ClientContractCreateWithoutManagerInput = {
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActCreateNestedOneWithoutClientContractInput
    dduClientContractProperties?: DduClientContractPropertiesCreateNestedOneWithoutClientContractInput
    dkpClientContractProperties?: DkpClientContractPropertiesCreateNestedOneWithoutClientContractInput
    product: ProductCreateNestedOneWithoutClientContractInput
    object: ObjectCreateNestedOneWithoutClientContractsInput
    realEstateAgent?: RealEstateAgentCreateNestedOneWithoutClientContractsInput
    bank?: BankCreateNestedOneWithoutClientContractsInput
    subsidy?: SubsidyCreateNestedOneWithoutClientContractsInput
    scheduledPayments?: ScheduledPaymentCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractUncheckedCreateWithoutManagerInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    realEstateAgentId?: number | null
    bankId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActUncheckedCreateNestedOneWithoutClientContractInput
    scheduledPayments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentUncheckedCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractCreateOrConnectWithoutManagerInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutManagerInput, ClientContractUncheckedCreateWithoutManagerInput>
  }

  export type ClientContractCreateManyManagerInputEnvelope = {
    data: ClientContractCreateManyManagerInput | ClientContractCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type AgencyContractCreateWithoutResponsibleUserInput = {
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entity: EntityCreateNestedOneWithoutAgencyContractsInput
    object: ObjectCreateNestedOneWithoutAgencyContractsInput
    agency: AgencyCreateNestedOneWithoutAgencyContractsInput
    agencyContractSignatory?: AgencyContractSignatoryCreateNestedOneWithoutAgencyContractsInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput
    realEstateAgencyAct?: RealEstateAgencyActCreateNestedManyWithoutAgencyContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractUncheckedCreateWithoutResponsibleUserInput = {
    id?: number
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    entityId: number
    objectId: number
    agencyId: number
    agencyContractSignatoryId?: number | null
    realEstateAgencyContractPropertiesId?: number | null
    mipAgencyContractPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    realEstateAgencyAct?: RealEstateAgencyActUncheckedCreateNestedManyWithoutAgencyContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractCreateOrConnectWithoutResponsibleUserInput = {
    where: AgencyContractWhereUniqueInput
    create: XOR<AgencyContractCreateWithoutResponsibleUserInput, AgencyContractUncheckedCreateWithoutResponsibleUserInput>
  }

  export type AgencyContractCreateManyResponsibleUserInputEnvelope = {
    data: AgencyContractCreateManyResponsibleUserInput | AgencyContractCreateManyResponsibleUserInput[]
    skipDuplicates?: boolean
  }

  export type ClientContractUpsertWithWhereUniqueWithoutManagerInput = {
    where: ClientContractWhereUniqueInput
    update: XOR<ClientContractUpdateWithoutManagerInput, ClientContractUncheckedUpdateWithoutManagerInput>
    create: XOR<ClientContractCreateWithoutManagerInput, ClientContractUncheckedCreateWithoutManagerInput>
  }

  export type ClientContractUpdateWithWhereUniqueWithoutManagerInput = {
    where: ClientContractWhereUniqueInput
    data: XOR<ClientContractUpdateWithoutManagerInput, ClientContractUncheckedUpdateWithoutManagerInput>
  }

  export type ClientContractUpdateManyWithWhereWithoutManagerInput = {
    where: ClientContractScalarWhereInput
    data: XOR<ClientContractUpdateManyMutationInput, ClientContractUncheckedUpdateManyWithoutManagerInput>
  }

  export type ClientContractScalarWhereInput = {
    AND?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
    OR?: ClientContractScalarWhereInput[]
    NOT?: ClientContractScalarWhereInput | ClientContractScalarWhereInput[]
    id?: IntFilter<"ClientContract"> | number
    number?: StringFilter<"ClientContract"> | string
    date?: DateTimeFilter<"ClientContract"> | Date | string
    registrationDate?: DateTimeNullableFilter<"ClientContract"> | Date | string | null
    price?: DecimalFilter<"ClientContract"> | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFilter<"ClientContract"> | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: BoolNullableFilter<"ClientContract"> | boolean | null
    isTransferActDisabled?: BoolNullableFilter<"ClientContract"> | boolean | null
    comment?: StringNullableFilter<"ClientContract"> | string | null
    link?: StringNullableFilter<"ClientContract"> | string | null
    uuContractId?: IntNullableFilter<"ClientContract"> | number | null
    dduClientContractPropertiesId?: IntNullableFilter<"ClientContract"> | number | null
    dkpClientContractPropertiesId?: IntNullableFilter<"ClientContract"> | number | null
    productId?: IntFilter<"ClientContract"> | number
    objectId?: IntFilter<"ClientContract"> | number
    realEstateAgentId?: IntNullableFilter<"ClientContract"> | number | null
    managerId?: IntNullableFilter<"ClientContract"> | number | null
    bankId?: IntNullableFilter<"ClientContract"> | number | null
    subsidyId?: IntNullableFilter<"ClientContract"> | number | null
    createdAt?: DateTimeFilter<"ClientContract"> | Date | string
    updatedAt?: DateTimeFilter<"ClientContract"> | Date | string
  }

  export type AgencyContractUpsertWithWhereUniqueWithoutResponsibleUserInput = {
    where: AgencyContractWhereUniqueInput
    update: XOR<AgencyContractUpdateWithoutResponsibleUserInput, AgencyContractUncheckedUpdateWithoutResponsibleUserInput>
    create: XOR<AgencyContractCreateWithoutResponsibleUserInput, AgencyContractUncheckedCreateWithoutResponsibleUserInput>
  }

  export type AgencyContractUpdateWithWhereUniqueWithoutResponsibleUserInput = {
    where: AgencyContractWhereUniqueInput
    data: XOR<AgencyContractUpdateWithoutResponsibleUserInput, AgencyContractUncheckedUpdateWithoutResponsibleUserInput>
  }

  export type AgencyContractUpdateManyWithWhereWithoutResponsibleUserInput = {
    where: AgencyContractScalarWhereInput
    data: XOR<AgencyContractUpdateManyMutationInput, AgencyContractUncheckedUpdateManyWithoutResponsibleUserInput>
  }

  export type AgencyContractScalarWhereInput = {
    AND?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
    OR?: AgencyContractScalarWhereInput[]
    NOT?: AgencyContractScalarWhereInput | AgencyContractScalarWhereInput[]
    id?: IntFilter<"AgencyContract"> | number
    number?: StringFilter<"AgencyContract"> | string
    date?: DateTimeFilter<"AgencyContract"> | Date | string
    agencyContractType?: EnumAgencyContractTypeFilter<"AgencyContract"> | $Enums.AgencyContractType
    link?: StringNullableFilter<"AgencyContract"> | string | null
    responsibleUserId?: IntNullableFilter<"AgencyContract"> | number | null
    entityId?: IntFilter<"AgencyContract"> | number
    objectId?: IntFilter<"AgencyContract"> | number
    agencyId?: IntFilter<"AgencyContract"> | number
    agencyContractSignatoryId?: IntNullableFilter<"AgencyContract"> | number | null
    realEstateAgencyContractPropertiesId?: IntNullableFilter<"AgencyContract"> | number | null
    mipAgencyContractPropertiesId?: IntNullableFilter<"AgencyContract"> | number | null
    createdAt?: DateTimeFilter<"AgencyContract"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyContract"> | Date | string
  }

  export type ClientIndividualPropertiesCreateWithoutClientInput = {
    dob?: Date | string | null
    snils?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientPassport?: ClientPassportCreateNestedOneWithoutClientIndividualPropertiesInput
  }

  export type ClientIndividualPropertiesUncheckedCreateWithoutClientInput = {
    id?: number
    dob?: Date | string | null
    snils?: string | null
    clientPassportId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientIndividualPropertiesCreateOrConnectWithoutClientInput = {
    where: ClientIndividualPropertiesWhereUniqueInput
    create: XOR<ClientIndividualPropertiesCreateWithoutClientInput, ClientIndividualPropertiesUncheckedCreateWithoutClientInput>
  }

  export type ClientIndividualMinorPropertiesCreateWithoutClientInput = {
    dob?: Date | string | null
    snils?: string | null
    birthCertificate?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientPassport?: ClientPassportCreateNestedOneWithoutClientIndividualMinorPropertiesInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClientIndividualMinorPropertiesInput
  }

  export type ClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput = {
    id?: number
    dob?: Date | string | null
    snils?: string | null
    birthCertificate?: string | null
    clientPassportId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClientIndividualMinorPropertiesInput
  }

  export type ClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput = {
    where: ClientIndividualMinorPropertiesWhereUniqueInput
    create: XOR<ClientIndividualMinorPropertiesCreateWithoutClientInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput>
  }

  export type ClientEntityPropertiesCreateWithoutClientInput = {
    kpp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientEntityPropertiesUncheckedCreateWithoutClientInput = {
    id?: number
    kpp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientEntityPropertiesCreateOrConnectWithoutClientInput = {
    where: ClientEntityPropertiesWhereUniqueInput
    create: XOR<ClientEntityPropertiesCreateWithoutClientInput, ClientEntityPropertiesUncheckedCreateWithoutClientInput>
  }

  export type AssignmentCreateWithoutClientInput = {
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract: ClientContractCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentUncheckedCreateWithoutClientInput = {
    id?: number
    order: number
    clientContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateOrConnectWithoutClientInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutClientInput, AssignmentUncheckedCreateWithoutClientInput>
  }

  export type AssignmentCreateManyClientInputEnvelope = {
    data: AssignmentCreateManyClientInput | AssignmentCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientToClientIndividualMinorPropertiesCreateWithoutClientInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    clientIndividualMinorProperties: ClientIndividualMinorPropertiesCreateNestedOneWithoutClientsToClientIndividualMinorPropertiesInput
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput = {
    clientIndividualMinorPropertiesId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientInput = {
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    create: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClientInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput>
  }

  export type ClientToClientIndividualMinorPropertiesCreateManyClientInputEnvelope = {
    data: ClientToClientIndividualMinorPropertiesCreateManyClientInput | ClientToClientIndividualMinorPropertiesCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientContractToClientCreateWithoutClientInput = {
    isMain: boolean
    share: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract: ClientContractCreateNestedOneWithoutClientContractsToClientsInput
  }

  export type ClientContractToClientUncheckedCreateWithoutClientInput = {
    isMain: boolean
    share: number
    clientContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientContractToClientCreateOrConnectWithoutClientInput = {
    where: ClientContractToClientWhereUniqueInput
    create: XOR<ClientContractToClientCreateWithoutClientInput, ClientContractToClientUncheckedCreateWithoutClientInput>
  }

  export type ClientContractToClientCreateManyClientInputEnvelope = {
    data: ClientContractToClientCreateManyClientInput | ClientContractToClientCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type RepresentativeCreateWithoutClientInput = {
    fullName: string
    attorneyNumber?: string | null
    attorneyDate?: Date | string | null
    authorizedBy?: string | null
    authorizedRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferActsToRepresentatives?: TransferActToRepresentativeCreateNestedManyWithoutRepresentativeInput
  }

  export type RepresentativeUncheckedCreateWithoutClientInput = {
    id?: number
    fullName: string
    attorneyNumber?: string | null
    attorneyDate?: Date | string | null
    authorizedBy?: string | null
    authorizedRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferActsToRepresentatives?: TransferActToRepresentativeUncheckedCreateNestedManyWithoutRepresentativeInput
  }

  export type RepresentativeCreateOrConnectWithoutClientInput = {
    where: RepresentativeWhereUniqueInput
    create: XOR<RepresentativeCreateWithoutClientInput, RepresentativeUncheckedCreateWithoutClientInput>
  }

  export type RepresentativeCreateManyClientInputEnvelope = {
    data: RepresentativeCreateManyClientInput | RepresentativeCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientIndividualPropertiesUpsertWithoutClientInput = {
    update: XOR<ClientIndividualPropertiesUpdateWithoutClientInput, ClientIndividualPropertiesUncheckedUpdateWithoutClientInput>
    create: XOR<ClientIndividualPropertiesCreateWithoutClientInput, ClientIndividualPropertiesUncheckedCreateWithoutClientInput>
    where?: ClientIndividualPropertiesWhereInput
  }

  export type ClientIndividualPropertiesUpdateToOneWithWhereWithoutClientInput = {
    where?: ClientIndividualPropertiesWhereInput
    data: XOR<ClientIndividualPropertiesUpdateWithoutClientInput, ClientIndividualPropertiesUncheckedUpdateWithoutClientInput>
  }

  export type ClientIndividualPropertiesUpdateWithoutClientInput = {
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientPassport?: ClientPassportUpdateOneWithoutClientIndividualPropertiesNestedInput
  }

  export type ClientIndividualPropertiesUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    clientPassportId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientIndividualMinorPropertiesUpsertWithoutClientInput = {
    update: XOR<ClientIndividualMinorPropertiesUpdateWithoutClientInput, ClientIndividualMinorPropertiesUncheckedUpdateWithoutClientInput>
    create: XOR<ClientIndividualMinorPropertiesCreateWithoutClientInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput>
    where?: ClientIndividualMinorPropertiesWhereInput
  }

  export type ClientIndividualMinorPropertiesUpdateToOneWithWhereWithoutClientInput = {
    where?: ClientIndividualMinorPropertiesWhereInput
    data: XOR<ClientIndividualMinorPropertiesUpdateWithoutClientInput, ClientIndividualMinorPropertiesUncheckedUpdateWithoutClientInput>
  }

  export type ClientIndividualMinorPropertiesUpdateWithoutClientInput = {
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birthCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientPassport?: ClientPassportUpdateOneWithoutClientIndividualMinorPropertiesNestedInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUpdateManyWithoutClientIndividualMinorPropertiesNestedInput
  }

  export type ClientIndividualMinorPropertiesUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birthCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    clientPassportId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientIndividualMinorPropertiesNestedInput
  }

  export type ClientEntityPropertiesUpsertWithoutClientInput = {
    update: XOR<ClientEntityPropertiesUpdateWithoutClientInput, ClientEntityPropertiesUncheckedUpdateWithoutClientInput>
    create: XOR<ClientEntityPropertiesCreateWithoutClientInput, ClientEntityPropertiesUncheckedCreateWithoutClientInput>
    where?: ClientEntityPropertiesWhereInput
  }

  export type ClientEntityPropertiesUpdateToOneWithWhereWithoutClientInput = {
    where?: ClientEntityPropertiesWhereInput
    data: XOR<ClientEntityPropertiesUpdateWithoutClientInput, ClientEntityPropertiesUncheckedUpdateWithoutClientInput>
  }

  export type ClientEntityPropertiesUpdateWithoutClientInput = {
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEntityPropertiesUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    kpp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUpsertWithWhereUniqueWithoutClientInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutClientInput, AssignmentUncheckedUpdateWithoutClientInput>
    create: XOR<AssignmentCreateWithoutClientInput, AssignmentUncheckedCreateWithoutClientInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutClientInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutClientInput, AssignmentUncheckedUpdateWithoutClientInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutClientInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutClientInput>
  }

  export type AssignmentScalarWhereInput = {
    AND?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    OR?: AssignmentScalarWhereInput[]
    NOT?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    id?: IntFilter<"Assignment"> | number
    order?: IntFilter<"Assignment"> | number
    clientContractId?: IntFilter<"Assignment"> | number
    clientId?: IntFilter<"Assignment"> | number
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
  }

  export type ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    update: XOR<ClientToClientIndividualMinorPropertiesUpdateWithoutClientInput, ClientToClientIndividualMinorPropertiesUncheckedUpdateWithoutClientInput>
    create: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClientInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientInput>
  }

  export type ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    data: XOR<ClientToClientIndividualMinorPropertiesUpdateWithoutClientInput, ClientToClientIndividualMinorPropertiesUncheckedUpdateWithoutClientInput>
  }

  export type ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClientInput = {
    where: ClientToClientIndividualMinorPropertiesScalarWhereInput
    data: XOR<ClientToClientIndividualMinorPropertiesUpdateManyMutationInput, ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientToClientIndividualMinorPropertiesScalarWhereInput = {
    AND?: ClientToClientIndividualMinorPropertiesScalarWhereInput | ClientToClientIndividualMinorPropertiesScalarWhereInput[]
    OR?: ClientToClientIndividualMinorPropertiesScalarWhereInput[]
    NOT?: ClientToClientIndividualMinorPropertiesScalarWhereInput | ClientToClientIndividualMinorPropertiesScalarWhereInput[]
    clientId?: IntFilter<"ClientToClientIndividualMinorProperties"> | number
    clientIndividualMinorPropertiesId?: IntFilter<"ClientToClientIndividualMinorProperties"> | number
    createdAt?: DateTimeFilter<"ClientToClientIndividualMinorProperties"> | Date | string
    updatedAt?: DateTimeFilter<"ClientToClientIndividualMinorProperties"> | Date | string
  }

  export type ClientContractToClientUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientContractToClientWhereUniqueInput
    update: XOR<ClientContractToClientUpdateWithoutClientInput, ClientContractToClientUncheckedUpdateWithoutClientInput>
    create: XOR<ClientContractToClientCreateWithoutClientInput, ClientContractToClientUncheckedCreateWithoutClientInput>
  }

  export type ClientContractToClientUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientContractToClientWhereUniqueInput
    data: XOR<ClientContractToClientUpdateWithoutClientInput, ClientContractToClientUncheckedUpdateWithoutClientInput>
  }

  export type ClientContractToClientUpdateManyWithWhereWithoutClientInput = {
    where: ClientContractToClientScalarWhereInput
    data: XOR<ClientContractToClientUpdateManyMutationInput, ClientContractToClientUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientContractToClientScalarWhereInput = {
    AND?: ClientContractToClientScalarWhereInput | ClientContractToClientScalarWhereInput[]
    OR?: ClientContractToClientScalarWhereInput[]
    NOT?: ClientContractToClientScalarWhereInput | ClientContractToClientScalarWhereInput[]
    isMain?: BoolFilter<"ClientContractToClient"> | boolean
    share?: IntFilter<"ClientContractToClient"> | number
    clientContractId?: IntFilter<"ClientContractToClient"> | number
    clientId?: IntFilter<"ClientContractToClient"> | number
    createdAt?: DateTimeFilter<"ClientContractToClient"> | Date | string
    updatedAt?: DateTimeFilter<"ClientContractToClient"> | Date | string
  }

  export type RepresentativeUpsertWithWhereUniqueWithoutClientInput = {
    where: RepresentativeWhereUniqueInput
    update: XOR<RepresentativeUpdateWithoutClientInput, RepresentativeUncheckedUpdateWithoutClientInput>
    create: XOR<RepresentativeCreateWithoutClientInput, RepresentativeUncheckedCreateWithoutClientInput>
  }

  export type RepresentativeUpdateWithWhereUniqueWithoutClientInput = {
    where: RepresentativeWhereUniqueInput
    data: XOR<RepresentativeUpdateWithoutClientInput, RepresentativeUncheckedUpdateWithoutClientInput>
  }

  export type RepresentativeUpdateManyWithWhereWithoutClientInput = {
    where: RepresentativeScalarWhereInput
    data: XOR<RepresentativeUpdateManyMutationInput, RepresentativeUncheckedUpdateManyWithoutClientInput>
  }

  export type RepresentativeScalarWhereInput = {
    AND?: RepresentativeScalarWhereInput | RepresentativeScalarWhereInput[]
    OR?: RepresentativeScalarWhereInput[]
    NOT?: RepresentativeScalarWhereInput | RepresentativeScalarWhereInput[]
    id?: IntFilter<"Representative"> | number
    fullName?: StringFilter<"Representative"> | string
    attorneyNumber?: StringNullableFilter<"Representative"> | string | null
    attorneyDate?: DateTimeNullableFilter<"Representative"> | Date | string | null
    authorizedBy?: StringNullableFilter<"Representative"> | string | null
    authorizedRole?: StringNullableFilter<"Representative"> | string | null
    clientId?: IntFilter<"Representative"> | number
    createdAt?: DateTimeFilter<"Representative"> | Date | string
    updatedAt?: DateTimeFilter<"Representative"> | Date | string
  }

  export type ClientCreateWithoutClientIndividualPropertiesInput = {
    fullName: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    clientCategory: $Enums.ClientCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesCreateNestedOneWithoutClientInput
    clientEntityProperties?: ClientEntityPropertiesCreateNestedOneWithoutClientInput
    assignments?: AssignmentCreateNestedManyWithoutClientInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClientInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientInput
    representatives?: RepresentativeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutClientIndividualPropertiesInput = {
    id?: number
    fullName: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    clientCategory: $Enums.ClientCategory
    clientIndividualMinorPropertiesId?: number | null
    clientEntityPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClientInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutClientIndividualPropertiesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutClientIndividualPropertiesInput, ClientUncheckedCreateWithoutClientIndividualPropertiesInput>
  }

  export type ClientPassportCreateWithoutClientIndividualPropertiesInput = {
    number?: string | null
    issued?: string | null
    code?: string | null
    placeOfBirth?: string | null
    registrationAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesCreateNestedOneWithoutClientPassportInput
  }

  export type ClientPassportUncheckedCreateWithoutClientIndividualPropertiesInput = {
    id?: number
    number?: string | null
    issued?: string | null
    code?: string | null
    placeOfBirth?: string | null
    registrationAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesUncheckedCreateNestedOneWithoutClientPassportInput
  }

  export type ClientPassportCreateOrConnectWithoutClientIndividualPropertiesInput = {
    where: ClientPassportWhereUniqueInput
    create: XOR<ClientPassportCreateWithoutClientIndividualPropertiesInput, ClientPassportUncheckedCreateWithoutClientIndividualPropertiesInput>
  }

  export type ClientUpsertWithoutClientIndividualPropertiesInput = {
    update: XOR<ClientUpdateWithoutClientIndividualPropertiesInput, ClientUncheckedUpdateWithoutClientIndividualPropertiesInput>
    create: XOR<ClientCreateWithoutClientIndividualPropertiesInput, ClientUncheckedCreateWithoutClientIndividualPropertiesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutClientIndividualPropertiesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutClientIndividualPropertiesInput, ClientUncheckedUpdateWithoutClientIndividualPropertiesInput>
  }

  export type ClientUpdateWithoutClientIndividualPropertiesInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    clientCategory?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesUpdateOneWithoutClientNestedInput
    clientEntityProperties?: ClientEntityPropertiesUpdateOneWithoutClientNestedInput
    assignments?: AssignmentUpdateManyWithoutClientNestedInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUpdateManyWithoutClientNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientNestedInput
    representatives?: RepresentativeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutClientIndividualPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    clientCategory?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    clientIndividualMinorPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    clientEntityPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutClientNestedInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientPassportUpsertWithoutClientIndividualPropertiesInput = {
    update: XOR<ClientPassportUpdateWithoutClientIndividualPropertiesInput, ClientPassportUncheckedUpdateWithoutClientIndividualPropertiesInput>
    create: XOR<ClientPassportCreateWithoutClientIndividualPropertiesInput, ClientPassportUncheckedCreateWithoutClientIndividualPropertiesInput>
    where?: ClientPassportWhereInput
  }

  export type ClientPassportUpdateToOneWithWhereWithoutClientIndividualPropertiesInput = {
    where?: ClientPassportWhereInput
    data: XOR<ClientPassportUpdateWithoutClientIndividualPropertiesInput, ClientPassportUncheckedUpdateWithoutClientIndividualPropertiesInput>
  }

  export type ClientPassportUpdateWithoutClientIndividualPropertiesInput = {
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issued?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    registrationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesUpdateOneWithoutClientPassportNestedInput
  }

  export type ClientPassportUncheckedUpdateWithoutClientIndividualPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issued?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    registrationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesUncheckedUpdateOneWithoutClientPassportNestedInput
  }

  export type ClientCreateWithoutClientIndividualMinorPropertiesInput = {
    fullName: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    clientCategory: $Enums.ClientCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    clientIndividualProperties?: ClientIndividualPropertiesCreateNestedOneWithoutClientInput
    clientEntityProperties?: ClientEntityPropertiesCreateNestedOneWithoutClientInput
    assignments?: AssignmentCreateNestedManyWithoutClientInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClientInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientInput
    representatives?: RepresentativeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutClientIndividualMinorPropertiesInput = {
    id?: number
    fullName: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    clientCategory: $Enums.ClientCategory
    clientIndividualPropertiesId?: number | null
    clientEntityPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClientInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutClientIndividualMinorPropertiesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutClientIndividualMinorPropertiesInput, ClientUncheckedCreateWithoutClientIndividualMinorPropertiesInput>
  }

  export type ClientPassportCreateWithoutClientIndividualMinorPropertiesInput = {
    number?: string | null
    issued?: string | null
    code?: string | null
    placeOfBirth?: string | null
    registrationAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientIndividualProperties?: ClientIndividualPropertiesCreateNestedOneWithoutClientPassportInput
  }

  export type ClientPassportUncheckedCreateWithoutClientIndividualMinorPropertiesInput = {
    id?: number
    number?: string | null
    issued?: string | null
    code?: string | null
    placeOfBirth?: string | null
    registrationAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientIndividualProperties?: ClientIndividualPropertiesUncheckedCreateNestedOneWithoutClientPassportInput
  }

  export type ClientPassportCreateOrConnectWithoutClientIndividualMinorPropertiesInput = {
    where: ClientPassportWhereUniqueInput
    create: XOR<ClientPassportCreateWithoutClientIndividualMinorPropertiesInput, ClientPassportUncheckedCreateWithoutClientIndividualMinorPropertiesInput>
  }

  export type ClientToClientIndividualMinorPropertiesCreateWithoutClientIndividualMinorPropertiesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutClientsToClientIndividualMinorPropertiesInput
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientIndividualMinorPropertiesInput = {
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientToClientIndividualMinorPropertiesCreateOrConnectWithoutClientIndividualMinorPropertiesInput = {
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    create: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClientIndividualMinorPropertiesInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientIndividualMinorPropertiesInput>
  }

  export type ClientToClientIndividualMinorPropertiesCreateManyClientIndividualMinorPropertiesInputEnvelope = {
    data: ClientToClientIndividualMinorPropertiesCreateManyClientIndividualMinorPropertiesInput | ClientToClientIndividualMinorPropertiesCreateManyClientIndividualMinorPropertiesInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutClientIndividualMinorPropertiesInput = {
    update: XOR<ClientUpdateWithoutClientIndividualMinorPropertiesInput, ClientUncheckedUpdateWithoutClientIndividualMinorPropertiesInput>
    create: XOR<ClientCreateWithoutClientIndividualMinorPropertiesInput, ClientUncheckedCreateWithoutClientIndividualMinorPropertiesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutClientIndividualMinorPropertiesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutClientIndividualMinorPropertiesInput, ClientUncheckedUpdateWithoutClientIndividualMinorPropertiesInput>
  }

  export type ClientUpdateWithoutClientIndividualMinorPropertiesInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    clientCategory?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientIndividualProperties?: ClientIndividualPropertiesUpdateOneWithoutClientNestedInput
    clientEntityProperties?: ClientEntityPropertiesUpdateOneWithoutClientNestedInput
    assignments?: AssignmentUpdateManyWithoutClientNestedInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUpdateManyWithoutClientNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientNestedInput
    representatives?: RepresentativeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutClientIndividualMinorPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    clientCategory?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    clientIndividualPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    clientEntityPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutClientNestedInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientPassportUpsertWithoutClientIndividualMinorPropertiesInput = {
    update: XOR<ClientPassportUpdateWithoutClientIndividualMinorPropertiesInput, ClientPassportUncheckedUpdateWithoutClientIndividualMinorPropertiesInput>
    create: XOR<ClientPassportCreateWithoutClientIndividualMinorPropertiesInput, ClientPassportUncheckedCreateWithoutClientIndividualMinorPropertiesInput>
    where?: ClientPassportWhereInput
  }

  export type ClientPassportUpdateToOneWithWhereWithoutClientIndividualMinorPropertiesInput = {
    where?: ClientPassportWhereInput
    data: XOR<ClientPassportUpdateWithoutClientIndividualMinorPropertiesInput, ClientPassportUncheckedUpdateWithoutClientIndividualMinorPropertiesInput>
  }

  export type ClientPassportUpdateWithoutClientIndividualMinorPropertiesInput = {
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issued?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    registrationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientIndividualProperties?: ClientIndividualPropertiesUpdateOneWithoutClientPassportNestedInput
  }

  export type ClientPassportUncheckedUpdateWithoutClientIndividualMinorPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issued?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    registrationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientIndividualProperties?: ClientIndividualPropertiesUncheckedUpdateOneWithoutClientPassportNestedInput
  }

  export type ClientToClientIndividualMinorPropertiesUpsertWithWhereUniqueWithoutClientIndividualMinorPropertiesInput = {
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    update: XOR<ClientToClientIndividualMinorPropertiesUpdateWithoutClientIndividualMinorPropertiesInput, ClientToClientIndividualMinorPropertiesUncheckedUpdateWithoutClientIndividualMinorPropertiesInput>
    create: XOR<ClientToClientIndividualMinorPropertiesCreateWithoutClientIndividualMinorPropertiesInput, ClientToClientIndividualMinorPropertiesUncheckedCreateWithoutClientIndividualMinorPropertiesInput>
  }

  export type ClientToClientIndividualMinorPropertiesUpdateWithWhereUniqueWithoutClientIndividualMinorPropertiesInput = {
    where: ClientToClientIndividualMinorPropertiesWhereUniqueInput
    data: XOR<ClientToClientIndividualMinorPropertiesUpdateWithoutClientIndividualMinorPropertiesInput, ClientToClientIndividualMinorPropertiesUncheckedUpdateWithoutClientIndividualMinorPropertiesInput>
  }

  export type ClientToClientIndividualMinorPropertiesUpdateManyWithWhereWithoutClientIndividualMinorPropertiesInput = {
    where: ClientToClientIndividualMinorPropertiesScalarWhereInput
    data: XOR<ClientToClientIndividualMinorPropertiesUpdateManyMutationInput, ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientIndividualMinorPropertiesInput>
  }

  export type ClientCreateWithoutClientEntityPropertiesInput = {
    fullName: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    clientCategory: $Enums.ClientCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    clientIndividualProperties?: ClientIndividualPropertiesCreateNestedOneWithoutClientInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesCreateNestedOneWithoutClientInput
    assignments?: AssignmentCreateNestedManyWithoutClientInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClientInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientInput
    representatives?: RepresentativeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutClientEntityPropertiesInput = {
    id?: number
    fullName: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    clientCategory: $Enums.ClientCategory
    clientIndividualPropertiesId?: number | null
    clientIndividualMinorPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClientInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutClientEntityPropertiesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutClientEntityPropertiesInput, ClientUncheckedCreateWithoutClientEntityPropertiesInput>
  }

  export type ClientUpsertWithoutClientEntityPropertiesInput = {
    update: XOR<ClientUpdateWithoutClientEntityPropertiesInput, ClientUncheckedUpdateWithoutClientEntityPropertiesInput>
    create: XOR<ClientCreateWithoutClientEntityPropertiesInput, ClientUncheckedCreateWithoutClientEntityPropertiesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutClientEntityPropertiesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutClientEntityPropertiesInput, ClientUncheckedUpdateWithoutClientEntityPropertiesInput>
  }

  export type ClientUpdateWithoutClientEntityPropertiesInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    clientCategory?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientIndividualProperties?: ClientIndividualPropertiesUpdateOneWithoutClientNestedInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesUpdateOneWithoutClientNestedInput
    assignments?: AssignmentUpdateManyWithoutClientNestedInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUpdateManyWithoutClientNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientNestedInput
    representatives?: RepresentativeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutClientEntityPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    clientCategory?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    clientIndividualPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    clientIndividualMinorPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutClientNestedInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutClientsToClientIndividualMinorPropertiesInput = {
    fullName: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    clientCategory: $Enums.ClientCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    clientIndividualProperties?: ClientIndividualPropertiesCreateNestedOneWithoutClientInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesCreateNestedOneWithoutClientInput
    clientEntityProperties?: ClientEntityPropertiesCreateNestedOneWithoutClientInput
    assignments?: AssignmentCreateNestedManyWithoutClientInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientInput
    representatives?: RepresentativeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutClientsToClientIndividualMinorPropertiesInput = {
    id?: number
    fullName: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    clientCategory: $Enums.ClientCategory
    clientIndividualPropertiesId?: number | null
    clientIndividualMinorPropertiesId?: number | null
    clientEntityPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutClientsToClientIndividualMinorPropertiesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutClientsToClientIndividualMinorPropertiesInput, ClientUncheckedCreateWithoutClientsToClientIndividualMinorPropertiesInput>
  }

  export type ClientIndividualMinorPropertiesCreateWithoutClientsToClientIndividualMinorPropertiesInput = {
    dob?: Date | string | null
    snils?: string | null
    birthCertificate?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutClientIndividualMinorPropertiesInput
    clientPassport?: ClientPassportCreateNestedOneWithoutClientIndividualMinorPropertiesInput
  }

  export type ClientIndividualMinorPropertiesUncheckedCreateWithoutClientsToClientIndividualMinorPropertiesInput = {
    id?: number
    dob?: Date | string | null
    snils?: string | null
    birthCertificate?: string | null
    clientPassportId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientUncheckedCreateNestedOneWithoutClientIndividualMinorPropertiesInput
  }

  export type ClientIndividualMinorPropertiesCreateOrConnectWithoutClientsToClientIndividualMinorPropertiesInput = {
    where: ClientIndividualMinorPropertiesWhereUniqueInput
    create: XOR<ClientIndividualMinorPropertiesCreateWithoutClientsToClientIndividualMinorPropertiesInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClientsToClientIndividualMinorPropertiesInput>
  }

  export type ClientUpsertWithoutClientsToClientIndividualMinorPropertiesInput = {
    update: XOR<ClientUpdateWithoutClientsToClientIndividualMinorPropertiesInput, ClientUncheckedUpdateWithoutClientsToClientIndividualMinorPropertiesInput>
    create: XOR<ClientCreateWithoutClientsToClientIndividualMinorPropertiesInput, ClientUncheckedCreateWithoutClientsToClientIndividualMinorPropertiesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutClientsToClientIndividualMinorPropertiesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutClientsToClientIndividualMinorPropertiesInput, ClientUncheckedUpdateWithoutClientsToClientIndividualMinorPropertiesInput>
  }

  export type ClientUpdateWithoutClientsToClientIndividualMinorPropertiesInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    clientCategory?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientIndividualProperties?: ClientIndividualPropertiesUpdateOneWithoutClientNestedInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesUpdateOneWithoutClientNestedInput
    clientEntityProperties?: ClientEntityPropertiesUpdateOneWithoutClientNestedInput
    assignments?: AssignmentUpdateManyWithoutClientNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientNestedInput
    representatives?: RepresentativeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutClientsToClientIndividualMinorPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    clientCategory?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    clientIndividualPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    clientIndividualMinorPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    clientEntityPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutClientNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientIndividualMinorPropertiesUpsertWithoutClientsToClientIndividualMinorPropertiesInput = {
    update: XOR<ClientIndividualMinorPropertiesUpdateWithoutClientsToClientIndividualMinorPropertiesInput, ClientIndividualMinorPropertiesUncheckedUpdateWithoutClientsToClientIndividualMinorPropertiesInput>
    create: XOR<ClientIndividualMinorPropertiesCreateWithoutClientsToClientIndividualMinorPropertiesInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClientsToClientIndividualMinorPropertiesInput>
    where?: ClientIndividualMinorPropertiesWhereInput
  }

  export type ClientIndividualMinorPropertiesUpdateToOneWithWhereWithoutClientsToClientIndividualMinorPropertiesInput = {
    where?: ClientIndividualMinorPropertiesWhereInput
    data: XOR<ClientIndividualMinorPropertiesUpdateWithoutClientsToClientIndividualMinorPropertiesInput, ClientIndividualMinorPropertiesUncheckedUpdateWithoutClientsToClientIndividualMinorPropertiesInput>
  }

  export type ClientIndividualMinorPropertiesUpdateWithoutClientsToClientIndividualMinorPropertiesInput = {
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birthCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutClientIndividualMinorPropertiesNestedInput
    clientPassport?: ClientPassportUpdateOneWithoutClientIndividualMinorPropertiesNestedInput
  }

  export type ClientIndividualMinorPropertiesUncheckedUpdateWithoutClientsToClientIndividualMinorPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birthCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    clientPassportId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUncheckedUpdateOneWithoutClientIndividualMinorPropertiesNestedInput
  }

  export type ClientIndividualPropertiesCreateWithoutClientPassportInput = {
    dob?: Date | string | null
    snils?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutClientIndividualPropertiesInput
  }

  export type ClientIndividualPropertiesUncheckedCreateWithoutClientPassportInput = {
    id?: number
    dob?: Date | string | null
    snils?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientUncheckedCreateNestedOneWithoutClientIndividualPropertiesInput
  }

  export type ClientIndividualPropertiesCreateOrConnectWithoutClientPassportInput = {
    where: ClientIndividualPropertiesWhereUniqueInput
    create: XOR<ClientIndividualPropertiesCreateWithoutClientPassportInput, ClientIndividualPropertiesUncheckedCreateWithoutClientPassportInput>
  }

  export type ClientIndividualMinorPropertiesCreateWithoutClientPassportInput = {
    dob?: Date | string | null
    snils?: string | null
    birthCertificate?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutClientIndividualMinorPropertiesInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClientIndividualMinorPropertiesInput
  }

  export type ClientIndividualMinorPropertiesUncheckedCreateWithoutClientPassportInput = {
    id?: number
    dob?: Date | string | null
    snils?: string | null
    birthCertificate?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientUncheckedCreateNestedOneWithoutClientIndividualMinorPropertiesInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClientIndividualMinorPropertiesInput
  }

  export type ClientIndividualMinorPropertiesCreateOrConnectWithoutClientPassportInput = {
    where: ClientIndividualMinorPropertiesWhereUniqueInput
    create: XOR<ClientIndividualMinorPropertiesCreateWithoutClientPassportInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClientPassportInput>
  }

  export type ClientIndividualPropertiesUpsertWithoutClientPassportInput = {
    update: XOR<ClientIndividualPropertiesUpdateWithoutClientPassportInput, ClientIndividualPropertiesUncheckedUpdateWithoutClientPassportInput>
    create: XOR<ClientIndividualPropertiesCreateWithoutClientPassportInput, ClientIndividualPropertiesUncheckedCreateWithoutClientPassportInput>
    where?: ClientIndividualPropertiesWhereInput
  }

  export type ClientIndividualPropertiesUpdateToOneWithWhereWithoutClientPassportInput = {
    where?: ClientIndividualPropertiesWhereInput
    data: XOR<ClientIndividualPropertiesUpdateWithoutClientPassportInput, ClientIndividualPropertiesUncheckedUpdateWithoutClientPassportInput>
  }

  export type ClientIndividualPropertiesUpdateWithoutClientPassportInput = {
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutClientIndividualPropertiesNestedInput
  }

  export type ClientIndividualPropertiesUncheckedUpdateWithoutClientPassportInput = {
    id?: IntFieldUpdateOperationsInput | number
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUncheckedUpdateOneWithoutClientIndividualPropertiesNestedInput
  }

  export type ClientIndividualMinorPropertiesUpsertWithoutClientPassportInput = {
    update: XOR<ClientIndividualMinorPropertiesUpdateWithoutClientPassportInput, ClientIndividualMinorPropertiesUncheckedUpdateWithoutClientPassportInput>
    create: XOR<ClientIndividualMinorPropertiesCreateWithoutClientPassportInput, ClientIndividualMinorPropertiesUncheckedCreateWithoutClientPassportInput>
    where?: ClientIndividualMinorPropertiesWhereInput
  }

  export type ClientIndividualMinorPropertiesUpdateToOneWithWhereWithoutClientPassportInput = {
    where?: ClientIndividualMinorPropertiesWhereInput
    data: XOR<ClientIndividualMinorPropertiesUpdateWithoutClientPassportInput, ClientIndividualMinorPropertiesUncheckedUpdateWithoutClientPassportInput>
  }

  export type ClientIndividualMinorPropertiesUpdateWithoutClientPassportInput = {
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birthCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutClientIndividualMinorPropertiesNestedInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUpdateManyWithoutClientIndividualMinorPropertiesNestedInput
  }

  export type ClientIndividualMinorPropertiesUncheckedUpdateWithoutClientPassportInput = {
    id?: IntFieldUpdateOperationsInput | number
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snils?: NullableStringFieldUpdateOperationsInput | string | null
    birthCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUncheckedUpdateOneWithoutClientIndividualMinorPropertiesNestedInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientIndividualMinorPropertiesNestedInput
  }

  export type TransferActCreateWithoutClientContractInput = {
    number: string
    date: Date | string
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    object: ObjectCreateNestedOneWithoutTransferActsInput
    product: ProductCreateNestedOneWithoutTransferActInput
    transferActsToRepresentatives?: TransferActToRepresentativeCreateNestedManyWithoutTransferActInput
  }

  export type TransferActUncheckedCreateWithoutClientContractInput = {
    id?: number
    number: string
    date: Date | string
    link?: string | null
    objectId: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transferActsToRepresentatives?: TransferActToRepresentativeUncheckedCreateNestedManyWithoutTransferActInput
  }

  export type TransferActCreateOrConnectWithoutClientContractInput = {
    where: TransferActWhereUniqueInput
    create: XOR<TransferActCreateWithoutClientContractInput, TransferActUncheckedCreateWithoutClientContractInput>
  }

  export type DduClientContractPropertiesCreateWithoutClientContractInput = {
    dduLink?: string | null
    returnAccount?: string | null
    escrowAccountOpeningDate?: Date | string | null
    escrowPeriod?: Date | string | null
    escrowAccountNumber?: string | null
    isEscrowDiscount?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DduClientContractPropertiesUncheckedCreateWithoutClientContractInput = {
    id?: number
    dduLink?: string | null
    returnAccount?: string | null
    escrowAccountOpeningDate?: Date | string | null
    escrowPeriod?: Date | string | null
    escrowAccountNumber?: string | null
    isEscrowDiscount?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DduClientContractPropertiesCreateOrConnectWithoutClientContractInput = {
    where: DduClientContractPropertiesWhereUniqueInput
    create: XOR<DduClientContractPropertiesCreateWithoutClientContractInput, DduClientContractPropertiesUncheckedCreateWithoutClientContractInput>
  }

  export type DkpClientContractPropertiesCreateWithoutClientContractInput = {
    dkpLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DkpClientContractPropertiesUncheckedCreateWithoutClientContractInput = {
    id?: number
    dkpLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DkpClientContractPropertiesCreateOrConnectWithoutClientContractInput = {
    where: DkpClientContractPropertiesWhereUniqueInput
    create: XOR<DkpClientContractPropertiesCreateWithoutClientContractInput, DkpClientContractPropertiesUncheckedCreateWithoutClientContractInput>
  }

  export type ProductCreateWithoutClientContractInput = {
    pricingProductsId: number
    number: string
    productCategory: $Enums.ProductCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActCreateNestedOneWithoutProductInput
    object: ObjectCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutClientContractInput = {
    id?: number
    pricingProductsId: number
    number: string
    productCategory: $Enums.ProductCategory
    objectId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutClientContractInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutClientContractInput, ProductUncheckedCreateWithoutClientContractInput>
  }

  export type ObjectCreateWithoutClientContractsInput = {
    commonDbObjectsId: number
    name: string
    dateIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entity: EntityCreateNestedOneWithoutObjectsInput
    products?: ProductCreateNestedManyWithoutObjectInput
    agencyContracts?: AgencyContractCreateNestedManyWithoutObjectInput
    transferActs?: TransferActCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutClientContractsInput = {
    id?: number
    commonDbObjectsId: number
    name: string
    dateIn?: Date | string | null
    entityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutObjectInput
    agencyContracts?: AgencyContractUncheckedCreateNestedManyWithoutObjectInput
    transferActs?: TransferActUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutClientContractsInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutClientContractsInput, ObjectUncheckedCreateWithoutClientContractsInput>
  }

  export type RealEstateAgentCreateWithoutClientContractsInput = {
    fullName: string
    phone?: string | null
    oneGtId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentCreateNestedManyWithoutRealEstateAgentInput
  }

  export type RealEstateAgentUncheckedCreateWithoutClientContractsInput = {
    id?: number
    fullName: string
    phone?: string | null
    oneGtId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentUncheckedCreateNestedManyWithoutRealEstateAgentInput
  }

  export type RealEstateAgentCreateOrConnectWithoutClientContractsInput = {
    where: RealEstateAgentWhereUniqueInput
    create: XOR<RealEstateAgentCreateWithoutClientContractsInput, RealEstateAgentUncheckedCreateWithoutClientContractsInput>
  }

  export type UserCreateWithoutClientContractsInput = {
    fullName: string
    email: string
    phone?: string | null
    isManager?: boolean
    isStaff?: boolean
    userRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractCreateNestedManyWithoutResponsibleUserInput
  }

  export type UserUncheckedCreateWithoutClientContractsInput = {
    id?: number
    fullName: string
    email: string
    phone?: string | null
    isManager?: boolean
    isStaff?: boolean
    userRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractUncheckedCreateNestedManyWithoutResponsibleUserInput
  }

  export type UserCreateOrConnectWithoutClientContractsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientContractsInput, UserUncheckedCreateWithoutClientContractsInput>
  }

  export type BankCreateWithoutClientContractsInput = {
    name: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankUncheckedCreateWithoutClientContractsInput = {
    id?: number
    name: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankCreateOrConnectWithoutClientContractsInput = {
    where: BankWhereUniqueInput
    create: XOR<BankCreateWithoutClientContractsInput, BankUncheckedCreateWithoutClientContractsInput>
  }

  export type SubsidyCreateWithoutClientContractsInput = {
    name: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubsidyUncheckedCreateWithoutClientContractsInput = {
    id?: number
    name: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubsidyCreateOrConnectWithoutClientContractsInput = {
    where: SubsidyWhereUniqueInput
    create: XOR<SubsidyCreateWithoutClientContractsInput, SubsidyUncheckedCreateWithoutClientContractsInput>
  }

  export type ScheduledPaymentCreateWithoutClientContractInput = {
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    scheduledPaymentType: $Enums.ScheduledPaymentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledPaymentUncheckedCreateWithoutClientContractInput = {
    id?: number
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    scheduledPaymentType: $Enums.ScheduledPaymentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledPaymentCreateOrConnectWithoutClientContractInput = {
    where: ScheduledPaymentWhereUniqueInput
    create: XOR<ScheduledPaymentCreateWithoutClientContractInput, ScheduledPaymentUncheckedCreateWithoutClientContractInput>
  }

  export type ScheduledPaymentCreateManyClientContractInputEnvelope = {
    data: ScheduledPaymentCreateManyClientContractInput | ScheduledPaymentCreateManyClientContractInput[]
    skipDuplicates?: boolean
  }

  export type ActualPaymentCreateWithoutClientContractInput = {
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActualPaymentUncheckedCreateWithoutClientContractInput = {
    id?: number
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActualPaymentCreateOrConnectWithoutClientContractInput = {
    where: ActualPaymentWhereUniqueInput
    create: XOR<ActualPaymentCreateWithoutClientContractInput, ActualPaymentUncheckedCreateWithoutClientContractInput>
  }

  export type ActualPaymentCreateManyClientContractInputEnvelope = {
    data: ActualPaymentCreateManyClientContractInput | ActualPaymentCreateManyClientContractInput[]
    skipDuplicates?: boolean
  }

  export type RealEstateAgencyActCreateWithoutClientContractInput = {
    number: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    retention?: Decimal | DecimalJsLike | number | string | null
    note?: string | null
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutRealEstateAgencyActsInput
    agencyContract: AgencyContractCreateNestedOneWithoutRealEstateAgencyActInput
  }

  export type RealEstateAgencyActUncheckedCreateWithoutClientContractInput = {
    id?: number
    number: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    retention?: Decimal | DecimalJsLike | number | string | null
    note?: string | null
    link?: string | null
    agencyId: number
    agencyContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RealEstateAgencyActCreateOrConnectWithoutClientContractInput = {
    where: RealEstateAgencyActWhereUniqueInput
    create: XOR<RealEstateAgencyActCreateWithoutClientContractInput, RealEstateAgencyActUncheckedCreateWithoutClientContractInput>
  }

  export type RealEstateAgencyActCreateManyClientContractInputEnvelope = {
    data: RealEstateAgencyActCreateManyClientContractInput | RealEstateAgencyActCreateManyClientContractInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentCreateWithoutClientContractInput = {
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentUncheckedCreateWithoutClientContractInput = {
    id?: number
    order: number
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateOrConnectWithoutClientContractInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutClientContractInput, AssignmentUncheckedCreateWithoutClientContractInput>
  }

  export type AssignmentCreateManyClientContractInputEnvelope = {
    data: AssignmentCreateManyClientContractInput | AssignmentCreateManyClientContractInput[]
    skipDuplicates?: boolean
  }

  export type ClientContractToClientCreateWithoutClientContractInput = {
    isMain: boolean
    share: number
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutClientContractsToClientsInput
  }

  export type ClientContractToClientUncheckedCreateWithoutClientContractInput = {
    isMain: boolean
    share: number
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientContractToClientCreateOrConnectWithoutClientContractInput = {
    where: ClientContractToClientWhereUniqueInput
    create: XOR<ClientContractToClientCreateWithoutClientContractInput, ClientContractToClientUncheckedCreateWithoutClientContractInput>
  }

  export type ClientContractToClientCreateManyClientContractInputEnvelope = {
    data: ClientContractToClientCreateManyClientContractInput | ClientContractToClientCreateManyClientContractInput[]
    skipDuplicates?: boolean
  }

  export type ClientContractToAgencyContractCreateWithoutClientContractInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContract: AgencyContractCreateNestedOneWithoutClientContractsToAgencyContractsInput
  }

  export type ClientContractToAgencyContractUncheckedCreateWithoutClientContractInput = {
    agencyContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientContractToAgencyContractCreateOrConnectWithoutClientContractInput = {
    where: ClientContractToAgencyContractWhereUniqueInput
    create: XOR<ClientContractToAgencyContractCreateWithoutClientContractInput, ClientContractToAgencyContractUncheckedCreateWithoutClientContractInput>
  }

  export type ClientContractToAgencyContractCreateManyClientContractInputEnvelope = {
    data: ClientContractToAgencyContractCreateManyClientContractInput | ClientContractToAgencyContractCreateManyClientContractInput[]
    skipDuplicates?: boolean
  }

  export type TransferActUpsertWithoutClientContractInput = {
    update: XOR<TransferActUpdateWithoutClientContractInput, TransferActUncheckedUpdateWithoutClientContractInput>
    create: XOR<TransferActCreateWithoutClientContractInput, TransferActUncheckedCreateWithoutClientContractInput>
    where?: TransferActWhereInput
  }

  export type TransferActUpdateToOneWithWhereWithoutClientContractInput = {
    where?: TransferActWhereInput
    data: XOR<TransferActUpdateWithoutClientContractInput, TransferActUncheckedUpdateWithoutClientContractInput>
  }

  export type TransferActUpdateWithoutClientContractInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    object?: ObjectUpdateOneRequiredWithoutTransferActsNestedInput
    product?: ProductUpdateOneRequiredWithoutTransferActNestedInput
    transferActsToRepresentatives?: TransferActToRepresentativeUpdateManyWithoutTransferActNestedInput
  }

  export type TransferActUncheckedUpdateWithoutClientContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    objectId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferActsToRepresentatives?: TransferActToRepresentativeUncheckedUpdateManyWithoutTransferActNestedInput
  }

  export type DduClientContractPropertiesUpsertWithoutClientContractInput = {
    update: XOR<DduClientContractPropertiesUpdateWithoutClientContractInput, DduClientContractPropertiesUncheckedUpdateWithoutClientContractInput>
    create: XOR<DduClientContractPropertiesCreateWithoutClientContractInput, DduClientContractPropertiesUncheckedCreateWithoutClientContractInput>
    where?: DduClientContractPropertiesWhereInput
  }

  export type DduClientContractPropertiesUpdateToOneWithWhereWithoutClientContractInput = {
    where?: DduClientContractPropertiesWhereInput
    data: XOR<DduClientContractPropertiesUpdateWithoutClientContractInput, DduClientContractPropertiesUncheckedUpdateWithoutClientContractInput>
  }

  export type DduClientContractPropertiesUpdateWithoutClientContractInput = {
    dduLink?: NullableStringFieldUpdateOperationsInput | string | null
    returnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    escrowAccountOpeningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrowPeriod?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrowAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isEscrowDiscount?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DduClientContractPropertiesUncheckedUpdateWithoutClientContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    dduLink?: NullableStringFieldUpdateOperationsInput | string | null
    returnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    escrowAccountOpeningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrowPeriod?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escrowAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isEscrowDiscount?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DkpClientContractPropertiesUpsertWithoutClientContractInput = {
    update: XOR<DkpClientContractPropertiesUpdateWithoutClientContractInput, DkpClientContractPropertiesUncheckedUpdateWithoutClientContractInput>
    create: XOR<DkpClientContractPropertiesCreateWithoutClientContractInput, DkpClientContractPropertiesUncheckedCreateWithoutClientContractInput>
    where?: DkpClientContractPropertiesWhereInput
  }

  export type DkpClientContractPropertiesUpdateToOneWithWhereWithoutClientContractInput = {
    where?: DkpClientContractPropertiesWhereInput
    data: XOR<DkpClientContractPropertiesUpdateWithoutClientContractInput, DkpClientContractPropertiesUncheckedUpdateWithoutClientContractInput>
  }

  export type DkpClientContractPropertiesUpdateWithoutClientContractInput = {
    dkpLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DkpClientContractPropertiesUncheckedUpdateWithoutClientContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    dkpLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutClientContractInput = {
    update: XOR<ProductUpdateWithoutClientContractInput, ProductUncheckedUpdateWithoutClientContractInput>
    create: XOR<ProductCreateWithoutClientContractInput, ProductUncheckedCreateWithoutClientContractInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutClientContractInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutClientContractInput, ProductUncheckedUpdateWithoutClientContractInput>
  }

  export type ProductUpdateWithoutClientContractInput = {
    pricingProductsId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    productCategory?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneWithoutProductNestedInput
    object?: ObjectUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutClientContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    pricingProductsId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    productCategory?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    objectId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUncheckedUpdateOneWithoutProductNestedInput
  }

  export type ObjectUpsertWithoutClientContractsInput = {
    update: XOR<ObjectUpdateWithoutClientContractsInput, ObjectUncheckedUpdateWithoutClientContractsInput>
    create: XOR<ObjectCreateWithoutClientContractsInput, ObjectUncheckedCreateWithoutClientContractsInput>
    where?: ObjectWhereInput
  }

  export type ObjectUpdateToOneWithWhereWithoutClientContractsInput = {
    where?: ObjectWhereInput
    data: XOR<ObjectUpdateWithoutClientContractsInput, ObjectUncheckedUpdateWithoutClientContractsInput>
  }

  export type ObjectUpdateWithoutClientContractsInput = {
    commonDbObjectsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: EntityUpdateOneRequiredWithoutObjectsNestedInput
    products?: ProductUpdateManyWithoutObjectNestedInput
    agencyContracts?: AgencyContractUpdateManyWithoutObjectNestedInput
    transferActs?: TransferActUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutClientContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbObjectsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutObjectNestedInput
    agencyContracts?: AgencyContractUncheckedUpdateManyWithoutObjectNestedInput
    transferActs?: TransferActUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type RealEstateAgentUpsertWithoutClientContractsInput = {
    update: XOR<RealEstateAgentUpdateWithoutClientContractsInput, RealEstateAgentUncheckedUpdateWithoutClientContractsInput>
    create: XOR<RealEstateAgentCreateWithoutClientContractsInput, RealEstateAgentUncheckedCreateWithoutClientContractsInput>
    where?: RealEstateAgentWhereInput
  }

  export type RealEstateAgentUpdateToOneWithWhereWithoutClientContractsInput = {
    where?: RealEstateAgentWhereInput
    data: XOR<RealEstateAgentUpdateWithoutClientContractsInput, RealEstateAgentUncheckedUpdateWithoutClientContractsInput>
  }

  export type RealEstateAgentUpdateWithoutClientContractsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    oneGtId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentUpdateManyWithoutRealEstateAgentNestedInput
  }

  export type RealEstateAgentUncheckedUpdateWithoutClientContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    oneGtId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentUncheckedUpdateManyWithoutRealEstateAgentNestedInput
  }

  export type UserUpsertWithoutClientContractsInput = {
    update: XOR<UserUpdateWithoutClientContractsInput, UserUncheckedUpdateWithoutClientContractsInput>
    create: XOR<UserCreateWithoutClientContractsInput, UserUncheckedCreateWithoutClientContractsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientContractsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientContractsInput, UserUncheckedUpdateWithoutClientContractsInput>
  }

  export type UserUpdateWithoutClientContractsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    userRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUpdateManyWithoutResponsibleUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    userRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUncheckedUpdateManyWithoutResponsibleUserNestedInput
  }

  export type BankUpsertWithoutClientContractsInput = {
    update: XOR<BankUpdateWithoutClientContractsInput, BankUncheckedUpdateWithoutClientContractsInput>
    create: XOR<BankCreateWithoutClientContractsInput, BankUncheckedCreateWithoutClientContractsInput>
    where?: BankWhereInput
  }

  export type BankUpdateToOneWithWhereWithoutClientContractsInput = {
    where?: BankWhereInput
    data: XOR<BankUpdateWithoutClientContractsInput, BankUncheckedUpdateWithoutClientContractsInput>
  }

  export type BankUpdateWithoutClientContractsInput = {
    name?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankUncheckedUpdateWithoutClientContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubsidyUpsertWithoutClientContractsInput = {
    update: XOR<SubsidyUpdateWithoutClientContractsInput, SubsidyUncheckedUpdateWithoutClientContractsInput>
    create: XOR<SubsidyCreateWithoutClientContractsInput, SubsidyUncheckedCreateWithoutClientContractsInput>
    where?: SubsidyWhereInput
  }

  export type SubsidyUpdateToOneWithWhereWithoutClientContractsInput = {
    where?: SubsidyWhereInput
    data: XOR<SubsidyUpdateWithoutClientContractsInput, SubsidyUncheckedUpdateWithoutClientContractsInput>
  }

  export type SubsidyUpdateWithoutClientContractsInput = {
    name?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubsidyUncheckedUpdateWithoutClientContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPaymentUpsertWithWhereUniqueWithoutClientContractInput = {
    where: ScheduledPaymentWhereUniqueInput
    update: XOR<ScheduledPaymentUpdateWithoutClientContractInput, ScheduledPaymentUncheckedUpdateWithoutClientContractInput>
    create: XOR<ScheduledPaymentCreateWithoutClientContractInput, ScheduledPaymentUncheckedCreateWithoutClientContractInput>
  }

  export type ScheduledPaymentUpdateWithWhereUniqueWithoutClientContractInput = {
    where: ScheduledPaymentWhereUniqueInput
    data: XOR<ScheduledPaymentUpdateWithoutClientContractInput, ScheduledPaymentUncheckedUpdateWithoutClientContractInput>
  }

  export type ScheduledPaymentUpdateManyWithWhereWithoutClientContractInput = {
    where: ScheduledPaymentScalarWhereInput
    data: XOR<ScheduledPaymentUpdateManyMutationInput, ScheduledPaymentUncheckedUpdateManyWithoutClientContractInput>
  }

  export type ScheduledPaymentScalarWhereInput = {
    AND?: ScheduledPaymentScalarWhereInput | ScheduledPaymentScalarWhereInput[]
    OR?: ScheduledPaymentScalarWhereInput[]
    NOT?: ScheduledPaymentScalarWhereInput | ScheduledPaymentScalarWhereInput[]
    id?: IntFilter<"ScheduledPayment"> | number
    payment?: DecimalFilter<"ScheduledPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"ScheduledPayment"> | Date | string
    scheduledPaymentType?: EnumScheduledPaymentTypeFilter<"ScheduledPayment"> | $Enums.ScheduledPaymentType
    clientContractId?: IntFilter<"ScheduledPayment"> | number
    createdAt?: DateTimeFilter<"ScheduledPayment"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledPayment"> | Date | string
  }

  export type ActualPaymentUpsertWithWhereUniqueWithoutClientContractInput = {
    where: ActualPaymentWhereUniqueInput
    update: XOR<ActualPaymentUpdateWithoutClientContractInput, ActualPaymentUncheckedUpdateWithoutClientContractInput>
    create: XOR<ActualPaymentCreateWithoutClientContractInput, ActualPaymentUncheckedCreateWithoutClientContractInput>
  }

  export type ActualPaymentUpdateWithWhereUniqueWithoutClientContractInput = {
    where: ActualPaymentWhereUniqueInput
    data: XOR<ActualPaymentUpdateWithoutClientContractInput, ActualPaymentUncheckedUpdateWithoutClientContractInput>
  }

  export type ActualPaymentUpdateManyWithWhereWithoutClientContractInput = {
    where: ActualPaymentScalarWhereInput
    data: XOR<ActualPaymentUpdateManyMutationInput, ActualPaymentUncheckedUpdateManyWithoutClientContractInput>
  }

  export type ActualPaymentScalarWhereInput = {
    AND?: ActualPaymentScalarWhereInput | ActualPaymentScalarWhereInput[]
    OR?: ActualPaymentScalarWhereInput[]
    NOT?: ActualPaymentScalarWhereInput | ActualPaymentScalarWhereInput[]
    id?: IntFilter<"ActualPayment"> | number
    payment?: DecimalFilter<"ActualPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"ActualPayment"> | Date | string
    clientContractId?: IntFilter<"ActualPayment"> | number
    createdAt?: DateTimeFilter<"ActualPayment"> | Date | string
    updatedAt?: DateTimeFilter<"ActualPayment"> | Date | string
  }

  export type RealEstateAgencyActUpsertWithWhereUniqueWithoutClientContractInput = {
    where: RealEstateAgencyActWhereUniqueInput
    update: XOR<RealEstateAgencyActUpdateWithoutClientContractInput, RealEstateAgencyActUncheckedUpdateWithoutClientContractInput>
    create: XOR<RealEstateAgencyActCreateWithoutClientContractInput, RealEstateAgencyActUncheckedCreateWithoutClientContractInput>
  }

  export type RealEstateAgencyActUpdateWithWhereUniqueWithoutClientContractInput = {
    where: RealEstateAgencyActWhereUniqueInput
    data: XOR<RealEstateAgencyActUpdateWithoutClientContractInput, RealEstateAgencyActUncheckedUpdateWithoutClientContractInput>
  }

  export type RealEstateAgencyActUpdateManyWithWhereWithoutClientContractInput = {
    where: RealEstateAgencyActScalarWhereInput
    data: XOR<RealEstateAgencyActUpdateManyMutationInput, RealEstateAgencyActUncheckedUpdateManyWithoutClientContractInput>
  }

  export type RealEstateAgencyActScalarWhereInput = {
    AND?: RealEstateAgencyActScalarWhereInput | RealEstateAgencyActScalarWhereInput[]
    OR?: RealEstateAgencyActScalarWhereInput[]
    NOT?: RealEstateAgencyActScalarWhereInput | RealEstateAgencyActScalarWhereInput[]
    id?: IntFilter<"RealEstateAgencyAct"> | number
    number?: StringFilter<"RealEstateAgencyAct"> | string
    date?: DateTimeFilter<"RealEstateAgencyAct"> | Date | string
    amount?: DecimalFilter<"RealEstateAgencyAct"> | Decimal | DecimalJsLike | number | string
    retention?: DecimalNullableFilter<"RealEstateAgencyAct"> | Decimal | DecimalJsLike | number | string | null
    note?: StringNullableFilter<"RealEstateAgencyAct"> | string | null
    link?: StringNullableFilter<"RealEstateAgencyAct"> | string | null
    clientContractId?: IntFilter<"RealEstateAgencyAct"> | number
    agencyId?: IntFilter<"RealEstateAgencyAct"> | number
    agencyContractId?: IntFilter<"RealEstateAgencyAct"> | number
    createdAt?: DateTimeFilter<"RealEstateAgencyAct"> | Date | string
    updatedAt?: DateTimeFilter<"RealEstateAgencyAct"> | Date | string
  }

  export type AssignmentUpsertWithWhereUniqueWithoutClientContractInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutClientContractInput, AssignmentUncheckedUpdateWithoutClientContractInput>
    create: XOR<AssignmentCreateWithoutClientContractInput, AssignmentUncheckedCreateWithoutClientContractInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutClientContractInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutClientContractInput, AssignmentUncheckedUpdateWithoutClientContractInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutClientContractInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutClientContractInput>
  }

  export type ClientContractToClientUpsertWithWhereUniqueWithoutClientContractInput = {
    where: ClientContractToClientWhereUniqueInput
    update: XOR<ClientContractToClientUpdateWithoutClientContractInput, ClientContractToClientUncheckedUpdateWithoutClientContractInput>
    create: XOR<ClientContractToClientCreateWithoutClientContractInput, ClientContractToClientUncheckedCreateWithoutClientContractInput>
  }

  export type ClientContractToClientUpdateWithWhereUniqueWithoutClientContractInput = {
    where: ClientContractToClientWhereUniqueInput
    data: XOR<ClientContractToClientUpdateWithoutClientContractInput, ClientContractToClientUncheckedUpdateWithoutClientContractInput>
  }

  export type ClientContractToClientUpdateManyWithWhereWithoutClientContractInput = {
    where: ClientContractToClientScalarWhereInput
    data: XOR<ClientContractToClientUpdateManyMutationInput, ClientContractToClientUncheckedUpdateManyWithoutClientContractInput>
  }

  export type ClientContractToAgencyContractUpsertWithWhereUniqueWithoutClientContractInput = {
    where: ClientContractToAgencyContractWhereUniqueInput
    update: XOR<ClientContractToAgencyContractUpdateWithoutClientContractInput, ClientContractToAgencyContractUncheckedUpdateWithoutClientContractInput>
    create: XOR<ClientContractToAgencyContractCreateWithoutClientContractInput, ClientContractToAgencyContractUncheckedCreateWithoutClientContractInput>
  }

  export type ClientContractToAgencyContractUpdateWithWhereUniqueWithoutClientContractInput = {
    where: ClientContractToAgencyContractWhereUniqueInput
    data: XOR<ClientContractToAgencyContractUpdateWithoutClientContractInput, ClientContractToAgencyContractUncheckedUpdateWithoutClientContractInput>
  }

  export type ClientContractToAgencyContractUpdateManyWithWhereWithoutClientContractInput = {
    where: ClientContractToAgencyContractScalarWhereInput
    data: XOR<ClientContractToAgencyContractUpdateManyMutationInput, ClientContractToAgencyContractUncheckedUpdateManyWithoutClientContractInput>
  }

  export type ClientContractToAgencyContractScalarWhereInput = {
    AND?: ClientContractToAgencyContractScalarWhereInput | ClientContractToAgencyContractScalarWhereInput[]
    OR?: ClientContractToAgencyContractScalarWhereInput[]
    NOT?: ClientContractToAgencyContractScalarWhereInput | ClientContractToAgencyContractScalarWhereInput[]
    clientContractId?: IntFilter<"ClientContractToAgencyContract"> | number
    agencyContractId?: IntFilter<"ClientContractToAgencyContract"> | number
    createdAt?: DateTimeFilter<"ClientContractToAgencyContract"> | Date | string
    updatedAt?: DateTimeFilter<"ClientContractToAgencyContract"> | Date | string
  }

  export type ClientContractCreateWithoutDduClientContractPropertiesInput = {
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActCreateNestedOneWithoutClientContractInput
    dkpClientContractProperties?: DkpClientContractPropertiesCreateNestedOneWithoutClientContractInput
    product: ProductCreateNestedOneWithoutClientContractInput
    object: ObjectCreateNestedOneWithoutClientContractsInput
    realEstateAgent?: RealEstateAgentCreateNestedOneWithoutClientContractsInput
    manager?: UserCreateNestedOneWithoutClientContractsInput
    bank?: BankCreateNestedOneWithoutClientContractsInput
    subsidy?: SubsidyCreateNestedOneWithoutClientContractsInput
    scheduledPayments?: ScheduledPaymentCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractUncheckedCreateWithoutDduClientContractPropertiesInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    realEstateAgentId?: number | null
    managerId?: number | null
    bankId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActUncheckedCreateNestedOneWithoutClientContractInput
    scheduledPayments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentUncheckedCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractCreateOrConnectWithoutDduClientContractPropertiesInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutDduClientContractPropertiesInput, ClientContractUncheckedCreateWithoutDduClientContractPropertiesInput>
  }

  export type ClientContractUpsertWithoutDduClientContractPropertiesInput = {
    update: XOR<ClientContractUpdateWithoutDduClientContractPropertiesInput, ClientContractUncheckedUpdateWithoutDduClientContractPropertiesInput>
    create: XOR<ClientContractCreateWithoutDduClientContractPropertiesInput, ClientContractUncheckedCreateWithoutDduClientContractPropertiesInput>
    where?: ClientContractWhereInput
  }

  export type ClientContractUpdateToOneWithWhereWithoutDduClientContractPropertiesInput = {
    where?: ClientContractWhereInput
    data: XOR<ClientContractUpdateWithoutDduClientContractPropertiesInput, ClientContractUncheckedUpdateWithoutDduClientContractPropertiesInput>
  }

  export type ClientContractUpdateWithoutDduClientContractPropertiesInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneWithoutClientContractNestedInput
    dkpClientContractProperties?: DkpClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    product?: ProductUpdateOneRequiredWithoutClientContractNestedInput
    object?: ObjectUpdateOneRequiredWithoutClientContractsNestedInput
    realEstateAgent?: RealEstateAgentUpdateOneWithoutClientContractsNestedInput
    manager?: UserUpdateOneWithoutClientContractsNestedInput
    bank?: BankUpdateOneWithoutClientContractsNestedInput
    subsidy?: SubsidyUpdateOneWithoutClientContractsNestedInput
    scheduledPayments?: ScheduledPaymentUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutDduClientContractPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUncheckedUpdateOneWithoutClientContractNestedInput
    scheduledPayments?: ScheduledPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractCreateWithoutDkpClientContractPropertiesInput = {
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActCreateNestedOneWithoutClientContractInput
    dduClientContractProperties?: DduClientContractPropertiesCreateNestedOneWithoutClientContractInput
    product: ProductCreateNestedOneWithoutClientContractInput
    object: ObjectCreateNestedOneWithoutClientContractsInput
    realEstateAgent?: RealEstateAgentCreateNestedOneWithoutClientContractsInput
    manager?: UserCreateNestedOneWithoutClientContractsInput
    bank?: BankCreateNestedOneWithoutClientContractsInput
    subsidy?: SubsidyCreateNestedOneWithoutClientContractsInput
    scheduledPayments?: ScheduledPaymentCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractUncheckedCreateWithoutDkpClientContractPropertiesInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    realEstateAgentId?: number | null
    managerId?: number | null
    bankId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActUncheckedCreateNestedOneWithoutClientContractInput
    scheduledPayments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentUncheckedCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractCreateOrConnectWithoutDkpClientContractPropertiesInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutDkpClientContractPropertiesInput, ClientContractUncheckedCreateWithoutDkpClientContractPropertiesInput>
  }

  export type ClientContractUpsertWithoutDkpClientContractPropertiesInput = {
    update: XOR<ClientContractUpdateWithoutDkpClientContractPropertiesInput, ClientContractUncheckedUpdateWithoutDkpClientContractPropertiesInput>
    create: XOR<ClientContractCreateWithoutDkpClientContractPropertiesInput, ClientContractUncheckedCreateWithoutDkpClientContractPropertiesInput>
    where?: ClientContractWhereInput
  }

  export type ClientContractUpdateToOneWithWhereWithoutDkpClientContractPropertiesInput = {
    where?: ClientContractWhereInput
    data: XOR<ClientContractUpdateWithoutDkpClientContractPropertiesInput, ClientContractUncheckedUpdateWithoutDkpClientContractPropertiesInput>
  }

  export type ClientContractUpdateWithoutDkpClientContractPropertiesInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneWithoutClientContractNestedInput
    dduClientContractProperties?: DduClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    product?: ProductUpdateOneRequiredWithoutClientContractNestedInput
    object?: ObjectUpdateOneRequiredWithoutClientContractsNestedInput
    realEstateAgent?: RealEstateAgentUpdateOneWithoutClientContractsNestedInput
    manager?: UserUpdateOneWithoutClientContractsNestedInput
    bank?: BankUpdateOneWithoutClientContractsNestedInput
    subsidy?: SubsidyUpdateOneWithoutClientContractsNestedInput
    scheduledPayments?: ScheduledPaymentUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutDkpClientContractPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUncheckedUpdateOneWithoutClientContractNestedInput
    scheduledPayments?: ScheduledPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractCreateWithoutClientContractsToAgencyContractsInput = {
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActCreateNestedOneWithoutClientContractInput
    dduClientContractProperties?: DduClientContractPropertiesCreateNestedOneWithoutClientContractInput
    dkpClientContractProperties?: DkpClientContractPropertiesCreateNestedOneWithoutClientContractInput
    product: ProductCreateNestedOneWithoutClientContractInput
    object: ObjectCreateNestedOneWithoutClientContractsInput
    realEstateAgent?: RealEstateAgentCreateNestedOneWithoutClientContractsInput
    manager?: UserCreateNestedOneWithoutClientContractsInput
    bank?: BankCreateNestedOneWithoutClientContractsInput
    subsidy?: SubsidyCreateNestedOneWithoutClientContractsInput
    scheduledPayments?: ScheduledPaymentCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractUncheckedCreateWithoutClientContractsToAgencyContractsInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    realEstateAgentId?: number | null
    managerId?: number | null
    bankId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActUncheckedCreateNestedOneWithoutClientContractInput
    scheduledPayments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentUncheckedCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractCreateOrConnectWithoutClientContractsToAgencyContractsInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutClientContractsToAgencyContractsInput, ClientContractUncheckedCreateWithoutClientContractsToAgencyContractsInput>
  }

  export type AgencyContractCreateWithoutClientContractsToAgencyContractsInput = {
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responsibleUser?: UserCreateNestedOneWithoutAgencyContractsInput
    entity: EntityCreateNestedOneWithoutAgencyContractsInput
    object: ObjectCreateNestedOneWithoutAgencyContractsInput
    agency: AgencyCreateNestedOneWithoutAgencyContractsInput
    agencyContractSignatory?: AgencyContractSignatoryCreateNestedOneWithoutAgencyContractsInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput
    realEstateAgencyAct?: RealEstateAgencyActCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractUncheckedCreateWithoutClientContractsToAgencyContractsInput = {
    id?: number
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    responsibleUserId?: number | null
    entityId: number
    objectId: number
    agencyId: number
    agencyContractSignatoryId?: number | null
    realEstateAgencyContractPropertiesId?: number | null
    mipAgencyContractPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    realEstateAgencyAct?: RealEstateAgencyActUncheckedCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractCreateOrConnectWithoutClientContractsToAgencyContractsInput = {
    where: AgencyContractWhereUniqueInput
    create: XOR<AgencyContractCreateWithoutClientContractsToAgencyContractsInput, AgencyContractUncheckedCreateWithoutClientContractsToAgencyContractsInput>
  }

  export type ClientContractUpsertWithoutClientContractsToAgencyContractsInput = {
    update: XOR<ClientContractUpdateWithoutClientContractsToAgencyContractsInput, ClientContractUncheckedUpdateWithoutClientContractsToAgencyContractsInput>
    create: XOR<ClientContractCreateWithoutClientContractsToAgencyContractsInput, ClientContractUncheckedCreateWithoutClientContractsToAgencyContractsInput>
    where?: ClientContractWhereInput
  }

  export type ClientContractUpdateToOneWithWhereWithoutClientContractsToAgencyContractsInput = {
    where?: ClientContractWhereInput
    data: XOR<ClientContractUpdateWithoutClientContractsToAgencyContractsInput, ClientContractUncheckedUpdateWithoutClientContractsToAgencyContractsInput>
  }

  export type ClientContractUpdateWithoutClientContractsToAgencyContractsInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneWithoutClientContractNestedInput
    dduClientContractProperties?: DduClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    dkpClientContractProperties?: DkpClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    product?: ProductUpdateOneRequiredWithoutClientContractNestedInput
    object?: ObjectUpdateOneRequiredWithoutClientContractsNestedInput
    realEstateAgent?: RealEstateAgentUpdateOneWithoutClientContractsNestedInput
    manager?: UserUpdateOneWithoutClientContractsNestedInput
    bank?: BankUpdateOneWithoutClientContractsNestedInput
    subsidy?: SubsidyUpdateOneWithoutClientContractsNestedInput
    scheduledPayments?: ScheduledPaymentUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutClientContractsToAgencyContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUncheckedUpdateOneWithoutClientContractNestedInput
    scheduledPayments?: ScheduledPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientContractNestedInput
  }

  export type AgencyContractUpsertWithoutClientContractsToAgencyContractsInput = {
    update: XOR<AgencyContractUpdateWithoutClientContractsToAgencyContractsInput, AgencyContractUncheckedUpdateWithoutClientContractsToAgencyContractsInput>
    create: XOR<AgencyContractCreateWithoutClientContractsToAgencyContractsInput, AgencyContractUncheckedCreateWithoutClientContractsToAgencyContractsInput>
    where?: AgencyContractWhereInput
  }

  export type AgencyContractUpdateToOneWithWhereWithoutClientContractsToAgencyContractsInput = {
    where?: AgencyContractWhereInput
    data: XOR<AgencyContractUpdateWithoutClientContractsToAgencyContractsInput, AgencyContractUncheckedUpdateWithoutClientContractsToAgencyContractsInput>
  }

  export type AgencyContractUpdateWithoutClientContractsToAgencyContractsInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUser?: UserUpdateOneWithoutAgencyContractsNestedInput
    entity?: EntityUpdateOneRequiredWithoutAgencyContractsNestedInput
    object?: ObjectUpdateOneRequiredWithoutAgencyContractsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgencyContractsNestedInput
    agencyContractSignatory?: AgencyContractSignatoryUpdateOneWithoutAgencyContractsNestedInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput
    realEstateAgencyAct?: RealEstateAgencyActUpdateManyWithoutAgencyContractNestedInput
  }

  export type AgencyContractUncheckedUpdateWithoutClientContractsToAgencyContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    entityId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    agencyContractSignatoryId?: NullableIntFieldUpdateOperationsInput | number | null
    realEstateAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    mipAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstateAgencyAct?: RealEstateAgencyActUncheckedUpdateManyWithoutAgencyContractNestedInput
  }

  export type ClientCreateWithoutClientContractsToClientsInput = {
    fullName: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    clientCategory: $Enums.ClientCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    clientIndividualProperties?: ClientIndividualPropertiesCreateNestedOneWithoutClientInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesCreateNestedOneWithoutClientInput
    clientEntityProperties?: ClientEntityPropertiesCreateNestedOneWithoutClientInput
    assignments?: AssignmentCreateNestedManyWithoutClientInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClientInput
    representatives?: RepresentativeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutClientContractsToClientsInput = {
    id?: number
    fullName: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    clientCategory: $Enums.ClientCategory
    clientIndividualPropertiesId?: number | null
    clientIndividualMinorPropertiesId?: number | null
    clientEntityPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClientInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutClientContractsToClientsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutClientContractsToClientsInput, ClientUncheckedCreateWithoutClientContractsToClientsInput>
  }

  export type ClientContractCreateWithoutClientContractsToClientsInput = {
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActCreateNestedOneWithoutClientContractInput
    dduClientContractProperties?: DduClientContractPropertiesCreateNestedOneWithoutClientContractInput
    dkpClientContractProperties?: DkpClientContractPropertiesCreateNestedOneWithoutClientContractInput
    product: ProductCreateNestedOneWithoutClientContractInput
    object: ObjectCreateNestedOneWithoutClientContractsInput
    realEstateAgent?: RealEstateAgentCreateNestedOneWithoutClientContractsInput
    manager?: UserCreateNestedOneWithoutClientContractsInput
    bank?: BankCreateNestedOneWithoutClientContractsInput
    subsidy?: SubsidyCreateNestedOneWithoutClientContractsInput
    scheduledPayments?: ScheduledPaymentCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractUncheckedCreateWithoutClientContractsToClientsInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    realEstateAgentId?: number | null
    managerId?: number | null
    bankId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActUncheckedCreateNestedOneWithoutClientContractInput
    scheduledPayments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentUncheckedCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractCreateOrConnectWithoutClientContractsToClientsInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutClientContractsToClientsInput, ClientContractUncheckedCreateWithoutClientContractsToClientsInput>
  }

  export type ClientUpsertWithoutClientContractsToClientsInput = {
    update: XOR<ClientUpdateWithoutClientContractsToClientsInput, ClientUncheckedUpdateWithoutClientContractsToClientsInput>
    create: XOR<ClientCreateWithoutClientContractsToClientsInput, ClientUncheckedCreateWithoutClientContractsToClientsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutClientContractsToClientsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutClientContractsToClientsInput, ClientUncheckedUpdateWithoutClientContractsToClientsInput>
  }

  export type ClientUpdateWithoutClientContractsToClientsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    clientCategory?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientIndividualProperties?: ClientIndividualPropertiesUpdateOneWithoutClientNestedInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesUpdateOneWithoutClientNestedInput
    clientEntityProperties?: ClientEntityPropertiesUpdateOneWithoutClientNestedInput
    assignments?: AssignmentUpdateManyWithoutClientNestedInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUpdateManyWithoutClientNestedInput
    representatives?: RepresentativeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutClientContractsToClientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    clientCategory?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    clientIndividualPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    clientIndividualMinorPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    clientEntityPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutClientNestedInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientContractUpsertWithoutClientContractsToClientsInput = {
    update: XOR<ClientContractUpdateWithoutClientContractsToClientsInput, ClientContractUncheckedUpdateWithoutClientContractsToClientsInput>
    create: XOR<ClientContractCreateWithoutClientContractsToClientsInput, ClientContractUncheckedCreateWithoutClientContractsToClientsInput>
    where?: ClientContractWhereInput
  }

  export type ClientContractUpdateToOneWithWhereWithoutClientContractsToClientsInput = {
    where?: ClientContractWhereInput
    data: XOR<ClientContractUpdateWithoutClientContractsToClientsInput, ClientContractUncheckedUpdateWithoutClientContractsToClientsInput>
  }

  export type ClientContractUpdateWithoutClientContractsToClientsInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneWithoutClientContractNestedInput
    dduClientContractProperties?: DduClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    dkpClientContractProperties?: DkpClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    product?: ProductUpdateOneRequiredWithoutClientContractNestedInput
    object?: ObjectUpdateOneRequiredWithoutClientContractsNestedInput
    realEstateAgent?: RealEstateAgentUpdateOneWithoutClientContractsNestedInput
    manager?: UserUpdateOneWithoutClientContractsNestedInput
    bank?: BankUpdateOneWithoutClientContractsNestedInput
    subsidy?: SubsidyUpdateOneWithoutClientContractsNestedInput
    scheduledPayments?: ScheduledPaymentUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutClientContractsToClientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUncheckedUpdateOneWithoutClientContractNestedInput
    scheduledPayments?: ScheduledPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractCreateWithoutScheduledPaymentsInput = {
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActCreateNestedOneWithoutClientContractInput
    dduClientContractProperties?: DduClientContractPropertiesCreateNestedOneWithoutClientContractInput
    dkpClientContractProperties?: DkpClientContractPropertiesCreateNestedOneWithoutClientContractInput
    product: ProductCreateNestedOneWithoutClientContractInput
    object: ObjectCreateNestedOneWithoutClientContractsInput
    realEstateAgent?: RealEstateAgentCreateNestedOneWithoutClientContractsInput
    manager?: UserCreateNestedOneWithoutClientContractsInput
    bank?: BankCreateNestedOneWithoutClientContractsInput
    subsidy?: SubsidyCreateNestedOneWithoutClientContractsInput
    actualPayments?: ActualPaymentCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractUncheckedCreateWithoutScheduledPaymentsInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    realEstateAgentId?: number | null
    managerId?: number | null
    bankId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActUncheckedCreateNestedOneWithoutClientContractInput
    actualPayments?: ActualPaymentUncheckedCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractCreateOrConnectWithoutScheduledPaymentsInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutScheduledPaymentsInput, ClientContractUncheckedCreateWithoutScheduledPaymentsInput>
  }

  export type ClientContractUpsertWithoutScheduledPaymentsInput = {
    update: XOR<ClientContractUpdateWithoutScheduledPaymentsInput, ClientContractUncheckedUpdateWithoutScheduledPaymentsInput>
    create: XOR<ClientContractCreateWithoutScheduledPaymentsInput, ClientContractUncheckedCreateWithoutScheduledPaymentsInput>
    where?: ClientContractWhereInput
  }

  export type ClientContractUpdateToOneWithWhereWithoutScheduledPaymentsInput = {
    where?: ClientContractWhereInput
    data: XOR<ClientContractUpdateWithoutScheduledPaymentsInput, ClientContractUncheckedUpdateWithoutScheduledPaymentsInput>
  }

  export type ClientContractUpdateWithoutScheduledPaymentsInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneWithoutClientContractNestedInput
    dduClientContractProperties?: DduClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    dkpClientContractProperties?: DkpClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    product?: ProductUpdateOneRequiredWithoutClientContractNestedInput
    object?: ObjectUpdateOneRequiredWithoutClientContractsNestedInput
    realEstateAgent?: RealEstateAgentUpdateOneWithoutClientContractsNestedInput
    manager?: UserUpdateOneWithoutClientContractsNestedInput
    bank?: BankUpdateOneWithoutClientContractsNestedInput
    subsidy?: SubsidyUpdateOneWithoutClientContractsNestedInput
    actualPayments?: ActualPaymentUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutScheduledPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUncheckedUpdateOneWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractCreateWithoutActualPaymentsInput = {
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActCreateNestedOneWithoutClientContractInput
    dduClientContractProperties?: DduClientContractPropertiesCreateNestedOneWithoutClientContractInput
    dkpClientContractProperties?: DkpClientContractPropertiesCreateNestedOneWithoutClientContractInput
    product: ProductCreateNestedOneWithoutClientContractInput
    object: ObjectCreateNestedOneWithoutClientContractsInput
    realEstateAgent?: RealEstateAgentCreateNestedOneWithoutClientContractsInput
    manager?: UserCreateNestedOneWithoutClientContractsInput
    bank?: BankCreateNestedOneWithoutClientContractsInput
    subsidy?: SubsidyCreateNestedOneWithoutClientContractsInput
    scheduledPayments?: ScheduledPaymentCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractUncheckedCreateWithoutActualPaymentsInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    realEstateAgentId?: number | null
    managerId?: number | null
    bankId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActUncheckedCreateNestedOneWithoutClientContractInput
    scheduledPayments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractCreateOrConnectWithoutActualPaymentsInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutActualPaymentsInput, ClientContractUncheckedCreateWithoutActualPaymentsInput>
  }

  export type ClientContractUpsertWithoutActualPaymentsInput = {
    update: XOR<ClientContractUpdateWithoutActualPaymentsInput, ClientContractUncheckedUpdateWithoutActualPaymentsInput>
    create: XOR<ClientContractCreateWithoutActualPaymentsInput, ClientContractUncheckedCreateWithoutActualPaymentsInput>
    where?: ClientContractWhereInput
  }

  export type ClientContractUpdateToOneWithWhereWithoutActualPaymentsInput = {
    where?: ClientContractWhereInput
    data: XOR<ClientContractUpdateWithoutActualPaymentsInput, ClientContractUncheckedUpdateWithoutActualPaymentsInput>
  }

  export type ClientContractUpdateWithoutActualPaymentsInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneWithoutClientContractNestedInput
    dduClientContractProperties?: DduClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    dkpClientContractProperties?: DkpClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    product?: ProductUpdateOneRequiredWithoutClientContractNestedInput
    object?: ObjectUpdateOneRequiredWithoutClientContractsNestedInput
    realEstateAgent?: RealEstateAgentUpdateOneWithoutClientContractsNestedInput
    manager?: UserUpdateOneWithoutClientContractsNestedInput
    bank?: BankUpdateOneWithoutClientContractsNestedInput
    subsidy?: SubsidyUpdateOneWithoutClientContractsNestedInput
    scheduledPayments?: ScheduledPaymentUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutActualPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUncheckedUpdateOneWithoutClientContractNestedInput
    scheduledPayments?: ScheduledPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClientContractNestedInput
  }

  export type EntityCreateWithoutObjectsInput = {
    commonDbEntitiesId: number
    commonContractorId?: number | null
    name: string
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractCreateNestedManyWithoutEntityInput
    entityForbiddenWebsites?: EntityForbiddenWebsiteCreateNestedManyWithoutEntityInput
    entityForbiddenBrands?: EntityForbiddenBrandCreateNestedManyWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutObjectsInput = {
    id?: number
    commonDbEntitiesId: number
    commonContractorId?: number | null
    name: string
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractUncheckedCreateNestedManyWithoutEntityInput
    entityForbiddenWebsites?: EntityForbiddenWebsiteUncheckedCreateNestedManyWithoutEntityInput
    entityForbiddenBrands?: EntityForbiddenBrandUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutObjectsInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutObjectsInput, EntityUncheckedCreateWithoutObjectsInput>
  }

  export type ProductCreateWithoutObjectInput = {
    pricingProductsId: number
    number: string
    productCategory: $Enums.ProductCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActCreateNestedOneWithoutProductInput
    clientContract?: ClientContractCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutObjectInput = {
    id?: number
    pricingProductsId: number
    number: string
    productCategory: $Enums.ProductCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActUncheckedCreateNestedOneWithoutProductInput
    clientContract?: ClientContractUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutObjectInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutObjectInput, ProductUncheckedCreateWithoutObjectInput>
  }

  export type ProductCreateManyObjectInputEnvelope = {
    data: ProductCreateManyObjectInput | ProductCreateManyObjectInput[]
    skipDuplicates?: boolean
  }

  export type ClientContractCreateWithoutObjectInput = {
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActCreateNestedOneWithoutClientContractInput
    dduClientContractProperties?: DduClientContractPropertiesCreateNestedOneWithoutClientContractInput
    dkpClientContractProperties?: DkpClientContractPropertiesCreateNestedOneWithoutClientContractInput
    product: ProductCreateNestedOneWithoutClientContractInput
    realEstateAgent?: RealEstateAgentCreateNestedOneWithoutClientContractsInput
    manager?: UserCreateNestedOneWithoutClientContractsInput
    bank?: BankCreateNestedOneWithoutClientContractsInput
    subsidy?: SubsidyCreateNestedOneWithoutClientContractsInput
    scheduledPayments?: ScheduledPaymentCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractUncheckedCreateWithoutObjectInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    realEstateAgentId?: number | null
    managerId?: number | null
    bankId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActUncheckedCreateNestedOneWithoutClientContractInput
    scheduledPayments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentUncheckedCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractCreateOrConnectWithoutObjectInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutObjectInput, ClientContractUncheckedCreateWithoutObjectInput>
  }

  export type ClientContractCreateManyObjectInputEnvelope = {
    data: ClientContractCreateManyObjectInput | ClientContractCreateManyObjectInput[]
    skipDuplicates?: boolean
  }

  export type AgencyContractCreateWithoutObjectInput = {
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responsibleUser?: UserCreateNestedOneWithoutAgencyContractsInput
    entity: EntityCreateNestedOneWithoutAgencyContractsInput
    agency: AgencyCreateNestedOneWithoutAgencyContractsInput
    agencyContractSignatory?: AgencyContractSignatoryCreateNestedOneWithoutAgencyContractsInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput
    realEstateAgencyAct?: RealEstateAgencyActCreateNestedManyWithoutAgencyContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractUncheckedCreateWithoutObjectInput = {
    id?: number
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    responsibleUserId?: number | null
    entityId: number
    agencyId: number
    agencyContractSignatoryId?: number | null
    realEstateAgencyContractPropertiesId?: number | null
    mipAgencyContractPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    realEstateAgencyAct?: RealEstateAgencyActUncheckedCreateNestedManyWithoutAgencyContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractCreateOrConnectWithoutObjectInput = {
    where: AgencyContractWhereUniqueInput
    create: XOR<AgencyContractCreateWithoutObjectInput, AgencyContractUncheckedCreateWithoutObjectInput>
  }

  export type AgencyContractCreateManyObjectInputEnvelope = {
    data: AgencyContractCreateManyObjectInput | AgencyContractCreateManyObjectInput[]
    skipDuplicates?: boolean
  }

  export type TransferActCreateWithoutObjectInput = {
    number: string
    date: Date | string
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract: ClientContractCreateNestedOneWithoutTransferActInput
    product: ProductCreateNestedOneWithoutTransferActInput
    transferActsToRepresentatives?: TransferActToRepresentativeCreateNestedManyWithoutTransferActInput
  }

  export type TransferActUncheckedCreateWithoutObjectInput = {
    id?: number
    number: string
    date: Date | string
    link?: string | null
    clientContractId: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transferActsToRepresentatives?: TransferActToRepresentativeUncheckedCreateNestedManyWithoutTransferActInput
  }

  export type TransferActCreateOrConnectWithoutObjectInput = {
    where: TransferActWhereUniqueInput
    create: XOR<TransferActCreateWithoutObjectInput, TransferActUncheckedCreateWithoutObjectInput>
  }

  export type TransferActCreateManyObjectInputEnvelope = {
    data: TransferActCreateManyObjectInput | TransferActCreateManyObjectInput[]
    skipDuplicates?: boolean
  }

  export type EntityUpsertWithoutObjectsInput = {
    update: XOR<EntityUpdateWithoutObjectsInput, EntityUncheckedUpdateWithoutObjectsInput>
    create: XOR<EntityCreateWithoutObjectsInput, EntityUncheckedCreateWithoutObjectsInput>
    where?: EntityWhereInput
  }

  export type EntityUpdateToOneWithWhereWithoutObjectsInput = {
    where?: EntityWhereInput
    data: XOR<EntityUpdateWithoutObjectsInput, EntityUncheckedUpdateWithoutObjectsInput>
  }

  export type EntityUpdateWithoutObjectsInput = {
    commonDbEntitiesId?: IntFieldUpdateOperationsInput | number
    commonContractorId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUpdateManyWithoutEntityNestedInput
    entityForbiddenWebsites?: EntityForbiddenWebsiteUpdateManyWithoutEntityNestedInput
    entityForbiddenBrands?: EntityForbiddenBrandUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutObjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbEntitiesId?: IntFieldUpdateOperationsInput | number
    commonContractorId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUncheckedUpdateManyWithoutEntityNestedInput
    entityForbiddenWebsites?: EntityForbiddenWebsiteUncheckedUpdateManyWithoutEntityNestedInput
    entityForbiddenBrands?: EntityForbiddenBrandUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutObjectInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutObjectInput, ProductUncheckedUpdateWithoutObjectInput>
    create: XOR<ProductCreateWithoutObjectInput, ProductUncheckedCreateWithoutObjectInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutObjectInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutObjectInput, ProductUncheckedUpdateWithoutObjectInput>
  }

  export type ProductUpdateManyWithWhereWithoutObjectInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutObjectInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    pricingProductsId?: IntFilter<"Product"> | number
    number?: StringFilter<"Product"> | string
    productCategory?: EnumProductCategoryFilter<"Product"> | $Enums.ProductCategory
    objectId?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type ClientContractUpsertWithWhereUniqueWithoutObjectInput = {
    where: ClientContractWhereUniqueInput
    update: XOR<ClientContractUpdateWithoutObjectInput, ClientContractUncheckedUpdateWithoutObjectInput>
    create: XOR<ClientContractCreateWithoutObjectInput, ClientContractUncheckedCreateWithoutObjectInput>
  }

  export type ClientContractUpdateWithWhereUniqueWithoutObjectInput = {
    where: ClientContractWhereUniqueInput
    data: XOR<ClientContractUpdateWithoutObjectInput, ClientContractUncheckedUpdateWithoutObjectInput>
  }

  export type ClientContractUpdateManyWithWhereWithoutObjectInput = {
    where: ClientContractScalarWhereInput
    data: XOR<ClientContractUpdateManyMutationInput, ClientContractUncheckedUpdateManyWithoutObjectInput>
  }

  export type AgencyContractUpsertWithWhereUniqueWithoutObjectInput = {
    where: AgencyContractWhereUniqueInput
    update: XOR<AgencyContractUpdateWithoutObjectInput, AgencyContractUncheckedUpdateWithoutObjectInput>
    create: XOR<AgencyContractCreateWithoutObjectInput, AgencyContractUncheckedCreateWithoutObjectInput>
  }

  export type AgencyContractUpdateWithWhereUniqueWithoutObjectInput = {
    where: AgencyContractWhereUniqueInput
    data: XOR<AgencyContractUpdateWithoutObjectInput, AgencyContractUncheckedUpdateWithoutObjectInput>
  }

  export type AgencyContractUpdateManyWithWhereWithoutObjectInput = {
    where: AgencyContractScalarWhereInput
    data: XOR<AgencyContractUpdateManyMutationInput, AgencyContractUncheckedUpdateManyWithoutObjectInput>
  }

  export type TransferActUpsertWithWhereUniqueWithoutObjectInput = {
    where: TransferActWhereUniqueInput
    update: XOR<TransferActUpdateWithoutObjectInput, TransferActUncheckedUpdateWithoutObjectInput>
    create: XOR<TransferActCreateWithoutObjectInput, TransferActUncheckedCreateWithoutObjectInput>
  }

  export type TransferActUpdateWithWhereUniqueWithoutObjectInput = {
    where: TransferActWhereUniqueInput
    data: XOR<TransferActUpdateWithoutObjectInput, TransferActUncheckedUpdateWithoutObjectInput>
  }

  export type TransferActUpdateManyWithWhereWithoutObjectInput = {
    where: TransferActScalarWhereInput
    data: XOR<TransferActUpdateManyMutationInput, TransferActUncheckedUpdateManyWithoutObjectInput>
  }

  export type TransferActScalarWhereInput = {
    AND?: TransferActScalarWhereInput | TransferActScalarWhereInput[]
    OR?: TransferActScalarWhereInput[]
    NOT?: TransferActScalarWhereInput | TransferActScalarWhereInput[]
    id?: IntFilter<"TransferAct"> | number
    number?: StringFilter<"TransferAct"> | string
    date?: DateTimeFilter<"TransferAct"> | Date | string
    link?: StringNullableFilter<"TransferAct"> | string | null
    clientContractId?: IntFilter<"TransferAct"> | number
    objectId?: IntFilter<"TransferAct"> | number
    productId?: IntFilter<"TransferAct"> | number
    createdAt?: DateTimeFilter<"TransferAct"> | Date | string
    updatedAt?: DateTimeFilter<"TransferAct"> | Date | string
  }

  export type TransferActCreateWithoutProductInput = {
    number: string
    date: Date | string
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract: ClientContractCreateNestedOneWithoutTransferActInput
    object: ObjectCreateNestedOneWithoutTransferActsInput
    transferActsToRepresentatives?: TransferActToRepresentativeCreateNestedManyWithoutTransferActInput
  }

  export type TransferActUncheckedCreateWithoutProductInput = {
    id?: number
    number: string
    date: Date | string
    link?: string | null
    clientContractId: number
    objectId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transferActsToRepresentatives?: TransferActToRepresentativeUncheckedCreateNestedManyWithoutTransferActInput
  }

  export type TransferActCreateOrConnectWithoutProductInput = {
    where: TransferActWhereUniqueInput
    create: XOR<TransferActCreateWithoutProductInput, TransferActUncheckedCreateWithoutProductInput>
  }

  export type ClientContractCreateWithoutProductInput = {
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActCreateNestedOneWithoutClientContractInput
    dduClientContractProperties?: DduClientContractPropertiesCreateNestedOneWithoutClientContractInput
    dkpClientContractProperties?: DkpClientContractPropertiesCreateNestedOneWithoutClientContractInput
    object: ObjectCreateNestedOneWithoutClientContractsInput
    realEstateAgent?: RealEstateAgentCreateNestedOneWithoutClientContractsInput
    manager?: UserCreateNestedOneWithoutClientContractsInput
    bank?: BankCreateNestedOneWithoutClientContractsInput
    subsidy?: SubsidyCreateNestedOneWithoutClientContractsInput
    scheduledPayments?: ScheduledPaymentCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractUncheckedCreateWithoutProductInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    objectId: number
    realEstateAgentId?: number | null
    managerId?: number | null
    bankId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActUncheckedCreateNestedOneWithoutClientContractInput
    scheduledPayments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentUncheckedCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractCreateOrConnectWithoutProductInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutProductInput, ClientContractUncheckedCreateWithoutProductInput>
  }

  export type ObjectCreateWithoutProductsInput = {
    commonDbObjectsId: number
    name: string
    dateIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entity: EntityCreateNestedOneWithoutObjectsInput
    clientContracts?: ClientContractCreateNestedManyWithoutObjectInput
    agencyContracts?: AgencyContractCreateNestedManyWithoutObjectInput
    transferActs?: TransferActCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutProductsInput = {
    id?: number
    commonDbObjectsId: number
    name: string
    dateIn?: Date | string | null
    entityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContracts?: ClientContractUncheckedCreateNestedManyWithoutObjectInput
    agencyContracts?: AgencyContractUncheckedCreateNestedManyWithoutObjectInput
    transferActs?: TransferActUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutProductsInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutProductsInput, ObjectUncheckedCreateWithoutProductsInput>
  }

  export type TransferActUpsertWithoutProductInput = {
    update: XOR<TransferActUpdateWithoutProductInput, TransferActUncheckedUpdateWithoutProductInput>
    create: XOR<TransferActCreateWithoutProductInput, TransferActUncheckedCreateWithoutProductInput>
    where?: TransferActWhereInput
  }

  export type TransferActUpdateToOneWithWhereWithoutProductInput = {
    where?: TransferActWhereInput
    data: XOR<TransferActUpdateWithoutProductInput, TransferActUncheckedUpdateWithoutProductInput>
  }

  export type TransferActUpdateWithoutProductInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUpdateOneRequiredWithoutTransferActNestedInput
    object?: ObjectUpdateOneRequiredWithoutTransferActsNestedInput
    transferActsToRepresentatives?: TransferActToRepresentativeUpdateManyWithoutTransferActNestedInput
  }

  export type TransferActUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    clientContractId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferActsToRepresentatives?: TransferActToRepresentativeUncheckedUpdateManyWithoutTransferActNestedInput
  }

  export type ClientContractUpsertWithoutProductInput = {
    update: XOR<ClientContractUpdateWithoutProductInput, ClientContractUncheckedUpdateWithoutProductInput>
    create: XOR<ClientContractCreateWithoutProductInput, ClientContractUncheckedCreateWithoutProductInput>
    where?: ClientContractWhereInput
  }

  export type ClientContractUpdateToOneWithWhereWithoutProductInput = {
    where?: ClientContractWhereInput
    data: XOR<ClientContractUpdateWithoutProductInput, ClientContractUncheckedUpdateWithoutProductInput>
  }

  export type ClientContractUpdateWithoutProductInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneWithoutClientContractNestedInput
    dduClientContractProperties?: DduClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    dkpClientContractProperties?: DkpClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    object?: ObjectUpdateOneRequiredWithoutClientContractsNestedInput
    realEstateAgent?: RealEstateAgentUpdateOneWithoutClientContractsNestedInput
    manager?: UserUpdateOneWithoutClientContractsNestedInput
    bank?: BankUpdateOneWithoutClientContractsNestedInput
    subsidy?: SubsidyUpdateOneWithoutClientContractsNestedInput
    scheduledPayments?: ScheduledPaymentUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    objectId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUncheckedUpdateOneWithoutClientContractNestedInput
    scheduledPayments?: ScheduledPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClientContractNestedInput
  }

  export type ObjectUpsertWithoutProductsInput = {
    update: XOR<ObjectUpdateWithoutProductsInput, ObjectUncheckedUpdateWithoutProductsInput>
    create: XOR<ObjectCreateWithoutProductsInput, ObjectUncheckedCreateWithoutProductsInput>
    where?: ObjectWhereInput
  }

  export type ObjectUpdateToOneWithWhereWithoutProductsInput = {
    where?: ObjectWhereInput
    data: XOR<ObjectUpdateWithoutProductsInput, ObjectUncheckedUpdateWithoutProductsInput>
  }

  export type ObjectUpdateWithoutProductsInput = {
    commonDbObjectsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: EntityUpdateOneRequiredWithoutObjectsNestedInput
    clientContracts?: ClientContractUpdateManyWithoutObjectNestedInput
    agencyContracts?: AgencyContractUpdateManyWithoutObjectNestedInput
    transferActs?: TransferActUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbObjectsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContracts?: ClientContractUncheckedUpdateManyWithoutObjectNestedInput
    agencyContracts?: AgencyContractUncheckedUpdateManyWithoutObjectNestedInput
    transferActs?: TransferActUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type AgencyContractCreateWithoutAgencyInput = {
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responsibleUser?: UserCreateNestedOneWithoutAgencyContractsInput
    entity: EntityCreateNestedOneWithoutAgencyContractsInput
    object: ObjectCreateNestedOneWithoutAgencyContractsInput
    agencyContractSignatory?: AgencyContractSignatoryCreateNestedOneWithoutAgencyContractsInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput
    realEstateAgencyAct?: RealEstateAgencyActCreateNestedManyWithoutAgencyContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractUncheckedCreateWithoutAgencyInput = {
    id?: number
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    responsibleUserId?: number | null
    entityId: number
    objectId: number
    agencyContractSignatoryId?: number | null
    realEstateAgencyContractPropertiesId?: number | null
    mipAgencyContractPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    realEstateAgencyAct?: RealEstateAgencyActUncheckedCreateNestedManyWithoutAgencyContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractCreateOrConnectWithoutAgencyInput = {
    where: AgencyContractWhereUniqueInput
    create: XOR<AgencyContractCreateWithoutAgencyInput, AgencyContractUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyContractCreateManyAgencyInputEnvelope = {
    data: AgencyContractCreateManyAgencyInput | AgencyContractCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type AgencyContractSignatoryCreateWithoutAgencyInput = {
    fullName: string
    basedOn?: string | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractCreateNestedManyWithoutAgencyContractSignatoryInput
  }

  export type AgencyContractSignatoryUncheckedCreateWithoutAgencyInput = {
    id?: number
    fullName: string
    basedOn?: string | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractUncheckedCreateNestedManyWithoutAgencyContractSignatoryInput
  }

  export type AgencyContractSignatoryCreateOrConnectWithoutAgencyInput = {
    where: AgencyContractSignatoryWhereUniqueInput
    create: XOR<AgencyContractSignatoryCreateWithoutAgencyInput, AgencyContractSignatoryUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyContractSignatoryCreateManyAgencyInputEnvelope = {
    data: AgencyContractSignatoryCreateManyAgencyInput | AgencyContractSignatoryCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type RealEstateAgencyActCreateWithoutAgencyInput = {
    number: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    retention?: Decimal | DecimalJsLike | number | string | null
    note?: string | null
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract: ClientContractCreateNestedOneWithoutRealEstateAgencyActsInput
    agencyContract: AgencyContractCreateNestedOneWithoutRealEstateAgencyActInput
  }

  export type RealEstateAgencyActUncheckedCreateWithoutAgencyInput = {
    id?: number
    number: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    retention?: Decimal | DecimalJsLike | number | string | null
    note?: string | null
    link?: string | null
    clientContractId: number
    agencyContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RealEstateAgencyActCreateOrConnectWithoutAgencyInput = {
    where: RealEstateAgencyActWhereUniqueInput
    create: XOR<RealEstateAgencyActCreateWithoutAgencyInput, RealEstateAgencyActUncheckedCreateWithoutAgencyInput>
  }

  export type RealEstateAgencyActCreateManyAgencyInputEnvelope = {
    data: RealEstateAgencyActCreateManyAgencyInput | RealEstateAgencyActCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type AgencyToRealEstateAgentCreateWithoutAgencyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    realEstateAgent: RealEstateAgentCreateNestedOneWithoutAgenciesToRealEstateAgentsInput
  }

  export type AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput = {
    realEstateAgentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyToRealEstateAgentCreateOrConnectWithoutAgencyInput = {
    where: AgencyToRealEstateAgentWhereUniqueInput
    create: XOR<AgencyToRealEstateAgentCreateWithoutAgencyInput, AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyToRealEstateAgentCreateManyAgencyInputEnvelope = {
    data: AgencyToRealEstateAgentCreateManyAgencyInput | AgencyToRealEstateAgentCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type AgencyContractUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AgencyContractWhereUniqueInput
    update: XOR<AgencyContractUpdateWithoutAgencyInput, AgencyContractUncheckedUpdateWithoutAgencyInput>
    create: XOR<AgencyContractCreateWithoutAgencyInput, AgencyContractUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyContractUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AgencyContractWhereUniqueInput
    data: XOR<AgencyContractUpdateWithoutAgencyInput, AgencyContractUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencyContractUpdateManyWithWhereWithoutAgencyInput = {
    where: AgencyContractScalarWhereInput
    data: XOR<AgencyContractUpdateManyMutationInput, AgencyContractUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AgencyContractSignatoryUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AgencyContractSignatoryWhereUniqueInput
    update: XOR<AgencyContractSignatoryUpdateWithoutAgencyInput, AgencyContractSignatoryUncheckedUpdateWithoutAgencyInput>
    create: XOR<AgencyContractSignatoryCreateWithoutAgencyInput, AgencyContractSignatoryUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyContractSignatoryUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AgencyContractSignatoryWhereUniqueInput
    data: XOR<AgencyContractSignatoryUpdateWithoutAgencyInput, AgencyContractSignatoryUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencyContractSignatoryUpdateManyWithWhereWithoutAgencyInput = {
    where: AgencyContractSignatoryScalarWhereInput
    data: XOR<AgencyContractSignatoryUpdateManyMutationInput, AgencyContractSignatoryUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AgencyContractSignatoryScalarWhereInput = {
    AND?: AgencyContractSignatoryScalarWhereInput | AgencyContractSignatoryScalarWhereInput[]
    OR?: AgencyContractSignatoryScalarWhereInput[]
    NOT?: AgencyContractSignatoryScalarWhereInput | AgencyContractSignatoryScalarWhereInput[]
    id?: IntFilter<"AgencyContractSignatory"> | number
    fullName?: StringFilter<"AgencyContractSignatory"> | string
    basedOn?: StringNullableFilter<"AgencyContractSignatory"> | string | null
    title?: StringNullableFilter<"AgencyContractSignatory"> | string | null
    agencyId?: IntFilter<"AgencyContractSignatory"> | number
    createdAt?: DateTimeFilter<"AgencyContractSignatory"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyContractSignatory"> | Date | string
  }

  export type RealEstateAgencyActUpsertWithWhereUniqueWithoutAgencyInput = {
    where: RealEstateAgencyActWhereUniqueInput
    update: XOR<RealEstateAgencyActUpdateWithoutAgencyInput, RealEstateAgencyActUncheckedUpdateWithoutAgencyInput>
    create: XOR<RealEstateAgencyActCreateWithoutAgencyInput, RealEstateAgencyActUncheckedCreateWithoutAgencyInput>
  }

  export type RealEstateAgencyActUpdateWithWhereUniqueWithoutAgencyInput = {
    where: RealEstateAgencyActWhereUniqueInput
    data: XOR<RealEstateAgencyActUpdateWithoutAgencyInput, RealEstateAgencyActUncheckedUpdateWithoutAgencyInput>
  }

  export type RealEstateAgencyActUpdateManyWithWhereWithoutAgencyInput = {
    where: RealEstateAgencyActScalarWhereInput
    data: XOR<RealEstateAgencyActUpdateManyMutationInput, RealEstateAgencyActUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AgencyToRealEstateAgentWhereUniqueInput
    update: XOR<AgencyToRealEstateAgentUpdateWithoutAgencyInput, AgencyToRealEstateAgentUncheckedUpdateWithoutAgencyInput>
    create: XOR<AgencyToRealEstateAgentCreateWithoutAgencyInput, AgencyToRealEstateAgentUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AgencyToRealEstateAgentWhereUniqueInput
    data: XOR<AgencyToRealEstateAgentUpdateWithoutAgencyInput, AgencyToRealEstateAgentUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencyToRealEstateAgentUpdateManyWithWhereWithoutAgencyInput = {
    where: AgencyToRealEstateAgentScalarWhereInput
    data: XOR<AgencyToRealEstateAgentUpdateManyMutationInput, AgencyToRealEstateAgentUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AgencyToRealEstateAgentScalarWhereInput = {
    AND?: AgencyToRealEstateAgentScalarWhereInput | AgencyToRealEstateAgentScalarWhereInput[]
    OR?: AgencyToRealEstateAgentScalarWhereInput[]
    NOT?: AgencyToRealEstateAgentScalarWhereInput | AgencyToRealEstateAgentScalarWhereInput[]
    agencyId?: IntFilter<"AgencyToRealEstateAgent"> | number
    realEstateAgentId?: IntFilter<"AgencyToRealEstateAgent"> | number
    createdAt?: DateTimeFilter<"AgencyToRealEstateAgent"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyToRealEstateAgent"> | Date | string
  }

  export type UserCreateWithoutAgencyContractsInput = {
    fullName: string
    email: string
    phone?: string | null
    isManager?: boolean
    isStaff?: boolean
    userRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContracts?: ClientContractCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutAgencyContractsInput = {
    id?: number
    fullName: string
    email: string
    phone?: string | null
    isManager?: boolean
    isStaff?: boolean
    userRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContracts?: ClientContractUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutAgencyContractsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgencyContractsInput, UserUncheckedCreateWithoutAgencyContractsInput>
  }

  export type EntityCreateWithoutAgencyContractsInput = {
    commonDbEntitiesId: number
    commonContractorId?: number | null
    name: string
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    objects?: ObjectCreateNestedManyWithoutEntityInput
    entityForbiddenWebsites?: EntityForbiddenWebsiteCreateNestedManyWithoutEntityInput
    entityForbiddenBrands?: EntityForbiddenBrandCreateNestedManyWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutAgencyContractsInput = {
    id?: number
    commonDbEntitiesId: number
    commonContractorId?: number | null
    name: string
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    objects?: ObjectUncheckedCreateNestedManyWithoutEntityInput
    entityForbiddenWebsites?: EntityForbiddenWebsiteUncheckedCreateNestedManyWithoutEntityInput
    entityForbiddenBrands?: EntityForbiddenBrandUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutAgencyContractsInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutAgencyContractsInput, EntityUncheckedCreateWithoutAgencyContractsInput>
  }

  export type ObjectCreateWithoutAgencyContractsInput = {
    commonDbObjectsId: number
    name: string
    dateIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entity: EntityCreateNestedOneWithoutObjectsInput
    products?: ProductCreateNestedManyWithoutObjectInput
    clientContracts?: ClientContractCreateNestedManyWithoutObjectInput
    transferActs?: TransferActCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutAgencyContractsInput = {
    id?: number
    commonDbObjectsId: number
    name: string
    dateIn?: Date | string | null
    entityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutObjectInput
    clientContracts?: ClientContractUncheckedCreateNestedManyWithoutObjectInput
    transferActs?: TransferActUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutAgencyContractsInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutAgencyContractsInput, ObjectUncheckedCreateWithoutAgencyContractsInput>
  }

  export type AgencyCreateWithoutAgencyContractsInput = {
    commonDbContractorsId: number
    name: string
    inn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContractSignatory?: AgencyContractSignatoryCreateNestedManyWithoutAgencyInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutAgencyInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutAgencyContractsInput = {
    id?: number
    commonDbContractorsId: number
    name: string
    inn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContractSignatory?: AgencyContractSignatoryUncheckedCreateNestedManyWithoutAgencyInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutAgencyInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutAgencyContractsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutAgencyContractsInput, AgencyUncheckedCreateWithoutAgencyContractsInput>
  }

  export type AgencyContractSignatoryCreateWithoutAgencyContractsInput = {
    fullName: string
    basedOn?: string | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutAgencyContractSignatoryInput
  }

  export type AgencyContractSignatoryUncheckedCreateWithoutAgencyContractsInput = {
    id?: number
    fullName: string
    basedOn?: string | null
    title?: string | null
    agencyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyContractSignatoryCreateOrConnectWithoutAgencyContractsInput = {
    where: AgencyContractSignatoryWhereUniqueInput
    create: XOR<AgencyContractSignatoryCreateWithoutAgencyContractsInput, AgencyContractSignatoryUncheckedCreateWithoutAgencyContractsInput>
  }

  export type RealEstateAgencyContractPropertiesCreateWithoutAgencyContractInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContractCommission: AgencyContractCommissionCreateNestedOneWithoutRealEstateAgencyContractPropertiesInput
  }

  export type RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgencyContractInput = {
    id?: number
    agencyContractCommissionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RealEstateAgencyContractPropertiesCreateOrConnectWithoutAgencyContractInput = {
    where: RealEstateAgencyContractPropertiesWhereUniqueInput
    create: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgencyContractInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgencyContractInput>
  }

  export type MipAgencyContractPropertiesCreateWithoutAgencyContractInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContractCommission: AgencyContractCommissionCreateNestedOneWithoutMipAgencyContractPropertiesInput
  }

  export type MipAgencyContractPropertiesUncheckedCreateWithoutAgencyContractInput = {
    id?: number
    agencyContractCommissionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MipAgencyContractPropertiesCreateOrConnectWithoutAgencyContractInput = {
    where: MipAgencyContractPropertiesWhereUniqueInput
    create: XOR<MipAgencyContractPropertiesCreateWithoutAgencyContractInput, MipAgencyContractPropertiesUncheckedCreateWithoutAgencyContractInput>
  }

  export type RealEstateAgencyActCreateWithoutAgencyContractInput = {
    number: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    retention?: Decimal | DecimalJsLike | number | string | null
    note?: string | null
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract: ClientContractCreateNestedOneWithoutRealEstateAgencyActsInput
    agency: AgencyCreateNestedOneWithoutRealEstateAgencyActsInput
  }

  export type RealEstateAgencyActUncheckedCreateWithoutAgencyContractInput = {
    id?: number
    number: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    retention?: Decimal | DecimalJsLike | number | string | null
    note?: string | null
    link?: string | null
    clientContractId: number
    agencyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RealEstateAgencyActCreateOrConnectWithoutAgencyContractInput = {
    where: RealEstateAgencyActWhereUniqueInput
    create: XOR<RealEstateAgencyActCreateWithoutAgencyContractInput, RealEstateAgencyActUncheckedCreateWithoutAgencyContractInput>
  }

  export type RealEstateAgencyActCreateManyAgencyContractInputEnvelope = {
    data: RealEstateAgencyActCreateManyAgencyContractInput | RealEstateAgencyActCreateManyAgencyContractInput[]
    skipDuplicates?: boolean
  }

  export type ClientContractToAgencyContractCreateWithoutAgencyContractInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract: ClientContractCreateNestedOneWithoutClientContractsToAgencyContractsInput
  }

  export type ClientContractToAgencyContractUncheckedCreateWithoutAgencyContractInput = {
    clientContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientContractToAgencyContractCreateOrConnectWithoutAgencyContractInput = {
    where: ClientContractToAgencyContractWhereUniqueInput
    create: XOR<ClientContractToAgencyContractCreateWithoutAgencyContractInput, ClientContractToAgencyContractUncheckedCreateWithoutAgencyContractInput>
  }

  export type ClientContractToAgencyContractCreateManyAgencyContractInputEnvelope = {
    data: ClientContractToAgencyContractCreateManyAgencyContractInput | ClientContractToAgencyContractCreateManyAgencyContractInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAgencyContractsInput = {
    update: XOR<UserUpdateWithoutAgencyContractsInput, UserUncheckedUpdateWithoutAgencyContractsInput>
    create: XOR<UserCreateWithoutAgencyContractsInput, UserUncheckedCreateWithoutAgencyContractsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgencyContractsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgencyContractsInput, UserUncheckedUpdateWithoutAgencyContractsInput>
  }

  export type UserUpdateWithoutAgencyContractsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    userRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContracts?: ClientContractUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutAgencyContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    userRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContracts?: ClientContractUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type EntityUpsertWithoutAgencyContractsInput = {
    update: XOR<EntityUpdateWithoutAgencyContractsInput, EntityUncheckedUpdateWithoutAgencyContractsInput>
    create: XOR<EntityCreateWithoutAgencyContractsInput, EntityUncheckedCreateWithoutAgencyContractsInput>
    where?: EntityWhereInput
  }

  export type EntityUpdateToOneWithWhereWithoutAgencyContractsInput = {
    where?: EntityWhereInput
    data: XOR<EntityUpdateWithoutAgencyContractsInput, EntityUncheckedUpdateWithoutAgencyContractsInput>
  }

  export type EntityUpdateWithoutAgencyContractsInput = {
    commonDbEntitiesId?: IntFieldUpdateOperationsInput | number
    commonContractorId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    objects?: ObjectUpdateManyWithoutEntityNestedInput
    entityForbiddenWebsites?: EntityForbiddenWebsiteUpdateManyWithoutEntityNestedInput
    entityForbiddenBrands?: EntityForbiddenBrandUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutAgencyContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbEntitiesId?: IntFieldUpdateOperationsInput | number
    commonContractorId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    objects?: ObjectUncheckedUpdateManyWithoutEntityNestedInput
    entityForbiddenWebsites?: EntityForbiddenWebsiteUncheckedUpdateManyWithoutEntityNestedInput
    entityForbiddenBrands?: EntityForbiddenBrandUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type ObjectUpsertWithoutAgencyContractsInput = {
    update: XOR<ObjectUpdateWithoutAgencyContractsInput, ObjectUncheckedUpdateWithoutAgencyContractsInput>
    create: XOR<ObjectCreateWithoutAgencyContractsInput, ObjectUncheckedCreateWithoutAgencyContractsInput>
    where?: ObjectWhereInput
  }

  export type ObjectUpdateToOneWithWhereWithoutAgencyContractsInput = {
    where?: ObjectWhereInput
    data: XOR<ObjectUpdateWithoutAgencyContractsInput, ObjectUncheckedUpdateWithoutAgencyContractsInput>
  }

  export type ObjectUpdateWithoutAgencyContractsInput = {
    commonDbObjectsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: EntityUpdateOneRequiredWithoutObjectsNestedInput
    products?: ProductUpdateManyWithoutObjectNestedInput
    clientContracts?: ClientContractUpdateManyWithoutObjectNestedInput
    transferActs?: TransferActUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutAgencyContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbObjectsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutObjectNestedInput
    clientContracts?: ClientContractUncheckedUpdateManyWithoutObjectNestedInput
    transferActs?: TransferActUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type AgencyUpsertWithoutAgencyContractsInput = {
    update: XOR<AgencyUpdateWithoutAgencyContractsInput, AgencyUncheckedUpdateWithoutAgencyContractsInput>
    create: XOR<AgencyCreateWithoutAgencyContractsInput, AgencyUncheckedCreateWithoutAgencyContractsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutAgencyContractsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutAgencyContractsInput, AgencyUncheckedUpdateWithoutAgencyContractsInput>
  }

  export type AgencyUpdateWithoutAgencyContractsInput = {
    commonDbContractorsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractSignatory?: AgencyContractSignatoryUpdateManyWithoutAgencyNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutAgencyNestedInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutAgencyContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbContractorsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractSignatory?: AgencyContractSignatoryUncheckedUpdateManyWithoutAgencyNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutAgencyNestedInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyContractSignatoryUpsertWithoutAgencyContractsInput = {
    update: XOR<AgencyContractSignatoryUpdateWithoutAgencyContractsInput, AgencyContractSignatoryUncheckedUpdateWithoutAgencyContractsInput>
    create: XOR<AgencyContractSignatoryCreateWithoutAgencyContractsInput, AgencyContractSignatoryUncheckedCreateWithoutAgencyContractsInput>
    where?: AgencyContractSignatoryWhereInput
  }

  export type AgencyContractSignatoryUpdateToOneWithWhereWithoutAgencyContractsInput = {
    where?: AgencyContractSignatoryWhereInput
    data: XOR<AgencyContractSignatoryUpdateWithoutAgencyContractsInput, AgencyContractSignatoryUncheckedUpdateWithoutAgencyContractsInput>
  }

  export type AgencyContractSignatoryUpdateWithoutAgencyContractsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    basedOn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutAgencyContractSignatoryNestedInput
  }

  export type AgencyContractSignatoryUncheckedUpdateWithoutAgencyContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    basedOn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealEstateAgencyContractPropertiesUpsertWithoutAgencyContractInput = {
    update: XOR<RealEstateAgencyContractPropertiesUpdateWithoutAgencyContractInput, RealEstateAgencyContractPropertiesUncheckedUpdateWithoutAgencyContractInput>
    create: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgencyContractInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgencyContractInput>
    where?: RealEstateAgencyContractPropertiesWhereInput
  }

  export type RealEstateAgencyContractPropertiesUpdateToOneWithWhereWithoutAgencyContractInput = {
    where?: RealEstateAgencyContractPropertiesWhereInput
    data: XOR<RealEstateAgencyContractPropertiesUpdateWithoutAgencyContractInput, RealEstateAgencyContractPropertiesUncheckedUpdateWithoutAgencyContractInput>
  }

  export type RealEstateAgencyContractPropertiesUpdateWithoutAgencyContractInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractCommission?: AgencyContractCommissionUpdateOneRequiredWithoutRealEstateAgencyContractPropertiesNestedInput
  }

  export type RealEstateAgencyContractPropertiesUncheckedUpdateWithoutAgencyContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    agencyContractCommissionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MipAgencyContractPropertiesUpsertWithoutAgencyContractInput = {
    update: XOR<MipAgencyContractPropertiesUpdateWithoutAgencyContractInput, MipAgencyContractPropertiesUncheckedUpdateWithoutAgencyContractInput>
    create: XOR<MipAgencyContractPropertiesCreateWithoutAgencyContractInput, MipAgencyContractPropertiesUncheckedCreateWithoutAgencyContractInput>
    where?: MipAgencyContractPropertiesWhereInput
  }

  export type MipAgencyContractPropertiesUpdateToOneWithWhereWithoutAgencyContractInput = {
    where?: MipAgencyContractPropertiesWhereInput
    data: XOR<MipAgencyContractPropertiesUpdateWithoutAgencyContractInput, MipAgencyContractPropertiesUncheckedUpdateWithoutAgencyContractInput>
  }

  export type MipAgencyContractPropertiesUpdateWithoutAgencyContractInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractCommission?: AgencyContractCommissionUpdateOneRequiredWithoutMipAgencyContractPropertiesNestedInput
  }

  export type MipAgencyContractPropertiesUncheckedUpdateWithoutAgencyContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    agencyContractCommissionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealEstateAgencyActUpsertWithWhereUniqueWithoutAgencyContractInput = {
    where: RealEstateAgencyActWhereUniqueInput
    update: XOR<RealEstateAgencyActUpdateWithoutAgencyContractInput, RealEstateAgencyActUncheckedUpdateWithoutAgencyContractInput>
    create: XOR<RealEstateAgencyActCreateWithoutAgencyContractInput, RealEstateAgencyActUncheckedCreateWithoutAgencyContractInput>
  }

  export type RealEstateAgencyActUpdateWithWhereUniqueWithoutAgencyContractInput = {
    where: RealEstateAgencyActWhereUniqueInput
    data: XOR<RealEstateAgencyActUpdateWithoutAgencyContractInput, RealEstateAgencyActUncheckedUpdateWithoutAgencyContractInput>
  }

  export type RealEstateAgencyActUpdateManyWithWhereWithoutAgencyContractInput = {
    where: RealEstateAgencyActScalarWhereInput
    data: XOR<RealEstateAgencyActUpdateManyMutationInput, RealEstateAgencyActUncheckedUpdateManyWithoutAgencyContractInput>
  }

  export type ClientContractToAgencyContractUpsertWithWhereUniqueWithoutAgencyContractInput = {
    where: ClientContractToAgencyContractWhereUniqueInput
    update: XOR<ClientContractToAgencyContractUpdateWithoutAgencyContractInput, ClientContractToAgencyContractUncheckedUpdateWithoutAgencyContractInput>
    create: XOR<ClientContractToAgencyContractCreateWithoutAgencyContractInput, ClientContractToAgencyContractUncheckedCreateWithoutAgencyContractInput>
  }

  export type ClientContractToAgencyContractUpdateWithWhereUniqueWithoutAgencyContractInput = {
    where: ClientContractToAgencyContractWhereUniqueInput
    data: XOR<ClientContractToAgencyContractUpdateWithoutAgencyContractInput, ClientContractToAgencyContractUncheckedUpdateWithoutAgencyContractInput>
  }

  export type ClientContractToAgencyContractUpdateManyWithWhereWithoutAgencyContractInput = {
    where: ClientContractToAgencyContractScalarWhereInput
    data: XOR<ClientContractToAgencyContractUpdateManyMutationInput, ClientContractToAgencyContractUncheckedUpdateManyWithoutAgencyContractInput>
  }

  export type AgencyCreateWithoutAgencyContractSignatoryInput = {
    commonDbContractorsId: number
    name: string
    inn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractCreateNestedManyWithoutAgencyInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutAgencyInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutAgencyContractSignatoryInput = {
    id?: number
    commonDbContractorsId: number
    name: string
    inn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractUncheckedCreateNestedManyWithoutAgencyInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutAgencyInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutAgencyContractSignatoryInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutAgencyContractSignatoryInput, AgencyUncheckedCreateWithoutAgencyContractSignatoryInput>
  }

  export type AgencyContractCreateWithoutAgencyContractSignatoryInput = {
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responsibleUser?: UserCreateNestedOneWithoutAgencyContractsInput
    entity: EntityCreateNestedOneWithoutAgencyContractsInput
    object: ObjectCreateNestedOneWithoutAgencyContractsInput
    agency: AgencyCreateNestedOneWithoutAgencyContractsInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput
    realEstateAgencyAct?: RealEstateAgencyActCreateNestedManyWithoutAgencyContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractUncheckedCreateWithoutAgencyContractSignatoryInput = {
    id?: number
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    responsibleUserId?: number | null
    entityId: number
    objectId: number
    agencyId: number
    realEstateAgencyContractPropertiesId?: number | null
    mipAgencyContractPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    realEstateAgencyAct?: RealEstateAgencyActUncheckedCreateNestedManyWithoutAgencyContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractCreateOrConnectWithoutAgencyContractSignatoryInput = {
    where: AgencyContractWhereUniqueInput
    create: XOR<AgencyContractCreateWithoutAgencyContractSignatoryInput, AgencyContractUncheckedCreateWithoutAgencyContractSignatoryInput>
  }

  export type AgencyContractCreateManyAgencyContractSignatoryInputEnvelope = {
    data: AgencyContractCreateManyAgencyContractSignatoryInput | AgencyContractCreateManyAgencyContractSignatoryInput[]
    skipDuplicates?: boolean
  }

  export type AgencyUpsertWithoutAgencyContractSignatoryInput = {
    update: XOR<AgencyUpdateWithoutAgencyContractSignatoryInput, AgencyUncheckedUpdateWithoutAgencyContractSignatoryInput>
    create: XOR<AgencyCreateWithoutAgencyContractSignatoryInput, AgencyUncheckedCreateWithoutAgencyContractSignatoryInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutAgencyContractSignatoryInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutAgencyContractSignatoryInput, AgencyUncheckedUpdateWithoutAgencyContractSignatoryInput>
  }

  export type AgencyUpdateWithoutAgencyContractSignatoryInput = {
    commonDbContractorsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUpdateManyWithoutAgencyNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutAgencyNestedInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutAgencyContractSignatoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbContractorsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUncheckedUpdateManyWithoutAgencyNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutAgencyNestedInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyContractUpsertWithWhereUniqueWithoutAgencyContractSignatoryInput = {
    where: AgencyContractWhereUniqueInput
    update: XOR<AgencyContractUpdateWithoutAgencyContractSignatoryInput, AgencyContractUncheckedUpdateWithoutAgencyContractSignatoryInput>
    create: XOR<AgencyContractCreateWithoutAgencyContractSignatoryInput, AgencyContractUncheckedCreateWithoutAgencyContractSignatoryInput>
  }

  export type AgencyContractUpdateWithWhereUniqueWithoutAgencyContractSignatoryInput = {
    where: AgencyContractWhereUniqueInput
    data: XOR<AgencyContractUpdateWithoutAgencyContractSignatoryInput, AgencyContractUncheckedUpdateWithoutAgencyContractSignatoryInput>
  }

  export type AgencyContractUpdateManyWithWhereWithoutAgencyContractSignatoryInput = {
    where: AgencyContractScalarWhereInput
    data: XOR<AgencyContractUpdateManyMutationInput, AgencyContractUncheckedUpdateManyWithoutAgencyContractSignatoryInput>
  }

  export type AgencyContractCreateWithoutRealEstateAgencyContractPropertiesInput = {
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responsibleUser?: UserCreateNestedOneWithoutAgencyContractsInput
    entity: EntityCreateNestedOneWithoutAgencyContractsInput
    object: ObjectCreateNestedOneWithoutAgencyContractsInput
    agency: AgencyCreateNestedOneWithoutAgencyContractsInput
    agencyContractSignatory?: AgencyContractSignatoryCreateNestedOneWithoutAgencyContractsInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput
    realEstateAgencyAct?: RealEstateAgencyActCreateNestedManyWithoutAgencyContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractUncheckedCreateWithoutRealEstateAgencyContractPropertiesInput = {
    id?: number
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    responsibleUserId?: number | null
    entityId: number
    objectId: number
    agencyId: number
    agencyContractSignatoryId?: number | null
    mipAgencyContractPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    realEstateAgencyAct?: RealEstateAgencyActUncheckedCreateNestedManyWithoutAgencyContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractCreateOrConnectWithoutRealEstateAgencyContractPropertiesInput = {
    where: AgencyContractWhereUniqueInput
    create: XOR<AgencyContractCreateWithoutRealEstateAgencyContractPropertiesInput, AgencyContractUncheckedCreateWithoutRealEstateAgencyContractPropertiesInput>
  }

  export type AgencyContractCommissionCreateWithoutRealEstateAgencyContractPropertiesInput = {
    percent: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    maxDays: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mipAgencyContractProperties?: MipAgencyContractPropertiesCreateNestedOneWithoutAgencyContractCommissionInput
  }

  export type AgencyContractCommissionUncheckedCreateWithoutRealEstateAgencyContractPropertiesInput = {
    id?: number
    percent: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    maxDays: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mipAgencyContractProperties?: MipAgencyContractPropertiesUncheckedCreateNestedOneWithoutAgencyContractCommissionInput
  }

  export type AgencyContractCommissionCreateOrConnectWithoutRealEstateAgencyContractPropertiesInput = {
    where: AgencyContractCommissionWhereUniqueInput
    create: XOR<AgencyContractCommissionCreateWithoutRealEstateAgencyContractPropertiesInput, AgencyContractCommissionUncheckedCreateWithoutRealEstateAgencyContractPropertiesInput>
  }

  export type AgencyContractUpsertWithoutRealEstateAgencyContractPropertiesInput = {
    update: XOR<AgencyContractUpdateWithoutRealEstateAgencyContractPropertiesInput, AgencyContractUncheckedUpdateWithoutRealEstateAgencyContractPropertiesInput>
    create: XOR<AgencyContractCreateWithoutRealEstateAgencyContractPropertiesInput, AgencyContractUncheckedCreateWithoutRealEstateAgencyContractPropertiesInput>
    where?: AgencyContractWhereInput
  }

  export type AgencyContractUpdateToOneWithWhereWithoutRealEstateAgencyContractPropertiesInput = {
    where?: AgencyContractWhereInput
    data: XOR<AgencyContractUpdateWithoutRealEstateAgencyContractPropertiesInput, AgencyContractUncheckedUpdateWithoutRealEstateAgencyContractPropertiesInput>
  }

  export type AgencyContractUpdateWithoutRealEstateAgencyContractPropertiesInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUser?: UserUpdateOneWithoutAgencyContractsNestedInput
    entity?: EntityUpdateOneRequiredWithoutAgencyContractsNestedInput
    object?: ObjectUpdateOneRequiredWithoutAgencyContractsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgencyContractsNestedInput
    agencyContractSignatory?: AgencyContractSignatoryUpdateOneWithoutAgencyContractsNestedInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput
    realEstateAgencyAct?: RealEstateAgencyActUpdateManyWithoutAgencyContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutAgencyContractNestedInput
  }

  export type AgencyContractUncheckedUpdateWithoutRealEstateAgencyContractPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    entityId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    agencyContractSignatoryId?: NullableIntFieldUpdateOperationsInput | number | null
    mipAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstateAgencyAct?: RealEstateAgencyActUncheckedUpdateManyWithoutAgencyContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutAgencyContractNestedInput
  }

  export type AgencyContractCommissionUpsertWithoutRealEstateAgencyContractPropertiesInput = {
    update: XOR<AgencyContractCommissionUpdateWithoutRealEstateAgencyContractPropertiesInput, AgencyContractCommissionUncheckedUpdateWithoutRealEstateAgencyContractPropertiesInput>
    create: XOR<AgencyContractCommissionCreateWithoutRealEstateAgencyContractPropertiesInput, AgencyContractCommissionUncheckedCreateWithoutRealEstateAgencyContractPropertiesInput>
    where?: AgencyContractCommissionWhereInput
  }

  export type AgencyContractCommissionUpdateToOneWithWhereWithoutRealEstateAgencyContractPropertiesInput = {
    where?: AgencyContractCommissionWhereInput
    data: XOR<AgencyContractCommissionUpdateWithoutRealEstateAgencyContractPropertiesInput, AgencyContractCommissionUncheckedUpdateWithoutRealEstateAgencyContractPropertiesInput>
  }

  export type AgencyContractCommissionUpdateWithoutRealEstateAgencyContractPropertiesInput = {
    percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mipAgencyContractProperties?: MipAgencyContractPropertiesUpdateOneWithoutAgencyContractCommissionNestedInput
  }

  export type AgencyContractCommissionUncheckedUpdateWithoutRealEstateAgencyContractPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mipAgencyContractProperties?: MipAgencyContractPropertiesUncheckedUpdateOneWithoutAgencyContractCommissionNestedInput
  }

  export type AgencyContractCreateWithoutMipAgencyContractPropertiesInput = {
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responsibleUser?: UserCreateNestedOneWithoutAgencyContractsInput
    entity: EntityCreateNestedOneWithoutAgencyContractsInput
    object: ObjectCreateNestedOneWithoutAgencyContractsInput
    agency: AgencyCreateNestedOneWithoutAgencyContractsInput
    agencyContractSignatory?: AgencyContractSignatoryCreateNestedOneWithoutAgencyContractsInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput
    realEstateAgencyAct?: RealEstateAgencyActCreateNestedManyWithoutAgencyContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractUncheckedCreateWithoutMipAgencyContractPropertiesInput = {
    id?: number
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    responsibleUserId?: number | null
    entityId: number
    objectId: number
    agencyId: number
    agencyContractSignatoryId?: number | null
    realEstateAgencyContractPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    realEstateAgencyAct?: RealEstateAgencyActUncheckedCreateNestedManyWithoutAgencyContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractCreateOrConnectWithoutMipAgencyContractPropertiesInput = {
    where: AgencyContractWhereUniqueInput
    create: XOR<AgencyContractCreateWithoutMipAgencyContractPropertiesInput, AgencyContractUncheckedCreateWithoutMipAgencyContractPropertiesInput>
  }

  export type AgencyContractCommissionCreateWithoutMipAgencyContractPropertiesInput = {
    percent: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    maxDays: number
    createdAt?: Date | string
    updatedAt?: Date | string
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgencyContractCommissionInput
  }

  export type AgencyContractCommissionUncheckedCreateWithoutMipAgencyContractPropertiesInput = {
    id?: number
    percent: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    maxDays: number
    createdAt?: Date | string
    updatedAt?: Date | string
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesUncheckedCreateNestedOneWithoutAgencyContractCommissionInput
  }

  export type AgencyContractCommissionCreateOrConnectWithoutMipAgencyContractPropertiesInput = {
    where: AgencyContractCommissionWhereUniqueInput
    create: XOR<AgencyContractCommissionCreateWithoutMipAgencyContractPropertiesInput, AgencyContractCommissionUncheckedCreateWithoutMipAgencyContractPropertiesInput>
  }

  export type AgencyContractUpsertWithoutMipAgencyContractPropertiesInput = {
    update: XOR<AgencyContractUpdateWithoutMipAgencyContractPropertiesInput, AgencyContractUncheckedUpdateWithoutMipAgencyContractPropertiesInput>
    create: XOR<AgencyContractCreateWithoutMipAgencyContractPropertiesInput, AgencyContractUncheckedCreateWithoutMipAgencyContractPropertiesInput>
    where?: AgencyContractWhereInput
  }

  export type AgencyContractUpdateToOneWithWhereWithoutMipAgencyContractPropertiesInput = {
    where?: AgencyContractWhereInput
    data: XOR<AgencyContractUpdateWithoutMipAgencyContractPropertiesInput, AgencyContractUncheckedUpdateWithoutMipAgencyContractPropertiesInput>
  }

  export type AgencyContractUpdateWithoutMipAgencyContractPropertiesInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUser?: UserUpdateOneWithoutAgencyContractsNestedInput
    entity?: EntityUpdateOneRequiredWithoutAgencyContractsNestedInput
    object?: ObjectUpdateOneRequiredWithoutAgencyContractsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgencyContractsNestedInput
    agencyContractSignatory?: AgencyContractSignatoryUpdateOneWithoutAgencyContractsNestedInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput
    realEstateAgencyAct?: RealEstateAgencyActUpdateManyWithoutAgencyContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutAgencyContractNestedInput
  }

  export type AgencyContractUncheckedUpdateWithoutMipAgencyContractPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    entityId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    agencyContractSignatoryId?: NullableIntFieldUpdateOperationsInput | number | null
    realEstateAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstateAgencyAct?: RealEstateAgencyActUncheckedUpdateManyWithoutAgencyContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutAgencyContractNestedInput
  }

  export type AgencyContractCommissionUpsertWithoutMipAgencyContractPropertiesInput = {
    update: XOR<AgencyContractCommissionUpdateWithoutMipAgencyContractPropertiesInput, AgencyContractCommissionUncheckedUpdateWithoutMipAgencyContractPropertiesInput>
    create: XOR<AgencyContractCommissionCreateWithoutMipAgencyContractPropertiesInput, AgencyContractCommissionUncheckedCreateWithoutMipAgencyContractPropertiesInput>
    where?: AgencyContractCommissionWhereInput
  }

  export type AgencyContractCommissionUpdateToOneWithWhereWithoutMipAgencyContractPropertiesInput = {
    where?: AgencyContractCommissionWhereInput
    data: XOR<AgencyContractCommissionUpdateWithoutMipAgencyContractPropertiesInput, AgencyContractCommissionUncheckedUpdateWithoutMipAgencyContractPropertiesInput>
  }

  export type AgencyContractCommissionUpdateWithoutMipAgencyContractPropertiesInput = {
    percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgencyContractCommissionNestedInput
  }

  export type AgencyContractCommissionUncheckedUpdateWithoutMipAgencyContractPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesUncheckedUpdateOneWithoutAgencyContractCommissionNestedInput
  }

  export type RealEstateAgencyContractPropertiesCreateWithoutAgencyContractCommissionInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContract?: AgencyContractCreateNestedOneWithoutRealEstateAgencyContractPropertiesInput
  }

  export type RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgencyContractCommissionInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContract?: AgencyContractUncheckedCreateNestedOneWithoutRealEstateAgencyContractPropertiesInput
  }

  export type RealEstateAgencyContractPropertiesCreateOrConnectWithoutAgencyContractCommissionInput = {
    where: RealEstateAgencyContractPropertiesWhereUniqueInput
    create: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgencyContractCommissionInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgencyContractCommissionInput>
  }

  export type MipAgencyContractPropertiesCreateWithoutAgencyContractCommissionInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContract?: AgencyContractCreateNestedOneWithoutMipAgencyContractPropertiesInput
  }

  export type MipAgencyContractPropertiesUncheckedCreateWithoutAgencyContractCommissionInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContract?: AgencyContractUncheckedCreateNestedOneWithoutMipAgencyContractPropertiesInput
  }

  export type MipAgencyContractPropertiesCreateOrConnectWithoutAgencyContractCommissionInput = {
    where: MipAgencyContractPropertiesWhereUniqueInput
    create: XOR<MipAgencyContractPropertiesCreateWithoutAgencyContractCommissionInput, MipAgencyContractPropertiesUncheckedCreateWithoutAgencyContractCommissionInput>
  }

  export type RealEstateAgencyContractPropertiesUpsertWithoutAgencyContractCommissionInput = {
    update: XOR<RealEstateAgencyContractPropertiesUpdateWithoutAgencyContractCommissionInput, RealEstateAgencyContractPropertiesUncheckedUpdateWithoutAgencyContractCommissionInput>
    create: XOR<RealEstateAgencyContractPropertiesCreateWithoutAgencyContractCommissionInput, RealEstateAgencyContractPropertiesUncheckedCreateWithoutAgencyContractCommissionInput>
    where?: RealEstateAgencyContractPropertiesWhereInput
  }

  export type RealEstateAgencyContractPropertiesUpdateToOneWithWhereWithoutAgencyContractCommissionInput = {
    where?: RealEstateAgencyContractPropertiesWhereInput
    data: XOR<RealEstateAgencyContractPropertiesUpdateWithoutAgencyContractCommissionInput, RealEstateAgencyContractPropertiesUncheckedUpdateWithoutAgencyContractCommissionInput>
  }

  export type RealEstateAgencyContractPropertiesUpdateWithoutAgencyContractCommissionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContract?: AgencyContractUpdateOneWithoutRealEstateAgencyContractPropertiesNestedInput
  }

  export type RealEstateAgencyContractPropertiesUncheckedUpdateWithoutAgencyContractCommissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContract?: AgencyContractUncheckedUpdateOneWithoutRealEstateAgencyContractPropertiesNestedInput
  }

  export type MipAgencyContractPropertiesUpsertWithoutAgencyContractCommissionInput = {
    update: XOR<MipAgencyContractPropertiesUpdateWithoutAgencyContractCommissionInput, MipAgencyContractPropertiesUncheckedUpdateWithoutAgencyContractCommissionInput>
    create: XOR<MipAgencyContractPropertiesCreateWithoutAgencyContractCommissionInput, MipAgencyContractPropertiesUncheckedCreateWithoutAgencyContractCommissionInput>
    where?: MipAgencyContractPropertiesWhereInput
  }

  export type MipAgencyContractPropertiesUpdateToOneWithWhereWithoutAgencyContractCommissionInput = {
    where?: MipAgencyContractPropertiesWhereInput
    data: XOR<MipAgencyContractPropertiesUpdateWithoutAgencyContractCommissionInput, MipAgencyContractPropertiesUncheckedUpdateWithoutAgencyContractCommissionInput>
  }

  export type MipAgencyContractPropertiesUpdateWithoutAgencyContractCommissionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContract?: AgencyContractUpdateOneWithoutMipAgencyContractPropertiesNestedInput
  }

  export type MipAgencyContractPropertiesUncheckedUpdateWithoutAgencyContractCommissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContract?: AgencyContractUncheckedUpdateOneWithoutMipAgencyContractPropertiesNestedInput
  }

  export type ClientContractCreateWithoutRealEstateAgentInput = {
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActCreateNestedOneWithoutClientContractInput
    dduClientContractProperties?: DduClientContractPropertiesCreateNestedOneWithoutClientContractInput
    dkpClientContractProperties?: DkpClientContractPropertiesCreateNestedOneWithoutClientContractInput
    product: ProductCreateNestedOneWithoutClientContractInput
    object: ObjectCreateNestedOneWithoutClientContractsInput
    manager?: UserCreateNestedOneWithoutClientContractsInput
    bank?: BankCreateNestedOneWithoutClientContractsInput
    subsidy?: SubsidyCreateNestedOneWithoutClientContractsInput
    scheduledPayments?: ScheduledPaymentCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractUncheckedCreateWithoutRealEstateAgentInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    managerId?: number | null
    bankId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActUncheckedCreateNestedOneWithoutClientContractInput
    scheduledPayments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentUncheckedCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractCreateOrConnectWithoutRealEstateAgentInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutRealEstateAgentInput, ClientContractUncheckedCreateWithoutRealEstateAgentInput>
  }

  export type ClientContractCreateManyRealEstateAgentInputEnvelope = {
    data: ClientContractCreateManyRealEstateAgentInput | ClientContractCreateManyRealEstateAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgencyToRealEstateAgentCreateWithoutRealEstateAgentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutAgenciesToRealEstateAgentsInput
  }

  export type AgencyToRealEstateAgentUncheckedCreateWithoutRealEstateAgentInput = {
    agencyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyToRealEstateAgentCreateOrConnectWithoutRealEstateAgentInput = {
    where: AgencyToRealEstateAgentWhereUniqueInput
    create: XOR<AgencyToRealEstateAgentCreateWithoutRealEstateAgentInput, AgencyToRealEstateAgentUncheckedCreateWithoutRealEstateAgentInput>
  }

  export type AgencyToRealEstateAgentCreateManyRealEstateAgentInputEnvelope = {
    data: AgencyToRealEstateAgentCreateManyRealEstateAgentInput | AgencyToRealEstateAgentCreateManyRealEstateAgentInput[]
    skipDuplicates?: boolean
  }

  export type ClientContractUpsertWithWhereUniqueWithoutRealEstateAgentInput = {
    where: ClientContractWhereUniqueInput
    update: XOR<ClientContractUpdateWithoutRealEstateAgentInput, ClientContractUncheckedUpdateWithoutRealEstateAgentInput>
    create: XOR<ClientContractCreateWithoutRealEstateAgentInput, ClientContractUncheckedCreateWithoutRealEstateAgentInput>
  }

  export type ClientContractUpdateWithWhereUniqueWithoutRealEstateAgentInput = {
    where: ClientContractWhereUniqueInput
    data: XOR<ClientContractUpdateWithoutRealEstateAgentInput, ClientContractUncheckedUpdateWithoutRealEstateAgentInput>
  }

  export type ClientContractUpdateManyWithWhereWithoutRealEstateAgentInput = {
    where: ClientContractScalarWhereInput
    data: XOR<ClientContractUpdateManyMutationInput, ClientContractUncheckedUpdateManyWithoutRealEstateAgentInput>
  }

  export type AgencyToRealEstateAgentUpsertWithWhereUniqueWithoutRealEstateAgentInput = {
    where: AgencyToRealEstateAgentWhereUniqueInput
    update: XOR<AgencyToRealEstateAgentUpdateWithoutRealEstateAgentInput, AgencyToRealEstateAgentUncheckedUpdateWithoutRealEstateAgentInput>
    create: XOR<AgencyToRealEstateAgentCreateWithoutRealEstateAgentInput, AgencyToRealEstateAgentUncheckedCreateWithoutRealEstateAgentInput>
  }

  export type AgencyToRealEstateAgentUpdateWithWhereUniqueWithoutRealEstateAgentInput = {
    where: AgencyToRealEstateAgentWhereUniqueInput
    data: XOR<AgencyToRealEstateAgentUpdateWithoutRealEstateAgentInput, AgencyToRealEstateAgentUncheckedUpdateWithoutRealEstateAgentInput>
  }

  export type AgencyToRealEstateAgentUpdateManyWithWhereWithoutRealEstateAgentInput = {
    where: AgencyToRealEstateAgentScalarWhereInput
    data: XOR<AgencyToRealEstateAgentUpdateManyMutationInput, AgencyToRealEstateAgentUncheckedUpdateManyWithoutRealEstateAgentInput>
  }

  export type AgencyCreateWithoutAgenciesToRealEstateAgentsInput = {
    commonDbContractorsId: number
    name: string
    inn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractCreateNestedManyWithoutAgencyInput
    agencyContractSignatory?: AgencyContractSignatoryCreateNestedManyWithoutAgencyInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutAgenciesToRealEstateAgentsInput = {
    id?: number
    commonDbContractorsId: number
    name: string
    inn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractUncheckedCreateNestedManyWithoutAgencyInput
    agencyContractSignatory?: AgencyContractSignatoryUncheckedCreateNestedManyWithoutAgencyInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutAgenciesToRealEstateAgentsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutAgenciesToRealEstateAgentsInput, AgencyUncheckedCreateWithoutAgenciesToRealEstateAgentsInput>
  }

  export type RealEstateAgentCreateWithoutAgenciesToRealEstateAgentsInput = {
    fullName: string
    phone?: string | null
    oneGtId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContracts?: ClientContractCreateNestedManyWithoutRealEstateAgentInput
  }

  export type RealEstateAgentUncheckedCreateWithoutAgenciesToRealEstateAgentsInput = {
    id?: number
    fullName: string
    phone?: string | null
    oneGtId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContracts?: ClientContractUncheckedCreateNestedManyWithoutRealEstateAgentInput
  }

  export type RealEstateAgentCreateOrConnectWithoutAgenciesToRealEstateAgentsInput = {
    where: RealEstateAgentWhereUniqueInput
    create: XOR<RealEstateAgentCreateWithoutAgenciesToRealEstateAgentsInput, RealEstateAgentUncheckedCreateWithoutAgenciesToRealEstateAgentsInput>
  }

  export type AgencyUpsertWithoutAgenciesToRealEstateAgentsInput = {
    update: XOR<AgencyUpdateWithoutAgenciesToRealEstateAgentsInput, AgencyUncheckedUpdateWithoutAgenciesToRealEstateAgentsInput>
    create: XOR<AgencyCreateWithoutAgenciesToRealEstateAgentsInput, AgencyUncheckedCreateWithoutAgenciesToRealEstateAgentsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutAgenciesToRealEstateAgentsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutAgenciesToRealEstateAgentsInput, AgencyUncheckedUpdateWithoutAgenciesToRealEstateAgentsInput>
  }

  export type AgencyUpdateWithoutAgenciesToRealEstateAgentsInput = {
    commonDbContractorsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUpdateManyWithoutAgencyNestedInput
    agencyContractSignatory?: AgencyContractSignatoryUpdateManyWithoutAgencyNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutAgenciesToRealEstateAgentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbContractorsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUncheckedUpdateManyWithoutAgencyNestedInput
    agencyContractSignatory?: AgencyContractSignatoryUncheckedUpdateManyWithoutAgencyNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type RealEstateAgentUpsertWithoutAgenciesToRealEstateAgentsInput = {
    update: XOR<RealEstateAgentUpdateWithoutAgenciesToRealEstateAgentsInput, RealEstateAgentUncheckedUpdateWithoutAgenciesToRealEstateAgentsInput>
    create: XOR<RealEstateAgentCreateWithoutAgenciesToRealEstateAgentsInput, RealEstateAgentUncheckedCreateWithoutAgenciesToRealEstateAgentsInput>
    where?: RealEstateAgentWhereInput
  }

  export type RealEstateAgentUpdateToOneWithWhereWithoutAgenciesToRealEstateAgentsInput = {
    where?: RealEstateAgentWhereInput
    data: XOR<RealEstateAgentUpdateWithoutAgenciesToRealEstateAgentsInput, RealEstateAgentUncheckedUpdateWithoutAgenciesToRealEstateAgentsInput>
  }

  export type RealEstateAgentUpdateWithoutAgenciesToRealEstateAgentsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    oneGtId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContracts?: ClientContractUpdateManyWithoutRealEstateAgentNestedInput
  }

  export type RealEstateAgentUncheckedUpdateWithoutAgenciesToRealEstateAgentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    oneGtId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContracts?: ClientContractUncheckedUpdateManyWithoutRealEstateAgentNestedInput
  }

  export type AgencyContractCreateWithoutEntityInput = {
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responsibleUser?: UserCreateNestedOneWithoutAgencyContractsInput
    object: ObjectCreateNestedOneWithoutAgencyContractsInput
    agency: AgencyCreateNestedOneWithoutAgencyContractsInput
    agencyContractSignatory?: AgencyContractSignatoryCreateNestedOneWithoutAgencyContractsInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput
    realEstateAgencyAct?: RealEstateAgencyActCreateNestedManyWithoutAgencyContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractUncheckedCreateWithoutEntityInput = {
    id?: number
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    responsibleUserId?: number | null
    objectId: number
    agencyId: number
    agencyContractSignatoryId?: number | null
    realEstateAgencyContractPropertiesId?: number | null
    mipAgencyContractPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    realEstateAgencyAct?: RealEstateAgencyActUncheckedCreateNestedManyWithoutAgencyContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractCreateOrConnectWithoutEntityInput = {
    where: AgencyContractWhereUniqueInput
    create: XOR<AgencyContractCreateWithoutEntityInput, AgencyContractUncheckedCreateWithoutEntityInput>
  }

  export type AgencyContractCreateManyEntityInputEnvelope = {
    data: AgencyContractCreateManyEntityInput | AgencyContractCreateManyEntityInput[]
    skipDuplicates?: boolean
  }

  export type ObjectCreateWithoutEntityInput = {
    commonDbObjectsId: number
    name: string
    dateIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutObjectInput
    clientContracts?: ClientContractCreateNestedManyWithoutObjectInput
    agencyContracts?: AgencyContractCreateNestedManyWithoutObjectInput
    transferActs?: TransferActCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutEntityInput = {
    id?: number
    commonDbObjectsId: number
    name: string
    dateIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutObjectInput
    clientContracts?: ClientContractUncheckedCreateNestedManyWithoutObjectInput
    agencyContracts?: AgencyContractUncheckedCreateNestedManyWithoutObjectInput
    transferActs?: TransferActUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutEntityInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutEntityInput, ObjectUncheckedCreateWithoutEntityInput>
  }

  export type ObjectCreateManyEntityInputEnvelope = {
    data: ObjectCreateManyEntityInput | ObjectCreateManyEntityInput[]
    skipDuplicates?: boolean
  }

  export type EntityForbiddenWebsiteCreateWithoutEntityInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EntityForbiddenWebsiteCreateOrConnectWithoutEntityInput = {
    where: EntityForbiddenWebsiteWhereUniqueInput
    create: XOR<EntityForbiddenWebsiteCreateWithoutEntityInput, EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput>
  }

  export type EntityForbiddenWebsiteCreateManyEntityInputEnvelope = {
    data: EntityForbiddenWebsiteCreateManyEntityInput | EntityForbiddenWebsiteCreateManyEntityInput[]
    skipDuplicates?: boolean
  }

  export type EntityForbiddenBrandCreateWithoutEntityInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EntityForbiddenBrandUncheckedCreateWithoutEntityInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EntityForbiddenBrandCreateOrConnectWithoutEntityInput = {
    where: EntityForbiddenBrandWhereUniqueInput
    create: XOR<EntityForbiddenBrandCreateWithoutEntityInput, EntityForbiddenBrandUncheckedCreateWithoutEntityInput>
  }

  export type EntityForbiddenBrandCreateManyEntityInputEnvelope = {
    data: EntityForbiddenBrandCreateManyEntityInput | EntityForbiddenBrandCreateManyEntityInput[]
    skipDuplicates?: boolean
  }

  export type AgencyContractUpsertWithWhereUniqueWithoutEntityInput = {
    where: AgencyContractWhereUniqueInput
    update: XOR<AgencyContractUpdateWithoutEntityInput, AgencyContractUncheckedUpdateWithoutEntityInput>
    create: XOR<AgencyContractCreateWithoutEntityInput, AgencyContractUncheckedCreateWithoutEntityInput>
  }

  export type AgencyContractUpdateWithWhereUniqueWithoutEntityInput = {
    where: AgencyContractWhereUniqueInput
    data: XOR<AgencyContractUpdateWithoutEntityInput, AgencyContractUncheckedUpdateWithoutEntityInput>
  }

  export type AgencyContractUpdateManyWithWhereWithoutEntityInput = {
    where: AgencyContractScalarWhereInput
    data: XOR<AgencyContractUpdateManyMutationInput, AgencyContractUncheckedUpdateManyWithoutEntityInput>
  }

  export type ObjectUpsertWithWhereUniqueWithoutEntityInput = {
    where: ObjectWhereUniqueInput
    update: XOR<ObjectUpdateWithoutEntityInput, ObjectUncheckedUpdateWithoutEntityInput>
    create: XOR<ObjectCreateWithoutEntityInput, ObjectUncheckedCreateWithoutEntityInput>
  }

  export type ObjectUpdateWithWhereUniqueWithoutEntityInput = {
    where: ObjectWhereUniqueInput
    data: XOR<ObjectUpdateWithoutEntityInput, ObjectUncheckedUpdateWithoutEntityInput>
  }

  export type ObjectUpdateManyWithWhereWithoutEntityInput = {
    where: ObjectScalarWhereInput
    data: XOR<ObjectUpdateManyMutationInput, ObjectUncheckedUpdateManyWithoutEntityInput>
  }

  export type ObjectScalarWhereInput = {
    AND?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
    OR?: ObjectScalarWhereInput[]
    NOT?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
    id?: IntFilter<"Object"> | number
    commonDbObjectsId?: IntFilter<"Object"> | number
    name?: StringFilter<"Object"> | string
    dateIn?: DateTimeNullableFilter<"Object"> | Date | string | null
    entityId?: IntFilter<"Object"> | number
    createdAt?: DateTimeFilter<"Object"> | Date | string
    updatedAt?: DateTimeFilter<"Object"> | Date | string
  }

  export type EntityForbiddenWebsiteUpsertWithWhereUniqueWithoutEntityInput = {
    where: EntityForbiddenWebsiteWhereUniqueInput
    update: XOR<EntityForbiddenWebsiteUpdateWithoutEntityInput, EntityForbiddenWebsiteUncheckedUpdateWithoutEntityInput>
    create: XOR<EntityForbiddenWebsiteCreateWithoutEntityInput, EntityForbiddenWebsiteUncheckedCreateWithoutEntityInput>
  }

  export type EntityForbiddenWebsiteUpdateWithWhereUniqueWithoutEntityInput = {
    where: EntityForbiddenWebsiteWhereUniqueInput
    data: XOR<EntityForbiddenWebsiteUpdateWithoutEntityInput, EntityForbiddenWebsiteUncheckedUpdateWithoutEntityInput>
  }

  export type EntityForbiddenWebsiteUpdateManyWithWhereWithoutEntityInput = {
    where: EntityForbiddenWebsiteScalarWhereInput
    data: XOR<EntityForbiddenWebsiteUpdateManyMutationInput, EntityForbiddenWebsiteUncheckedUpdateManyWithoutEntityInput>
  }

  export type EntityForbiddenWebsiteScalarWhereInput = {
    AND?: EntityForbiddenWebsiteScalarWhereInput | EntityForbiddenWebsiteScalarWhereInput[]
    OR?: EntityForbiddenWebsiteScalarWhereInput[]
    NOT?: EntityForbiddenWebsiteScalarWhereInput | EntityForbiddenWebsiteScalarWhereInput[]
    id?: IntFilter<"EntityForbiddenWebsite"> | number
    name?: StringFilter<"EntityForbiddenWebsite"> | string
    entityId?: IntFilter<"EntityForbiddenWebsite"> | number
    createdAt?: DateTimeFilter<"EntityForbiddenWebsite"> | Date | string
    updatedAt?: DateTimeFilter<"EntityForbiddenWebsite"> | Date | string
  }

  export type EntityForbiddenBrandUpsertWithWhereUniqueWithoutEntityInput = {
    where: EntityForbiddenBrandWhereUniqueInput
    update: XOR<EntityForbiddenBrandUpdateWithoutEntityInput, EntityForbiddenBrandUncheckedUpdateWithoutEntityInput>
    create: XOR<EntityForbiddenBrandCreateWithoutEntityInput, EntityForbiddenBrandUncheckedCreateWithoutEntityInput>
  }

  export type EntityForbiddenBrandUpdateWithWhereUniqueWithoutEntityInput = {
    where: EntityForbiddenBrandWhereUniqueInput
    data: XOR<EntityForbiddenBrandUpdateWithoutEntityInput, EntityForbiddenBrandUncheckedUpdateWithoutEntityInput>
  }

  export type EntityForbiddenBrandUpdateManyWithWhereWithoutEntityInput = {
    where: EntityForbiddenBrandScalarWhereInput
    data: XOR<EntityForbiddenBrandUpdateManyMutationInput, EntityForbiddenBrandUncheckedUpdateManyWithoutEntityInput>
  }

  export type EntityForbiddenBrandScalarWhereInput = {
    AND?: EntityForbiddenBrandScalarWhereInput | EntityForbiddenBrandScalarWhereInput[]
    OR?: EntityForbiddenBrandScalarWhereInput[]
    NOT?: EntityForbiddenBrandScalarWhereInput | EntityForbiddenBrandScalarWhereInput[]
    id?: IntFilter<"EntityForbiddenBrand"> | number
    name?: StringFilter<"EntityForbiddenBrand"> | string
    entityId?: IntFilter<"EntityForbiddenBrand"> | number
    createdAt?: DateTimeFilter<"EntityForbiddenBrand"> | Date | string
    updatedAt?: DateTimeFilter<"EntityForbiddenBrand"> | Date | string
  }

  export type EntityCreateWithoutEntityForbiddenWebsitesInput = {
    commonDbEntitiesId: number
    commonContractorId?: number | null
    name: string
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractCreateNestedManyWithoutEntityInput
    objects?: ObjectCreateNestedManyWithoutEntityInput
    entityForbiddenBrands?: EntityForbiddenBrandCreateNestedManyWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutEntityForbiddenWebsitesInput = {
    id?: number
    commonDbEntitiesId: number
    commonContractorId?: number | null
    name: string
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractUncheckedCreateNestedManyWithoutEntityInput
    objects?: ObjectUncheckedCreateNestedManyWithoutEntityInput
    entityForbiddenBrands?: EntityForbiddenBrandUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutEntityForbiddenWebsitesInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutEntityForbiddenWebsitesInput, EntityUncheckedCreateWithoutEntityForbiddenWebsitesInput>
  }

  export type EntityUpsertWithoutEntityForbiddenWebsitesInput = {
    update: XOR<EntityUpdateWithoutEntityForbiddenWebsitesInput, EntityUncheckedUpdateWithoutEntityForbiddenWebsitesInput>
    create: XOR<EntityCreateWithoutEntityForbiddenWebsitesInput, EntityUncheckedCreateWithoutEntityForbiddenWebsitesInput>
    where?: EntityWhereInput
  }

  export type EntityUpdateToOneWithWhereWithoutEntityForbiddenWebsitesInput = {
    where?: EntityWhereInput
    data: XOR<EntityUpdateWithoutEntityForbiddenWebsitesInput, EntityUncheckedUpdateWithoutEntityForbiddenWebsitesInput>
  }

  export type EntityUpdateWithoutEntityForbiddenWebsitesInput = {
    commonDbEntitiesId?: IntFieldUpdateOperationsInput | number
    commonContractorId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUpdateManyWithoutEntityNestedInput
    objects?: ObjectUpdateManyWithoutEntityNestedInput
    entityForbiddenBrands?: EntityForbiddenBrandUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutEntityForbiddenWebsitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbEntitiesId?: IntFieldUpdateOperationsInput | number
    commonContractorId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUncheckedUpdateManyWithoutEntityNestedInput
    objects?: ObjectUncheckedUpdateManyWithoutEntityNestedInput
    entityForbiddenBrands?: EntityForbiddenBrandUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type EntityCreateWithoutEntityForbiddenBrandsInput = {
    commonDbEntitiesId: number
    commonContractorId?: number | null
    name: string
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractCreateNestedManyWithoutEntityInput
    objects?: ObjectCreateNestedManyWithoutEntityInput
    entityForbiddenWebsites?: EntityForbiddenWebsiteCreateNestedManyWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutEntityForbiddenBrandsInput = {
    id?: number
    commonDbEntitiesId: number
    commonContractorId?: number | null
    name: string
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractUncheckedCreateNestedManyWithoutEntityInput
    objects?: ObjectUncheckedCreateNestedManyWithoutEntityInput
    entityForbiddenWebsites?: EntityForbiddenWebsiteUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutEntityForbiddenBrandsInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutEntityForbiddenBrandsInput, EntityUncheckedCreateWithoutEntityForbiddenBrandsInput>
  }

  export type EntityUpsertWithoutEntityForbiddenBrandsInput = {
    update: XOR<EntityUpdateWithoutEntityForbiddenBrandsInput, EntityUncheckedUpdateWithoutEntityForbiddenBrandsInput>
    create: XOR<EntityCreateWithoutEntityForbiddenBrandsInput, EntityUncheckedCreateWithoutEntityForbiddenBrandsInput>
    where?: EntityWhereInput
  }

  export type EntityUpdateToOneWithWhereWithoutEntityForbiddenBrandsInput = {
    where?: EntityWhereInput
    data: XOR<EntityUpdateWithoutEntityForbiddenBrandsInput, EntityUncheckedUpdateWithoutEntityForbiddenBrandsInput>
  }

  export type EntityUpdateWithoutEntityForbiddenBrandsInput = {
    commonDbEntitiesId?: IntFieldUpdateOperationsInput | number
    commonContractorId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUpdateManyWithoutEntityNestedInput
    objects?: ObjectUpdateManyWithoutEntityNestedInput
    entityForbiddenWebsites?: EntityForbiddenWebsiteUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutEntityForbiddenBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbEntitiesId?: IntFieldUpdateOperationsInput | number
    commonContractorId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUncheckedUpdateManyWithoutEntityNestedInput
    objects?: ObjectUncheckedUpdateManyWithoutEntityNestedInput
    entityForbiddenWebsites?: EntityForbiddenWebsiteUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type ClientContractCreateWithoutBankInput = {
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActCreateNestedOneWithoutClientContractInput
    dduClientContractProperties?: DduClientContractPropertiesCreateNestedOneWithoutClientContractInput
    dkpClientContractProperties?: DkpClientContractPropertiesCreateNestedOneWithoutClientContractInput
    product: ProductCreateNestedOneWithoutClientContractInput
    object: ObjectCreateNestedOneWithoutClientContractsInput
    realEstateAgent?: RealEstateAgentCreateNestedOneWithoutClientContractsInput
    manager?: UserCreateNestedOneWithoutClientContractsInput
    subsidy?: SubsidyCreateNestedOneWithoutClientContractsInput
    scheduledPayments?: ScheduledPaymentCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractUncheckedCreateWithoutBankInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    realEstateAgentId?: number | null
    managerId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActUncheckedCreateNestedOneWithoutClientContractInput
    scheduledPayments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentUncheckedCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractCreateOrConnectWithoutBankInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutBankInput, ClientContractUncheckedCreateWithoutBankInput>
  }

  export type ClientContractCreateManyBankInputEnvelope = {
    data: ClientContractCreateManyBankInput | ClientContractCreateManyBankInput[]
    skipDuplicates?: boolean
  }

  export type ClientContractUpsertWithWhereUniqueWithoutBankInput = {
    where: ClientContractWhereUniqueInput
    update: XOR<ClientContractUpdateWithoutBankInput, ClientContractUncheckedUpdateWithoutBankInput>
    create: XOR<ClientContractCreateWithoutBankInput, ClientContractUncheckedCreateWithoutBankInput>
  }

  export type ClientContractUpdateWithWhereUniqueWithoutBankInput = {
    where: ClientContractWhereUniqueInput
    data: XOR<ClientContractUpdateWithoutBankInput, ClientContractUncheckedUpdateWithoutBankInput>
  }

  export type ClientContractUpdateManyWithWhereWithoutBankInput = {
    where: ClientContractScalarWhereInput
    data: XOR<ClientContractUpdateManyMutationInput, ClientContractUncheckedUpdateManyWithoutBankInput>
  }

  export type ClientContractCreateWithoutRealEstateAgencyActsInput = {
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActCreateNestedOneWithoutClientContractInput
    dduClientContractProperties?: DduClientContractPropertiesCreateNestedOneWithoutClientContractInput
    dkpClientContractProperties?: DkpClientContractPropertiesCreateNestedOneWithoutClientContractInput
    product: ProductCreateNestedOneWithoutClientContractInput
    object: ObjectCreateNestedOneWithoutClientContractsInput
    realEstateAgent?: RealEstateAgentCreateNestedOneWithoutClientContractsInput
    manager?: UserCreateNestedOneWithoutClientContractsInput
    bank?: BankCreateNestedOneWithoutClientContractsInput
    subsidy?: SubsidyCreateNestedOneWithoutClientContractsInput
    scheduledPayments?: ScheduledPaymentCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractUncheckedCreateWithoutRealEstateAgencyActsInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    realEstateAgentId?: number | null
    managerId?: number | null
    bankId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActUncheckedCreateNestedOneWithoutClientContractInput
    scheduledPayments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentUncheckedCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractCreateOrConnectWithoutRealEstateAgencyActsInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutRealEstateAgencyActsInput, ClientContractUncheckedCreateWithoutRealEstateAgencyActsInput>
  }

  export type AgencyCreateWithoutRealEstateAgencyActsInput = {
    commonDbContractorsId: number
    name: string
    inn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractCreateNestedManyWithoutAgencyInput
    agencyContractSignatory?: AgencyContractSignatoryCreateNestedManyWithoutAgencyInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutRealEstateAgencyActsInput = {
    id?: number
    commonDbContractorsId: number
    name: string
    inn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyContracts?: AgencyContractUncheckedCreateNestedManyWithoutAgencyInput
    agencyContractSignatory?: AgencyContractSignatoryUncheckedCreateNestedManyWithoutAgencyInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutRealEstateAgencyActsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutRealEstateAgencyActsInput, AgencyUncheckedCreateWithoutRealEstateAgencyActsInput>
  }

  export type AgencyContractCreateWithoutRealEstateAgencyActInput = {
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responsibleUser?: UserCreateNestedOneWithoutAgencyContractsInput
    entity: EntityCreateNestedOneWithoutAgencyContractsInput
    object: ObjectCreateNestedOneWithoutAgencyContractsInput
    agency: AgencyCreateNestedOneWithoutAgencyContractsInput
    agencyContractSignatory?: AgencyContractSignatoryCreateNestedOneWithoutAgencyContractsInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesCreateNestedOneWithoutAgencyContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractUncheckedCreateWithoutRealEstateAgencyActInput = {
    id?: number
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    responsibleUserId?: number | null
    entityId: number
    objectId: number
    agencyId: number
    agencyContractSignatoryId?: number | null
    realEstateAgencyContractPropertiesId?: number | null
    mipAgencyContractPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutAgencyContractInput
  }

  export type AgencyContractCreateOrConnectWithoutRealEstateAgencyActInput = {
    where: AgencyContractWhereUniqueInput
    create: XOR<AgencyContractCreateWithoutRealEstateAgencyActInput, AgencyContractUncheckedCreateWithoutRealEstateAgencyActInput>
  }

  export type ClientContractUpsertWithoutRealEstateAgencyActsInput = {
    update: XOR<ClientContractUpdateWithoutRealEstateAgencyActsInput, ClientContractUncheckedUpdateWithoutRealEstateAgencyActsInput>
    create: XOR<ClientContractCreateWithoutRealEstateAgencyActsInput, ClientContractUncheckedCreateWithoutRealEstateAgencyActsInput>
    where?: ClientContractWhereInput
  }

  export type ClientContractUpdateToOneWithWhereWithoutRealEstateAgencyActsInput = {
    where?: ClientContractWhereInput
    data: XOR<ClientContractUpdateWithoutRealEstateAgencyActsInput, ClientContractUncheckedUpdateWithoutRealEstateAgencyActsInput>
  }

  export type ClientContractUpdateWithoutRealEstateAgencyActsInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneWithoutClientContractNestedInput
    dduClientContractProperties?: DduClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    dkpClientContractProperties?: DkpClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    product?: ProductUpdateOneRequiredWithoutClientContractNestedInput
    object?: ObjectUpdateOneRequiredWithoutClientContractsNestedInput
    realEstateAgent?: RealEstateAgentUpdateOneWithoutClientContractsNestedInput
    manager?: UserUpdateOneWithoutClientContractsNestedInput
    bank?: BankUpdateOneWithoutClientContractsNestedInput
    subsidy?: SubsidyUpdateOneWithoutClientContractsNestedInput
    scheduledPayments?: ScheduledPaymentUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutRealEstateAgencyActsInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUncheckedUpdateOneWithoutClientContractNestedInput
    scheduledPayments?: ScheduledPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClientContractNestedInput
  }

  export type AgencyUpsertWithoutRealEstateAgencyActsInput = {
    update: XOR<AgencyUpdateWithoutRealEstateAgencyActsInput, AgencyUncheckedUpdateWithoutRealEstateAgencyActsInput>
    create: XOR<AgencyCreateWithoutRealEstateAgencyActsInput, AgencyUncheckedCreateWithoutRealEstateAgencyActsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutRealEstateAgencyActsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutRealEstateAgencyActsInput, AgencyUncheckedUpdateWithoutRealEstateAgencyActsInput>
  }

  export type AgencyUpdateWithoutRealEstateAgencyActsInput = {
    commonDbContractorsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUpdateManyWithoutAgencyNestedInput
    agencyContractSignatory?: AgencyContractSignatoryUpdateManyWithoutAgencyNestedInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutRealEstateAgencyActsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbContractorsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUncheckedUpdateManyWithoutAgencyNestedInput
    agencyContractSignatory?: AgencyContractSignatoryUncheckedUpdateManyWithoutAgencyNestedInput
    agenciesToRealEstateAgents?: AgencyToRealEstateAgentUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyContractUpsertWithoutRealEstateAgencyActInput = {
    update: XOR<AgencyContractUpdateWithoutRealEstateAgencyActInput, AgencyContractUncheckedUpdateWithoutRealEstateAgencyActInput>
    create: XOR<AgencyContractCreateWithoutRealEstateAgencyActInput, AgencyContractUncheckedCreateWithoutRealEstateAgencyActInput>
    where?: AgencyContractWhereInput
  }

  export type AgencyContractUpdateToOneWithWhereWithoutRealEstateAgencyActInput = {
    where?: AgencyContractWhereInput
    data: XOR<AgencyContractUpdateWithoutRealEstateAgencyActInput, AgencyContractUncheckedUpdateWithoutRealEstateAgencyActInput>
  }

  export type AgencyContractUpdateWithoutRealEstateAgencyActInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUser?: UserUpdateOneWithoutAgencyContractsNestedInput
    entity?: EntityUpdateOneRequiredWithoutAgencyContractsNestedInput
    object?: ObjectUpdateOneRequiredWithoutAgencyContractsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgencyContractsNestedInput
    agencyContractSignatory?: AgencyContractSignatoryUpdateOneWithoutAgencyContractsNestedInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutAgencyContractNestedInput
  }

  export type AgencyContractUncheckedUpdateWithoutRealEstateAgencyActInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    entityId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    agencyContractSignatoryId?: NullableIntFieldUpdateOperationsInput | number | null
    realEstateAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    mipAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutAgencyContractNestedInput
  }

  export type ClientContractCreateWithoutSubsidyInput = {
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActCreateNestedOneWithoutClientContractInput
    dduClientContractProperties?: DduClientContractPropertiesCreateNestedOneWithoutClientContractInput
    dkpClientContractProperties?: DkpClientContractPropertiesCreateNestedOneWithoutClientContractInput
    product: ProductCreateNestedOneWithoutClientContractInput
    object: ObjectCreateNestedOneWithoutClientContractsInput
    realEstateAgent?: RealEstateAgentCreateNestedOneWithoutClientContractsInput
    manager?: UserCreateNestedOneWithoutClientContractsInput
    bank?: BankCreateNestedOneWithoutClientContractsInput
    scheduledPayments?: ScheduledPaymentCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractUncheckedCreateWithoutSubsidyInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    realEstateAgentId?: number | null
    managerId?: number | null
    bankId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActUncheckedCreateNestedOneWithoutClientContractInput
    scheduledPayments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentUncheckedCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractCreateOrConnectWithoutSubsidyInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutSubsidyInput, ClientContractUncheckedCreateWithoutSubsidyInput>
  }

  export type ClientContractCreateManySubsidyInputEnvelope = {
    data: ClientContractCreateManySubsidyInput | ClientContractCreateManySubsidyInput[]
    skipDuplicates?: boolean
  }

  export type ClientContractUpsertWithWhereUniqueWithoutSubsidyInput = {
    where: ClientContractWhereUniqueInput
    update: XOR<ClientContractUpdateWithoutSubsidyInput, ClientContractUncheckedUpdateWithoutSubsidyInput>
    create: XOR<ClientContractCreateWithoutSubsidyInput, ClientContractUncheckedCreateWithoutSubsidyInput>
  }

  export type ClientContractUpdateWithWhereUniqueWithoutSubsidyInput = {
    where: ClientContractWhereUniqueInput
    data: XOR<ClientContractUpdateWithoutSubsidyInput, ClientContractUncheckedUpdateWithoutSubsidyInput>
  }

  export type ClientContractUpdateManyWithWhereWithoutSubsidyInput = {
    where: ClientContractScalarWhereInput
    data: XOR<ClientContractUpdateManyMutationInput, ClientContractUncheckedUpdateManyWithoutSubsidyInput>
  }

  export type ClientContractCreateWithoutAssignmentsInput = {
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActCreateNestedOneWithoutClientContractInput
    dduClientContractProperties?: DduClientContractPropertiesCreateNestedOneWithoutClientContractInput
    dkpClientContractProperties?: DkpClientContractPropertiesCreateNestedOneWithoutClientContractInput
    product: ProductCreateNestedOneWithoutClientContractInput
    object: ObjectCreateNestedOneWithoutClientContractsInput
    realEstateAgent?: RealEstateAgentCreateNestedOneWithoutClientContractsInput
    manager?: UserCreateNestedOneWithoutClientContractsInput
    bank?: BankCreateNestedOneWithoutClientContractsInput
    subsidy?: SubsidyCreateNestedOneWithoutClientContractsInput
    scheduledPayments?: ScheduledPaymentCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    realEstateAgentId?: number | null
    managerId?: number | null
    bankId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct?: TransferActUncheckedCreateNestedOneWithoutClientContractInput
    scheduledPayments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentUncheckedCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractCreateOrConnectWithoutAssignmentsInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutAssignmentsInput, ClientContractUncheckedCreateWithoutAssignmentsInput>
  }

  export type ClientCreateWithoutAssignmentsInput = {
    fullName: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    clientCategory: $Enums.ClientCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    clientIndividualProperties?: ClientIndividualPropertiesCreateNestedOneWithoutClientInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesCreateNestedOneWithoutClientInput
    clientEntityProperties?: ClientEntityPropertiesCreateNestedOneWithoutClientInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClientInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientInput
    representatives?: RepresentativeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    fullName: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    clientCategory: $Enums.ClientCategory
    clientIndividualPropertiesId?: number | null
    clientIndividualMinorPropertiesId?: number | null
    clientEntityPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClientInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientInput
    representatives?: RepresentativeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutAssignmentsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAssignmentsInput, ClientUncheckedCreateWithoutAssignmentsInput>
  }

  export type ClientContractUpsertWithoutAssignmentsInput = {
    update: XOR<ClientContractUpdateWithoutAssignmentsInput, ClientContractUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<ClientContractCreateWithoutAssignmentsInput, ClientContractUncheckedCreateWithoutAssignmentsInput>
    where?: ClientContractWhereInput
  }

  export type ClientContractUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: ClientContractWhereInput
    data: XOR<ClientContractUpdateWithoutAssignmentsInput, ClientContractUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ClientContractUpdateWithoutAssignmentsInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneWithoutClientContractNestedInput
    dduClientContractProperties?: DduClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    dkpClientContractProperties?: DkpClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    product?: ProductUpdateOneRequiredWithoutClientContractNestedInput
    object?: ObjectUpdateOneRequiredWithoutClientContractsNestedInput
    realEstateAgent?: RealEstateAgentUpdateOneWithoutClientContractsNestedInput
    manager?: UserUpdateOneWithoutClientContractsNestedInput
    bank?: BankUpdateOneWithoutClientContractsNestedInput
    subsidy?: SubsidyUpdateOneWithoutClientContractsNestedInput
    scheduledPayments?: ScheduledPaymentUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUncheckedUpdateOneWithoutClientContractNestedInput
    scheduledPayments?: ScheduledPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClientContractNestedInput
  }

  export type ClientUpsertWithoutAssignmentsInput = {
    update: XOR<ClientUpdateWithoutAssignmentsInput, ClientUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<ClientCreateWithoutAssignmentsInput, ClientUncheckedCreateWithoutAssignmentsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutAssignmentsInput, ClientUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ClientUpdateWithoutAssignmentsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    clientCategory?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientIndividualProperties?: ClientIndividualPropertiesUpdateOneWithoutClientNestedInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesUpdateOneWithoutClientNestedInput
    clientEntityProperties?: ClientEntityPropertiesUpdateOneWithoutClientNestedInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUpdateManyWithoutClientNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientNestedInput
    representatives?: RepresentativeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    clientCategory?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    clientIndividualPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    clientIndividualMinorPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    clientEntityPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientNestedInput
    representatives?: RepresentativeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientContractCreateWithoutTransferActInput = {
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dduClientContractProperties?: DduClientContractPropertiesCreateNestedOneWithoutClientContractInput
    dkpClientContractProperties?: DkpClientContractPropertiesCreateNestedOneWithoutClientContractInput
    product: ProductCreateNestedOneWithoutClientContractInput
    object: ObjectCreateNestedOneWithoutClientContractsInput
    realEstateAgent?: RealEstateAgentCreateNestedOneWithoutClientContractsInput
    manager?: UserCreateNestedOneWithoutClientContractsInput
    bank?: BankCreateNestedOneWithoutClientContractsInput
    subsidy?: SubsidyCreateNestedOneWithoutClientContractsInput
    scheduledPayments?: ScheduledPaymentCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractUncheckedCreateWithoutTransferActInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    realEstateAgentId?: number | null
    managerId?: number | null
    bankId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scheduledPayments?: ScheduledPaymentUncheckedCreateNestedManyWithoutClientContractInput
    actualPayments?: ActualPaymentUncheckedCreateNestedManyWithoutClientContractInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedCreateNestedManyWithoutClientContractInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientContractInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedCreateNestedManyWithoutClientContractInput
  }

  export type ClientContractCreateOrConnectWithoutTransferActInput = {
    where: ClientContractWhereUniqueInput
    create: XOR<ClientContractCreateWithoutTransferActInput, ClientContractUncheckedCreateWithoutTransferActInput>
  }

  export type ObjectCreateWithoutTransferActsInput = {
    commonDbObjectsId: number
    name: string
    dateIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entity: EntityCreateNestedOneWithoutObjectsInput
    products?: ProductCreateNestedManyWithoutObjectInput
    clientContracts?: ClientContractCreateNestedManyWithoutObjectInput
    agencyContracts?: AgencyContractCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutTransferActsInput = {
    id?: number
    commonDbObjectsId: number
    name: string
    dateIn?: Date | string | null
    entityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutObjectInput
    clientContracts?: ClientContractUncheckedCreateNestedManyWithoutObjectInput
    agencyContracts?: AgencyContractUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutTransferActsInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutTransferActsInput, ObjectUncheckedCreateWithoutTransferActsInput>
  }

  export type ProductCreateWithoutTransferActInput = {
    pricingProductsId: number
    number: string
    productCategory: $Enums.ProductCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract?: ClientContractCreateNestedOneWithoutProductInput
    object: ObjectCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutTransferActInput = {
    id?: number
    pricingProductsId: number
    number: string
    productCategory: $Enums.ProductCategory
    objectId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract?: ClientContractUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTransferActInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTransferActInput, ProductUncheckedCreateWithoutTransferActInput>
  }

  export type TransferActToRepresentativeCreateWithoutTransferActInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    representative: RepresentativeCreateNestedOneWithoutTransferActsToRepresentativesInput
  }

  export type TransferActToRepresentativeUncheckedCreateWithoutTransferActInput = {
    representativeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferActToRepresentativeCreateOrConnectWithoutTransferActInput = {
    where: TransferActToRepresentativeWhereUniqueInput
    create: XOR<TransferActToRepresentativeCreateWithoutTransferActInput, TransferActToRepresentativeUncheckedCreateWithoutTransferActInput>
  }

  export type TransferActToRepresentativeCreateManyTransferActInputEnvelope = {
    data: TransferActToRepresentativeCreateManyTransferActInput | TransferActToRepresentativeCreateManyTransferActInput[]
    skipDuplicates?: boolean
  }

  export type ClientContractUpsertWithoutTransferActInput = {
    update: XOR<ClientContractUpdateWithoutTransferActInput, ClientContractUncheckedUpdateWithoutTransferActInput>
    create: XOR<ClientContractCreateWithoutTransferActInput, ClientContractUncheckedCreateWithoutTransferActInput>
    where?: ClientContractWhereInput
  }

  export type ClientContractUpdateToOneWithWhereWithoutTransferActInput = {
    where?: ClientContractWhereInput
    data: XOR<ClientContractUpdateWithoutTransferActInput, ClientContractUncheckedUpdateWithoutTransferActInput>
  }

  export type ClientContractUpdateWithoutTransferActInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dduClientContractProperties?: DduClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    dkpClientContractProperties?: DkpClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    product?: ProductUpdateOneRequiredWithoutClientContractNestedInput
    object?: ObjectUpdateOneRequiredWithoutClientContractsNestedInput
    realEstateAgent?: RealEstateAgentUpdateOneWithoutClientContractsNestedInput
    manager?: UserUpdateOneWithoutClientContractsNestedInput
    bank?: BankUpdateOneWithoutClientContractsNestedInput
    subsidy?: SubsidyUpdateOneWithoutClientContractsNestedInput
    scheduledPayments?: ScheduledPaymentUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutTransferActInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledPayments?: ScheduledPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClientContractNestedInput
  }

  export type ObjectUpsertWithoutTransferActsInput = {
    update: XOR<ObjectUpdateWithoutTransferActsInput, ObjectUncheckedUpdateWithoutTransferActsInput>
    create: XOR<ObjectCreateWithoutTransferActsInput, ObjectUncheckedCreateWithoutTransferActsInput>
    where?: ObjectWhereInput
  }

  export type ObjectUpdateToOneWithWhereWithoutTransferActsInput = {
    where?: ObjectWhereInput
    data: XOR<ObjectUpdateWithoutTransferActsInput, ObjectUncheckedUpdateWithoutTransferActsInput>
  }

  export type ObjectUpdateWithoutTransferActsInput = {
    commonDbObjectsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: EntityUpdateOneRequiredWithoutObjectsNestedInput
    products?: ProductUpdateManyWithoutObjectNestedInput
    clientContracts?: ClientContractUpdateManyWithoutObjectNestedInput
    agencyContracts?: AgencyContractUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutTransferActsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbObjectsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutObjectNestedInput
    clientContracts?: ClientContractUncheckedUpdateManyWithoutObjectNestedInput
    agencyContracts?: AgencyContractUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type ProductUpsertWithoutTransferActInput = {
    update: XOR<ProductUpdateWithoutTransferActInput, ProductUncheckedUpdateWithoutTransferActInput>
    create: XOR<ProductCreateWithoutTransferActInput, ProductUncheckedCreateWithoutTransferActInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutTransferActInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutTransferActInput, ProductUncheckedUpdateWithoutTransferActInput>
  }

  export type ProductUpdateWithoutTransferActInput = {
    pricingProductsId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    productCategory?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUpdateOneWithoutProductNestedInput
    object?: ObjectUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutTransferActInput = {
    id?: IntFieldUpdateOperationsInput | number
    pricingProductsId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    productCategory?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    objectId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUncheckedUpdateOneWithoutProductNestedInput
  }

  export type TransferActToRepresentativeUpsertWithWhereUniqueWithoutTransferActInput = {
    where: TransferActToRepresentativeWhereUniqueInput
    update: XOR<TransferActToRepresentativeUpdateWithoutTransferActInput, TransferActToRepresentativeUncheckedUpdateWithoutTransferActInput>
    create: XOR<TransferActToRepresentativeCreateWithoutTransferActInput, TransferActToRepresentativeUncheckedCreateWithoutTransferActInput>
  }

  export type TransferActToRepresentativeUpdateWithWhereUniqueWithoutTransferActInput = {
    where: TransferActToRepresentativeWhereUniqueInput
    data: XOR<TransferActToRepresentativeUpdateWithoutTransferActInput, TransferActToRepresentativeUncheckedUpdateWithoutTransferActInput>
  }

  export type TransferActToRepresentativeUpdateManyWithWhereWithoutTransferActInput = {
    where: TransferActToRepresentativeScalarWhereInput
    data: XOR<TransferActToRepresentativeUpdateManyMutationInput, TransferActToRepresentativeUncheckedUpdateManyWithoutTransferActInput>
  }

  export type TransferActToRepresentativeScalarWhereInput = {
    AND?: TransferActToRepresentativeScalarWhereInput | TransferActToRepresentativeScalarWhereInput[]
    OR?: TransferActToRepresentativeScalarWhereInput[]
    NOT?: TransferActToRepresentativeScalarWhereInput | TransferActToRepresentativeScalarWhereInput[]
    transferActId?: IntFilter<"TransferActToRepresentative"> | number
    representativeId?: IntFilter<"TransferActToRepresentative"> | number
    createdAt?: DateTimeFilter<"TransferActToRepresentative"> | Date | string
    updatedAt?: DateTimeFilter<"TransferActToRepresentative"> | Date | string
  }

  export type ClientCreateWithoutRepresentativesInput = {
    fullName: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    clientCategory: $Enums.ClientCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    clientIndividualProperties?: ClientIndividualPropertiesCreateNestedOneWithoutClientInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesCreateNestedOneWithoutClientInput
    clientEntityProperties?: ClientEntityPropertiesCreateNestedOneWithoutClientInput
    assignments?: AssignmentCreateNestedManyWithoutClientInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesCreateNestedManyWithoutClientInput
    clientContractsToClients?: ClientContractToClientCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutRepresentativesInput = {
    id?: number
    fullName: string
    inn?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    clientCategory: $Enums.ClientCategory
    clientIndividualPropertiesId?: number | null
    clientIndividualMinorPropertiesId?: number | null
    clientEntityPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedCreateNestedManyWithoutClientInput
    clientContractsToClients?: ClientContractToClientUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutRepresentativesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutRepresentativesInput, ClientUncheckedCreateWithoutRepresentativesInput>
  }

  export type TransferActToRepresentativeCreateWithoutRepresentativeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    transferAct: TransferActCreateNestedOneWithoutTransferActsToRepresentativesInput
  }

  export type TransferActToRepresentativeUncheckedCreateWithoutRepresentativeInput = {
    transferActId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferActToRepresentativeCreateOrConnectWithoutRepresentativeInput = {
    where: TransferActToRepresentativeWhereUniqueInput
    create: XOR<TransferActToRepresentativeCreateWithoutRepresentativeInput, TransferActToRepresentativeUncheckedCreateWithoutRepresentativeInput>
  }

  export type TransferActToRepresentativeCreateManyRepresentativeInputEnvelope = {
    data: TransferActToRepresentativeCreateManyRepresentativeInput | TransferActToRepresentativeCreateManyRepresentativeInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutRepresentativesInput = {
    update: XOR<ClientUpdateWithoutRepresentativesInput, ClientUncheckedUpdateWithoutRepresentativesInput>
    create: XOR<ClientCreateWithoutRepresentativesInput, ClientUncheckedCreateWithoutRepresentativesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutRepresentativesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutRepresentativesInput, ClientUncheckedUpdateWithoutRepresentativesInput>
  }

  export type ClientUpdateWithoutRepresentativesInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    clientCategory?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientIndividualProperties?: ClientIndividualPropertiesUpdateOneWithoutClientNestedInput
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesUpdateOneWithoutClientNestedInput
    clientEntityProperties?: ClientEntityPropertiesUpdateOneWithoutClientNestedInput
    assignments?: AssignmentUpdateManyWithoutClientNestedInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUpdateManyWithoutClientNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutRepresentativesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    inn?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    clientCategory?: EnumClientCategoryFieldUpdateOperationsInput | $Enums.ClientCategory
    clientIndividualPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    clientIndividualMinorPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    clientEntityPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutClientNestedInput
    clientsToClientIndividualMinorProperties?: ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientNestedInput
  }

  export type TransferActToRepresentativeUpsertWithWhereUniqueWithoutRepresentativeInput = {
    where: TransferActToRepresentativeWhereUniqueInput
    update: XOR<TransferActToRepresentativeUpdateWithoutRepresentativeInput, TransferActToRepresentativeUncheckedUpdateWithoutRepresentativeInput>
    create: XOR<TransferActToRepresentativeCreateWithoutRepresentativeInput, TransferActToRepresentativeUncheckedCreateWithoutRepresentativeInput>
  }

  export type TransferActToRepresentativeUpdateWithWhereUniqueWithoutRepresentativeInput = {
    where: TransferActToRepresentativeWhereUniqueInput
    data: XOR<TransferActToRepresentativeUpdateWithoutRepresentativeInput, TransferActToRepresentativeUncheckedUpdateWithoutRepresentativeInput>
  }

  export type TransferActToRepresentativeUpdateManyWithWhereWithoutRepresentativeInput = {
    where: TransferActToRepresentativeScalarWhereInput
    data: XOR<TransferActToRepresentativeUpdateManyMutationInput, TransferActToRepresentativeUncheckedUpdateManyWithoutRepresentativeInput>
  }

  export type TransferActCreateWithoutTransferActsToRepresentativesInput = {
    number: string
    date: Date | string
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientContract: ClientContractCreateNestedOneWithoutTransferActInput
    object: ObjectCreateNestedOneWithoutTransferActsInput
    product: ProductCreateNestedOneWithoutTransferActInput
  }

  export type TransferActUncheckedCreateWithoutTransferActsToRepresentativesInput = {
    id?: number
    number: string
    date: Date | string
    link?: string | null
    clientContractId: number
    objectId: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferActCreateOrConnectWithoutTransferActsToRepresentativesInput = {
    where: TransferActWhereUniqueInput
    create: XOR<TransferActCreateWithoutTransferActsToRepresentativesInput, TransferActUncheckedCreateWithoutTransferActsToRepresentativesInput>
  }

  export type RepresentativeCreateWithoutTransferActsToRepresentativesInput = {
    fullName: string
    attorneyNumber?: string | null
    attorneyDate?: Date | string | null
    authorizedBy?: string | null
    authorizedRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutRepresentativesInput
  }

  export type RepresentativeUncheckedCreateWithoutTransferActsToRepresentativesInput = {
    id?: number
    fullName: string
    attorneyNumber?: string | null
    attorneyDate?: Date | string | null
    authorizedBy?: string | null
    authorizedRole?: string | null
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RepresentativeCreateOrConnectWithoutTransferActsToRepresentativesInput = {
    where: RepresentativeWhereUniqueInput
    create: XOR<RepresentativeCreateWithoutTransferActsToRepresentativesInput, RepresentativeUncheckedCreateWithoutTransferActsToRepresentativesInput>
  }

  export type TransferActUpsertWithoutTransferActsToRepresentativesInput = {
    update: XOR<TransferActUpdateWithoutTransferActsToRepresentativesInput, TransferActUncheckedUpdateWithoutTransferActsToRepresentativesInput>
    create: XOR<TransferActCreateWithoutTransferActsToRepresentativesInput, TransferActUncheckedCreateWithoutTransferActsToRepresentativesInput>
    where?: TransferActWhereInput
  }

  export type TransferActUpdateToOneWithWhereWithoutTransferActsToRepresentativesInput = {
    where?: TransferActWhereInput
    data: XOR<TransferActUpdateWithoutTransferActsToRepresentativesInput, TransferActUncheckedUpdateWithoutTransferActsToRepresentativesInput>
  }

  export type TransferActUpdateWithoutTransferActsToRepresentativesInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUpdateOneRequiredWithoutTransferActNestedInput
    object?: ObjectUpdateOneRequiredWithoutTransferActsNestedInput
    product?: ProductUpdateOneRequiredWithoutTransferActNestedInput
  }

  export type TransferActUncheckedUpdateWithoutTransferActsToRepresentativesInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    clientContractId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepresentativeUpsertWithoutTransferActsToRepresentativesInput = {
    update: XOR<RepresentativeUpdateWithoutTransferActsToRepresentativesInput, RepresentativeUncheckedUpdateWithoutTransferActsToRepresentativesInput>
    create: XOR<RepresentativeCreateWithoutTransferActsToRepresentativesInput, RepresentativeUncheckedCreateWithoutTransferActsToRepresentativesInput>
    where?: RepresentativeWhereInput
  }

  export type RepresentativeUpdateToOneWithWhereWithoutTransferActsToRepresentativesInput = {
    where?: RepresentativeWhereInput
    data: XOR<RepresentativeUpdateWithoutTransferActsToRepresentativesInput, RepresentativeUncheckedUpdateWithoutTransferActsToRepresentativesInput>
  }

  export type RepresentativeUpdateWithoutTransferActsToRepresentativesInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    attorneyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    attorneyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizedBy?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutRepresentativesNestedInput
  }

  export type RepresentativeUncheckedUpdateWithoutTransferActsToRepresentativesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    attorneyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    attorneyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizedBy?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedRole?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractCreateManyManagerInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    realEstateAgentId?: number | null
    bankId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyContractCreateManyResponsibleUserInput = {
    id?: number
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    entityId: number
    objectId: number
    agencyId: number
    agencyContractSignatoryId?: number | null
    realEstateAgencyContractPropertiesId?: number | null
    mipAgencyContractPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientContractUpdateWithoutManagerInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneWithoutClientContractNestedInput
    dduClientContractProperties?: DduClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    dkpClientContractProperties?: DkpClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    product?: ProductUpdateOneRequiredWithoutClientContractNestedInput
    object?: ObjectUpdateOneRequiredWithoutClientContractsNestedInput
    realEstateAgent?: RealEstateAgentUpdateOneWithoutClientContractsNestedInput
    bank?: BankUpdateOneWithoutClientContractsNestedInput
    subsidy?: SubsidyUpdateOneWithoutClientContractsNestedInput
    scheduledPayments?: ScheduledPaymentUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUncheckedUpdateOneWithoutClientContractNestedInput
    scheduledPayments?: ScheduledPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateManyWithoutManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyContractUpdateWithoutResponsibleUserInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: EntityUpdateOneRequiredWithoutAgencyContractsNestedInput
    object?: ObjectUpdateOneRequiredWithoutAgencyContractsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgencyContractsNestedInput
    agencyContractSignatory?: AgencyContractSignatoryUpdateOneWithoutAgencyContractsNestedInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput
    realEstateAgencyAct?: RealEstateAgencyActUpdateManyWithoutAgencyContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutAgencyContractNestedInput
  }

  export type AgencyContractUncheckedUpdateWithoutResponsibleUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    agencyContractSignatoryId?: NullableIntFieldUpdateOperationsInput | number | null
    realEstateAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    mipAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstateAgencyAct?: RealEstateAgencyActUncheckedUpdateManyWithoutAgencyContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutAgencyContractNestedInput
  }

  export type AgencyContractUncheckedUpdateManyWithoutResponsibleUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    agencyContractSignatoryId?: NullableIntFieldUpdateOperationsInput | number | null
    realEstateAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    mipAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentCreateManyClientInput = {
    id?: number
    order: number
    clientContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientToClientIndividualMinorPropertiesCreateManyClientInput = {
    clientIndividualMinorPropertiesId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientContractToClientCreateManyClientInput = {
    isMain: boolean
    share: number
    clientContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RepresentativeCreateManyClientInput = {
    id?: number
    fullName: string
    attorneyNumber?: string | null
    attorneyDate?: Date | string | null
    authorizedBy?: string | null
    authorizedRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentUpdateWithoutClientInput = {
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    clientContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    clientContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientToClientIndividualMinorPropertiesUpdateWithoutClientInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientIndividualMinorProperties?: ClientIndividualMinorPropertiesUpdateOneRequiredWithoutClientsToClientIndividualMinorPropertiesNestedInput
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedUpdateWithoutClientInput = {
    clientIndividualMinorPropertiesId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientInput = {
    clientIndividualMinorPropertiesId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToClientUpdateWithoutClientInput = {
    isMain?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUpdateOneRequiredWithoutClientContractsToClientsNestedInput
  }

  export type ClientContractToClientUncheckedUpdateWithoutClientInput = {
    isMain?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    clientContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToClientUncheckedUpdateManyWithoutClientInput = {
    isMain?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    clientContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepresentativeUpdateWithoutClientInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    attorneyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    attorneyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizedBy?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferActsToRepresentatives?: TransferActToRepresentativeUpdateManyWithoutRepresentativeNestedInput
  }

  export type RepresentativeUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    attorneyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    attorneyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizedBy?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferActsToRepresentatives?: TransferActToRepresentativeUncheckedUpdateManyWithoutRepresentativeNestedInput
  }

  export type RepresentativeUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    attorneyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    attorneyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizedBy?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientToClientIndividualMinorPropertiesCreateManyClientIndividualMinorPropertiesInput = {
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientToClientIndividualMinorPropertiesUpdateWithoutClientIndividualMinorPropertiesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutClientsToClientIndividualMinorPropertiesNestedInput
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedUpdateWithoutClientIndividualMinorPropertiesInput = {
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientToClientIndividualMinorPropertiesUncheckedUpdateManyWithoutClientIndividualMinorPropertiesInput = {
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPaymentCreateManyClientContractInput = {
    id?: number
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    scheduledPaymentType: $Enums.ScheduledPaymentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActualPaymentCreateManyClientContractInput = {
    id?: number
    payment: Decimal | DecimalJsLike | number | string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RealEstateAgencyActCreateManyClientContractInput = {
    id?: number
    number: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    retention?: Decimal | DecimalJsLike | number | string | null
    note?: string | null
    link?: string | null
    agencyId: number
    agencyContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateManyClientContractInput = {
    id?: number
    order: number
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientContractToClientCreateManyClientContractInput = {
    isMain: boolean
    share: number
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientContractToAgencyContractCreateManyClientContractInput = {
    agencyContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledPaymentUpdateWithoutClientContractInput = {
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledPaymentType?: EnumScheduledPaymentTypeFieldUpdateOperationsInput | $Enums.ScheduledPaymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPaymentUncheckedUpdateWithoutClientContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledPaymentType?: EnumScheduledPaymentTypeFieldUpdateOperationsInput | $Enums.ScheduledPaymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPaymentUncheckedUpdateManyWithoutClientContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledPaymentType?: EnumScheduledPaymentTypeFieldUpdateOperationsInput | $Enums.ScheduledPaymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActualPaymentUpdateWithoutClientContractInput = {
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActualPaymentUncheckedUpdateWithoutClientContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActualPaymentUncheckedUpdateManyWithoutClientContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealEstateAgencyActUpdateWithoutClientContractInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retention?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutRealEstateAgencyActsNestedInput
    agencyContract?: AgencyContractUpdateOneRequiredWithoutRealEstateAgencyActNestedInput
  }

  export type RealEstateAgencyActUncheckedUpdateWithoutClientContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retention?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: IntFieldUpdateOperationsInput | number
    agencyContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealEstateAgencyActUncheckedUpdateManyWithoutClientContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retention?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: IntFieldUpdateOperationsInput | number
    agencyContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUpdateWithoutClientContractInput = {
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutClientContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUncheckedUpdateManyWithoutClientContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToClientUpdateWithoutClientContractInput = {
    isMain?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutClientContractsToClientsNestedInput
  }

  export type ClientContractToClientUncheckedUpdateWithoutClientContractInput = {
    isMain?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToClientUncheckedUpdateManyWithoutClientContractInput = {
    isMain?: BoolFieldUpdateOperationsInput | boolean
    share?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToAgencyContractUpdateWithoutClientContractInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContract?: AgencyContractUpdateOneRequiredWithoutClientContractsToAgencyContractsNestedInput
  }

  export type ClientContractToAgencyContractUncheckedUpdateWithoutClientContractInput = {
    agencyContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToAgencyContractUncheckedUpdateManyWithoutClientContractInput = {
    agencyContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyObjectInput = {
    id?: number
    pricingProductsId: number
    number: string
    productCategory: $Enums.ProductCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientContractCreateManyObjectInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    realEstateAgentId?: number | null
    managerId?: number | null
    bankId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyContractCreateManyObjectInput = {
    id?: number
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    responsibleUserId?: number | null
    entityId: number
    agencyId: number
    agencyContractSignatoryId?: number | null
    realEstateAgencyContractPropertiesId?: number | null
    mipAgencyContractPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferActCreateManyObjectInput = {
    id?: number
    number: string
    date: Date | string
    link?: string | null
    clientContractId: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutObjectInput = {
    pricingProductsId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    productCategory?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneWithoutProductNestedInput
    clientContract?: ClientContractUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    pricingProductsId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    productCategory?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUncheckedUpdateOneWithoutProductNestedInput
    clientContract?: ClientContractUncheckedUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    pricingProductsId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    productCategory?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractUpdateWithoutObjectInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneWithoutClientContractNestedInput
    dduClientContractProperties?: DduClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    dkpClientContractProperties?: DkpClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    product?: ProductUpdateOneRequiredWithoutClientContractNestedInput
    realEstateAgent?: RealEstateAgentUpdateOneWithoutClientContractsNestedInput
    manager?: UserUpdateOneWithoutClientContractsNestedInput
    bank?: BankUpdateOneWithoutClientContractsNestedInput
    subsidy?: SubsidyUpdateOneWithoutClientContractsNestedInput
    scheduledPayments?: ScheduledPaymentUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUncheckedUpdateOneWithoutClientContractNestedInput
    scheduledPayments?: ScheduledPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateManyWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyContractUpdateWithoutObjectInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUser?: UserUpdateOneWithoutAgencyContractsNestedInput
    entity?: EntityUpdateOneRequiredWithoutAgencyContractsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgencyContractsNestedInput
    agencyContractSignatory?: AgencyContractSignatoryUpdateOneWithoutAgencyContractsNestedInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput
    realEstateAgencyAct?: RealEstateAgencyActUpdateManyWithoutAgencyContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutAgencyContractNestedInput
  }

  export type AgencyContractUncheckedUpdateWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    entityId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    agencyContractSignatoryId?: NullableIntFieldUpdateOperationsInput | number | null
    realEstateAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    mipAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstateAgencyAct?: RealEstateAgencyActUncheckedUpdateManyWithoutAgencyContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutAgencyContractNestedInput
  }

  export type AgencyContractUncheckedUpdateManyWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    entityId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    agencyContractSignatoryId?: NullableIntFieldUpdateOperationsInput | number | null
    realEstateAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    mipAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferActUpdateWithoutObjectInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUpdateOneRequiredWithoutTransferActNestedInput
    product?: ProductUpdateOneRequiredWithoutTransferActNestedInput
    transferActsToRepresentatives?: TransferActToRepresentativeUpdateManyWithoutTransferActNestedInput
  }

  export type TransferActUncheckedUpdateWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    clientContractId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferActsToRepresentatives?: TransferActToRepresentativeUncheckedUpdateManyWithoutTransferActNestedInput
  }

  export type TransferActUncheckedUpdateManyWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    clientContractId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyContractCreateManyAgencyInput = {
    id?: number
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    responsibleUserId?: number | null
    entityId: number
    objectId: number
    agencyContractSignatoryId?: number | null
    realEstateAgencyContractPropertiesId?: number | null
    mipAgencyContractPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyContractSignatoryCreateManyAgencyInput = {
    id?: number
    fullName: string
    basedOn?: string | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RealEstateAgencyActCreateManyAgencyInput = {
    id?: number
    number: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    retention?: Decimal | DecimalJsLike | number | string | null
    note?: string | null
    link?: string | null
    clientContractId: number
    agencyContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyToRealEstateAgentCreateManyAgencyInput = {
    realEstateAgentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyContractUpdateWithoutAgencyInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUser?: UserUpdateOneWithoutAgencyContractsNestedInput
    entity?: EntityUpdateOneRequiredWithoutAgencyContractsNestedInput
    object?: ObjectUpdateOneRequiredWithoutAgencyContractsNestedInput
    agencyContractSignatory?: AgencyContractSignatoryUpdateOneWithoutAgencyContractsNestedInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput
    realEstateAgencyAct?: RealEstateAgencyActUpdateManyWithoutAgencyContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutAgencyContractNestedInput
  }

  export type AgencyContractUncheckedUpdateWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    entityId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    agencyContractSignatoryId?: NullableIntFieldUpdateOperationsInput | number | null
    realEstateAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    mipAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstateAgencyAct?: RealEstateAgencyActUncheckedUpdateManyWithoutAgencyContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutAgencyContractNestedInput
  }

  export type AgencyContractUncheckedUpdateManyWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    entityId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    agencyContractSignatoryId?: NullableIntFieldUpdateOperationsInput | number | null
    realEstateAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    mipAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyContractSignatoryUpdateWithoutAgencyInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    basedOn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUpdateManyWithoutAgencyContractSignatoryNestedInput
  }

  export type AgencyContractSignatoryUncheckedUpdateWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    basedOn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContracts?: AgencyContractUncheckedUpdateManyWithoutAgencyContractSignatoryNestedInput
  }

  export type AgencyContractSignatoryUncheckedUpdateManyWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    basedOn?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealEstateAgencyActUpdateWithoutAgencyInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retention?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUpdateOneRequiredWithoutRealEstateAgencyActsNestedInput
    agencyContract?: AgencyContractUpdateOneRequiredWithoutRealEstateAgencyActNestedInput
  }

  export type RealEstateAgencyActUncheckedUpdateWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retention?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    clientContractId?: IntFieldUpdateOperationsInput | number
    agencyContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealEstateAgencyActUncheckedUpdateManyWithoutAgencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retention?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    clientContractId?: IntFieldUpdateOperationsInput | number
    agencyContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyToRealEstateAgentUpdateWithoutAgencyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstateAgent?: RealEstateAgentUpdateOneRequiredWithoutAgenciesToRealEstateAgentsNestedInput
  }

  export type AgencyToRealEstateAgentUncheckedUpdateWithoutAgencyInput = {
    realEstateAgentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyToRealEstateAgentUncheckedUpdateManyWithoutAgencyInput = {
    realEstateAgentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealEstateAgencyActCreateManyAgencyContractInput = {
    id?: number
    number: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    retention?: Decimal | DecimalJsLike | number | string | null
    note?: string | null
    link?: string | null
    clientContractId: number
    agencyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientContractToAgencyContractCreateManyAgencyContractInput = {
    clientContractId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RealEstateAgencyActUpdateWithoutAgencyContractInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retention?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUpdateOneRequiredWithoutRealEstateAgencyActsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutRealEstateAgencyActsNestedInput
  }

  export type RealEstateAgencyActUncheckedUpdateWithoutAgencyContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retention?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    clientContractId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealEstateAgencyActUncheckedUpdateManyWithoutAgencyContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retention?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    clientContractId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToAgencyContractUpdateWithoutAgencyContractInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientContract?: ClientContractUpdateOneRequiredWithoutClientContractsToAgencyContractsNestedInput
  }

  export type ClientContractToAgencyContractUncheckedUpdateWithoutAgencyContractInput = {
    clientContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractToAgencyContractUncheckedUpdateManyWithoutAgencyContractInput = {
    clientContractId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyContractCreateManyAgencyContractSignatoryInput = {
    id?: number
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    responsibleUserId?: number | null
    entityId: number
    objectId: number
    agencyId: number
    realEstateAgencyContractPropertiesId?: number | null
    mipAgencyContractPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyContractUpdateWithoutAgencyContractSignatoryInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUser?: UserUpdateOneWithoutAgencyContractsNestedInput
    entity?: EntityUpdateOneRequiredWithoutAgencyContractsNestedInput
    object?: ObjectUpdateOneRequiredWithoutAgencyContractsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgencyContractsNestedInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput
    realEstateAgencyAct?: RealEstateAgencyActUpdateManyWithoutAgencyContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutAgencyContractNestedInput
  }

  export type AgencyContractUncheckedUpdateWithoutAgencyContractSignatoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    entityId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    realEstateAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    mipAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstateAgencyAct?: RealEstateAgencyActUncheckedUpdateManyWithoutAgencyContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutAgencyContractNestedInput
  }

  export type AgencyContractUncheckedUpdateManyWithoutAgencyContractSignatoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    entityId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    realEstateAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    mipAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractCreateManyRealEstateAgentInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    managerId?: number | null
    bankId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyToRealEstateAgentCreateManyRealEstateAgentInput = {
    agencyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientContractUpdateWithoutRealEstateAgentInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneWithoutClientContractNestedInput
    dduClientContractProperties?: DduClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    dkpClientContractProperties?: DkpClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    product?: ProductUpdateOneRequiredWithoutClientContractNestedInput
    object?: ObjectUpdateOneRequiredWithoutClientContractsNestedInput
    manager?: UserUpdateOneWithoutClientContractsNestedInput
    bank?: BankUpdateOneWithoutClientContractsNestedInput
    subsidy?: SubsidyUpdateOneWithoutClientContractsNestedInput
    scheduledPayments?: ScheduledPaymentUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutRealEstateAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUncheckedUpdateOneWithoutClientContractNestedInput
    scheduledPayments?: ScheduledPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateManyWithoutRealEstateAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyToRealEstateAgentUpdateWithoutRealEstateAgentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutAgenciesToRealEstateAgentsNestedInput
  }

  export type AgencyToRealEstateAgentUncheckedUpdateWithoutRealEstateAgentInput = {
    agencyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyToRealEstateAgentUncheckedUpdateManyWithoutRealEstateAgentInput = {
    agencyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyContractCreateManyEntityInput = {
    id?: number
    number: string
    date: Date | string
    agencyContractType: $Enums.AgencyContractType
    link?: string | null
    responsibleUserId?: number | null
    objectId: number
    agencyId: number
    agencyContractSignatoryId?: number | null
    realEstateAgencyContractPropertiesId?: number | null
    mipAgencyContractPropertiesId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ObjectCreateManyEntityInput = {
    id?: number
    commonDbObjectsId: number
    name: string
    dateIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EntityForbiddenWebsiteCreateManyEntityInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EntityForbiddenBrandCreateManyEntityInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyContractUpdateWithoutEntityInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUser?: UserUpdateOneWithoutAgencyContractsNestedInput
    object?: ObjectUpdateOneRequiredWithoutAgencyContractsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgencyContractsNestedInput
    agencyContractSignatory?: AgencyContractSignatoryUpdateOneWithoutAgencyContractsNestedInput
    realEstateAgencyContractProperties?: RealEstateAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput
    mipAgencyContractProperties?: MipAgencyContractPropertiesUpdateOneWithoutAgencyContractNestedInput
    realEstateAgencyAct?: RealEstateAgencyActUpdateManyWithoutAgencyContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutAgencyContractNestedInput
  }

  export type AgencyContractUncheckedUpdateWithoutEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    objectId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    agencyContractSignatoryId?: NullableIntFieldUpdateOperationsInput | number | null
    realEstateAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    mipAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstateAgencyAct?: RealEstateAgencyActUncheckedUpdateManyWithoutAgencyContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutAgencyContractNestedInput
  }

  export type AgencyContractUncheckedUpdateManyWithoutEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyContractType?: EnumAgencyContractTypeFieldUpdateOperationsInput | $Enums.AgencyContractType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    objectId?: IntFieldUpdateOperationsInput | number
    agencyId?: IntFieldUpdateOperationsInput | number
    agencyContractSignatoryId?: NullableIntFieldUpdateOperationsInput | number | null
    realEstateAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    mipAgencyContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObjectUpdateWithoutEntityInput = {
    commonDbObjectsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutObjectNestedInput
    clientContracts?: ClientContractUpdateManyWithoutObjectNestedInput
    agencyContracts?: AgencyContractUpdateManyWithoutObjectNestedInput
    transferActs?: TransferActUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbObjectsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutObjectNestedInput
    clientContracts?: ClientContractUncheckedUpdateManyWithoutObjectNestedInput
    agencyContracts?: AgencyContractUncheckedUpdateManyWithoutObjectNestedInput
    transferActs?: TransferActUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateManyWithoutEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonDbObjectsId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenWebsiteUpdateWithoutEntityInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenWebsiteUncheckedUpdateWithoutEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenWebsiteUncheckedUpdateManyWithoutEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenBrandUpdateWithoutEntityInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenBrandUncheckedUpdateWithoutEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityForbiddenBrandUncheckedUpdateManyWithoutEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractCreateManyBankInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    realEstateAgentId?: number | null
    managerId?: number | null
    subsidyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientContractUpdateWithoutBankInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneWithoutClientContractNestedInput
    dduClientContractProperties?: DduClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    dkpClientContractProperties?: DkpClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    product?: ProductUpdateOneRequiredWithoutClientContractNestedInput
    object?: ObjectUpdateOneRequiredWithoutClientContractsNestedInput
    realEstateAgent?: RealEstateAgentUpdateOneWithoutClientContractsNestedInput
    manager?: UserUpdateOneWithoutClientContractsNestedInput
    subsidy?: SubsidyUpdateOneWithoutClientContractsNestedInput
    scheduledPayments?: ScheduledPaymentUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutBankInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUncheckedUpdateOneWithoutClientContractNestedInput
    scheduledPayments?: ScheduledPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateManyWithoutBankInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    subsidyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContractCreateManySubsidyInput = {
    id?: number
    number: string
    date: Date | string
    registrationDate?: Date | string | null
    price: Decimal | DecimalJsLike | number | string
    clientContractType: $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: boolean | null
    isTransferActDisabled?: boolean | null
    comment?: string | null
    link?: string | null
    uuContractId?: number | null
    dduClientContractPropertiesId?: number | null
    dkpClientContractPropertiesId?: number | null
    productId: number
    objectId: number
    realEstateAgentId?: number | null
    managerId?: number | null
    bankId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientContractUpdateWithoutSubsidyInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneWithoutClientContractNestedInput
    dduClientContractProperties?: DduClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    dkpClientContractProperties?: DkpClientContractPropertiesUpdateOneWithoutClientContractNestedInput
    product?: ProductUpdateOneRequiredWithoutClientContractNestedInput
    object?: ObjectUpdateOneRequiredWithoutClientContractsNestedInput
    realEstateAgent?: RealEstateAgentUpdateOneWithoutClientContractsNestedInput
    manager?: UserUpdateOneWithoutClientContractsNestedInput
    bank?: BankUpdateOneWithoutClientContractsNestedInput
    scheduledPayments?: ScheduledPaymentUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateWithoutSubsidyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUncheckedUpdateOneWithoutClientContractNestedInput
    scheduledPayments?: ScheduledPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    actualPayments?: ActualPaymentUncheckedUpdateManyWithoutClientContractNestedInput
    realEstateAgencyActs?: RealEstateAgencyActUncheckedUpdateManyWithoutClientContractNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToClients?: ClientContractToClientUncheckedUpdateManyWithoutClientContractNestedInput
    clientContractsToAgencyContracts?: ClientContractToAgencyContractUncheckedUpdateManyWithoutClientContractNestedInput
  }

  export type ClientContractUncheckedUpdateManyWithoutSubsidyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientContractType?: EnumClientContractTypeFieldUpdateOperationsInput | $Enums.ClientContractType
    isRealEstateAgencyActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isTransferActDisabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    uuContractId?: NullableIntFieldUpdateOperationsInput | number | null
    dduClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    dkpClientContractPropertiesId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    realEstateAgentId?: NullableIntFieldUpdateOperationsInput | number | null
    managerId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferActToRepresentativeCreateManyTransferActInput = {
    representativeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferActToRepresentativeUpdateWithoutTransferActInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    representative?: RepresentativeUpdateOneRequiredWithoutTransferActsToRepresentativesNestedInput
  }

  export type TransferActToRepresentativeUncheckedUpdateWithoutTransferActInput = {
    representativeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferActToRepresentativeUncheckedUpdateManyWithoutTransferActInput = {
    representativeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferActToRepresentativeCreateManyRepresentativeInput = {
    transferActId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferActToRepresentativeUpdateWithoutRepresentativeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAct?: TransferActUpdateOneRequiredWithoutTransferActsToRepresentativesNestedInput
  }

  export type TransferActToRepresentativeUncheckedUpdateWithoutRepresentativeInput = {
    transferActId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferActToRepresentativeUncheckedUpdateManyWithoutRepresentativeInput = {
    transferActId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientCountOutputTypeDefaultArgs instead
     */
    export type ClientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientIndividualMinorPropertiesCountOutputTypeDefaultArgs instead
     */
    export type ClientIndividualMinorPropertiesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientIndividualMinorPropertiesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientContractCountOutputTypeDefaultArgs instead
     */
    export type ClientContractCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientContractCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectCountOutputTypeDefaultArgs instead
     */
    export type ObjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgencyCountOutputTypeDefaultArgs instead
     */
    export type AgencyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgencyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgencyContractCountOutputTypeDefaultArgs instead
     */
    export type AgencyContractCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgencyContractCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgencyContractSignatoryCountOutputTypeDefaultArgs instead
     */
    export type AgencyContractSignatoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgencyContractSignatoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RealEstateAgentCountOutputTypeDefaultArgs instead
     */
    export type RealEstateAgentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RealEstateAgentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntityCountOutputTypeDefaultArgs instead
     */
    export type EntityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BankCountOutputTypeDefaultArgs instead
     */
    export type BankCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BankCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubsidyCountOutputTypeDefaultArgs instead
     */
    export type SubsidyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubsidyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransferActCountOutputTypeDefaultArgs instead
     */
    export type TransferActCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransferActCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RepresentativeCountOutputTypeDefaultArgs instead
     */
    export type RepresentativeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RepresentativeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientDefaultArgs instead
     */
    export type ClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientIndividualPropertiesDefaultArgs instead
     */
    export type ClientIndividualPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientIndividualPropertiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientIndividualMinorPropertiesDefaultArgs instead
     */
    export type ClientIndividualMinorPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientIndividualMinorPropertiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientEntityPropertiesDefaultArgs instead
     */
    export type ClientEntityPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientEntityPropertiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientToClientIndividualMinorPropertiesDefaultArgs instead
     */
    export type ClientToClientIndividualMinorPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientToClientIndividualMinorPropertiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientPassportDefaultArgs instead
     */
    export type ClientPassportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientPassportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientContractDefaultArgs instead
     */
    export type ClientContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientContractDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DduClientContractPropertiesDefaultArgs instead
     */
    export type DduClientContractPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DduClientContractPropertiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DkpClientContractPropertiesDefaultArgs instead
     */
    export type DkpClientContractPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DkpClientContractPropertiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientContractToAgencyContractDefaultArgs instead
     */
    export type ClientContractToAgencyContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientContractToAgencyContractDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientContractToClientDefaultArgs instead
     */
    export type ClientContractToClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientContractToClientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduledPaymentDefaultArgs instead
     */
    export type ScheduledPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduledPaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActualPaymentDefaultArgs instead
     */
    export type ActualPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActualPaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectDefaultArgs instead
     */
    export type ObjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgencyDefaultArgs instead
     */
    export type AgencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgencyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgencyContractDefaultArgs instead
     */
    export type AgencyContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgencyContractDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgencyContractSignatoryDefaultArgs instead
     */
    export type AgencyContractSignatoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgencyContractSignatoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RealEstateAgencyContractPropertiesDefaultArgs instead
     */
    export type RealEstateAgencyContractPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RealEstateAgencyContractPropertiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MipAgencyContractPropertiesDefaultArgs instead
     */
    export type MipAgencyContractPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MipAgencyContractPropertiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgencyContractCommissionDefaultArgs instead
     */
    export type AgencyContractCommissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgencyContractCommissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RealEstateAgentDefaultArgs instead
     */
    export type RealEstateAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RealEstateAgentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgencyToRealEstateAgentDefaultArgs instead
     */
    export type AgencyToRealEstateAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgencyToRealEstateAgentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntityDefaultArgs instead
     */
    export type EntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntityForbiddenWebsiteDefaultArgs instead
     */
    export type EntityForbiddenWebsiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntityForbiddenWebsiteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntityForbiddenBrandDefaultArgs instead
     */
    export type EntityForbiddenBrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntityForbiddenBrandDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BankDefaultArgs instead
     */
    export type BankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BankDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EscrowAccountHistoryDefaultArgs instead
     */
    export type EscrowAccountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EscrowAccountHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RealEstateAgencyActDefaultArgs instead
     */
    export type RealEstateAgencyActArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RealEstateAgencyActDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubsidyDefaultArgs instead
     */
    export type SubsidyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubsidyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssignmentDefaultArgs instead
     */
    export type AssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransferActDefaultArgs instead
     */
    export type TransferActArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransferActDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RepresentativeDefaultArgs instead
     */
    export type RepresentativeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RepresentativeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransferActToRepresentativeDefaultArgs instead
     */
    export type TransferActToRepresentativeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransferActToRepresentativeDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}